# 29.Ders 26.04.2025 ğŸ•˜

Derse 11(09:01)-14(09:13)-16(09:16)-17(09:29)-17(10:03)-19(10:24)-19(11:10)-17(12:08)-18(12:27)-16(12:55) kiÅŸi katÄ±ldÄ±.
---

## Pointers Devam


### Adresler(pointer) ve KarÅŸÄ±laÅŸtÄ±rma Ä°ÅŸlemleri Devam


ğŸ‘‡ AÅŸaÄŸÄ±daki programda farklÄ± iki pointer deÄŸiÅŸkenin ve gÃ¶sterdikleri adres deÄŸerlerinin eÅŸitlik karÅŸÄ±laÅŸtÄ±rÄ±lmasÄ± incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int ar[5] = { 0, 1, 2, 3, 4};
    int* p1 = ar + 5; // Burada 'ar' dizisinin bittiÄŸi yerin adresi(diziye dahil deÄŸil) pointer deÄŸiÅŸkene atanÄ±yor.
    int* p2 = ar + 5;

    if(p1 == p2) // Burada 'p1' ve 'p2' pointer deÄŸiÅŸkenlerinin tutuÄŸu adres deÄŸerleri karÅŸÄ±laÅŸtÄ±rÄ±lÄ±yor ve bu karÅŸÄ±laÅŸtÄ±rmanÄ±n sonucu 'always-true' durumundadÄ±r.
        printf("evet esit.\n");
    else
        printf("evet esit degil.\n");

    // Ã–nemli bir nokta olarak eÄŸer bir dizinin sonunun adresinin deÄŸerine eriÅŸilmesi 'ub' durumudur, buradaki '*p1' ve '*p2' ifadeleri 'ub' durumudur.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir dizinin baÅŸlangÄ±ÅŸ adresi ile bittiÄŸi yerin adresi kullanÄ±larak dizinin tÃ¼m elemanlarÄ±nÄ±n nasÄ±l ekrana yazdÄ±rÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int ar[5] = { 0, 1, 2, 3, 4};
    int* pfirst = ar;
    int* pend = ar + 5;

    while(pfirst != pend){
        printf("%d ", *pfirst);
        ++pfirst;
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `PrintArray` fonksiyonu bir diziyi yazdÄ±rmak iÃ§in kullanÄ±lmaktadÄ±r ve bu fonksiyona geÃ§ilen farklÄ± adres deÄŸerleriyle birlikte dizinin farklÄ± bir alt dizisinin elemanlarÄ±nÄ±n yazdÄ±rÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

void PrintArray(const int* pbeg, const int* pend)
{
    while(pbeg != pend){
        printf("%d ", *pbeg);
        ++pbeg;
    }
    printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
}

int main(void)
{
    int ar[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

    PrintArray(ar, ar + 5); // Dizinin ilk elemanÄ±ndan 5. elemanÄ±na kadar elemanlarÄ±nÄ±n yazdÄ±rÄ±lmasÄ± iÅŸlemi
    PrintArray(ar, ar + 10); // Dizinin ilk elemanÄ±ndan 10. elemanÄ±na kadar elemanlarÄ±nÄ±n yazdÄ±rÄ±lmasÄ± iÅŸlemi
    PrintArray(ar+ 2, ar + 5); // Dizinin 3. elemanÄ±ndan 5. elemanÄ±na kadar elemanlarÄ±nÄ±n yazdÄ±rÄ±lmasÄ± iÅŸlemi 
}
```

ğŸ§  C dilinde dizinin adresini ve uzunluÄŸunu alan fonksiyonlar yaygÄ±ndÄ±r, C++ dilinde ilk elemanÄ±n ve son elemanÄ±n indeks deÄŸerlerini alan fonksiyonlarÄ±n kullanÄ±mÄ± yaygÄ±ndÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir sonraki derste incelenecek olan **NULL pointer** deÄŸere sahip pointer deÄŸiÅŸkenlerin karÅŸÄ±laÅŸtÄ±rÄ±lmasÄ± incelenebilir. EÄŸer iki **NULL pointer** deÄŸere eÅŸitlik karÅŸÄ±laÅŸtÄ±rmasÄ±na tabi tutulursa sonuÃ§ **logic true** olacaktÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 24;
    int* p1 = NULL;
    int* p2 = &x;

    if(p1 == p2)
        printf("dogru\n");
    else
        printf("yanlis\n");

    p2 = NULL;

    if(p1 == p2)
        printf("dogru\n");
    else
        printf("yanlis\n");
}
```



â—â—â— Ä°ki **adres(pointer)** aynÄ± nesnenin adresiyse, iki adres bir dizinin bittiÄŸi yerin adresiyse ve **NULL pointer** ise eÅŸit olmak zorundadÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda sÄ±k yapÄ±lan bir hata olan iki dizinin karÅŸÄ±laÅŸtÄ±rmasÄ± iÅŸleminin dizilerin iÃ§erikleri iÃ§in deÄŸil dizilerin ilk adreslerinin karÅŸÄ±laÅŸtÄ±rÄ±lmasÄ± ÅŸeklinde yapÄ±lmaktadÄ±r Ã§Ã¼nkÃ¼ burada **array decal** iÅŸlemi uygulanÄ±yor.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int ar1[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    int ar2[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

    if(ar1 == ar2) // always-false
        printf("evet esit\n");
    else
        printf("hayir esit degil\n");
}
```


>â”
> 
> Sorulan soru; 
> 
> Anlamadim sadece sonu mu "arr + 6" , "arr + 7" ler de aynÄ± olmuyor mu?
> 
> Cevap;
> 
> Bir dizinin dÄ±ÅŸÄ±ndaki adreslerin kullanÄ±lmasÄ±(dereferencing iÅŸlemiyle o adreslerdeki deÄŸerlere eriÅŸilmese bile) C dilinin kurallarÄ±na gÃ¶re **sÃ¶zdizim hatasÄ±(syntax error)** deÄŸildir ama bu ÅŸekilde kod yazÄ±lmamalÄ±dÄ±r ve bu kullanÄ±mlar **ub** durumuna neden olabilir.
> 
> ```C
> #define _CRT_SECURE_NO_WARNINGS
> 
> #include <stdio.h>
> 
> int main(void)
> {
>     int ar[4] = { 0, 1, 2, 3};
> 
>     // ar - 1 // Burada eriÅŸilen adresin kullanÄ±lmasÄ± doÄŸru deÄŸildir.
>     // ar + 6 // Burada eriÅŸilen adresin kullanÄ±lmasÄ± doÄŸru deÄŸildir.
> }
> ```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda sÄ±k yapÄ±lan bir hata olan iki **string literal** karÅŸÄ±laÅŸtÄ±rmasÄ± iÅŸleminin yazÄ±larÄ± karÅŸÄ±laÅŸtÄ±racaÄŸÄ±nÄ±n dÃ¼ÅŸÃ¼nÃ¼lmesi durumu incelenebilir fakat **string literal** iÃ§erikleri iÃ§in deÄŸil **string literal**'lerin ilk adreslerinin karÅŸÄ±laÅŸtÄ±rÄ±lmasÄ± yapÄ±lacaktÄ±r. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int s1[10] = "civelek";
    int s2[10] = "civelek";

    if(s1 == s2) // always-false
        printf("evet esit\n");
    else
        printf("hayir esit degil\n");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan iki **string literal** iÃ§eriÄŸinin standart C fonksiyonu olan `strcmp` fonksiyonuyla nasÄ±l karÅŸÄ±laÅŸtÄ±rÄ±lacaÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int main(void)
{
    char s1[100];
    char s2[100];

    printf("iki ad giriniz: ");
    scanf("%s%s", s1, s2);
    printf("[%s]  [%s]\n", s1, s2);

    if(!strcmp(s1, s2))
        printf("evet ayni ad.\n");
    else
        printf("hayir farkli adlar.\n");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki pointer deÄŸiÅŸkenin deÄŸerlerinin ve gÃ¶sterdikleri adreslerdeki deÄŸerlerin(pointii value) karÅŸÄ±laÅŸtÄ±rmasÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int main(void)
{
    int x = 5, y = 5;
    int* p1 = &x, * p2 = &y;

    printf("p1 == p2 => %s\n", p1 == p2 ? "evet esit." : "hayir esit degil."); // Buradaki 'printf' kullanÄ±mÄ± C dilinin idiomatic kullanÄ±mlarÄ±ndan biridir.
    printf("*p1 == *p2 => %s\n", *p1 == *p2 ? "evet esit." : "hayir esit degil.");
    printf("x == y => %s\n", x == y ? "evet esit." : "hayir esit degil.");
}
```



â— `>`,`>=`,`<`,`<=` karÅŸÄ±laÅŸtÄ±rma operatÃ¶rlerinin operantlarÄ± pointer deÄŸiÅŸkenler yani adresler olabilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda pointer aritmetiÄŸinin bir dizi Ã¼zerinden nasÄ±l uygulandÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility"

#define SIZE 20

int main(void)
{
    int ar[SIZE];

    radomize();
    set_array_ramdom(ar ,SIZE);
    print_array(ar ,SIZE);

    int* p1 = &ar[5]; // ar + 5
    int* p2 = &ar[13]; // ar + 13

    // 'p2 - p1' iÅŸleminin sonucu '13 - 5 = 8' olacaktÄ±r.

    if(p1 < p2)
        printf("evet dogru.\n");
    else
        printf("hayir yanlis.\n");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda pointer aritmetiÄŸi ile yapÄ±lan karÅŸÄ±laÅŸtÄ±rma incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility"

#define SIZE 20

int main(void)
{
    int ar[SIZE];

    radomize();
    set_array_ramdom(ar ,SIZE);
    print_array(ar ,SIZE);

    int* p1 = &ar[5]; // ar + 5
    int* p2 = &ar[13]; // ar + 13

    while(p1 < p2){ // Buradaki ÅŸart 'p1 != p2' ÅŸeklinde de yazÄ±labilir.
        printf("%3d ", *p1);
        ++p1;
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda yapÄ±lan adres karÅŸÄ±laÅŸtÄ±rmalarÄ±nÄ±n kullanÄ±lmasÄ±nÄ±n bir faydasÄ± yoktur, burada **unspesifield behiver** vardÄ±r. Derleyicinin Ã¼rettiÄŸi makine kodunda x ve y deÄŸiÅŸkeninin adresinin bellekte nerede tutulacaÄŸÄ± belli olmayacaktÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int main(void)
{
    int x = 10, y = 20;
    int* px = &x, * py = &y;

    // AÅŸaÄŸÄ±daki karÅŸÄ±laÅŸtÄ±rma iÅŸleminde 'ub' yoktur ama yapÄ±lan iÅŸlemin bir faydasÄ± ve mantÄ±ÄŸÄ± yok. 
    if(&x < &y){
        // ...
    }

    if(px < py){
        // ...
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir diziyi ters Ã§evirme iÅŸlemini pointer kullanarak yapan fonksiyon incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 20

void swap(int* p1, int* p2)
{
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}

void reverse_array(int* pa, int size)
{
    int* pe = pa + size; // Burada 'pe' gÃ¶stericisi 'pa' dizisine ait olmayan dizinin son elemannÄ±ndan sonraki adersin adresidir.

    while(pa < pe){
        swap(pa++, --pe); // Buradaki kullanÄ±m Ã§ok sÄ±k kullanÄ±lan bir C idiom yapÄ±sÄ±dÄ±r. 
    }
}

int main(void)
{
    int[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE5);

    reverse_array(ar, SIZE);
    print_array(ar, SIZE);
}
```



ğŸ” [Benim paylaÅŸtÄ±ÄŸÄ±m yukarÄ±daki basit C programÄ±nÄ±n aÃ§Ä±klamasÄ±nÄ± yapan YZ sohbetinin linki](https://chatgpt.com/share/680c82a7-33c4-800a-b18e-3db6bfa3ed07)


### GÃ¶stericilerle Birlikte KullanÄ±labilen BazÄ± OperatÃ¶rlerin Tekraredilmesi 


â— C++ dilinin standardÄ±nda bir ifadenin **R/L value** kategorisinde olmasÄ±na **Value Category** deniyor, C standardÄ± aÃ§Ä±k ÅŸekilde bu tanÄ±mÄ± yapmasa da C dili iÃ§in de aynÄ± ifadenin kullanÄ±lmasÄ±nda bir sakÄ±nca yoktur.

â—â—â— AÅŸaÄŸÄ±daki operatÃ¶rler gÃ¶stericilerle birlikte kullanÄ±labilen operatÃ¶rlerdir ve bu operatÃ¶rlerle ilgili aÅŸaÄŸÄ±daki bilgilerin bilinmesi Ã¶nemlidir;
- `++` operatÃ¶rÃ¼nÃ¼n operandÄ±nÄ±n value-category deÄŸerlerinin **L-value** olmasÄ± zorunluluÄŸu vardÄ±r.
- `--` operatÃ¶rÃ¼nÃ¼n operandÄ±nÄ±n value-category deÄŸerlerinin **L-value** olmasÄ± zorunluluÄŸu vardÄ±r.
- `&`  operatÃ¶rÃ¼nÃ¼n operandÄ±nÄ±n value-category deÄŸerlerinin **L-value** olmasÄ± zorunluluÄŸu vardÄ±r.
- `*`  operatÃ¶rÃ¼nÃ¼n operandÄ±nÄ±n adres olmasÄ± zorunluluÄŸu vardÄ±r ama operandÄ±n value-category deÄŸerlerinin **R-value** ya da **L-value** olabilir. Operant bir pointer deÄŸiÅŸken olabilir ya da doÄŸrudan adres deÄŸeri olan herhangi bir ifade olabilir.


â—â—â— AÅŸaÄŸÄ±da bazÄ± ifadelerin(expression) **value category** deÄŸerleri incelenebilir;
- `++x` ve `x++` ifadeleri(expression) **R-value**
- `--x` ve `x--` ifadeleri(expression) **R-value**
- `&x` ifadesi(expression) **R-value**
- `*p` ifadesi(expression) **L-value**



â—â—â—AÅŸaÄŸÄ±daki ifadede(expression) buunan operatÃ¶rler incelenebilir;
- `!~*ptr++` ifadesinde dÃ¶rt farklÄ± operatÃ¶r vardÄ±r, bunlar; 
    - `!` "**logical not**" operatÃ¶rÃ¼ 
    - `~` "**bitwise not**" operatÃ¶rÃ¼ 
    - `*` "**dereferencing**" operatÃ¶rÃ¼
    - `++` "**postfix increment**" operatÃ¶rÃ¼
- `!~*ptr++` ifadesindeki tÃ¼m operatÃ¶rler aynÄ± Ã¶ncelik seviyesinde olduÄŸu iÃ§in ifade ÅŸu `!(~(*(ptr++)))` ifade ile birbirine eÅŸittir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda geÃ§ersiz olan ifadeler(expression) incelenebilir. AÅŸaÄŸÄ±daki programdakine benzer ifadelerin geÃ§erli olup olmadÄ±ÄŸÄ± ve detaylÄ± aÃ§Ä±klamasÄ± C mÃ¼lakatlarÄ±nda sorulabilecek basit sorulardandÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 10;

    &x++; // '&(x++)' ile aynÄ± ifadedir ve bu ifade legal deÄŸildir Ã§Ã¼nkÃ¼ '&' operatÃ¶rÃ¼ R-value olan 'x++' ifadesini operant olarak alamaz(sadece L-value ifade alabilir).
    &++x; // '&(++x)' ile aynÄ± ifadedir ve bu ifade legal deÄŸildir Ã§Ã¼nkÃ¼ '&' operatÃ¶rÃ¼ R-value olan '++x' ifadesini operant olarak alamaz(sadece L-value ifade alabilir).
    ++&x; // '++(&x)' ile aynÄ± ifadedir ve bu ifade legal deÄŸildir Ã§Ã¼nkÃ¼ '++' operatÃ¶rÃ¼ R-value olan '&x' ifadesini operant olarak alamaz(sadece L-value ifade alabilir).
    (&x)++; // Bu ifade legal deÄŸildir Ã§Ã¼nkÃ¼ '++' operatÃ¶rÃ¼ R-value olan '&x' ifadesini operant olarak alamaz(sadece L-value ifade alabilir).
}
```


### Pointer Idioms 

AÅŸaÄŸÄ±daki idiom kullanÄ±mlarÄ± incelenecektir.
1. `*ptr++`
2. `++*ptr`
3. `*++ptr`

#### `*ptr = value; ptr++;` Gibi Ä°ki Statement'Ä±n `*ptr++;` Åeklinde Tek Statement Olarak KullanÄ±ldÄ±ÄŸÄ± Idiomatic YapÄ± 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `*ptr++` idiom yapÄ±sÄ±nÄ±n kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int ar[5] = { 10, 20, 30, 40, 50 };
    int* p = ar;

    print_array(ar, 5);

    // '*p++' bu ifade L-value kategorisindedir, '*(p++)' ifadesinde 'p' bir pointer olduÄŸu iÃ§in 'p++' ifadesi de bir nesne adresidir ve bu ifade 'dereferencing' operatÃ¶rÃ¼nÃ¼n operandÄ± olabilir.
    *p++ = 333; // Burada dizinin ilk elemanÄ±na '333' deÄŸeri atanÄ±yor ama 'side-effect' ilk 'sequance point'ten sonra yansÄ±yacaktÄ±r.

    print_array(ar, 5);

    *p = 999; // Burada dizinin ikinci elemanÄ±na '999' deÄŸeri atanÄ±yor.
    print_array(ar, 5);
}
```



â— C dilinde idiomatic yapÄ±larÄ±n kullanÄ±lmasÄ± gramer yapÄ±ya sahip insan dillerinden birini ana dili olarak konuÅŸan kiÅŸilerin o dili sonradan Ã¶ÄŸrenene kiÅŸilerin anlamasÄ±nÄ±n zor olabileceÄŸi deyimlerle(idiom) birlikte konuÅŸacaÄŸÄ± ile benzer ÅŸey olduÄŸu dÃ¼ÅŸÃ¼nÃ¼lebilir. O nedenle C programlarÄ±nÄ± yazarken sÄ±klÄ±kla C idiomatic yapÄ±larÄ±nÄ±n kullanÄ±lmasÄ±nÄ±n doÄŸru olacaÄŸÄ± dÃ¼ÅŸÃ¼nÃ¼lebilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `*p++;` idiomatic yapÄ±sÄ±nÄ±n kullanÄ±ldÄ±ÄŸÄ± bir dizinin elemanlarÄ±nÄ± baÅŸka diziye kopyalayan `copy_array` fonksiyonu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

// AÅŸaÄŸÄ±daki fonksiyon dizi baÅŸlangÄ±Ã§ adresleri gÃ¶nderilen bir diziden diÄŸerine kopyalama iÅŸlemini yapar.
void copy_array(int* pdest, const int* psource, int size)
{
    while(size--)
        *pdest++ = *psource++;
        // *(pdest++) = *(psource++);

    // C idiomatic yapÄ± kullanÄ±lmadÄ±ÄŸÄ±nda yukarÄ±daki dÃ¶ngÃ¼ aÅŸaÄŸÄ±daki gibi yazÄ±labilirdi.
    //while(size--){
    //    *pdest = *psource;
    //    ++pdest;
    //    ++psource;
    //}
}
```



â—â—â— `foo(*ptr); ++ptr;` yazmak yerine `foo(*ptr++);` kullanÄ±labileceÄŸini anlamak Ã¶nemlidir, ikinci kullanÄ±m C dilinde idiomatik bir kullanÄ±mdÄ±r.



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir dizi adÄ± Ã¼zerinden `*array_name++` ÅŸeklinde bir kullanÄ±mÄ±n "**array decay**" kuralÄ±ndan dolayÄ± legal olmadÄ±ÄŸÄ± durum incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int ar[] = { 1, 3, 5, 7, 9 };
    int* ptr = ar;

    *ar++ = 567; // Buradaki ifade '*(ar++)' ifadesi ile aynÄ±dÄ±r ve 'ar++' ifadesindeki 'ar' iÅŸleme girmeden Ã¶nce 'array decay' kuralÄ±ndan dolayÄ± R-value olan adres ifadesine Ã§evrileceÄŸinden dolayÄ± ve bu 'ar' ifadesi '++' operatÃ¶tÃ¼nÃ¼n operandÄ± olamaz.
    *&ar[0] = 998; // Buradaki ifade '*ar' ifadesi ile aynÄ±dÄ±r, legal ve mantÄ±ken(logic) doÄŸru bir kullanÄ±mdÄ±r. Burada dizinin ilk elemanÄ±na '998' deÄŸeri atanmaktadÄ±r.
    *ptr++; // Buradaki ifade '*(ptr++)' ifadesi ile aynÄ±dÄ±r ve 'ptr' ifadesi bir nesneye karÅŸÄ±lÄ±k geldiÄŸinde bir 'L-value' ifadedir ve bundan dolayÄ± da '++' operatÃ¶rÃ¼nÃ¼n operandÄ± olabilir, bu nedenlerden dolayÄ±dÄ±r ki bu ifade legaldir ve kullanÄ±mÄ±nda bir mantÄ±ksal hata yoktur.

    // AÅŸaÄŸÄ±daki Ã§Ä±ktÄ±larÄ± incele ve anlamaya Ã§alÄ±ÅŸ
    printf("ar = %d(decimal), %o(octal), %X(hex)\n", *ar, *ar, *ar);
    printf("ptr = %p, *ptr = %d\n", ptr, *ptr);
    printf("ar = %p, &ar[0] = %p", ar, &ar[0]);
}
```



ğŸ˜± Bazen C mÃ¼lakatlarÄ±nÄ± yapan kiÅŸilerin bilgi dÃ¼zeyleri yeterli olmadÄ±ÄŸÄ± iÃ§in sorulan sorulara doÄŸru cevap veren mÃ¼lakata giren kiÅŸilerin cevaplarÄ± doÄŸru kabul edilmediÄŸi durumlar da olabiliyormuÅŸ. </br>
ğŸ‘‡ Mesela C mÃ¼lakatÄ±nda aÅŸaÄŸÄ±daki gibi bir soru sorulup cevabÄ±n ne olduÄŸu sorulduÄŸunda bu programda "**ub**" var dendiÄŸinde mÃ¼lakatÄ± yapan kiÅŸi "TanÄ±msÄ±z davranÄ±ÅŸ ta nedir Ã¶yle ÅŸey mi olur." dediÄŸi olabiliyormuÅŸ.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int x = 10;

    int y = ++x + x++;
    printf("y = %d\n", y);
}
```



"**ub**" durumlarÄ± neden var diye sorulduÄŸunda bunun cevabÄ± Ã§oÄŸu zaman C dilinin standardÄ±nda o ÅŸekilde belirtildiÄŸinden dolayÄ± olduÄŸu bilinmelidir.

ğŸ‘‡ AÅŸaÄŸÄ±daki programda C ve C++ dillerinde "**ub**" olma durumlarÄ±nÄ±n farklÄ± olduÄŸu incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int x = 10;

    x = ++x; // Buradaki statement C dilinde 'ub' ama C++ dilinde 'ub' deÄŸildir.
}
```


#### `++ptr; *ptr = value;` Gibi Ä°ki Statement'Ä±n `*++ptr` Åeklinde Tek Statement Olarak KullanÄ±ldÄ±ÄŸÄ± Idiomatic YapÄ± 


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `*++ptr` ÅŸeklindeki C idiomatic kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int ar[] = { 1, 3, 5, 7, 9 };
    int* ptr = ar;

    print_array(ar, 5);

    *++ar = 999; // Burada sÃ¶zdizim hatasÄ±(syntax error) vardÄ±r, bunun nendeni '*(++ar)' ifadesinde dizi adÄ± olan 'ar' ifadesinin 'array decay' ile '&ar[0]' ifadesine Ã§evrilmesi ve ifadenin '*(++&ar[0])' haline gelmesidir ama burada '++' operatÃ¶rÃ¼nÃ¼n operandÄ± R-value olan '&ar[0]' ifadesi yapÄ±ldÄ±ÄŸÄ± iÃ§in sÃ¶zdizim hatasÄ±(syntax error) oluÅŸacaktÄ±r.

    *++ptr = 999; // Buradaki ifade '*(++ptr);' ifadesi ile aynÄ±dÄ±r, burada dizinin 1 indisli ikinci elemanÄ±na '999' deÄŸeri atanÄ±r.
    print_array(ar, 5);

    *ptr = 333; // Burada dizinin 1 indisli ikinci elemanÄ±na '333' deÄŸeri atanÄ±r.
    print_array(ar, 5);
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.53-11.12 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir dizi adÄ± Ã¼zerinden hangi adreslere eriÅŸilmek istendiÄŸinde "**ub**" oluÅŸacaÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int ar[] = { 1, 3, 5, 7, 9 };
    int* ptr = ar + 4; // Dizinin son elemanÄ±nÄ±n adresi 'ptr' gÃ¶sterici deÄŸiÅŸkenine ilk deÄŸer olarak veriliyor.

    print_array(ar, 5);

    *++ptr; // Burada '++ptr' adresi dizinin son elemanÄ±ndan sonraki adres olduÄŸu ve dizinin dÄ±ÅŸÄ±nda kaldÄ±ÄŸÄ± iÃ§in 'ub' vardÄ±r.

    ptr = ar;
    *--ptr; // Burada '--ptr' adresi dizinin 0.indisinden Ã¶nceki adres olduÄŸu ve dizinin dÄ±ÅŸÄ±nda kaldÄ±ÄŸÄ± iÃ§in 'ub' vardÄ±r.
}
```


#### `++*ptr;` Åeklinde KullanÄ±lan Idiomatic YapÄ± 


ğŸ‘‡ AÅŸaÄŸÄ±daki programdan `++*ptr;` idyomunun nasÄ±l kullanÄ±lacaÄŸÄ± incelenebilir;
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int ar[] = { 1, 3, 5, 7, 9 };
    int* ptr = ar;

    print_array(ar, 5);

    ++*ptr;

    print_array(ar, 5);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki gibi bir kod yazÄ±lmamalÄ±dÄ±r ama konuyu anlamak iÃ§in `++*p++` ifadesinin nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

void func(int* p, int size)
{
    while(size--)
        ++*p++; // Buradaki ifade '++(*(p++))' ile aynÄ±dÄ±r.
    
    // Buradaki dÃ¶ngÃ¼ ile yukarÄ±daki dÃ¶ngÃ¼ birbirine eÅŸittir.
    /*
    while(size--){
        ++*p;
        ++p;
    }
    */
}

int main(void)
{
    int ar[] = { 1, 3, 5, 7, 9 };
    int* ptr = ar;

    print_array(ar, 5);
    func(ar, 5);
    print_array(ar, 5);
}
```



â—â—â— `++*ar` ifadesi legal iken `ar++` ifadesi legal deÄŸildir, bunun nedenini iyi anlamak gerekiyor ve anlamadan ilerlenmemeli. `++*ar` ifadesindeki `*ar` alt ifadesi `ar` dizisinin ilk elemanÄ± olan nesnedir(burada **array decay** ile `ar` ÅŸuna Ã§evrilir `&ar[0]`). </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki gibi bir kod yazÄ±lmamalÄ±dÄ±r ama konuyu anlamak iÃ§in `++*ar` ifadesinin nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int ar[] = { 1, 3, 5, 7, 9 };

    print_array(ar, 5);
    ++*ar; // Buradaki iÅŸlem legal ve doÄŸrudur, dizinin ilk elemanÄ±nÄ±n deÄŸeri bir arttÄ±rÄ±lÄ±yor.
    print_array(ar, 5);
}
```


### FonksiyonlarÄ±n Geri DÃ¶nÃ¼ÅŸ DeÄŸeri Olarak Pointer'lar 

C dilinde bir fonksiyondan geriye dÃ¶ndÃ¼rÃ¼len veri tÃ¼rÃ¼ pointer tÃ¼rÃ¼nden olabiliyor, bu tÃ¼r fonksiyonlara "**functions returning pointer**" denilmektedir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda pointer dÃ¶ndÃ¼ren bir fonksiyonun deÄŸerinin nasÄ±l kullanÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int *foo(void);
int bar(void);

int main(void)
{
    int x = bar();
    int* ptr = foo();

    *ptr = 12341; // 'foo' fonksiyonundan dÃ¶nen pointer deÄŸiÅŸkenine deÄŸer atanÄ±yor.

    *foo() = 3423; // Buradaki eÅŸitliÄŸin sol tarafÄ±ndaki ifade '*(foo())' ile aynÄ±dÄ±r ve legal'dir ve bÃ¶yle bir kod yazÄ±labilir.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda parametre olarak adres alan bir fonksiyona baÅŸka bir fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸeri olan adres deÄŸeri ile argÃ¼man geÃ§ilmesinin nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int* foo(void);
int bar(int*);

int main(void)
{
    bar(foo()); // Bu ÅŸekilde bir kod yazÄ±labilir.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program ilk bakÄ±ÅŸta biraz karÄ±ÅŸÄ±k gelebilir ama detaylÄ± incelenirse adres deÄŸerleri ve adres bilgisi Ã¼zerinden nesnelerin tuttuÄŸu deÄŸerlerin deÄŸiÅŸtirmesi iÅŸlemleri anlaÅŸÄ±lacaktÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int g = 222;

int* foo(void)
{
    return &g;
}

int main(void)
{
    printf("g = %d\n", g);

    int* ptr = foo();

    *ptr = 6666; // Buradaki iÅŸlemde 'g' deÄŸiÅŸkeninin adresi Ã¼zerinden deÄŸeri deÄŸiÅŸtiriliyor.

    printf("g = %d\n", g);

    *foo() = 5553; // Burada doÄŸrudan pointer dÃ¶ndÃ¼ren bir fonksiyon Ã§aÄŸrÄ±sÄ± Ã¼zerinden dÃ¶nÃ¼ÅŸ yapÄ±lan pointer deÄŸiÅŸkenin gÃ¶sterdiÄŸi adresteki deÄŸerin deÄŸiÅŸtiriliÅŸi incelenebilir.

    printf("g = %d\n", g);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir dizinin adÄ± nerelerde ne ÅŸekilde kullanÄ±labileceÄŸi incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int ar[] = { 1, 3, 5, 7, 9 };

int* foo(void)
{
    return ar;
    //return &ar[0]; // Buradaki '&ar[0]' ifade 'ar' ifadesi ile aynÄ±dÄ±r, dizi adlarÄ± kullanÄ±ldÄ±ÄŸÄ± Ã§oÄŸu yerde 'array decal' iÅŸlemine tabi tutulur.
}

int main(void)
{
    print_array(ar, 5);
    *foo() = 777; // Buradaki iÅŸlemde '777' deÄŸeri global 'ar' dizisinin 0 indisli elemanÄ±na atanÄ±yor.

    print_array(ar, 5);

    foo()[2]++; // 'foo()[2]++' ifadesi operatÃ¶r Ã¶nceliÄŸi dikkate alÄ±ndÄ±ÄŸÄ±nda '((foo())[2])++' ifadesi ile Ã¶zdeÅŸtir. Buradaki ifade lageldir, burada 'ar' dizisinin 2 indisli elemanÄ±nÄ±n deÄŸeri bir arttÄ±rÄ±lÄ±yor.
    print_array(ar, 5);
}
```

ğŸ§  `foo()[2]++` ifadesinde Ã¼Ã§ farklÄ± operatÃ¶r vardÄ±r, bunlar;
1. `()` function call operator.
2. `[]` subscript(index of) operator.
3. `++` right increment operator.



ğŸ‘‡ AÅŸaÄŸÄ±daki program pointer deÄŸiÅŸkenlerin kullanÄ±mÄ±nÄ± daha iyi anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int* foo(int* ptr)
{
    *ptr *= 5; // Buradaki ifade '*ptr = *ptr * 5' ifadesi ile aynÄ±dÄ±r.
    return ptr;
}

int main(void)
{
    int x = 10;

    // Buradaki gibi kod Ã¼retimde yazÄ±lmaz, burada dilin kurallarÄ±nÄ± anlamak iÃ§in yazÄ±lmÄ±ÅŸtÄ±r.
    *foo(&x) += 33; // Buradaki gibi bir statement legaldir ve herhangi bir sorun yoktur, 
    printf("x = %d", x);
}
```


>â”
> 
> Sorulan soru; 
> 
> return `*ptr` deseydik "x" mi olucaktÄ± yoksa hata mÄ± verirdi?
> 
> ```C
> #define _CRT_SECURE_NO_WARNINGS
> 
> #include <stdio.h>
> #include "nutility.h"
> 
> int* foo(int* ptr)
> {
>     *ptr *= 5;
>     return *ptr; // Bu kullanÄ±m C dilinde legal'dir ama doÄŸru deÄŸildir, burada Ã¶rtÃ¼lÃ¼ tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapÄ±lÄ±yor ama derleyici uyarÄ± iletisi verir. C++ dilinde sÃ¶zdizim hatasÄ±(syntax error).
> }
> ```
> 
> Cevap;
> 
> `foo` fonksiyonunun geri dÃ¶nÃ¼ÅŸ ifadesi `*ptr` verilmiÅŸ ama bu `ptr` pointer deÄŸiÅŸkeninin gÃ¶sterdiÄŸi adresteki deÄŸer olduÄŸu ve bu fonksiyondan geriye bir `int*` tÃ¼rÃ¼ dÃ¶nÃ¼lmesi gerektiÄŸi iÃ§in doÄŸru olmayacaktÄ±r, ne kadar legal olsa da bu ÅŸekilde kod yazÄ±lmamalÄ±dÄ±r. C++ dilinde bu kullanÄ±m senteks hatasÄ±dÄ±r.
> 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `get_array_max` fonksiyonundan dÃ¶nen pointer Ã¼zerinden iÅŸlemler yapÄ±labilir, buradaki fonksiyonun tanÄ±mÄ± yapÄ±lmadÄ±ÄŸÄ± iÃ§in linking aÅŸamasÄ±nda hata alÄ±nacaktÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

// AÅŸaÄŸÄ±daki fonksiyon dizideki en bÃ¼yÃ¼k elemanÄ± tespit eder ve bu dizi elemanÄ±n adresini geriye dÃ¶ndÃ¼rÃ¼r.
int* get_array_max(const int* p, int size);

int main(void)
{
    int a[SIZE];

    randomize();
    set_array_random(a, SIZE);
    print_array(a, SIZE);

    int* ptr = get_array_max(a, SIZE);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki gibi programlarÄ± Necati Ergin C mÃ¼lakatlarÄ±nda pointer deÄŸiÅŸkenlerle yapÄ±lan iÅŸlemlerin mantÄ±ÄŸÄ±nÄ±n anlaÅŸÄ±ldÄ±ÄŸÄ±nÄ± sÄ±namak iÃ§in kullanÄ±yormuÅŸ, soru olarak aÅŸaÄŸÄ±daki programda **sÃ¶zdizim hatasÄ±(syntax error)** ya da "**ub**" gibi bir Ã¶zel durum olup olmadÄ±ÄŸÄ± soruluyormuÅŸ.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 100

int* foo(int* p)
{
    *p *= 2; // Bu statement sonunda 'p'nin gÃ¶sterdiÄŸi yerdeki deÄŸer '26' olur.
    bar(p); // Bu statement sonunda 'p'nin gÃ¶sterdiÄŸi yerdeki deÄŸer '17' olur.

    return p;
}

void bar(int* p)
{
    ++*p;
}

int main(void)
{
    int x = 13;

    *foo(&x) -= 7; // Burada '*foo(&x)' ifadesinin yani 'x' deÄŸiÅŸkeninin deÄŸeri '27'dir. '*foo(&x) -= 7;' statement'Ä± sonunda 'x' deÄŸiÅŸkeninin deÄŸeri '20' olacaktÄ±r.

    printf("x = %d\n", x); // Burada standart Ã§Ä±ktÄ± akÄ±mÄ±na ' x = 20\n' gÃ¶nderilir. 
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.00-12.10 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `get_value` fonksiyonundan geriye "**otomatic storage duration**" deÄŸiÅŸkenin adresi dÃ¶nÃ¼ldÃ¼ÄŸÃ¼ iÃ§in bu fonksiyondan geriye dÃ¶nen deÄŸerin kullanÄ±lmasÄ± **ub** oluÅŸturacaktÄ±r, bu tÃ¼r pointer'lara "**dangling pointer**" denilmektedir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 100

int* get_value(void)
{
    int x;

    printf("bir tam sayi giriniz: ");
    scanf("%d", &x);

    return &x;
}

int* get_name(void)
{
    char name[70];

    printf("adÄ±nÄ± bagisla: ");
    scanf("%s", &name);

    return name; // Burada geriye dÃ¶ndÃ¼rÃ¼len nesne 'otomatic storage duration' bellek Ã¶mrÃ¼ne sahip olduÄŸu iÃ§in bu 'ub'ye neden olacaktÄ±r.
}

int main(void)
{
    int* p = get_value();

    printf("deger = %d\n", *p); // Burada 'ub' vardÄ±r.

    char* p = get_name(); // Burada 'ub' vardÄ±r.
    puts(p);
}
```



â—â—â— Kursun pointer'lar ile ilgili en Ã¶nemli cÃ¼mlesi: Pointer deÄŸer dÃ¶ndÃ¼ren fonksiyonlardan geriye asla "**otomatic storage duration**" deÄŸiÅŸkenlerin adresleri dÃ¶ndÃ¼rÃ¼lmemelidir.  



â—â—â— Adres dÃ¶ndÃ¼ren fonksiyonlar **ub**'ye neden olmadan ne dÃ¶ndÃ¼rebilir?
1. **Static Ã¶mÃ¼rlÃ¼** nesne adresi dÃ¶ndÃ¼rebilir, bunlar aÅŸaÄŸÄ±daki gibi olabilir; 
    1. Global deÄŸiÅŸken adresleri.
    2. Static yerel deÄŸiÅŸken adresleri.
    3. **String literal** ifadeleri(**String literal** ifadeleri **Static Ã¶mÃ¼rlÃ¼** dizi nesneleridir).
2. Ã‡aÄŸÄ±ran kodun gÃ¶nderdiÄŸi adres dÃ¶ndÃ¼rebilir. 
3. Diziler Ã¼zerinde iÅŸlem yapan fonksiyonlarÄ±n dizinin bir elemanÄ±nÄ±n adresini dÃ¶ndÃ¼rmesi. 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**static storage duration**" Ã¶mÃ¼rlÃ¼ global bir deÄŸiÅŸkenin referansÄ±nÄ±n `get_name` fonksiyonundan dÃ¶ndÃ¼rÃ¼lÃ¼ÅŸÃ¼ incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 100

char name[70]; // 'static storage duration' global(genel) deÄŸiÅŸken bildirimi

int* get_name(void)
{
    printf("adÄ±nÄ± bagisla: ");
    scanf("%s", &name);

    return name;
}

int main(void)
{
    char* p = get_name();  // Burada 'ub' durumu yoktur.
    puts(p);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**static storage duration**" Ã¶mÃ¼rlÃ¼ local bir deÄŸiÅŸkenin referansÄ±nÄ±n `get_name` fonksiyonundan dÃ¶ndÃ¼rÃ¼lÃ¼ÅŸÃ¼ incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 100

int* get_name(void)
{
    static char name[70]; // 'static storage duration' local(yerel) deÄŸiÅŸken bildirimi

    printf("adÄ±nÄ± bagisla: ");
    scanf("%s", &name);

    return name;
}

int main(void)
{
    char* p = get_name(); // Burada 'ub' durumu yoktur.
    puts(p);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir hata yoktur ama kullanÄ±lan gÃ¶stericilerin Ã¼Ã§Ã¼ de aynÄ± "name" deÄŸiÅŸkeninin adresini kullanacaÄŸÄ± iÃ§in program istenildiÄŸi gibi Ã§alÄ±ÅŸmayacaktÄ±r, "name" **static storage duration** bir deÄŸiÅŸkendir ve `get_name` fonksiyonu her Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ±nda deÄŸeri deÄŸiÅŸecektir ve en son aldÄ±ÄŸÄ± deÄŸer bu nesneyi referans eden pointer deÄŸiÅŸkenlerin hepsiyle yapÄ±lan iÅŸlemi etkileyecektir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define ARRAY_SIZE 70

char* get_name(void)
{
    static char name[ARRAY_SIZE]; // 'static storage duration' local(yerel) deÄŸiÅŸken bildirimi

    printf("adÄ±nÄ± bagisla: ");
    scanf("%s", &name);
    printf("\n");

    return name;
}

int main(void)
{
    char* p1 = get_name();
    char* p2 = get_name();
    char* p3 = get_name();
    
    printf("aldigim uc ad sirasiyla: %s %s %s\n", p1, p2, p3);

    // AÅŸaÄŸÄ±daki gibi yazÄ±lÄ±rsa 'logic' hata oluÅŸmayacaktÄ±.
    char* p12 = get_name();
    printf("alinan ad: %s\n", p12);
    char* p22 = get_name();
    printf("alinan ad: %s\n", p22);
    char* p32 = get_name();
    printf("alinan ad: %s\n", p32);
}
```



â—â—â— Adres(pointer) dÃ¶ndÃ¼ren bir fonksiyon **static storage duration** nesne adresi dÃ¶ndÃ¼rebilir bu **tanÄ±msÄ±z davranÄ±ÅŸa(ub)** yol aÃ§maz ama **static storage duration** nesne adresi dÃ¶ndÃ¼rmesi demek fonksiyonun hep aynÄ± nesnenin adresini dÃ¶ndÃ¼rmesi demektir. </br>
**Static storage duration** nesne adresi dÃ¶ndÃ¼ren fonksiyonlarÄ±n bilinmesi gerekiyor ki o fonksiyon kullanÄ±lÄ±rken programda mantÄ±k(logic) hatalarÄ±na neden olabilecek ÅŸekilde kod yazÄ±lmasÄ±n, bu bilginin fonksiyonun dokÃ¼mantasyonunda aÃ§Ä±k ÅŸekilde belirtilmesi gerekiyor. </br>
C dilinin standart kÃ¼tÃ¼phanesindeki **static storage duration** nesne adresi dÃ¶ndÃ¼ren fonksiyonlarÄ±n dokÃ¼mantasyonunda bunun aÃ§Ä±k ÅŸekilde belirtildiÄŸi gÃ¶rÃ¼lebilir.



âš ï¸ `static char* foo();` gibi bir fonksiyon bildirimindeki `static` anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n bu ÅŸekilde kullanÄ±lmasÄ± `static` anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n yerel(local) seviyede kullanÄ±lmasÄ±ndaki anlamÄ± olan bu anahtar sÃ¶zcÃ¼k ile bildirilen deÄŸiÅŸkenin Ã¶mrÃ¼nÃ¼n **static storage duration** olmasÄ±ndan farklÄ± bir anlama gelmektedir ama bu ileride iÅŸlenecek ayrÄ± bir baÅŸlÄ±ÄŸÄ±n konusudur.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **string literal** ifadelerin `char*` tÃ¼rÃ¼nden deÄŸerini dÃ¶ndÃ¼ren `to_weekday` fonksiyonunun kullanÄ±mÄ± incelenebilir, bu tÃ¼r kullanÄ±mlar yaygÄ±ndÄ±r. **string literal** ifadeleri ileride daha detaylÄ± incelenecektir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 100

char* to_weekday(int dayno)
{
    switch(dayno){
        case 1: return "pazartesi";
        case 2: return "sali";
        case 3: return "carsamba";
        case 4: return "persembe";
        case 5: return "cuma";
        case 6: return "cumartesi";
        case 7: return "pazar";
        default return "";
    }
}

int main(void)
{
    for(int i = 0; i <= 7; ++i)
        puts(to_weekday(i))
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `foo` fonksiyonu parametre olarak dÄ±ÅŸarÄ±dan aldÄ±ÄŸÄ± bir adres Ã¼zerinden iÅŸlemler yaptÄ±ktan sonra aynÄ± adresi geriye dÃ¶ndÃ¼rmektedir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 100

int* foo(int* p)
{
    // some code here
    *p = (*p + 5) * *p;
   return p;
}

int main(void)
{
    int ival = 35;
    printf("ival = %d", ival);

    int* p = foo(&ival);

    printf("ival = %d", ival);
    printf("p = %p, *p = %d\n", p, *p);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `get_array_max` fonksiyonunun bir dizideki en bÃ¼yÃ¼k deÄŸeri bulmak iÃ§in "**input value**" olarak dizinin baÅŸlangÄ±Ã§ adresini aldÄ±ktan sonra tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mlerini nasÄ±l kullanarak geriye sonuÃ§ deÄŸerini dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 20

int* get_array_max_v1(const int* ptr, int size)
{
    const int* pmax = ptr;

    for(int i = 0; i < size; ++i){
        if(ptr[i] > *pmax){
            // pmax = &ptr[0];
            pmax = ptr + i; // Pointer aritmetiÄŸi ile dizinin i. elemanÄ±nÄ±n adresi 'pmax' gÃ¶stericisine yeni deÄŸeri olarak atanÄ±yor.
        }
    }

    return (int*)pmax; // Buradaki casting iÅŸlemi 'const cast' olarak adlandÄ±rÄ±lmaktadÄ±r, buradaki tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼nÃ¼n aÃ§Ä±k ÅŸekilde yapÄ±lmasÄ±nÄ±n nedeni derleyicisnin uyarÄ± vermemesi iÃ§indir. 
}

// Burada 'get_array_max' fonksiyonunun diÄŸer kullanÄ±mÄ±nÄ±n yazÄ±lmasÄ± gerekiyor.
int* get_array_max_v2(const int* ptr, int size)
{
    int* pmax = (int*)ptr;

    for(int i = 0; i < size; ++i){
        if(ptr[i] > *pmax){
            pmax = (int*)(ptr + i); // Pointer aritmetiÄŸi ile dizinin i. elemanÄ±nÄ±n adresi 'pmax' gÃ¶stericisine yeni deÄŸeri olarak atanÄ±yor.
        }
    }

    return pmax;
}

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    int* pmax = get_array_max_v1(ar, SIZE);

    printf("max = %d\n", *pmax);
    printf("en buyuk elemanin indeksi = %d\n", pmax - ar);
    *pmax = -1;

    print_array(ar, SIZE);
}
```


**Const Cast**: `const` olarak bildirilen bir deÄŸiÅŸkenin `const` olmayan tÃ¼rÃ¼ne Ã§evrilmesi iÅŸlemine verilen addÄ±r. YukarÄ±daki programda bu kullanÄ±m incelenebilir.


>â”
> 
> Sorulan soru; 
> 
> Bu fonksiyonu daha farkli sekilde de yazabilirdik. eskiden yazdigimiz gibi int degerler Ã¼zerinde max 'I bulup en sonda adress hesaplayip return edeblilrdik.
> BÃ¶ylece bizim eski swap fonk calisirdi yani nesnenin degerini degistirirdik
> ğŸ™‚ destan
> 
> Cevap;
> 
> Son programdaki `get_array_max` fonksiyonu aÅŸaÄŸÄ±daki gibi de yazÄ±labilir.
> 
> ```C
> int* get_array_max(const int* ptr, int size)
> {
>     int max  = *ptr;
>     int max_idx = 0;
> 
>     for(int i = 0; i < size; ++i){
>         if(ptr[i] > max){
>             max = ptr[i];
>             max_idx = i;
>         }
>     }
> 
>     return (int*)(ptr + max_idx);
> }
> ```


Ders sonu ...
