# 50.Ders 13.07.2025 ğŸ•˜

Derse 6(09:01)-7(09:04)-8(09:21)-10(10:02)-11(10:55)-11(11:35)-10(12:41) kiÅŸi katÄ±ldÄ±.
---

ğŸ“Œ Kursun tamamlanmasÄ± iÃ§in en az 16 saat ilave ders eklenmesi gerektiÄŸi belirtildi.

ğŸ“Œ Microsoft derleyicisinde `#pragma pack(1)` makrosu **pedding bytes** kullanÄ±lmamasÄ± iÃ§in kullanÄ±lÄ±yor.


## `offsetof` Function Like Makro 

Bu fonksiyonel makro `stddef.h` baÅŸlÄ±k dosyasÄ±nda bulunmaktadÄ±r ve C99 standardÄ± ile dile eklenmiÅŸtir. </br>
`offsetof` makrosunun Ã¼rettiÄŸi deÄŸer `size_t` tÃ¼rÃ¼ndendir. </br>
`offsetof` makrosunun bir tÃ¼rÃ¼n Ã¶yelerinin bellek adreslerinin tÃ¼rÃ¼n baÅŸlangÄ±Ã§ adresini referans alarak tÃ¼rÃ¼n baÅŸlangÄ±Ã§ adresinden kaÃ§ byte sonra bulunduÄŸu bilgisini `size_t` tÃ¼rÃ¼nden geriye dÃ¶nmektedir.


`offsetof` makrosunu iyi bilmek hem dile hakimiyet aÃ§Ä±sÄ±ndan Ã¶nemli hem de profesyonel C mÃ¼lakatlarÄ±nda bu makronun **gerÃ§ekleÅŸtiriminin(implementation)** yapÄ±lmasÄ± isteniyor, mÃ¼lakatlarda bunun istenmesinin nedeni C diline hakimiyeti Ã¶lÃ§mektir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `offsetof` fonkisyonel makrosunun nasÄ±l kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#include <stddef.h> // Standart kÃ¼tÃ¼phenedeki en sade baÅŸlÄ±k dosyasÄ±dÄ±r.
#include <stdio.h>

typedef struct Data {
    char c1;
    int i;
    char c2;
    char c3;
} Data;

int main(void)
{
    printf("offsetof c1 = %zu\n", offsetof(struct Data, c1));
    printf("offsetof i = %zu\n", offsetof(struct Data, i));
    printf("offsetof c2 = %zu\n", offsetof(struct Data, c2));
    printf("offsetof c3 = %zu\n", offsetof(struct Data, c3));

    Data data1 = { 19, 4423423, 54, 76};
    char* p = (char*)&data1;

    // 'offsetof' makrosunun doÄŸru Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± gÃ¶rmek iÃ§in aÅŸaÄŸÄ±daki sÄ±nama kodlarÄ±nÄ± yazdÄ±k.
    printf("c1 = %d", *(p + offsetof(struct Data, c1)));
    printf("i = %d", *(int*)(p + offsetof(struct Data, i)));
    printf("c2 = %d", *(p + offsetof(struct Data, c2)));
    printf("c3 = %d", *(p + offsetof(struct Data, c3)));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda standart olan `offsetof` maktosunun gerÃ§ekleÅŸtiriminin `OFFSETOF` adÄ±nda yapÄ±ldÄ±ÄŸÄ± incelenebilir, `OFFSETOF` gerÃ§ekleÅŸtirimini anlamak zor olabilir bu nedenden dolayÄ± ayrÄ±ca inceleme yapmak gerekebilir. 
```C
#include <stddef.h> // Standart kÃ¼tÃ¼phenedeki en sade baÅŸlÄ±k dosyasÄ±dÄ±r.
#include <stdio.h>

#define OFFSETOF(S, M)      (size_t)(&((S *)0)->m) // MÃ¼lakatlarda buradaki gibi 'offsetof' makrosunun yaptÄ±ÄŸÄ± iÅŸi yapan 'OFFSETOF' makrosu gibi bir tanÄ±mlamanÄ±n yapÄ±lmasÄ± istenebilir ve burada neden 'ub' olmadÄ±ÄŸÄ± sorulacaktÄ±r.

typedef struct Data {
    char c1;
    int i;
    char c2;
    char c3;
} Data;

int main(void)
{
    printf("OFFSETOF c1 = %zu\n", OFFSETOF(struct Data, c1));
    printf("OFFSETOF i = %zu\n", OFFSETOF(struct Data, i));
    printf("OFFSETOF c2 = %zu\n", OFFSETOF(struct Data, c2));
    printf("OFFSETOF c3 = %zu\n", OFFSETOF(struct Data, c3));

    Data data1 = { 19, 4423423, 54, 76};
    char* p = (char*)&data1;

    // 'OFFSETOF' makrosunun doÄŸru Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± gÃ¶rmek iÃ§in aÅŸaÄŸÄ±daki sÄ±nama kodlarÄ±nÄ± yazdÄ±k.
    printf("c1 = %d", *(p + OFFSETOF(struct Data, c1)));
    printf("i = %d", *(int*)(p + OFFSETOF(struct Data, i)));
    printf("c2 = %d", *(p + OFFSETOF(struct Data, c2)));
    printf("c3 = %d", *(p + OFFSETOF(struct Data, c3)));
}
```


## Unions(Birlikler) 

YapÄ± bildirimleriyle bir kaÃ§ farklÄ±lÄ±k dÄ±ÅŸÄ±nda aynÄ±dÄ±r. YapÄ±lar ve birlikler aradaki tek fark **memory layout** kÄ±smÄ±ndadÄ±r, yapÄ± nesneleri bellekte elemanlarÄ±nÄ±n toplan bellek alanÄ± kadar(**paddin bytes** dahil) yer kaplarken bir birlik nesnesi bellekte sadece en bÃ¼yÃ¼k bellek alanÄ±na sahip olan Ã¼yesi kadar yer kaplar.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda yapÄ± tÃ¼rÃ¼ ve birlik tÃ¼rlerinin bildirimi incelenebilir.
```C
#include <stddef.h>
#include <stdio.h>

struct SData {
    char c1;
    int i;
    char c2;
    char c3;
};

union UData {
    char c1;
    int i;
    char c2;
    char c3;
};
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda yapÄ± tÃ¼rÃ¼ ve birlik tÃ¼rlerinin bildirimi ve birlik kullanÄ±mÄ± incelenebilir.
```C
#include <stddef.h>
#include <stdio.h>

typedef struct SData {
    double d;
    int i;
    char c2;
    char c3;
}SData;

typedef union UData {
    double d;
    int i;
    char c2;
    char c3;
}UData;


int main(void)
{
    UData data1;

    // Birlik tÃ¼rÃ¼nden bir nesnesin 
    data1.d = 3.2423;
    data1.c1 = 23;
    UData* p = &data1;

    p.c2 = 4;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda yapÄ± nesnelerinin ve birlik nesnelerinin bellekte ne kadar yer kapladÄ±klarÄ± incelenebilir.
```C
#include <stddef.h>
#include <stdio.h>


typedef struct SData1 {
    int i;
}SData1;

typedef union UData1 {
    int i;
}UData1;


typedef struct SData2 {
    int x, y;
}SData2;

typedef union UData2 {
    int x, y;
}UData2;


typedef struct SData3 {
    int x, y, z;
}SData3;

typedef union UData3 {
    int x, y, z;
}UData3;


typedef struct SData4 {
    int x, y, z;
    double dval;
}SData4;

typedef union UData4 {
    int x, y, z;
    double dval;
}UData4;


typedef struct SData5 {
    int x, y, z;
    double d1, d2;
}SData5;

typedef union UData5 {
    int x, y, z;
    double d1, d2;
}UData5;


typedef struct SData6 {
    int x, y, z;
    double d1, d2;
    char str[12];
}SData6;

typedef union UData6 {
    int x, y, z;
    double d1, d2;
    char str[12];
}UData6;


int main(void)
{
    printf("sizeof(SData1) = %zu\n", sizeof(SData1)); // 'int' tÃ¼rÃ¼ 4 byte olan sistemde standart Ã§Ä±ktÄ± akÄ±mÄ±na 'sizeof(SData1) = 4\n' deÄŸeri gÃ¶nderilir.
    printf("sizeof(UData1) = %zu\n", sizeof(UData1)); // 'int' tÃ¼rÃ¼ 4 byte olan sistemde standart Ã§Ä±ktÄ± akÄ±mÄ±na 'sizeof(UData1) = 4\n' deÄŸeri gÃ¶nderilir.

    printf("sizeof(SData2) = %zu\n", sizeof(SData2)); // 'int' tÃ¼rÃ¼ 4 byte olan sistemde standart Ã§Ä±ktÄ± akÄ±mÄ±na 'sizeof(SData2) = 8\n' deÄŸeri gÃ¶nderilir.
    printf("sizeof(UData2) = %zu\n", sizeof(UData2)); // 'int' tÃ¼rÃ¼ 4 byte olan sistemde standart Ã§Ä±ktÄ± akÄ±mÄ±na 'sizeof(UData2) = 4\n' deÄŸeri gÃ¶nderilir.

    printf("sizeof(SData3) = %zu\n", sizeof(SData3)); // 'int' tÃ¼rÃ¼ 4 byte olan sistemde standart Ã§Ä±ktÄ± akÄ±mÄ±na 'sizeof(SData3) = 12\n' deÄŸeri gÃ¶nderilir.
    printf("sizeof(UData3) = %zu\n", sizeof(UData3)); // 'int' tÃ¼rÃ¼ 4 byte olan sistemde standart Ã§Ä±ktÄ± akÄ±mÄ±na 'sizeof(UData3) = 4\n' deÄŸeri gÃ¶nderilir.

    printf("sizeof(SData4) = %zu\n", sizeof(SData4)); // 'int' tÃ¼rÃ¼ 4 byte ve 'double' tÃ¼rÃ¼ 8 byte olan sistemde standart Ã§Ä±ktÄ± akÄ±mÄ±na 'sizeof(SData4) = 24\n' deÄŸeri gÃ¶nderilir. Burada yapÄ±nÄ±n bellek boyutunun '20' yerine '24' olmasÄ±nÄ±n nedeni geÃ§en derste incelenen 'alignment requirement' deÄŸerinin '8' olmasÄ±dÄ±r. 
    printf("sizeof(UData4) = %zu\n", sizeof(UData4)); // 'int' tÃ¼rÃ¼ 4 byte ve 'double' tÃ¼rÃ¼ 8 byte olan sistemde standart Ã§Ä±ktÄ± akÄ±mÄ±na 'sizeof(UData4) = 8\n' deÄŸeri gÃ¶nderilir.

    printf("sizeof(SData5) = %zu\n", sizeof(SData5)); // 'int' tÃ¼rÃ¼ 4 byte ve 'double' tÃ¼rÃ¼ 8 byte olan sistemde standart Ã§Ä±ktÄ± akÄ±mÄ±na 'sizeof(SData5) = 32\n' deÄŸeri gÃ¶nderilir. Burada yapÄ±nÄ±n bellek boyutunun '28' yerine '32' olmasÄ±nÄ±n nedeni geÃ§en derste incelenen 'alignment requirement' deÄŸerinin '8' olmasÄ±dÄ±r. 
    printf("sizeof(UData5) = %zu\n", sizeof(UData5)); // 'int' tÃ¼rÃ¼ 4 byte ve 'double' tÃ¼rÃ¼ 8 byte olan sistemde standart Ã§Ä±ktÄ± akÄ±mÄ±na 'sizeof(UData5) = 8\n' deÄŸeri gÃ¶nderilir.

    printf("sizeof(SData6) = %zu\n", sizeof(SData6)); // 'int' tÃ¼rÃ¼ 4 byte ve 'double' tÃ¼rÃ¼ 8 byte olan sistemde standart Ã§Ä±ktÄ± akÄ±mÄ±na 'sizeof(SData6) = 48\n' deÄŸeri gÃ¶nderilir. Burada yapÄ±nÄ±n bellek boyutunun '40' yerine '48' olmasÄ±nÄ±n nedeni geÃ§en derste incelenen 'alignment requirement' deÄŸerinin '8' olmasÄ±dÄ±r. 
    printf("sizeof(UData6) = %zu\n", sizeof(UData6)); // 'int' tÃ¼rÃ¼ 4 byte ve 'double' tÃ¼rÃ¼ 8 byte olan sistemde standart Ã§Ä±ktÄ± akÄ±mÄ±na 'sizeof(UData6) = 16\n' deÄŸeri gÃ¶nderilir Ã§Ã¼nkÃ¼ birliÄŸin bellekte en hazla yer kaplayan 'str[12]' Ã¼yesinin bellek bÃ¼yÃ¼klÃ¼ÄŸÃ¼ '12'dir ama birliÄŸin 'alignment requirement' deÄŸerinin '8' olduÄŸu iÃ§in varsayÄ±lan durumda bellekten yer 8 byte'lÄ±k dilimler halinde ayrÄ±lmaktadÄ±r.
}
```


â—â—â— ğŸ‘† YukarÄ±daki programdan da gÃ¶rÃ¼lebileceÄŸi gibi yapÄ±larda her Ã¼ye bellekte farklÄ± yerde tutulur ama birliklerde tÃ¼m Ã¼yeler aynÄ± bellek bloÄŸunda tutulurlar.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `union UData` tÃ¼rÃ¼nden olan bir birlik tÃ¼rÃ¼nÃ¼n nesnelerinin bellekte kaplayacaklarÄ± alanÄ±n kendi Ã¼yelerinden en bÃ¼yÃ¼k bellek boyutuna sahip Ã¼yenin bellek boyutu olduÄŸu ve birliÄŸin her Ã¼yesinin bellek boyutunun aynÄ± olduÄŸu incelenebilir.
```C
#include <stddef.h>
#include <stdio.h>

typedef union UData{
    int x, y, z;
    double d1, d2;
    char str[12];
} UData;

int main(void)
{
    UData data1 = { 0 };

    // AÅŸaÄŸÄ±daki kodlarda sÄ±tandart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderilecek bilgilerdeki adres deÄŸerinin aynÄ± olduÄŸu gÃ¶rÃ¼lecektir, bunun nedeni 'union' nesnelerin kendi adresi ile tÃ¼m Ã¼yelerinin adresinin aynÄ± olarak tutulmasÄ±ndan kaynaklanmaktadÄ±r.
    printf("&data1      = %p\n", &data1);
    printf("&data1      = %p\n", &data1.x);
    printf("&data1      = %p\n", &data1.y);
    printf("&data1      = %p\n", &data1.z);
    printf("&data1      = %p\n", &data1.d1);
    printf("&data1      = %p\n", &data1.d2);
    printf("&data1      = %p\n", &data1.str);


}
```

â—â—â— ğŸ‘† YukarÄ±daki programdan da gÃ¶rÃ¼lebileceÄŸi gibi birliklerin nesnelerinin tÃ¼m Ã¼yeleri aynÄ± bellek bloÄŸunu kullanÄ±rlar, bunun gerekli olduÄŸu senaryolar vardÄ±r, ilerleyen kÄ±sÄ±mlarda gÃ¶receÄŸiz.



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programdan birlik tÃ¼rlerine ilk deÄŸer verme sÃ¶zdizimi incenebilir.
```C
#include <stddef.h>
#include <stdio.h>

typedef union {
    int x, y, z;
    double d1, d2;
    char str[12];
} Data;

int main(void)
{
    Data data1 = { 12, 23 }; // Bir birlik tÃ¼rÃ¼nÃ¼n tÃ¼m Ã¶ÄŸeleri bellekte aynÄ± yerde tutulduÄŸu iÃ§in ilk deÄŸer verirken sadece tek bir Ã¼yeye ilk deÄŸer verilmesine izin verilmektedir, bu nedenlerden Ã¶tÃ¼rÃ¼ burada sÃ¶zdizimi hatasÄ± vardÄ±r.

    Data data2 = { 67 }; // Buradaki ilk deÄŸer verme iÅŸleminde verilen ilk deÄŸer birlik nesnesinin ilk Ã¼yesine verilecektir.

    Data data2 = { .d2 = 4.75 }; // Burada C99 standardÄ± ile dile eklenen 'designated initializer' sÃ¶zdizim'i ile birlik nesnesinin 'd2' adlÄ± Ã¼yesine ilk deÄŸer veriliyor.
}
```


### Unions(Birlikler) KullanÄ±n Nedenleri 

Bu baÅŸlÄ±k altÄ±nda **unions(birlikler)** aracÄ±nÄ±n kullanÄ±lma nedenlerini inceleyeceÄŸiz.


#### Bellekten Tasarruf Ä°Ã§in KullanÄ±lÄ±r

Bellekten tasarruf iÃ§in aynÄ± anda bir arada olma ihtimali olmayan iki deÄŸiÅŸken olduÄŸunda bu iki deÄŸiÅŸken `union` ile aynÄ± bellek alanÄ±nda tutulabilir, bÃ¶ylece hem bellekten tasarruf edilmiÅŸ olur hem de kafa karÄ±ÅŸÄ±klÄ± Ã¶nlenebilir. Bu **mikro controlor** Ã¼zerinde Ã§alÄ±ÅŸacak programlarÄ± yazarken Ã¶nemli olacaktÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `Employee` tÃ¼rÃ¼nde(esasÄ±nda tÃ¼r eÅŸ adÄ±) cinsiyete Ã¶zel bazÄ± bilgilerin cinsiyet fark etmeksizin tutulduÄŸu durum incelenebilir, bu kullanÄ±mda yapÄ± nesnelerinin bellek boyutlarÄ± olabileceÄŸinden daha bÃ¼yÃ¼ktÃ¼r.
```C
#include <stddef.h>
#include <stdio.h>

typedef struct {
    int category; 
    char dept[12]; // Ne olduÄŸu Ã¶nemli olmayan bir bilgi
} Milinfo; // DeÄŸiÅŸken alarÄ±na zaman ayrÄ±lmadÄ± ama Ã¼retimde dÃ¼zgÃ¼n adlar verilmelidir.

// 'Employee' yapÄ±sÄ±nda tutulacak olan kiÅŸi bilgisi erkek ya da kadÄ±n olabilir, 
typedef struct {
    int id;
    char name[24];
    char maiden_name[16]; // Evlenmeden Ã¶nceki soyad bilgisi.
    char gender;
    Milinfo minfo; // Askerlik bilgisi.
} Employee;


int main(void)
{
    printf("sizeof(Employee) = %zu\n", sizeof(Employee)); // 'int' tÃ¼rÃ¼nÃ¼n 4 byte oldÄŸu sistemde standart Ã§Ä±ktÄ± akÄ±mÄ±na 'sizeof(Employee) = 64\n' gÃ¶nderilir, bu deÄŸerin neden bÃ¶yle olduÄŸunu 'alignment requirement' deÄŸerinin 4 olduÄŸunu anlayÄ±nca hesaplayÄ±p anlayabilirsin.
}
```

ğŸ‘‡ AÅŸaÄŸÄ±daki programda `Employee` tÃ¼rÃ¼nde(esasÄ±nda tÃ¼r eÅŸ adÄ±) cinsiyete Ã¶zel bazÄ± bilgilerin cinsiyet fark etmeksizin tutulduÄŸu durum incelenebilir, bu kullanÄ±mda yapÄ± nesnelerinin bellek boyutlarÄ± olabileceÄŸinden daha bÃ¼yÃ¼ktÃ¼r.
```C
#include <stddef.h>
#include <stdio.h>

typedef struct {
    double category; 
    char dept[12]; // Ne olduÄŸu Ã¶nemli olmayan bir bilgi
} Milinfo; // DeÄŸiÅŸken alarÄ±na zaman ayrÄ±lmadÄ± ama Ã¼retimde dÃ¼zgÃ¼n adlar verilmelidir.

// 'Employee' yapÄ±sÄ±nda tutulacak olan kiÅŸi bilgisi erkek ya da kadÄ±n olabilir, 
typedef struct {
    int id;
    char name[24];
    char maiden_name[16]; // Evlenmeden Ã¶nceki soyad bilgisi.
    char gender;
    Milinfo minfo; // Askerlik bilgisi.
} Employee;


int main(void)
{
    printf("sizeof(Employee) = %zu\n", sizeof(Employee)); // 'int' tÃ¼rÃ¼nÃ¼n 4 byte oldÄŸu sistemde standart Ã§Ä±ktÄ± akÄ±mÄ±na 'sizeof(Employee) = 72\n' gÃ¶nderilir, bu deÄŸerin neden bÃ¶yle olduÄŸunu 'alignment requirement' deÄŸerinin 8 olduÄŸunu anlayÄ±nca hesaplayÄ±p anlayabilirsin. 
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **anonymous struct** ve **anonymous union** aracÄ±nÄ± kullanarak `Employee` tÃ¼rÃ¼nÃ¼n(esasÄ±nda tÃ¼r eÅŸ adÄ±) bellekte kapladÄ±ÄŸÄ± alanÄ±n nasÄ±l azaltÄ±labileceÄŸi incelenebilir.
```C
#include <stddef.h>
#include <stdio.h>

typedef struct {
    int id;
    char name[24];
    
    // AÅŸaÄŸÄ±daki kullanÄ±m 'anonymous struct' ve 'anonymous union' aracÄ± kullanÄ±lÄ±yor.
    union {
        char maiden_name[16];
        struct {
            int category; 
            char dept[12]; // Ne olduÄŸu Ã¶nemli olmayan bir bilgi
        };
    };

    char gender;
} Employee;


int main(void)
{
    printf("sizeof(Employee) = %zu\n", sizeof(Employee));// 'int' tÃ¼rÃ¼nÃ¼n 4 byte oldÄŸu sistemde standart Ã§Ä±ktÄ± akÄ±mÄ±na 'sizeof(Employee) = 48\n' gÃ¶nderilir, bu deÄŸerin neden bÃ¶yle olduÄŸunu 'alignment requirement' deÄŸerinin 4 olduÄŸunu anlayÄ±nca ve 'union' varlÄ±ÄŸÄ±n Ã§alÄ±ÅŸma biÃ§imini bildiÄŸinde hesaplayÄ±p gÃ¶rebilirsin. 
}
```


#### Bir Veri TÃ¼rÃ¼nÃ¼n FarklÄ± iki BiÃ§imde Temsil Edilmesi 


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `FLOAT_t` tÃ¼rÃ¼nÃ¼n(esasÄ±nda tÃ¼r eÅŸ adÄ±) aynÄ± anda hem tam sayÄ± hem de `float` tÃ¼rÃ¼nden ondalÄ±klÄ± sayÄ± tutabileceÄŸi(bu tÃ¼r ile bir ondalÄ±klÄ± sayÄ±nÄ±n virgÃ¼lden Ã¶nceki ve sonraki kÄ±sÄ±mlarÄ± ayrÄ± ayrÄ± bu tÃ¼r ile tutulabilir) bir kullanÄ±m incelenebilir.
```C
#include <stddef.h>
#include <stdio.h>
#include <stdint.h>

typedef union {
    int32_t i;
    float f;
} FLOAT_t;


int main(void)
{
    printf("sizeof(FLOAT_t) = %zu\n", sizeof(FLOAT_t)); // 'float' tÃ¼rÃ¼ 4 byte olan sistemde standart Ã§Ä±ktÄ± akÄ±mÄ±na 'sizeof(SData1) = 4\n' deÄŸeri gÃ¶nderilir.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program `myint_t` tÃ¼rÃ¼nÃ¼n(esasÄ±nda tÃ¼r eÅŸ adÄ±) aynÄ± anda farklÄ± tÃ¼rleri tutuyormuÅŸ gibi nasÄ±l kullanÄ±ldÄ±ÄŸÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#include <stddef.h>
#include <stdio.h>
#include <stdint.h>

typedef union {
    int32_t uval;
    struct {
        uint16_t lowbytes;
        uint16_t highbytes;
    };
    uint8_t bytes[4]
} myint_t;


int main(void)
{
    printf("sizeof(myint_t) = %zu\n", sizeof(myint_t)); // Burada standart Ã§Ä±ktÄ± akÄ±mÄ±na 'sizeof(myint_t) = 4\n' deÄŸeri gÃ¶nderilir.

    myint_t = { .uval = 123231321u };

    printf("%zu\n", x.lowbytes);
    printf("%zu\n", x.highbytes);

    for(int i = 0; i < 4; ++i){
        printf("%zu\n", x.bytes[i]);
    }
}
```



â—â—â— Ã–zellikle sistem programlama tarafÄ±nda bir **yazmaÃ§a(register)** eriÅŸimde buradakine benzer biÃ§imde `union` kullanÄ±lmaktadÄ±r, mesela 32 bitlik bir **yazmaÃ§a(register)** tek bir 32 bit deÄŸiÅŸken gibi, iki tane 16 bitlik deÄŸiÅŸken gibi ya da dÃ¶rt tane 8 bitlik bir deÄŸiÅŸken gibi kullanÄ±labilir.



Bu baÅŸlÄ±k altÄ±nda Ã¶zellikle de sistem programlama tarafÄ±nda kullanÄ±m biÃ§imleriyle ilgili olarak kullanÄ±mÄ±nÄ± incelemek iÃ§in bitsel iÅŸlemler konusun Ã¶ÄŸrenmiÅŸ olmak gerekiyor, o konuyu iÅŸledikten sonra bu konuya geri dÃ¶neceÄŸiz.


#### Discriminated union(tagged union) KullanÄ±m BiÃ§imi 

Programlamada ihtiyaÃ§ duyulan iÅŸlemlerden biri de ÅŸudur: Bazen bir deÄŸiÅŸkenin Ã¶nceden belirlenmiÅŸ farklÄ± tÃ¼rden deÄŸerler alabilmesini isteriz, bunun iÃ§in kullanÄ±lan yapÄ±ya **discriminated union** ya da **tagged union** deniliyor.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir tÃ¼r ile aynÄ± anda nasÄ±l hem bir iÅŸaretli tam sayÄ±, hem bir double ondalÄ±klÄ± sayÄ±, hem bir yazÄ±(ad), hem bir tarih tÃ¼rÃ¼nÃ¼ tutucak bir deÄŸiÅŸkenin nasÄ±l bildirilip kullanÄ±lacaÄŸÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#include <date.h>
#include <stdio.h>

// AÅŸaÄŸÄ±daki gibi birlik tanÄ±mÄ±nda farklÄ± tÃ¼rler aynÄ± nesne Ã¼zerinden kullanÄ±labiliyor ama bu kullanÄ±mda hangi verinin nesnede tutulduÄŸu bilgisi bulunmadÄ±ÄŸÄ± iÃ§in kullanÄ±lmasÄ±ndan sÄ±kÄ±ntÄ±lar Ã§Ä±kacaktÄ±r.
typedef union {
    char str[16]; // Ad
    Date dt;
    double dval;
    int ival;
} Data1;


// AÅŸaÄŸÄ±daki gibi bir 'struct' tÃ¼rÃ¼yle sarmalanmÄ±ÅŸ olan birlik tanÄ±mÄ±nÄ± ilk hale gÃ¶re daha kullanÄ±labilirdir. 
typedef struct{
    union {
        char str[16]; // Ad
        Date dt;
        double dval;
        int ival;
    };
    int type; // Hangi tÃ¼rden deÄŸer tutulacaÄŸÄ± bilgisini taÅŸÄ±yacak olan deÄŸiÅŸken.
} Data2;


int main(void)
{
    Data1 data1;

    data1.ival = 7; // Burada tam sayÄ± tÃ¼rÃ¼ne deÄŸer atanÄ±yor.

    printf("data1.dval = %f", data1.dval); // Bu kulanÄ±m hatalÄ±dÄ±r Ã§Ã¼nkÃ¼, birlik nesnesinin 'dval' Ã¼yesine deÄŸer atanmadan kullanÄ±lmaya Ã§alÄ±ÅŸÄ±lÄ±yor.
}
```



âš ï¸ C ve C++ dilindeki `union` tÃ¼rÃ¼nÃ¼n kullanÄ±mÄ±nda sÃ¶zdizim farklÄ±lÄ±klarÄ± vardÄ±r, bu rada anlatÄ±lan her ÅŸey C dili iÃ§in geÃ§erlidir, C++ dili iÃ§in geÃ§erli olmayabilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **discriminated union(tagged union)** olarak adlandÄ±rÄ±lan bir veri yapÄ±sÄ±nÄ±n nasÄ±l olabileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "date.h"
#include "nutility.h"


#define NAME_T     1
#define DATE_T     2
#define INT_T      3
#define DOUBLE_T   4

typedef struct {
    union {
        char name[16]; // Ad
        Date dt;
        double dval;
        int ival;
    };
    int type;
} Data;


void set_data_random(Data* p)
{
    switch(rand() % 4){
        case NAME_T : 
            strcpy(p->name, random_name()); 
            p->type = NAME_T;
        break;
        case DATE_T : 
            set_random_date(&p->dt);
            p->type = DATE_T;
        break;
        case INT_T : 
            p->ival = rand();
            p->type = INT_T;
        break;
        case DOUBLE_T : 
            p->dval = drand();
            p->type = DOUBLE_T;
        break;
    }
}

void print_data(const Data* p)
{
    switch(p->type){
        case NAME_T : 
            printf("%s\n", p->name); 
        break;
        case DATE_T : 
            printf_date(&p->dt);
        break;
        case INT_T : 
            printf("%d\n", p->ival);
        break;
        case DOUBLE_T : 
            printf("%f\n", p->dval);
        break;
    }
}


int main(void)
{
    randomize();
    Data data1;

    for(int i = 0; i < 100; ++i){
        set_data_random(&data1);
        print_data(&data1);
        (void)getchar(); // Burada kullanÄ±cÄ±dan bir karakter giriÅŸi bekleniyor, bÃ¶ylece program her dÃ¶ngÃ¼ adÄ±mÄ±nda durduruluyor.
    }
}
```



âœï¸ Burada `nutility` modÃ¼lÃ¼mÃ¼zÃ¼n baÅŸlÄ±k dosyasÄ±na aÅŸaÄŸÄ±daki gibi fonkisyon bildirimini ekliyoruz.
```C

// Rastgele bir ondalÄ±klÄ± deÄŸer dÃ¶nen fonksiyon.
double dran(void);

```

âœï¸ Burada `nutility` modÃ¼lÃ¼mÃ¼zÃ¼n kaynak dosyasÄ±na aÅŸaÄŸÄ±daki gibi fonkisyon tanÄ±mÄ±nÄ± ekliyoruz.
```C

double dran(void)
{
    return 1.735434 * rand();
}

```


> â” 
> 
> Sorulan soru;
> 
> union nesnesinin boyutu icindeki  en bÃ¼yÃ¼k elemanin boyutu kadar midir?
> 
> Cevap
> 
> Evet, ama aligmnet olabilir.



***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.35-10.56 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


â—â—â— **Discriminated union(tagged union)** olarak adlandÄ±rÄ±lan veri yapÄ±larÄ± **Xml parser**, **Json parser** gibi iÅŸlemlerde kullanÄ±lan bir veri yapÄ±sÄ±dÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **discriminated union(tagged union)** olarak adlandÄ±rÄ±lan bir veri yapÄ±sÄ±nÄ±n dizisinin kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "date.h"
#include "nutility.h"


#define NAME_T     1
#define DATE_T     2
#define INT_T      3
#define DOUBLE_T   4

typedef struct {
    union {
        char name[16]; // Ad
        Date dt;
        double dval;
        int ival;
    };
    int type;
} Data;


void set_data_random(Data* p)
{
    switch(rand() % 4){
        case NAME_T : 
            strcpy(p->name, random_name()); 
            p->type = NAME_T;
        break;
        case DATE_T : 
            set_random_date(&p->dt);
            p->type = DATE_T;
        break;
        case INT_T : 
            p->ival = rand();
            p->type = INT_T;
        break;
        case DOUBLE_T : 
            p->dval = drand();
            p->type = DOUBLE_T;
        break;
    }
}

void print_data(const Data* p)
{
    switch(p->type){
        case NAME_T : 
            printf("%s\n", p->name); 
        break;
        case DATE_T : 
            printf_date(&p->dt);
        break;
        case INT_T : 
            printf("%d\n", p->ival);
        break;
        case DOUBLE_T : 
            printf("%f\n", p->dval);
        break;
    }
}


int main(void)
{
    Data ar[100];

    randomize();

    for(int i = 0; i < 100; ++i){
        set_data_random(ar + i);
    }

    for(int i = 0; i < 100; ++i){
        print_data(ar + i);
    }
}
```


C++ dilinin standart kÃ¼tÃ¼phanesinde bu amaÃ§la kullanÄ±lan adÄ± `variant` olan bir `class` vardÄ±r ama C dilinin kendimiz yazmamÄ±z gerekiyor.


## Enumarations(NumaralandÄ±rmalar) 

**Enumaration(NumaralandÄ±rma)** aracÄ± sabit olan belirli bir tÃ¼re ait deÄŸerleri tutabilmek iÃ§in kullanÄ±lan bir varlÄ±ktÄ±r, mesela haftanÄ±n gÃ¼nleri, yazÄ±da kullanÄ±lan fonst ailesi, **state machine** iÃ§in belirlenmiÅŸ olan durum deÄŸerleri bilgileri **enumaration(numaralandÄ±rma)** bÃ¼nyesinde tutulabilir. </br>
Bu araÃ§ hem C hem de C++ dilinde yoÄŸun olarak kullanÄ±lmaktadÄ±r.


MÃ¼lakatlarda **Enumaration(NumaralandÄ±rma)** aracÄ±yla ilgili olarak kullanÄ±lan 



â—â—â— Enum tÃ¼rleri hem bir **user difined type** hem de aynÄ± zamanda **integer type** Ã¶zelliÄŸe sahiptir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir `enum` tÃ¼rÃ¼nÃ¼n nasÄ±l oluÅŸturulduÄŸu ve bu tÃ¼rÃ¼n kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>

// AÅŸaÄŸÄ±daki 'enum' bildiriminde adlandÄ±rma kurallarÄ±na dikkat edilmemiÅŸtir.
enum Color { // Buradaki 'Color'a 'Enumaration tag' deniliyor.
    // AÅŸaÄŸÄ±daki tam sayÄ± sabitlerine 'Enumaration constands' ya da 'Enumarator' deniliyor.
    // 'Enumarator' deÄŸerleri verilmediÄŸinde 0 deÄŸerinden baÅŸlayÄ±p artarak devam eder.
    White, // 0 deÄŸerine karÅŸÄ±lÄ±k geliyor.
    Red, // 1 deÄŸerine karÅŸÄ±lÄ±k geliyor.
    Yellow, // 2 deÄŸerine karÅŸÄ±lÄ±k geliyor.
    Green, // 3 deÄŸerine karÅŸÄ±lÄ±k geliyor.
    Black // 4 deÄŸerine karÅŸÄ±lÄ±k geliyor.
};

// AÅŸaÄŸÄ±daki gibi 'enum' tÃ¼rleri fonksiyonlarda kullanÄ±labilir.
void set_color(enum Color);
enum Color get_color(void);


// Bir yapÄ± Ã¼yesi aÅŸaÄŸÄ±daki gibi 'enum' tÃ¼rÃ¼nden olabilir.
struct Window{
    // ...
    enum Color base_color;
};


enum Color cgc = Yellow; // Burada olduÄŸu gibi global alanda enum tÃ¼rÃ¼ tanÄ±mÄ±(defination) yapÄ±labilir.


int main(void)
{
    enum Color c = Red;



}
```


â—â—â— `enum` tÃ¼rleri Ã¼retimde Ã§ok sÄ±k kullanÄ±lmaktadÄ±r ve makrolardan farklÄ± olarak **kapsamlarÄ±(scope)** vardÄ±r, derleyici program tarafÄ±ndan tanÄ±ndÄ±klarÄ± iÃ§in debug edilebilirler. 


ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir `enum` tÃ¼rÃ¼nÃ¼n deÄŸerlerinin sabit bir tam sayÄ± olduÄŸu gÃ¶rÃ¼lebilir.
```C

enum Color {
    White,
    Red,
    Yellow,
    Green,
    Black
};

int main(void)
{
    int ar[Green]; // Bu kullanÄ±m 'Green' ifadesinin sabit bir tam sayÄ± deÄŸeri olduÄŸu iÃ§in geÃ§erli(legal)'dir.

}
```





ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir `enum` **bildiriminde(decleration)** Ã¼yelerinin deÄŸerlerine farklÄ± deÄŸerler verileceÄŸi incelenebilir.
```C

enum Color {
    White = 17,
    Red, // Burada 'Red' sabiti '18' deÄŸerini alacaktÄ±r.
    Yellow = 90,
    Green, // Burada 'Green' sabiti '91' deÄŸerini alacaktÄ±r.
    Black = 27
};


int main(void)
{


}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir `enum` **bildiriminde(decleration)** varlÄ±ÄŸÄ±n Ã¼yelerinin deÄŸerlerine eksi deÄŸerler verileceÄŸi incelenebilir.
```C

enum Color {
    White = -5,
    Red, // Burada 'Red' sabiti '-4' deÄŸerini alacaktÄ±r.
    Yellow = -76,
    Green, // Burada 'Green' sabiti '-75' deÄŸerini alacaktÄ±r.
    Black = -3
};


int main(void)
{


}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir `enum` **bildiriminde(decleration)** varlÄ±ÄŸÄ±n farklÄ± Ã¼yelerinin deÄŸerlerinin aynÄ± olabileceÄŸi incelenebilir.
```C

enum Color {
    White = 1,
    Gray = 2,
    Grey = 2,
    Red, // Burada 'Red' sabiti '3' deÄŸerini alacaktÄ±r.
    Yellow,
    Green,
    Black
};


int main(void)
{


}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda oyun kartlarÄ±nÄ±n `enum` tÃ¼rleriyle temsil edilebileceÄŸi incelenebilir.
```C

// Ä°skambil kaÄŸÄ±tlarÄ±nÄ±n renk bilgisi 'enum Suit' adÄ±ndaki bir tÃ¼rle temsil ediliyor.
enum Suit {
    Club,
    Diamond,
    Heart,
    Spade
};

// Ä°skambil kaÄŸÄ±tlarÄ±nÄ±n deÄŸeri 'enum Face' adÄ±ndaki bir tÃ¼rle temsil ediliyor.
enum Face {
    Two,
    Three,
    Four,
    Five,
    Six,
    Seven,
    Eight,
    Nine,
    Ten,
    Jack,
    Queen,
    King,
    Ace
};


/*

// AÅŸaÄŸÄ±da 'enum' tÃ¼rleriyle birlikte 'typedef' kullanÄ±labildiÄŸi gÃ¶rÃ¼lebilir.

typedef enum Suit {
    Club,
    Diamond,
    Heart,
    Spade
} Suit;

typedef enum Face {
    Two,
    Three,
    Four,
    Five,
    Six,
    Seven,
    Eight,
    Nine,
    Ten,
    Jack,
    Queen,
    King,
    Ace
}Face;

*/

// Bir iskambil kaÄŸÄ±dÄ± da 'struct Card' adÄ±ndaki bir tÃ¼r ile temsil ediliyor.
struct Card{
    enum Suit s;
    enum Face f;
};


int main(void)
{
    struct Card mycard = { Spade, Queen };

}
```


> â” 
> 
> Sorulan soru;
> 
> BÃ¼tÃ¼n C Ã¶grendiklerimizi kapsayacak bir proje yapmak istesek, hobi amacli ya da open source olarak, bir tavsiyeniz olur mu?
> 
> Cevap;
> 
> Olucak, bu tavsiyeler ayrÄ± bir kayÄ±t ile ya da topluluk sayfasÄ±dan paylaÅŸÄ±lacakmÄ±ÅŸ, her domain iÃ§in inceleme yapÄ±labilecek aÃ§Ä±k kaynak projeler paylaÅŸÄ±lacaÄŸÄ± belirtildi.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `enum` tÃ¼rlerinde sÄ±ranÄ±n Ã¶nemli olduÄŸu durumlardan biri olarak kart oyununun tÃ¼rÃ¼ne gÃ¶re kartlarÄ±n renk aÃ§Ä±sÄ±ndan Ã¶nem sÄ±rasÄ±nÄ±n farklÄ± olduÄŸu durum incelenebilir. </br>
Kart oyununun tÃ¼rÃ¼ne `enum Suit` tÃ¼rÃ¼nÃ¼n bildirimindeki kartlarÄ±n sÄ±ralanÄ±ÅŸÄ± deÄŸiÅŸmektedir.
```C

#ifdef POKER

typedef enum Suit {
    Club, Diamond, Spade, Heart
} Suit;

#else

typedef enum Suit {
    Club, Diamond, Heart, Spade
} Suit;

#endif 

int main(void)
{
    

}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `enum` tÃ¼rlerinin `switch` ile kullanÄ±mÄ± gÃ¶rÃ¼lebilir, bu program Ã§alÄ±ÅŸtÄ±rÄ±lmak iÃ§in yazÄ±lmamÄ±ÅŸtÄ±r.
```C
typedef enum Suit {
    Club,
    Diamond,
    Heart,
    Spade
} Suit;

typedef enum Face {
    Two,
    Three,
    Four,
    Five,
    Six,
    Seven,
    Eight,
    Nine,
    Ten,
    Jack,
    Queen,
    King,
    Ace
} Face;


struct Card{
    enum Suit s;
    enum Face f;
};


void card_game_(Card c)
{
    swtich(c.s) {
        case Club:
            ;
        break;
        case Diamond:
            ;
        break;
        case Heart:
            ;
        break;
        case Spade:
            ;
        break;
    }
}


int main(void)
{


}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `enum` tÃ¼rlerinin **sabitlerin(Symbolinh Constant)** yerine kullanÄ±labildiÄŸi incelenebilir.
```C
#include <stdio.h>

// 'Enumaration tag' olmadan 'enum' tÃ¼rÃ¼ tanÄ±mlanÄ±yor, bu kullanÄ±m 'Sabitlerin(Symbolinh Constant)' bir muadilidir.
enum {
    LOW = 100,
    MEDIUM = 200,
    HIGH = 500
};


void foo(void)
{
    enum { SIZE = 100 }; // Burada 'enum' tÃ¼rÃ¼ bir sabit olarak kullanÄ±lmÄ±ÅŸtÄ±r, bu kullanÄ±m 'object like makro' kullanÄ±mÄ±nÄ±n yerine tercih edilebilir.

    printf("SIZE value: %d", SIZE);
}

int main(void)
{
    foo();
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `enum` tÃ¼rleriyle birlikte sÄ±k kullanÄ±lan iki durum incelenebilir.
```C

enum Color {
    White,
    Red,
    Yellow,
    Green,
    Black,
    NoOfColors // Bu bir renk bilgisi tutmamaktadÄ±r.
};

int main(void)
{
    // 'enum Color' tÃ¼rÃ¼nÃ¼n tÃ¼m elemanlarÄ± aÅŸaÄŸÄ±daki gibi gezilebilir.
    for(enum Color c = White; c < NoOfColors; ++c){

    }

    enum Color ar[NoOfColors]; // Buradaki gibi bir dizi bildirimi yapÄ±labiliyor.
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.00-12.06 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


âš ï¸ C dilinde numaralandÄ±rma tÃ¼rleriyle ilgili hoÅŸ karÅŸÄ±lanmayan bir durum var, bu durum C dilinde farklÄ± `enum` tÃ¼rleri ya da tam sayÄ± tÃ¼rleri arasÄ±nda Ã¶rtÃ¼lÃ¼ tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapÄ±labiliyor olmasÄ±dÄ±r ve bu bazÄ± hatalara neden olabiliyor.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda C dilindeki Ã¶rtÃ¼lÃ¼ olarak `enum` tÃ¼rlerine farklÄ± tÃ¼rlerin atabildiÄŸi incelenebilir, bu Ã¶zellik esasen istenilen bir durum deÄŸil Ã§Ã¼nkÃ¼ hatalara neden olabilmektedir.
```C
#include <stdio.h>

enum Color { Red, Black, White };
enum State { On, Off, Hold };


int main(void)
{
    enum Color color1;
    enum State state1;
    int ival = 4;

    color1 = ival; // 'int' tÃ¼rÃ¼nden 'enum Color' tÃ¼rÃ¼ne Ã¶rtÃ¼lÃ¼ tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapÄ±lÄ±yor, bu C dilinde legal bir durumdur.
    color1 = Off; // 'enum State' tÃ¼rÃ¼nden 'enum Color' tÃ¼rÃ¼ne Ã¶rtÃ¼lÃ¼ tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapÄ±lÄ±yor.
    state1 = Black; // 'enum Color' tÃ¼rÃ¼nden 'enum State' tÃ¼rÃ¼ne Ã¶rtÃ¼lÃ¼ tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapÄ±lÄ±yor.
    state1 = 48  ; // 'int' tÃ¼rÃ¼nden 'enum State' tÃ¼rÃ¼ne Ã¶rtÃ¼lÃ¼ tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapÄ±lÄ±yor.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `enum` tÃ¼rÃ¼nden bir deÄŸiÅŸkenin nasÄ±l yazdÄ±rÄ±labildiÄŸi incelenebilir.
```C
#include <stdio.h>

enum Color { Red, Black, White };
enum State { On, Off, Hold };

int main(void)
{
    enum Color color1 = Black;

    printf("%d\n", color1);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda C dilinde `enum` tÃ¼rÃ¼nÃ¼n adlarÄ±nÄ± yazdÄ±rmak iÃ§in kullanÄ±labilecek bir araÃ§ olmasada bunu yapmak iÃ§in **lookup table** kullanÄ±labileceÄŸi incelenebilir.
```C
#include <stdio.h>

enum Color { Red, Gree, Blue, Magente, Black, White };
const char* const pcolors[] = { "Red", "Gree", "Blue", "Magente", "Black", "White" }; // Bu lookup tablosu 'enum Color' tÃ¼rÃ¼nÃ¼n Ã¶ÄŸelerini temsil etmek iÃ§in kullanÄ±lmaktadÄ±r.

int main(void)
{
    enum Color color1 = Black;

    printf("%d\n", color1); 
    printf("%s\n", pcolors[color1]);
}
```



C mÃ¼lakatlarÄ±nda karÅŸÄ±labilecek sorulardan biri de iki farklÄ± baÅŸlÄ±k dosyasÄ±ndan gelen farklÄ± `enum` tÃ¼rÃ¼nden deÄŸiÅŸkenlerin Ã¼yeleri aynÄ± ada sahip olmasÄ± durumlarÄ±na karÅŸÄ± ne yapÄ±labileceÄŸidir. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda aynÄ± ada sahip olan varlÄ±klar olduÄŸu iÃ§in sÃ¶zdizim hatasÄ± oluÅŸacaktÄ±r.
```C
// #include <screen.h> // Bu baÅŸlÄ±k dosyasÄ±ndan 'enum ScreenColor' tanÄ±mÄ± geliyor.
enum ScreenColor { Red, Gree, Blue, Magente, Black, White };

// #include <traffic.h> // Bu baÅŸlÄ±k dosyasÄ±ndan 'enum TrafficLiht' tanÄ±mÄ± geliyor.
enum TrafficLiht { Red, Gree, Yellow };

// Yukaradaki iki farklÄ± baÅŸlÄ±k dosyasÄ±ndan gelen 'enum' tÃ¼rlerinin sabitleri aynÄ± olduÄŸu iÃ§in sÃ¶zdÃ¼zÃ¼m hatasÄ± oluÅŸacaktÄ±r.

int main(void)
{
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda aynÄ± ada sahip olan varlÄ±klar olduÄŸu iÃ§in sÃ¶zdizim hatasÄ± oluÅŸacaktÄ±r.
```C
// #include <screen.h> // Bu baÅŸlÄ±k dosyasÄ±ndan 'enum ScreenColor' tanÄ±mÄ± geliyor.
enum ScreenColor { ScreenColorRed, ScreenColorGree, ScreenColorBlue, ScreenColorMagente, ScreenColorBlack, ScreenColorWhite };

// #include <traffic.h> // Bu baÅŸlÄ±k dosyasÄ±ndan 'enum TrafficLiht' tanÄ±mÄ± geliyor.
enum TrafficLiht { TrafficLihtRed, TrafficLihtGree, TrafficLihtYellow };

// Yukaradaki iki farklÄ± baÅŸlÄ±k dosyasÄ±ndan gelen 'enum' tÃ¼rlerinin sabitlerinin aynÄ± olmasÄ±ndan dolayÄ± oluÅŸabilecek sÃ¶zdizimi hatasÄ±nÄ± Ã¶nlemek iÃ§in yukarÄ±daki gibi 'enum' tÃ¼rlerinin bulunduÄŸu kÃ¼tÃ¼phene modÃ¼llerini belirtecek biÃ§imde adlar gÃ¼ncellenerek ad Ã§akÄ±ÅŸmasÄ± Ã¶nlenmeye Ã§alÄ±ÅŸÄ±lmÄ±ÅŸtÄ±r.

int main(void)
{
}
```


## Endianness KavramÄ± ğŸŒŸ 

Tam sayÄ± deÄŸiÅŸkenlerin bellekteki yerleÅŸimiyle ilgili bir kavramdÄ±r. </br>
Bellekte her ÅŸey byte olarak tutulmaktadÄ±r bu nedenden dolayÄ± da birden fazla byte yer kaplayan tam sayÄ± tÃ¼rÃ¼nden nesnelerin byte'larÄ±nÄ±n bellekte nasÄ±l dizileneceÄŸi Ã¶nemlidir. </br>

`int x = 1;` deÄŸiÅŸken bildiriminde `x` deÄŸiÅŸkeninin deÄŸeri bir yazarken `00000000 00000000 00000000 00000001` biÃ§iminde yazarÄ±z ama bu deÄŸeri bellekte iki farklÄ± biÃ§imde tutulabiliriz, bunlar;
1. DÃ¼ÅŸÃ¼k sayÄ±sal adreste yÃ¼ksek anlamlÄ± byte, yÃ¼ksek sayÄ±sal adreste dÃ¼ÅŸÃ¼k anlamlÄ± byte bulunmasÄ± durumuna "**Big endian**" deniliyor.

    | Address       | Byte     |
    | ------------- | -------- |
    | 0xBFFFF000    | 00000000 |
    | 0xBFFFF001    | 00000000 |
    | 0xBFFFF002    | 00000000 |
    | 0xBFFFF003    | 00000001 |

2. DÃ¼ÅŸÃ¼k sayÄ±sal adreste dÃ¼ÅŸÃ¼k anlamlÄ± byte, yÃ¼ksek sayÄ±sal adreste yÃ¼ksek anlamlÄ± byte bulunmasÄ± durumuna "**Little endian**" deniliyor.
   
    | Address       | Byte     |
    | ------------- | -------- |
    | 0xBFFFF000    | 00000001 |
    | 0xBFFFF001    | 00000000 |
    | 0xBFFFF002    | 00000000 |
    | 0xBFFFF003    | 00000000 |


ğŸ“Œ **Endianness** davranÄ±ÅŸÄ±nÄ±n ne olacaÄŸÄ± iÅŸlemciye baÄŸlÄ±dÄ±r, Intel mimariler "**Little endian**", Motorola tarzÄ± mimari "**Big endian**", Arm mimaride her iki yaklaÅŸÄ±m da kullanÄ±labiliyor.


Bir sistemin "**Little endian**" ya da "**Big endian**" olmasÄ± bizi ne zaman ilgilendirir;
- Ä°ki farklÄ± mimarideki veri alÄ±ÅŸveriÅŸi sÄ±rasÄ±nda **endianness** durumu iki sistemde farklÄ± ise haberleÅŸme sÄ±rasÄ±nda dÃ¶nÃ¼ÅŸÃ¼m yapÄ±lmasÄ± gerekiyor, bu dÃ¶nÃ¼ÅŸÃ¼m iÅŸlemi bit iÅŸlemleri konusunda incelenecektir.
- Dosya iÅŸlemlerinde kaynaktaki dosyanÄ±n **endianness** durumu ile dosyayÄ± aÃ§Ä±k okuyacak sistemin **endianness** durumu birbirinden farklÄ± ise bu durumun anlaÅŸÄ±lÄ±p gerekli dÃ¶nÃ¼ÅŸÃ¼mÃ¼n yapÄ±lmasÄ± gerekecektir.



MÃ¼lakatlarda sistemin **big endian** ya da **little endian** olma durumunu tespit edip standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderen(yazdÄ±ran) bir C programÄ± yazÄ±lmasÄ± istenebilir. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda yukarÄ±daki mÃ¼lakat sorusunda istenilen program yazÄ±lmÄ±ÅŸtÄ±r.
```C
#include <stdio.h>

int main(void)
{
    int x = 1;
    
    // '*(char*)&x' ifadesinde '&x' ile 'x' deÄŸiÅŸkeninin adres deÄŸeri elde ediliyor(bu deÄŸer R-value) ardÄ±ndan '(char*)&x' ifadesindeki '(char*)' tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ ile adres deÄŸerinin sadece ilk byte'Ä± 'char' tÃ¼rÃ¼nÃ¼n adres tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼yor, ardÄ±ndan da '*(dereferencing)' iÅŸlemi ile tek byte'Ä±n deÄŸerine eriÅŸiliyor.
    // Burada ÅŸuna dikkat etmek gerekiyor, ilk byte demek ilgili tam sayÄ± tÃ¼rÃ¼nÃ¼n tÃ¼m byte'larÄ± iÃ§inde adres deÄŸeri en kÃ¼Ã§Ã¼n olan byte demektir.
    // '*(char*)&x' ifadesinin zero-nonzero durumuna gÃ¶re 'endianness' durumu tespit ediliyor.
    if(*(char*)&x){
        printf("little endian.\n");
    }
    else{
        printf("big endian.\n");
    }
}
```

âš ï¸ Bir sistemin **endianness** durumunu anlamak iÃ§in C dilinde tek yol bunu Ã§alÄ±ÅŸma zamanÄ±nda(run-time) sÄ±namaktÄ±r ama C++ dilinde derleme zamanÄ±nda da tespit edebiliyoruz(C++20 standardÄ±ndan eklenen `byte` adÄ±nda bir modÃ¼l eklendi oradaki Ã¶ÄŸelerle Ã¶ÄŸrenilebiliyor).



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iÅŸaretsiz bir tam sayÄ± deÄŸiÅŸkenin tÃ¼m byte'larÄ± dÃ¼ÅŸÃ¼k adresten bÃ¼yÃ¼k adrese doÄŸru yazdÄ±rÄ±lmÄ±ÅŸtÄ±r, bu yÃ¶ntemle sistemin **endianness** durumu tespit edilebilir.
```C
#include <stdio.h>

int main(void)
{
    unsigned int x = 0x1234ABCD;

    printf("%X\n", x);
    unsigned char* p = (unsigned char*)&x;

    int n = sizeof(int);
    while(n--){
        printf("%X\n", *p++);
    }
}
```


## Bitsel OperatÃ¶rler(Bitwise Operations) 

Bu konu 5, 6 saat kadar sÃ¼recektir. </br>
Bit manipÃ¼lasyonlarÄ± **bitsel operatÃ¶rler(bitwise operators)** kullanÄ±larak yapÄ±lÄ±yor.

C dilindeki **bitsel operatÃ¶rler(bitwise operators)** aÅŸaÄŸÄ±daki gibidir;
- `~` **bitwise not operator(bitsel deÄŸil operatÃ¶rÃ¼)**
- `>>` **bitwise right shift operator(bitsel saÄŸa kaydÄ±rma operatÃ¶rÃ¼)**
- `<<` **bitwise left shift operator(bitsel sola kaydÄ±rma operatÃ¶rÃ¼)**
- `&` **bitwise and operator(bitsel ve operatÃ¶rÃ¼)**
- `^` **bitwise xor operator(bitsel Ã¶zel veya operatÃ¶rÃ¼)**
- `|` **bitwise or operator(bitsel veya operatÃ¶rÃ¼)**
- `>>=`, `<<=`, `&=`, `^=`, `|=` **bitwise assignment operators(bitsel atama operatÃ¶rleri)**


âš ï¸ YukarÄ±da dizilenen **iÅŸleÃ§ler(operators)** Ã¶ÄŸrenildikten sonra C11 ile dile eklenen `_Alignof` ve `_Alignas` operatÃ¶rleri dÄ±ÅŸÄ±nda C dilindeki tÃ¼m operatÃ¶rleri gÃ¶rmÃ¼ÅŸ olacaÄŸÄ±z.


ğŸ“Œ Bu operatÃ¶rler ne iÅŸe yarÄ±yor sorusuna cevap vermeden Ã¶nce tek tek tÃ¼m bitsel operatÃ¶rlerini inceleyeceÄŸiz.


â—â—â— **Bitsel operatÃ¶rlerle(bitwise operators)** ilgili olarak aÅŸaÄŸÄ±daki durumlara dikkat edilmesi gerekiyor;
1. Bitsel operatÃ¶rlerin operantlarÄ± tam sayÄ± tÃ¼rlerinden olmak zorundadÄ±r, yani ondalÄ±klÄ± sayÄ± ya da baÅŸka bir tÃ¼r olamaz.
2. Bu operatorler aÅŸaÄŸÄ± seviyeli olarak bit bit iÅŸlem yapmak iÃ§in kullanÄ±lmaktadÄ±r.
3. Bitsel iÅŸlemler Ã§ok bÃ¼yÃ¼k Ã§oÄŸunlukla **iÅŸeretsiz(unsigned)** tam sayÄ± tÃ¼rleri Ã¼zerinde yapÄ±lÄ±rlar.


â—â—â— `0101'0101'0101'0101` biÃ§iminde olan iki byte'lÄ±k bir verinin en saÄŸÄ±ndaki en dÃ¼ÅŸÃ¼n anlamlÄ± bitin indeks deÄŸeri "0." bit olarak tanÄ±mlanÄ±r, bitlerin konumlarÄ±nÄ±n ne olduÄŸunu bilmek bitler Ã¼zerinde iÅŸlem yaparken Ã¶nemlidir ve iyi bilinmelidir.

â—â—â— Bitsel operatÃ¶rlerin operantlarÄ± Ã§ok bÃ¼yÃ¼k Ã§oÄŸunlukla iÅŸaretsiz tam sayÄ±lar oluyor, Ã§ok az oranda da iÅŸaretli tam sayÄ±lar da operand olabilir, bunun temel nedeni iÅŸaretsiz tam sayÄ±larda daha kolay iÅŸlem yapÄ±labilmesidir.


âœï¸ Burada `nutility` adÄ±ndaki kendi modÃ¼lÃ¼mÃ¼ze rastgele ad ve soyad soyad Ã¼retecek ayrÄ± ayrÄ± iki fonksiyon ekliyoruz.
```C
// YazÄ±lan 'nutility.h' dosyasÄ±na eklenenler.

void bprint(unsigned);
```

```C
// YazÄ±lan 'nutility.c' dosyasÄ±na eklenenler.

void bprint(unsigned x)
{
    while(x){
        putchar(x & 1 ? '1' : '0'); // Burada sayÄ±nÄ±n sÄ±fÄ±rÄ±ncÄ± bitinin ne olduÄŸu standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderiliyor.
        x >>= 1; // Burada sayÄ± bir saÄŸa kaydÄ±rÄ±lÄ±yor ve bÃ¶ylece sayÄ±yÄ± 0 yapana kadar tÃ¼m bitlerini gezmiÅŸ olacaÄŸÄ±z.
    }
    putchar('\n');
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda kendi `nutility.h` baÅŸlÄ±k dosyamÄ±za eklediÄŸimiz `bprint` fonksiyonu ile ilgili tam sayÄ±nÄ±n 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = 8795;

    bprint(x);
}
```


Ders sonu ...
