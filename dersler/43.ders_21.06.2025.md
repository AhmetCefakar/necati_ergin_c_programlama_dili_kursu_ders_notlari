# 43.Ders 21.06.2025 ğŸ•˜

Derse 10(09:02)-13(09:20)-14(09:45)-13(10:29)-12(11:04)-11(11:30)-12(12:02)-12(12:45) kiÅŸi katÄ±ldÄ±.
---


## C Dilindeki KullanÄ±lan BazÄ± Ã–nemli Anahtar SÃ¶zcÃ¼kler Devam

ğŸ§­ Åimdiye kadar aÅŸaÄŸÄ±daki anahtar sÃ¶zcÃ¼kleri gÃ¶rdÃ¼k;
- `auto`
- `register`
- `static`
    - `static` local
    - `static` global


### `static` Anahtar SÃ¶zcÃ¼ÄŸÃ¼nÃ¼n Global DeÄŸiÅŸkenlerde KullanÄ±lmasÄ± ve `extern` Anahtar SÃ¶zcÃ¼ÄŸÃ¼ Devam

`static` anahtar sÃ¶zcÃ¼ÄŸÃ¼ kullanÄ±ldÄ±ÄŸÄ± yere gÃ¶re farklÄ± anlama gelmektedir, bunlar; 
- `static` anahtar sÃ¶zcÃ¼ÄŸÃ¼ **local** alanda deÄŸiÅŸkenlerin Ã¶mÃ¼rlerini **static storage duration** yapmak iÃ§in kullanÄ±lÄ±yor.
- `static` anahtar sÃ¶zcÃ¼ÄŸÃ¼ **global** alanda bir deÄŸiÅŸkeni ya da bir fonksiyonu modÃ¼l dÄ±ÅŸÄ±ndan eriÅŸime kapatmak iÃ§in kullanÄ±lÄ±yor.


**Kapsam(Scope)** bir kaynak dosya ile sÄ±nÄ±rlÄ±dÄ±r. </br>
**Linkage(baÄŸlantÄ±)** birden fazla dosyayÄ± kapsar.


â—â—â— C dilinde oluÅŸturulan modÃ¼ller Ã§oÄŸunlukla "**.c**" ve "**.h**" uzantÄ±lÄ± olan iki farklÄ± dosya olarak oluÅŸturulmaktadÄ±r, bir modÃ¼lde tanÄ±mlanan deÄŸiÅŸken ve fonksiyonlarÄ±n iÃ§/dÄ±ÅŸ baÄŸlantÄ± yapmak iÃ§in aÅŸaÄŸÄ±daki iÅŸlemin yapÄ±lmasÄ± gerekiyor;
- Sadece modÃ¼lÃ¼n iÃ§inden eriÅŸilebilir olmasÄ± istenilen global deÄŸiÅŸkenlerin ve fonksiyonlarÄ±n "**.c**" uzantÄ±lÄ± kaynak dosyada `static` olarak tanÄ±mlanmasÄ± gerekiyor. Bu ÅŸekilde iÃ§ baÄŸlantÄ± yapÄ±lmÄ±ÅŸ oluyor.
- BaÅŸka modÃ¼llerden de kullanÄ±lmasÄ± istenilen global deÄŸiÅŸkenlerin ve fonksiyonlarÄ±n "**.c**" uzantÄ±lÄ± kaynak dosyadaki tanÄ±mlarÄ±nÄ±n `static` anahtar sÃ¶zcÃ¼ÄŸÃ¼ kullanÄ±lmadan yapÄ±lmasÄ± gerekiyor, ardÄ±ndan modÃ¼lÃ¼n "**.h**" uzantÄ±lÄ± baÅŸlÄ±k dosyasÄ±nda dÄ±ÅŸarÄ±ya aÃ§Ä±lacak global deÄŸiÅŸkenlerin `extern` olarak bildirilmesi gerekiyor, fonksiyon bildirimleri `extern` ile yapÄ±labilir ya da yapÄ±lmayabilir. Bu ÅŸekilde dÄ±ÅŸ baÄŸlantÄ± yapÄ±lmÄ±ÅŸ oluyor.



ğŸš€ **Global namespace pollution Problem**: Bir**ad(identifier)**dÄ±ÅŸ baÄŸlantÄ±ya ait yapÄ±lÄ±rsa dÄ±ÅŸ baÄŸlantÄ±ya aÃ§Ä±lan birden fazla**ad(identifier)**olduÄŸunda**ad(identifier)**Ã§akÄ±ÅŸmasÄ± olabilir, bu durumu belirtmek iÃ§in kullanÄ±lan terim.



ğŸ§­ SÄ±k yapÄ±lan **baÄŸlama(linker)** hatalarÄ±;

1. Linker programÄ±n **object dosyaya** yazÄ±lmÄ±ÅŸ olan bir **adÄ±(identifier)** baÄŸlama sÃ¼recinde(yani o **adÄ±(identifier)** bir varlÄ±kla iliÅŸkilendirme sÃ¼recinde) **object dosyada** o varlÄ±ÄŸa iliÅŸkin bir referansÄ±n bulunmamasÄ±dÄ±r. Bu gibi hatalarda linker programlar **Unresolved external symbol error** gibi bir hata verir.

    
    ğŸ‘‡ AÅŸaÄŸÄ±daki programda `funcx` adÄ±ndaki fonksiyonun sadece bildirimi yapÄ±lmÄ±ÅŸ ama tanÄ±mÄ± yapÄ±lmamÄ±ÅŸtÄ±r, bu durumda **baÄŸlama iÅŸini yapan program(linker)** hata verecektir.
    ```C
    #include <stdio.h>
    #include <stdbool.h>
    #include <stdlib.h>
    #include "nutility.h"

    int funcx(void);

    int main(void)
    {
        int ival =  funcx(); // Burada kullnÄ±lan fonksiyon Ã§aÄŸrÄ±sÄ± eÄŸer 'funcx' tanÄ±mÄ± yapÄ±lmamÄ±ÅŸsa(burada yapÄ±lmÄ±yor) derleyici iÅŸini dÃ¼zgÃ¼n yapacaktÄ±r ama 'linker' program Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda hata oluÅŸacaktÄ±r('LNK' Ã¶n ekiyle oluÅŸan hatalar 'linker' programÄ±n Ã¼rettiÄŸi hatalardÄ±r)

        ++ival;
    }
    ```

2. Global alanda farklÄ± iki varlÄ±ÄŸÄ±n adlarÄ±nÄ±n aynÄ± olmasÄ±ndan dolayÄ± baÄŸlama iÅŸini yapan program(linker) hata verecektir. Bu gibi hatalarda linker programlar **One or more multiply defined symbol found** gibi bir hata verir.

    C++ dilinde olan "**namespace**" aracÄ± global alandaki**ad(identifier)**Ã§akÄ±ÅŸmasÄ± sorununu Ã§Ã¶zmek iÃ§in dile eklenmiÅŸtir. </br>
    C dilinde global**ad(identifier)**alanÄ±nÄ±n kirlenmesi sorunu iÃ§in kullanÄ±labilecek bir araÃ§ olmadÄ±ÄŸÄ± iÃ§in Ã¼Ã§Ã¼ncÃ¼ taraf kÃ¼tÃ¼pheneler kendi saÄŸladÄ±klarÄ± dosyalardaki varlÄ±klarÄ±n adlarÄ±nÄ±n Ã¶nÃ¼ne kendi kÃ¼tÃ¼phenelerini belirten bir Ã¶n**ad(identifier)**eklerler 



â—â—â— C dilinde **decleration** ve **defination** terimleri birbirinden farklÄ± anlamlarda kullanÄ±lmaktadÄ±r. </br>
**Decleration** bir **adÄ±n(identifier)** bildirimi demektir ve bildirilen bir deÄŸiÅŸkense derleyici bellekte o deÄŸiÅŸken iÃ§in yer ayÄ±rmayacaktÄ±r. </br>
**Defination** aynÄ± zamanda bir deÄŸiÅŸken iÃ§in bir allocation yapÄ±lmasÄ±nÄ±(yani derleyicinin o varlÄ±ÄŸÄ±n yerini ayarlamasÄ±) anlamÄ±na geliyor. </br>
Her **tanÄ±mlama(defination)** bir **bildirimdir(decleration)** ama her **bildirim(decleration)** bir **tanÄ±mlama(defination)** olmak zorunda deÄŸildir. </br>
Åu `extern int x;` statement `x` adÄ±ndaki varlÄ±ÄŸÄ±n bildirimidir ama tanÄ±mlamasÄ± deÄŸildir, burada derleyici `x` deÄŸiÅŸkeni iÃ§in bellekte bir yer ayÄ±rmaz. </br>
Buradan ÅŸu sonuca varÄ±rÄ±z: DÄ±ÅŸ baÄŸlantÄ±ya sahip olan olan varlÄ±klarÄ±n birden fazla bildirimi olabilir, bu sorun oluÅŸturmaz ama bir varlÄ±ÄŸÄ±n sadece tek bir tanÄ±mlamasÄ± olmak zorundadÄ±r.



AÅŸaÄŸÄ±daki iÃ§/dÄ±ÅŸ baÄŸlantÄ± durumlarÄ± incelenebilir;
| source1.c                      | source2.c                      |  source3.c                     | AÃ§Ä±klama                     |
|:-------------------------------|:-------------------------------|:-------------------------------|:-----------------------------|
| `static int x= 5;`             | `static int x= 5;`             | `static int x= 5;`             | ÃœÃ§ farklÄ± dosyada `x` adÄ±ndaki deÄŸiÅŸken `static` olarak tanÄ±mlandÄ±ÄŸÄ± iÃ§in modÃ¼l dÄ±ÅŸÄ±ndan eriÅŸime kapalÄ±dÄ±r ve bu program **well-form** bir programdÄ±r |
| `int x= 5;`                    | `static int x= 5;`             | `int x= 5;`                    | Ä°ki farklÄ± dosyada `x` adÄ±ndaki deÄŸiÅŸken `static` olarak  tanÄ±mlanmadÄ±ÄŸÄ± iÃ§in modÃ¼l dÄ±ÅŸÄ±ndan eriÅŸime aÃ§Ä±k olabilir durumdadÄ±r ve bu program **ill-form** bir programdÄ±r denilebilir, bÃ¶yle kod yazmamak gerekiyor. |


> â” 
> 
> Sorulan soru;
> 
> Genel olarak .h icinde fonksiyon tanimi yapilmaz diye bir kullanim var mi?
> 
> Cevap;
> 
> Ä°ki istisna dÄ±ÅŸÄ±nda doÄŸru denilebilir. </br>
> Ä°lk istisna fonksiyonun `static` olmasÄ± ve ikinci istisna **inline function** olmasÄ±dÄ±r. Åu anda **inline function** konusun kafa karÄ±ÅŸÄ±klÄ±ÄŸÄ± oluÅŸturmamak iÃ§in deÄŸinilmiyor.



Ä°ÅŸletim sistemlerinde aynÄ± dizinde birden fazla aynÄ± ada sahip dosya oluÅŸturulmasÄ±na izin verilmemektedir, aynÄ± yerde aynÄ± ada sahip iki farklÄ± varlÄ±ÄŸÄ±n olmasÄ± soruna yol aÃ§acaÄŸÄ± iÃ§in buna izin verilmez. </br>
Genel amaÃ§lÄ± bir modÃ¼l oluÅŸturuluyorsa global alana aÃ§Ä±lan modÃ¼lÃ¼n oluÅŸturduÄŸu varlÄ±klarÄ±n adlarÄ±nÄ±n Ã§akÄ±ÅŸma sorunu olacaktÄ±r, bu nedenle modÃ¼llerden dÄ±ÅŸarÄ±ya aÃ§Ä±lan **idintifier**'lar ilgili modÃ¼lÃ¼n varlÄ±ÄŸÄ± olduÄŸunu belirtecek ÅŸekilde olmalÄ±dÄ±r.



C mÃ¼lakatlarÄ±nda sorulan bir soru; </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki baÅŸlÄ±k dosyasÄ±nÄ± yorumlayÄ±nÄ±z.
```C
// headfile1.h

int g = 20; // Burada 'g' adÄ±nda bir deÄŸiÅŸken tanÄ±mlanÄ±yor, bu yanlÄ±ÅŸtÄ±r Ã§Ã¼nkÃ¼ deÄŸiÅŸkeni tanÄ±mlamak demek derleyicinin o deÄŸiÅŸken iÃ§in bellekte yer ayarlamasÄ± anlamÄ±na geliyor.

// BaÅŸlÄ±k dosyalarÄ±nda fonksiyonlarÄ±n tanÄ±mlarÄ±nÄ±n olmasÄ±ndan kaÃ§Ä±nÄ±lmalÄ±dÄ±r, sadece bazÄ± istisnalarda bu tercih edilmelidir(istisnalarÄ± ÅŸimdilik bilmiyorum).
void foo(void)
{
    // ...
}
```



C mÃ¼lakatlarÄ±nda sorulan bir soru; </br>
"dosya1.c" dosyasÄ±nda `void foo(void){ ... }` adÄ±nda bir fonksiyon tanÄ±mlanmÄ±ÅŸ ama bu fonksiyon "dosya1.c"  dosyasÄ±ndan hiÃ§ Ã§aÄŸrÄ±lmamÄ±ÅŸ, bu bir mantÄ±ksal hata mÄ±? cevap => HayÄ±r deÄŸildir Ã§Ã¼nkÃ¼ modÃ¼lÃ¼n bu fonksiyonu sadece modÃ¼l dÄ±ÅŸÄ±ndan kullanÄ±lmak iÃ§in yazÄ±lmÄ±ÅŸtÄ±r. </br>
"dosya1.c" dosyasÄ±nda `static void foo(void){ ... }` adÄ±nda bir fonksiyon tanÄ±mlanmÄ±ÅŸ ama bu fonksiyon "dosya1.c"  dosyasÄ±ndan hiÃ§ Ã§aÄŸrÄ±lmamÄ±ÅŸ, bu bir mantÄ±ksal hata mÄ±? cevap => Evet Ã§Ã¼nkÃ¼ ilgili fonksiyon `static` tanÄ±mlandÄ±ÄŸÄ± iÃ§in dÄ±ÅŸarÄ±dan eriÅŸime kapalÄ±dÄ±r, o zaman ilgili fonksiyonun hiÃ§ olmamasÄ± daha doÄŸru olacaktÄ±r.



â—â—â— Dizilerin `extern` bildiriminin yapÄ±lmasÄ± durumunda dizilerin eleman sayÄ±larÄ±nÄ±n belirtilmesi gerekmez Ã§Ã¼nkÃ¼ derleyici bellekten yer ayÄ±rmayacaÄŸÄ± iÃ§in eleman sayÄ±sÄ± bilgisi gerekmez. `extern int ary[];` bildirimi legal ve **well-form** bir kullanÄ±mdÄ±r.



â—â—â— **BaÄŸlantÄ±(linkage)** konusunda C ve C++ dilleri arasÄ±nda Ã§ok Ã¶nemli bir kural farklÄ±lÄ±ÄŸÄ± vardÄ±r;
- C dilinde bir kaynak dosya iÃ§inde yer alan ÅŸu `const int x = 10;` ve `int y = 20;` varlÄ±klar dÄ±ÅŸ baÄŸlantÄ±dadÄ±r. C dilinde bir deÄŸiÅŸkenin `const` bildirilip bildirilmemesi dÄ±ÅŸ baÄŸlantÄ± olma durumunu etkilememektedir.
- C++ dilinde bir kaynak dosya iÃ§inde `const` anahtar sÃ¶zcÃ¼ÄŸÃ¼yle tanÄ±mlanan global deÄŸiÅŸkenler varsayÄ±lan olarak iÃ§ baÄŸlantÄ±dadÄ±r(`const int x = 10;` buradaki `x` varsayÄ±lan olarak `static` tanÄ±mlanmÄ±ÅŸ olarak yorumlanÄ±r) ama `int y = 20;` bu tanÄ±mlamadaki `y` deÄŸiÅŸkeni de baÄŸlantÄ±dadÄ±r.


### Type Qualifiers(TÃ¼r Niteleyicileri) 

ğŸ§­ AÅŸaÄŸÄ±daki anahtar sÃ¶zcÃ¼kleri bu baÅŸlÄ±k altÄ±nda iÅŸlenecektir.
- `const`: Biliyoruz ama tekrar edilecek ve bazÄ± ekelmeler yapacaÄŸÄ±z.
- `volative`: Hem C hem de C++ dilinde Ã§ok Ã¶nemli bir anahtar sÃ¶zcÃ¼k. 
- `restrict`: C99 standardÄ± ile dile eklendi, C++ dilinde bÃ¶yle bir anahtar sÃ¶zcÃ¼k yok(ama derleyiciler extension olarak destek verebiliyor).


#### `const` Anahta SÃ¶zcÃ¼ÄŸÃ¼ 

`const int x = 10;` olarak tanÄ±mlanan `x` deÄŸiÅŸkeni **const variable(deÄŸeri deÄŸiÅŸmeyen deÄŸiÅŸken)** bir deÄŸiÅŸkendir. </br>
TÃ¼m deÄŸiÅŸenler `const` olarak tanÄ±mlanabilir. </br>
`const` anahtar sÃ¶zcÃ¼ÄŸÃ¼ kodda kullanÄ±lmasÄ± gereken her yerde kullanÄ±lmalÄ±dÄ±r, `const` anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n doÄŸru yerde kullanÄ±lmasÄ± programcÄ±nÄ±n tecrÃ¼besini gÃ¶stermektedir. </br>

â—â—â— **Const Correctness** ve **Const Incorrectness** terimleri `const` anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n doÄŸru kullanÄ±lÄ±p kullanÄ±lmadÄ±ÄŸÄ±nÄ± belirtmek iÃ§in kullanÄ±lÄ±r.


ğŸ§­ DeÄŸiÅŸken tanÄ±mlamalarÄ±nda neden `const` anahtar sÃ¶zcÃ¼ÄŸÃ¼ kullanÄ±lÄ±yor;
1. Kendimize yardÄ±mcÄ± oluruz.
    - EÄŸer mantÄ±ksal(logic) olarak deÄŸiÅŸmemesi gereken bir deÄŸiÅŸkenimiz varsa onu `const` tanÄ±mladÄ±ÄŸÄ±mÄ±zda kodda o deÄŸiÅŸkeni deÄŸiÅŸtirmeye Ã§alÄ±ÅŸmak **sÃ¶zdizim hatasÄ±(syntax error)** olacaktÄ±r.
    - Bir deÄŸiÅŸken `const` anahtar sÃ¶zcÃ¼ÄŸÃ¼yle tanÄ±mlanmÄ±ÅŸsa o deÄŸiÅŸkeni deÄŸiÅŸtirmeye yÃ¶nelik olan tÃ¼m kodlarda **sÃ¶zdizim hatasÄ±(syntax error)** oluÅŸacaktÄ±r.

    ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki **sÃ¶zdizim hatasÄ±(syntax error)** incelenebilir.
    ```C
    int main(void)
    {
        const double pi = 3.1415962;

        pi += .18; // Burada derleyici 'const' tanÄ±mlanan bir deÄŸiÅŸkenin deÄŸerinin deÄŸiÅŸtirmek istendiÄŸinde 'sÃ¶zdizim hatasÄ±(syntax error)' verecektir.
    }
    ```

2. Okuyucuya yardÄ±mcÄ± oluruz.
    - `const` tanÄ±mlanan bir deÄŸiÅŸkenin **immutable** olduÄŸu anlaÅŸÄ±lacktÄ±r ve o deÄŸiÅŸken deÄŸiÅŸtirilmeye Ã§alÄ±ÅŸÄ±lmayacaktÄ±r.
    - Rust dilinde deÄŸiÅŸkenler varsayÄ±lan olarak **immutable** Ã¶zelliktedir, C ve C++ dillerinde deÄŸiÅŸkenler varsayÄ±lan olarak **mutable** Ã¶zelliktedir.
    - Bir kodun okunmasÄ±nÄ±n birden fazla nedeni olabilir: hata gidermek iÃ§in, kodu iyileÅŸtirmek iÃ§in vb.

    â­ **mutable** deÄŸiÅŸkenler deÄŸerleri deÄŸiÅŸtirilebilir deÄŸiÅŸkenlerdir, **immutable** deÄŸiÅŸkenler deÄŸerleri deÄŸiÅŸtirilemeyen deÄŸiÅŸkenlerdir.

3. Derleyiciye yardÄ±mcÄ± oluruz.
    - **Compiler Optimization** aÃ§Ä±sÄ±ndan deÄŸiÅŸkenlerin `const` olarak tanÄ±mlanmasÄ± daha dÃ¼ÅŸÃ¼k maliyetli makine kodu Ã¼retmesini saÄŸlayabilir.

    Donalt Knut "_Early optimization is evel_" olarak erkenden yapÄ±lan iyileÅŸtirmelerin gereksiz olduÄŸunu belirtmektedir.


    ğŸ‘‡ AÅŸaÄŸÄ±daki programÄ± derleyici yorumlarken `const` tanÄ±mlanmÄ±ÅŸ olan deÄŸiÅŸkeni dikkate alarak bir aÅŸaÄŸÄ±daki program gibi yorumlamasÄ± saÄŸlanabilir.
    ```C
    const int x = 10;

    int main(void)
    {
        int a = x;
        int b = x + 3;

        int c = a + b - x;
    }
    ```

    ğŸ‘‡ AÅŸaÄŸÄ±daki programda yukarÄ±daki programÄ± derleyicinin `const` tanÄ±mlanan deÄŸiÅŸkenden faydalanarak yapacaÄŸÄ± iyileÅŸtirmeler sonrasÄ±nda programÄ±n nasÄ±l yorumlanabileceÄŸi gÃ¶rÃ¼lebilir.
    ```C
    int main(void)
    {
        int a = 10;
        int b = 13;

        // some code here ...

        int c = a + b - 10;

        // some code here ...
    }
    ```


MÃ¼lakatlarda sÄ±k sorulan sorulardan bir aÅŸaÄŸÄ±daki gibidir; </br>
`const` deÄŸiÅŸkenlerin deÄŸiÅŸtirilme giriÅŸiminde bulunan ifadeler **ub** durumuna neden olur, Ã¶zellikle gÃ¶mÃ¼lÃ¼ programlama alanÄ±nda Ã§alÄ±ÅŸan yazÄ±lÄ±mcÄ±lar bu hatayÄ± yapmaktaymÄ±ÅŸ.
```C
#include <stdio.h>

int main(void)
{
    const int x = 23423;
    printf("x = %d\n", x);

    const int* p = &x; // 'p' deÄŸiÅŸkeni 'pointer to const int' olarak nitelendirilir.
    printf("*p = %d\n", *p);
    int* ptr = (int*)p;

    *ptr = 4445556; // Burada gÃ¶sterici Ã¼zerinden 'const int' olarak tanÄ±mlanan 'x' deÄŸiÅŸkeninin deÄŸerini deÄŸiÅŸtirilmesinden dolayÄ± 'ub' vadÄ±r.
    printf("x = %d\n", x);
}
```



MÃ¼lakatlarda sÄ±k sorulan sorulardan biri, **object-like macro** ile **cosnt variable** kullanÄ±mlarÄ±nÄ±n kÄ±yaslanmasÄ±dÄ±r.
Bir programlama dilinde bir iÅŸi yapmak iÃ§in birden fazla araÃ§ olduÄŸunda Ã§oÄŸu durumda bu iki aracÄ±n farklÄ± durumlarda kullanÄ±lmasÄ± daha faydalÄ± olacaktÄ±r, bu nedenle sorunun cevabÄ± baÄŸlama gÃ¶re deÄŸiÅŸir olmalÄ±dÄ±r.

ğŸ‘‡ AÅŸaÄŸÄ±daki programda **object-like macro** ile **cosnt variable** kullanÄ±mÄ± gÃ¶rÃ¼lebilir.
```C
#include <stdio.h>

// AÅŸaÄŸÄ±daki gibi '100' sabitini iki farklÄ± araÃ§ ile kullanabiliriz.
#define SIZE 100 // Buradaki 'SIZE' sadece Ã¶niÅŸlemci program iÃ§in bir identifier'dÄ±r.
const int size = 100; // Buradaki 'size' derleyici iÃ§in bir identifier'dÄ±r.

int main(void)
{
    &SIZE; // Buradaki gibi bir ifadekullanamayÄ±z, hata alÄ±rÄ±z, bÃ¶yle bir ifade kullanmak gerekiyorsa '&size' ile ihtiyacÄ± karÅŸÄ±layabiliriz.
}
```



âš ï¸ C dilinde ilk deÄŸerini bir sabit ifadesinden alan `const` deÄŸiÅŸkenler bir diziyi tanÄ±mlarken dizinin eleman sayÄ±sÄ±nÄ±n verildiÄŸi ifadede kullanÄ±lamaz. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki program yukarÄ±da aÃ§Ä±klanan durum incelenebilir.
```C
#include <stdio.h>

#define SIZE 100

int main(void)
{
    const int size = 5;
    
    int ar[size]; // C dilinde burada sÃ¶zdizim hatasÄ± oluÅŸacaktÄ±r.
}
```


â—â—â— C dilinde ilk deÄŸerini bir sabit ifadesinden alan `const` deÄŸiÅŸkenler sabit ifedesi gereken yerlerde kullanÄ±lamazlar, C++ dilinde bÃ¶yle bir kÄ±sÄ±tlama yoktur.


ğŸ‘‡ AÅŸaÄŸÄ±daki program sabit ifadesi kullanÄ±lmasÄ± gereken yerde `const` deÄŸiÅŸkenlerin kullanÄ±lmasÄ±ndan kaynaklanan **sÃ¶zdizim hatasÄ±(syntax error)** incelenebilir.
```C
#include <stdio.h>

#define SIZE 100

int main(void)
{
    const int x = 5;
    const int y = 6;
    const int z = 7;
    const int t = 9;

    // C dilinde burada sÃ¶zdizim hatasÄ±(syntax error) oluÅŸacaktÄ±r.
    switch{
        case x: 
            break;
        case y: 
            break;
        case z: 
            break;
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program **Designated Initializer** ile diziye ilk deÄŸer verirken index deÄŸerlerini belirten ifadelerin sabit ifadesi olmasÄ± gerektiÄŸi durumu incelenebilir.
```C
#include <stdio.h>

#define SIZE 100

int main(void)
{
    const int idx = 5;
    
    int ar[10] = { [2] = 6, [idx] = 1 }; // C dilinde burada sÃ¶zdizim hatasÄ±(syntax error) oluÅŸacaktÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki ilk deÄŸer verme iÅŸlemlerinin legal ve **well-form** olduÄŸu incelenebilir.
```C
#include <stdio.h>

int foo(void);

int main(void)
{
    // C dilinde burada sÃ¶zdizim hatasÄ±(syntax error) yoktur. 
    int x = foo();
    const int y = foo();
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programdan `const`tanÄ±mlanan deÄŸiÅŸkenlerin kullanÄ±m farklarÄ± incelenebilir.
```C
#include <stdio.h>

int foo(void);

int main(void)
{
    const int x = 10;
    const int y = foo();

    int ar1[x]; // C++ dilinde legal, C dilinde illegal.
    int ar2[y]; // C ve C++ dillerinde illegal.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan `const` tanÄ±mlanan deÄŸiÅŸkenlerin adlandÄ±rÄ±lmalarÄ± incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 10;
    int* const p1 = &x; // Buradaki 'p1' deÄŸiÅŸkeni 'const pointer to int' ya da 'top-level const' olarak tanÄ±mlanÄ±r.
    const int* p2 = &x; // 'low-level const'
    int const* p3 = &x; // 'low-level const'
}
```


> â” 
> SorduÄŸum soru
> 
> C++ dilinde "const pointer to const int" gibi bir ifadenin Ã¶zel bir karÅŸÄ±lÄ±ÄŸÄ± var mÄ±ydÄ±?
> 
> Cevap;
> 
> C dilindeki tanÄ±mlamalar C++ dilinde de kullanÄ±labilir. C++ dilinde o tanÄ±mlama iÃ§in idiomatic olarak Ã¶zel bir terim yoktur.


ğŸ‘‡ AÅŸaÄŸÄ±daki programdan `const` kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>

int a, b, c;
int x = 21;

int main(void)
{
    int* const p[] = { &a, &b, &c }; // 'p' dizisinin elemanlarÄ±nÄ± gÃ¶steren pointer const'tur deÄŸiÅŸtirilemez.
    int* px = &x;

    *p[0] = 24; // Bu iÅŸlem legaldir.
    p[0] = px; // Bu iÅŸlem illegaldir.
}
```


â—â—â— `void foo(Type *);` olarak bildirilen `foo` fonksiyonunun parametre olarak alacaÄŸÄ± nesneyi deÄŸiÅŸtirebileceÄŸi iÃ§in **mutater**, **set function**, **setter** adlarÄ±yla nitelendirilir.


ğŸ“Œ Bu noktada yazÄ±lÄ±m alanÄ±ndaki arzÄ±n yÃ¼ksekliÄŸi ve iÅŸ imkanlarÄ±nÄ±n bu istihdama nazaran daha az olmasÄ±ndan ve bu durumun da yazÄ±lÄ±mcÄ±larÄ±n kalitesinin Ã¶nemini arttÄ±rdÄ±ÄŸÄ±ndan bahsedildi.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 11.11-11.30 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


â—â—â— Fonksiyonun aldÄ±ÄŸÄ± tÃ¼rler aÅŸaÄŸÄ±daki gibi Ã¼Ã§ farklÄ± biÃ§imde adlandÄ±rÄ±lÄ±rlar;
- `void set(T* p);` buradaki `p` deÄŸiÅŸkeni **out parameter** olarak adlandÄ±rÄ±lÄ±r.
- `void get(const T* p);` buradaki `p` deÄŸiÅŸkeni **in parameter** olarak adlandÄ±rÄ±lÄ±r.
- `void foo(T* p);` buradaki `p` deÄŸiÅŸkeni **in-out parameter** olarak adlandÄ±rÄ±lÄ±r, bunun dilin sÃ¶zdiziminde bir karÅŸÄ±lÄ±ÄŸÄ± yok, bu durum fonksiyonun dÃ¶kÃ¼mantasyonunda belirtilmelidir.

â—â—â— Ã–zellikle **user defined type** sÃ¶z konusu olduÄŸunda bazÄ± fonksiyonlar kendilerine gÃ¶nderilen adresteki deÄŸiÅŸkenin deÄŸerini okurlar(yani input olarak kullanÄ±rlar) ama aynÄ± zamanda adresini aldÄ±klarÄ± deÄŸiÅŸkene deÄŸer yazarlar, bu parametrelere **in-out parameter** deniliyor.



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan **out parameter** ve **in-out parameter** deÄŸer alan iki farklÄ± fonksiyona gÃ¶nderilecek deÄŸerin Ã¶nemli olduÄŸu incelenebilir.
```C
#include <stdio.h>

void foo(int* p); // out parameter
void bar(int* p); // in-out parameter

int main(void)
{
    int x;

    foo(&x); // 'foo' fonksiyonuna geÃ§ilen deÄŸerin ilk deÄŸere sahip olmasÄ± Ã¶nemli olmadÄ±ÄŸÄ± iÃ§in bu kullanÄ±mda yanlÄ±ÅŸ bir ÅŸey yoktur.
    bar(&x); // Burada 'x' Ã§Ã¶p deÄŸerde olduÄŸunda 'bar' fonksiyonu 'in-out parameter' alÄ±yorsa 'ub' durumuna neden olacaktÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan `const` tanÄ±mlanan deÄŸiÅŸkenlerin tÃ¼r dÃ¶nÃ¼ÅŸÃ¼m durumlarÄ± incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    const int x = 10;

    int* ptr = &x; // C dili derleyicisi burada uyarÄ± mesajÄ± verecektir ama olmasÄ± gereken sÃ¶zdizim hatasÄ±dÄ±r(syntax error) Ã§Ã¼nkÃ¼ 'const int*' tÃ¼rÃ¼nden 'int*' tÃ¼rÃ¼ne Ã¶rtÃ¼lÃ¼ tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapÄ±lÄ±yor.
    int* ptr = (int*)&x; // sÃ¶zdizim hatasÄ±(syntax error) olmaz ama '*ptr' ifadesi ile nesneye deÄŸer atanÄ±rsa 'ub' oluÅŸur.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan `const` tanÄ±mlanan deÄŸiÅŸkenlere hangi deÄŸerlerin atanmasÄ±nÄ±n doÄŸru olup olmadÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 10;
    int y = 11;
    int* p1 = &x;
    int* p2 = &y;

    int** ptr1 = &p1;

    // AÅŸaÄŸÄ±daki atamalarÄ±n hepsi legaldir.
    ptr1 = &p2;
    *ptr1 = &y;
    **ptr1 = 23;

    int** const ptr2 = &p1;
    ptr2 = &p2; // Buradaki atama iÅŸlemi illegal.
    *ptr2 = &y; // Buradaki atama iÅŸlemi legal.
    **ptr2 = 23; // Buradaki atama iÅŸlemi legal.

    
    int* const * ptr3 = &p1;
    ptr3 = &p2; // Buradaki atama iÅŸlemi legal.
    *ptr3 = &y; // Buradaki atama iÅŸlemi illegal.
    **ptr3 = 23; // Buradaki atama iÅŸlemi legal.

    
    int const ** ptr4 = &p1;
    ptr4 = &p2; // Buradaki atama iÅŸlemi legal.
    *ptr4 = &y; // Buradaki atama iÅŸlemi legal.
    **ptr4 = 23; // Buradaki atama iÅŸlemi illegal.

    
    const int** ptr5 = &p1;
    ptr5 = &p2; // Buradaki atama iÅŸlemi legal.
    *ptr5 = &y; // Buradaki atama iÅŸlemi legal.
    **ptr5 = 23; // Buradaki atama iÅŸlemi illegal.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir fonksiyonda `int* const*` tÃ¼rÃ¼nÃ¼n kullanÄ±mÄ± incelenebilir. 
```C
#include <stdio.h>

void foo(int* const* ptr, int size)
{
    ptr[2] = 34; // Buradaki atama iÅŸlemi illegal.
    *ptr = 23; // Buradaki atama iÅŸlemi illegal.
}

int main(void)
{
    int* p[5] = { NULL };

    foo(p, 5);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `int*` tÃ¼rÃ¼ dÃ¶ndÃ¼ren bir fonksiyonun dÃ¶nÃ¼ÅŸ deÄŸerinin farklÄ± biÃ§imlerde nasÄ±l kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>

int* foo(void);

int main(void)
{
    *foo() = 98;

    int* ptr = foo();
    *ptr = 324;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `const int*` tÃ¼rÃ¼ dÃ¶ndÃ¼ren bir fonksiyonun dÃ¶nÃ¼ÅŸ deÄŸerinin farklÄ± biÃ§imlerde nasÄ±l kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>

// 'foo' fonksiyonu adresini dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ nesneye salt okuma amaÃ§lÄ± eriÅŸim veriyor.
const int* foo(void);

int main(void)
{
    *foo() = 98; // sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.

    int* ptr = foo(); // Ã–rtÃ¼lÃ¼ olarak 'const int*' tÃ¼rÃ¼nden 'int*' tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸÃ¼m yapÄ±lÄ±yor.
    *ptr = 324;
}
```


#### `volatile` Anahta SÃ¶zcÃ¼ÄŸÃ¼ 

Bu anahtar sÃ¶zcÃ¼k en Ã§ok sistem programlama ve **gÃ¶mÃ¼lÃ¼(embedded)** yazÄ±lÄ±mlarda kullanÄ±lmaktadÄ±r. </br>
`volatile` anahta sÃ¶zcÃ¼ÄŸÃ¼ ile tanÄ±mlanan bir deÄŸiÅŸkenin **program dÄ±ÅŸÄ± kaynaklar** tarafÄ±ndan deÄŸiÅŸtirilebileceÄŸi belirtilmiÅŸ oluyor. </br>
Derleyici `volatile` anahta sÃ¶zcÃ¼ÄŸÃ¼ ile tanÄ±mlanan bir deÄŸiÅŸkenle ilgili iyiliÅŸtirmeleri(optimization) yapmayacaktÄ±r ya da kÄ±sÄ±tlÄ± biÃ§imde yapacaktÄ±r.

`volatile` anahta sÃ¶zcÃ¼ÄŸÃ¼ ile ilgili iki soru sorulabilir;
1. **Program iÃ§in kaynak** ve **program dÄ±ÅŸÄ± kaynak** nedir?
2. `volatile` anahta sÃ¶zcÃ¼ÄŸÃ¼ neden kullanÄ±lÄ±r?


Adresler ile eriÅŸrilen bazÄ± deÄŸiÅŸkenlerin deÄŸerleri **program dÄ±ÅŸÄ± kaynaklar** ile deÄŸiÅŸtirilebilir, **program dÄ±ÅŸÄ± kaynaklardan** biri donanÄ±mla olan iletiÅŸimlerdir.

ğŸš€ **Memory mapped I/O**: DonanÄ±mla ilgili bir birim var ve o donanÄ±mla ilgili birim aynÄ± zamanda bellekte bir adresle iliÅŸkili yani o cihaz kullanÄ±ldÄ±ÄŸÄ±nda belleÄŸe bir deÄŸer yazabiliyor ya da bellekten bir deÄŸeri okuyabiliyor. Ä°ÅŸte bu duruma verilen ad **memory mapped I/O**. Mesal klavye bÃ¶yle bir donanÄ±m.

Sistem programlamada Ã§oÄŸunlukla **memory mapped I/O** durumlarÄ± vardÄ±r. **Memory mapped I/O** iÃ§in kullanÄ±lan bellek alanlarÄ±na **donanÄ±m yazmaÃ§larÄ±(hardware register)** deniliyor, **donanÄ±m yazmaÃ§larÄ±na(hardware register)** bazÄ± adresler yoluyla eriÅŸilebiliyor. </br>
**Program dÄ±ÅŸÄ± kaynaklarÄ±n** en Ã§ok kullanÄ±lan biÃ§imi donanÄ±mla iletiÅŸimdir. 


**Interrupt Service Rutine(ISR)**: Kesmeler yoluyla process'deki bir deÄŸiÅŸkene eriÅŸilip o deÄŸiÅŸkenin deÄŸeri deÄŸiÅŸtirilebilir. DoÄŸrudan bir deÄŸiÅŸkenin deÄŸeri deÄŸiÅŸtirilmiyor, kesme geldiÄŸinde dÄ±ÅŸ kaynaÄŸa ait olarak Ã§alÄ±ÅŸan bir kod bir deÄŸiÅŸkeni deÄŸiÅŸtirebilir.


**Program dÄ±ÅŸÄ± kaynaklar** ile bir deÄŸiÅŸkenin deÄŸerinin deÄŸiÅŸtirilebileceÄŸini gÃ¶rmÃ¼ÅŸ olduk ama buna neden ihtiyaÃ§ duyuluyur onu da anlamamÄ±z gerekiyor.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda derleyici `x` deÄŸiÅŸkenini deÄŸerinin **program dÄ±ÅŸÄ± kaynaklardan** ile deÄŸiÅŸtirilmeyeceÄŸini varsayarak makine koduna Ã§evirecektir.
```C
int x = 50;

int main(void)
{
    while(1){
        // ...

        x++; // Burada derleyici her dÃ¶ngÃ¼ adÄ±mÄ±nda 'x' deÄŸiÅŸkeninin deÄŸerini bellekten Ã§ekip yazmaca almayabilir, Ã§Ã¼nkÃ¼ bu deÄŸiÅŸkenin program dÄ±ÅŸÄ± kaynaklar tarafÄ±ndan deÄŸiÅŸtirilmediÄŸini varsaymaktadÄ±r.
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **program dÄ±ÅŸÄ± kaynaklardan** deÄŸiÅŸtirilebilir olarak tanÄ±mlanan bir adresin kullanÄ±mÄ± incelenebilir, buradaki kullanÄ±m sistem programlamayla ilgili olduÄŸu iÃ§in tam anlaÅŸÄ±lmasÄ± gerekmiyor.
```C
#define STATUS_REG (*(volatile unsinged int*)0x40000000)

void wait_for_ready()
{
    while ((STATUS_REG & 0x01) == 0){
        // DonanÄ±m hazÄ±r olana kadar bekle
    }
}
```


MÃ¼lakatlarda en sÄ±k sorulan sorulardan biri `volative` anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n kullanÄ±mÄ±nÄ±n doÄŸru bilinip bilinmediÄŸine yÃ¶nelik sorulardÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `volatile` kullanÄ±mÄ± incelenebilir, derleyici `volatile` olarak bildirilen adresteki deÄŸerlerin kullanÄ±ldÄ±ÄŸÄ± her yerde adresteki deÄŸeri bellekten okumasÄ± gerekiyor. 
```C
int main()
{
    int x = 5;
    int* const pc = &x; // const pointer to int

    int* volatile pv1 = &x; // 'volatile pointer to int'
    int volatile* pv2 = &x; // 'pointer to volatile int'
    volatile int * pv3 = &x; // 'pointer to volatile int'
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `volatile pointer to volatile int` tÃ¼rÃ¼nden bir deÄŸiÅŸken tanÄ±mlanabileceÄŸi gÃ¶rÃ¼lebilir.
```C
int main()
{
    int x = 5;
    int* const pc = &x;

    volatile int * volatile pv1 = &x; // 'volatile pointer to volatile int' olarak tanÄ±mlanÄ±r. 
}
```


> â” 
> 
> Sorulan soru;
> 
> O zaman volatile anahtar sÃ¶zcÃ¼ÄŸÃ¼ const ile aynÄ± Ã¶zellikte fakat zÄ±t anlamda diyebilir miyiz?
> 
> Cevap;
> 
> HayÄ±r `const` ve `volatile` birbirinin zÄ±ttÄ± deÄŸildir, birbirinden farklÄ± kullanÄ±ma sahiptirler.
> 
> 
> ğŸ‘‡ AÅŸaÄŸÄ±daki programda `const` olan bir deÄŸiÅŸkenin aynÄ± anda `volatile` olarak tanÄ±mlandÄ±ÄŸÄ±nda programÄ±n iÃ§inde deÄŸiÅŸtirilemeyeceÄŸi ama program dÄ±ÅŸÄ± kaynaklar tarafÄ±ndan deÄŸiÅŸtirilebilir olarak tanÄ±mlanabileceÄŸi gÃ¶rÃ¼lebilir.
> ```C
> const volatile int x = 4; // Burada olduÄŸu gibi bir deÄŸiÅŸken hem 'const' hem de 'volatile' olarak tanÄ±mlanabilir.
> 
> int main()
> {
>    
> 
> }
> ```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `const` olan bir deÄŸiÅŸkenin aynÄ± anda `volatile` olarak tanÄ±mlandÄ±ÄŸÄ±nda program iÃ§inden deÄŸerinin deÄŸiÅŸtirilemeyeceÄŸi gÃ¶rÃ¼lmelidir.
```C
#define STATUS_REG (*(const volatile unsinged int*)0x40000000)

void wait_for_ready()
{
    while ((STATUS_REG & 0x01) == 0){
        // DonanÄ±m hazÄ±r olanakadar bekle

        STATUS_REG = // Buradaki gibi bir atama iÅŸlemi sÃ¶zdizim hatasÄ±na neden olur.
    }
}
```



â—â—â— Bir zÄ±tlÄ±k aranÄ±yorsa `register` ile `volatile` anahtar sÃ¶zcÃ¼klerinde bir zÄ±tlÄ±k vardÄ±r, `register` anahtar sÃ¶zcÃ¼ÄŸÃ¼yle tanÄ±mlanan deÄŸiÅŸkenlerin deÄŸerlerinin bir **yazmaÃ§ta(register)** turulmasÄ± istenmiÅŸ oluyor ve bu iÅŸlem deÄŸiÅŸkenlerin deÄŸerleri Ã¼zerinde Ã§ok deÄŸiÅŸiklik yapÄ±lacaÄŸÄ± zaman kullanÄ±lÄ±yor(mesela dÃ¶ngÃ¼ sayacÄ± deÄŸiÅŸkenlerinin kullanÄ±mÄ±nda) ama `volatile` anahtar sÃ¶zcÃ¼ÄŸÃ¼ ile derleyiciye bu deÄŸiÅŸkenin deÄŸeri Ã¼zerinde her iÅŸlem yapÄ±lacaÄŸÄ± zaman bu deÄŸiÅŸkenin deÄŸerinin bellekten yeniden Ã§ekilmesi gerektiÄŸi bildiriliyor.


#### `restrict` Anahtar sÃ¶zcÃ¼ÄŸÃ¼  

C99 standardÄ±yla C diline eklenmiÅŸtir, C++ dilinde `restrict` anahtar sÃ¶zcÃ¼ÄŸÃ¼ yoktur. </br>
`restrict` anahtar sÃ¶zcÃ¼ÄŸÃ¼ sadece pointer deÄŸiÅŸkenlerin tanÄ±mÄ±nda kullanÄ±lÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `restrict` anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n sadece bir gÃ¶stericiyi niteleyebileceÄŸi incelenebilir.
```C
int main(void)
{
    int x = 4;
    int* restrict p1 = &x; // Legal ve doÄŸru kullanÄ±m.
    restrict int* p2 = &x; // Buradaki tanÄ±mlama 'sÃ¶zdizim hatasÄ±dÄ±r(syntax error)'.
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `restrict` bildirilen `p1` gÃ¶stericisinin deÄŸerini baÅŸka bir gÃ¶stericinin gÃ¶stermediÄŸi derleyiciye bildiriliyor, 
```C

// AÅŸaÄŸÄ±daki bildirimle derleyiciye 'p1' gÃ¶stericisinin gÃ¶sterdiÄŸi adresteki nesnenin baÅŸka bir gÃ¶sterici tarafÄ±ndan gÃ¶sterilmediÄŸi bildirilmiÅŸ oluyor ve derleyici kodu bu bilgiye gÃ¶re iyileÅŸtirerek makine koduna Ã§evirecektir.
void foo(int* restrict p1, int* p2)
{

}

int main(void)
{
    int x = 4, y = 2;
}
```



**Pointer Aliasing**: FarklÄ± pointer deÄŸiÅŸkenlerin aynÄ± adres deÄŸerine sahip olmasÄ± durumunu belirtmek iÃ§in kullanÄ±lmaktadÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir fonksiyona geÃ§ilen gÃ¶stericilerin **pointer aliasing** durumunda olabileceÄŸi durum incelenebilir.
```C
// AÅŸaÄŸÄ±daki fonksiyonun parametrelerindeki gÃ¶stericiler aynÄ± adres deÄŸerine sahipse derleyicinin yapacaÄŸÄ± iyileÅŸtirme(optimization) iÅŸlemleri soruna neden olabilir.
void foo(int* p1, int* p2, int* p3)
{
    *p1 += *p2;
    *p3 += *p2;
}

int main(void)
{
    int x = 5, y = 7;

    foo(&x, &x, &y);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `restrict` anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n kullanÄ±mÄ± incelenebilir.
```C
// AÅŸaÄŸÄ±daki fonksiyonun parametrelerindeki gÃ¶stericiler aynÄ± adres deÄŸerine sahip olmayacaÄŸÄ± 'restrict' anahtar sÃ¶zcÃ¼ÄŸÃ¼yle derleyiciye bildirilmiÅŸ oluyor ve  derleyicinin bu bilgiye gÃ¶re iyileÅŸtirme(optimization) iÅŸlemlerini yapacaktÄ±r.
void foo(int* restrict p1, int* restrict p2)
{
    *p1 += *p2;
    *p3 += *p2;
}

int main(void)
{
    int x = 5, y = 7;

    foo(&x, &x); // Buradaki fonksiyon Ã§aÄŸrÄ±sÄ±nÄ± 'ub' durumuna neden olur.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **Overlapped bellek bloklarÄ±nÄ±n** `foo` fonksiyonuna geÃ§ilmesinden kaynaklÄ± olan **ub** durumu incelenebilir.
```C

void foo(int* restrict p1, int* restrict p2, int n)
{
    while(n--){
        *p1++ = *p2++;
    }    
}

int main(void)
{
    int a[100] = { 0 };

    foo(a + 5, a + 9, 10);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda derleyicinin dÃ¶ngÃ¼de kullanÄ±lan bir gÃ¶stericinin eriÅŸtiÄŸi nasnenin deÄŸerinin baÅŸka yerlerden de deÄŸiÅŸtirilebilme ihtimali olma durumu incelenebilir.
```C
double g;

void foo(void);

int main(void)
{
    double* dp = &g;
    double sum = 0.;

    for(int i = 0; i < 100; ++i){
        sum += *dp; // Programda eÄŸer 'g' deÄŸiÅŸkenine tek eriÅŸim '*dp' ifadesi ise derleyici her dÃ¶ngÃ¼ adÄ±mÄ±nda 'g' deÄŸiÅŸkeninin deÄŸeirini bellekten okuyacak ÅŸekilde makine kodu Ã¼retecektir Ã§Ã¼nkÃ¼ ilgili nesnenin deÄŸeri baÅŸka yerden de deÄŸiÅŸtirilebilir.
        foo(); // EÄŸer 'foo' fonksiyonun 'g' deÄŸiÅŸkeninin deÄŸerini deÄŸiÅŸtirme ihtimali varsa derleyici bir Ã¼stteki statement'ta 'g' nesnesinin deÄŸerini her defasÄ±nda bellekten okumak zorunda olacaktÄ±r.
    }
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda derleyicinin dÃ¶ngÃ¼de kullanÄ±lan bir gÃ¶stericinin eriÅŸtiÄŸi nasnenin deÄŸerinin baÅŸka yerlerden deÄŸiÅŸtirilebilme ihtimalinin olmadÄ±ÄŸÄ± durumu incelenebilir.
```C
double g;

void foo(void);

int main(void)
{
    double* restrict dp = &g; // Burada 'g' deÄŸiÅŸkenini gÃ¶steren baÅŸka bir gÃ¶sterici olmadÄ±ÄŸÄ± belirtilmiÅŸ oluyor.
    double sum = 0.;

    for(int i = 0; i < 100; ++i){
        sum += *dp; // Programda eÄŸer 'g' deÄŸiÅŸkenine tek eriÅŸim '*dp' ifadesi ise derleyici her dÃ¶ngÃ¼ adÄ±mÄ±nda 'g' deÄŸiÅŸkeninin deÄŸerini bellekten okuyacak ÅŸekilde makine kodu Ã¼retmeyecektir Ã§Ã¼nkÃ¼ bunun maliyeti Ã§ok yÃ¼ksektir.
        foo(); // 'foo' fonksiyonun 'g' deÄŸiÅŸkeninin deÄŸerini deÄŸiÅŸtirme ihtimali olmadÄ±ÄŸÄ± bildirilmiÅŸti. 
    }
}
```


ğŸ“Œ Kursun son iki dersinde C99 standardÄ± ile gelen yenilikler anlatÄ±lacak.


Bu baÅŸlÄ±k altÄ±nda aÅŸaÄŸÄ±daki anahtar sÃ¶zcÃ¼klerin ne anlama geldiÄŸi incelendi;
- `outo`
- `register`
- `static`
- `extern`
- `const`
- `volatile`
- `restrict`


ğŸ“Œ Bir sonraki derste Ã¼retimde en Ã§ok kullanÄ±lacak olan `struct`, `union`, `enum`(bu tÃ¼rlere **user defined type** deniliyor) araÃ§larÄ±nÄ± Ã¶ÄŸrenmeye baÅŸlayacaÄŸÄ±z, bu konu 16-20 saat arasÄ±nda zaman alacak. 


> â”
> 
> Sorulan soru?
> 
> Konudan baÄŸÄ±mÄ±sz gÃ¶mÃ¼lÃ¼ sistem programlama iÃ§in bu kurstan sonra hangi kursu Ã¶neririrsiniz? mikrodenetleyiciler mi ? (c ve sistem programcÄ±larÄ± derneÄŸi) yoksa baÅŸka bir kurs mu?
> 
> Cevap;
> 
> C ve sistem programcÄ±larÄ± derneÄŸinde verilen kurslar C dilinin kullanÄ±mÄ±na yÃ¶nelik olarak **C UygulamalarÄ± I**, **C UygulamalarÄ± II**, **Unix/ILinux**, **GÃ¶mÃ¼lÃ¼ Sistem Programlama** gibi kurslara katÄ±lÄ±nabilir. </br>
> SektÃ¶rde hem C hem de C++ dili kullanÄ±ldÄ±ÄŸÄ± iÃ§in sadece C dilini bilmek yeterli olmayacaktÄ±r.

**Toolkit**: Ä°ÅŸletim sisteminden baÄŸÄ±msÄ±z olarak uygulama geliÅŸtirmeye yÃ¶nelik olan yazÄ±lÄ±mlara, ortamlara vb. verilen addÄ±r.


Ders sonu ...
