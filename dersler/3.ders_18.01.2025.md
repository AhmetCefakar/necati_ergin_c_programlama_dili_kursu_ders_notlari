# 3.Ders 18.01.2025 ğŸ•˜

Derse 44-37 kiÅŸi katÄ±ldÄ±-Sona doÄŸru.

## Token TÃ¼rleri Devam

**Token(Atom)**: Derleyicinin iÅŸlem yaparken ele aldÄ±ÄŸÄ± en ufak kod parÃ§alarÄ±na verilen addÄ±r.

Derleyicinin bir kaynak dosyayÄ± token'lara ayÄ±rma iÅŸlemine C dilinin resmi dokÃ¼mantasyonunda "**Lexical Analysis**" deniliyor, gayri resmi olarak "**Tokenizing**" deniliyor. 
Token terimlerinin ne olduÄŸunu anlamak dilin kurallarÄ±nÄ± anlamak iÃ§in gerekli ve Ã¶nemli bir konudur, bu tanÄ±mlarÄ± ve derleyicinin yaptÄ±ÄŸÄ± "**Tokenizing**" iÅŸlemini anlamak Ã¶nemlidir.

Alttakiler token tÃ¼rleridir(bir Ã¶nceki derste bunlar detaylÄ± olarak yazÄ±lmÄ±ÅŸtÄ±r);
1. **Keyword**
2. **Identifier**
3. **Constants**
4. **Operators**
5. **String Literal**
6. **Delimiter**

4) **Operators(Ä°ÅŸleÃ§)**: Kursun doÄŸrudan ya da dolaylÄ± olarak 16-20 saatini(kursun yaklaÅŸÄ±k %10'u) oluÅŸturacak konudur. C-89'da 45 adet operator vardÄ±r. Kod yazabilmek ve kodlarÄ± anlayabilmek iÃ§in operatÃ¶rlerin iyi bilinmesi gerekiyor. C-89'da bazÄ± operatÃ¶rler tek karakterlik, bazÄ±larÄ± iki karakterlik, bazÄ±larÄ± Ã¼Ã§ karakterlik operatÃ¶rlerdir ve bir de Ã¶zel olarak **sizeof** operatÃ¶rÃ¼ vardÄ±r ve bu operatÃ¶r hem bir "Keyword" hem de bir "Operator" olarak gÃ¶rev alÄ±r.

Alttakiler C-89'daki bazÄ± iÅŸlem operatÃ¶rleridir;

"`>` `>=` `<` `<=`" bu operatÃ¶rlere Ä°ngilizce "**relational operators**" denilmektedir.
"`==` `!=`" bu operatÃ¶rlere Ä°ngilizce "**equality operators**" denilmektedir.

AÅŸaÄŸÄ±da bazÄ± operatÃ¶rler gÃ¶rÃ¼lebilir, ilerleyen derslerde operatÃ¶rler ve detaylarÄ±na parÃ§a parÃ§a farklÄ± konularda deÄŸinilecektir.
- `>`    `<` bu operatÃ¶rler tek tokendan oluÅŸan operatÃ¶rler.
- `==`   `!=` bu operatÃ¶rler iki tokendan oluÅŸan operatÃ¶rler.
- `+`   `*` bu operatÃ¶rler tek tokendan oluÅŸan operatÃ¶rler.
- `>=`  `<=`  `++` bu operatÃ¶rler iki tokendan oluÅŸan operatÃ¶rler.
- `>>=`   `<<=` bu operatÃ¶rler Ã¼Ã§ tokendan oluÅŸan operatÃ¶rler.
- `sizeof` bu operatÃ¶r hem bir **key-word** hem de bir operatÃ¶r olmasÄ±yla Ã¶zeldir ve tek tokendan oluÅŸur.


5) **String Literal(String sabit)**: Kodda Ã§ift tÄ±rnak karakterleri arasÄ±nda yazÄ±lan yazÄ±lardan oluÅŸan **token**'laradÄ±r. Kursun ikinci yarÄ±sÄ±nda "**string literal**" konusuna detaylÄ± deÄŸinilecektir.

`x = y + z;` --> Buradaki ifadede toplamda altÄ± adet token mevcuttur(`x`, `y`, `z` olarak Ã¼Ã§ adet **identifier**, `=`, `+` olarak iki adet **Operator**, `;` olarak bir adet **delimiter**).
`"x = y + z;"` --> Buradaki ifadede toplamda sadece bir adet token mevcuttur, buradaki ifadeye "**string literal**" denmektedir.

YazÄ±lan bir kodu derleyici iÅŸlerken "Token"lara ayÄ±rÄ±r. `(` karakteri bir fonksiyon Ã§aÄŸÄ±rÄ±yorsa "**function call**" olarak adlandÄ±rÄ±lan bir Operator'dÃ¼r ama `(` karakteri her zaman bir Operator deÄŸildir, bazen Ã¶ncelik parantesi gÃ¶revindedir.

"#define", "#include" komutlarÄ± derleyiciye verilen komutlar deÄŸildir bu komutlar "**Preprocessor(Ã–n-iÅŸlemci)**" programÄ±na verilen komutlardÄ±r ve Ã¶n-iÅŸlemci program bu komutlarÄ± iÅŸler ve bu komutlarla derleyicinin iÅŸleyeceÄŸi asÄ±l komutlarÄ± yer deÄŸiÅŸtirir. 

"if", "else" **command(komut)** deÄŸildir bunlar "**atatement(deyim)**" olarak adlandÄ±rÄ±lmaktadÄ±r, C ve C++ dilinde **command(komut)** adlandÄ±rmasÄ± sadece "**preprocessor(Ã¶n-iÅŸlemci)**" programÄ±na verilen yÃ¶nergeler iÃ§in kullanÄ±lÄ±r.


"**Coding Style**", "**Coding Layout**", "**Coding Convention**" terimleri yazÄ±lan kodlarÄ±n okunurluÄŸunu yÃ¼ksek tutmak iÃ§in uygulanan kurallara verilen adlandÄ±rmadÄ±r. BazÄ± kod yazÄ±m kurallarÄ± vardÄ±r "**Google Coding Convention**" gibi, bu konuda internetten araÅŸtÄ±rma ğŸ” yapÄ±labilir. Profesyonel ortamlarda proje geliÅŸtirirken ilk baÅŸta projenin kodlamasÄ±nda takip edilip uyulacak olan kod yazma standartÄ±na karar verilir ve projede yer alan herkes buna uyar ve bu ÅŸekilde proje kodlarÄ± tek bir elden Ã§Ä±kmÄ±ÅŸ gibi olacaktÄ±r. 

Bizim en Ã§ok karÅŸÄ±mÄ±za Ã§Ä±kacak olan **token**'lar "**identifier(name)**" varlÄ±klarÄ±dÄ±r, dili Ã¶ÄŸrenirken en Ã§ok "**identifier(name)**" varlÄ±klarÄ±yla karÅŸÄ±laÅŸÄ±lacaktÄ±r.

Bir C programÄ±nda altÄ± adet kaynak dosya varsa derleyici program bu dosyalarÄ±n her birini ayrÄ± ayrÄ± derler(her bir ".c" uzantÄ±lÄ± dosya ayrÄ± ayrÄ± derlenir) ve en son "**Linker**" programÄ± bu derlenmiÅŸ dosyalarÄ± birleÅŸtirir. 


C dilinde yazÄ±lmÄ±ÅŸ olan bir program bir ya da daha Ã§ok kaynak dosyadan oluÅŸur ve her bir kaynak dosya ÅŸu adÄ±mlardan geÃ§mektedir; 
- "**.c File(Source File)**"
- "**Preprocessor(Ã–n-iÅŸlemci)**" Program
- "**Translation Unit(Ã‡eviri Birimi)**"
- "**Compiler(Derleyici)**" Program
- "**Object Code(Hedef Kod)**" ve baÅŸka diÄŸer "**Object Code(Hedef Kod)**" dosyalarÄ±
- "**Linker(BaÄŸlayÄ±cÄ±)**" Program
- "**Executable Code(Ã‡alÄ±ÅŸtÄ±rÄ±labilir Kod)**"



Bir Ã§ok dilde ayrÄ± paketler haline getirilmiÅŸ Ã§alÄ±ÅŸtÄ±rÄ±labilir kod kÄ±sÄ±mlarÄ±na "**Sub-rutin**", "**Method**", "**Procedure**", "**Function**" vb. terimler kullanÄ±lmaktadÄ±r. C ve C++ dillerinin standardÄ±nda **function** terimi kullanÄ±lmaktadÄ±r(Necati Ergin C ve C++ dillerinde **method** ifadesini kullananlardan rahatsÄ±z olduÄŸunu belirtti). 

C dilinde "**.c**" uzantÄ±lÄ± bir dosyada bir fonksiyon iÃ§inde tanÄ±mlanmayan varlÄ±klar "**Global Namespace**" alanÄ±nda tanÄ±mlanmÄ±ÅŸ olur, bir fonksiyon iÃ§inde tanÄ±mlanan varlÄ±klar "**Local Namespace**" alanÄ±nda tanÄ±mlanmÄ±ÅŸ olur. Bu alanlarda tanÄ±mlanan deÄŸiÅŸkenlere "**Global Variable**" ve "**Local Variable**" adlarÄ± verilir.


## C Dilinin SÃ¶zdiziminde(Syntax) En Ã‡ok KullanÄ±lan Terimler 

1. **Expression(Ä°fade)**
2. **Statement(Deyim)**


### Statement(Deyim) 

C ve C++ dillerinde(hatta Java, C# dillerinde de) her bir "**statement**" "**;**" ile sonlanmaktadÄ±r. C ve C++ dillerindeki "**statement**" bu dillerdeki cÃ¼mlelermiÅŸ gibi dÃ¼ÅŸÃ¼nÃ¼lebilir(burada bir benzetim yapÄ±lÄ±yor). Tek bir satÄ±rda `int x = 3; double t = 23;` ÅŸeklinde birden fazla "**statement(deyim)**" bulunabilir, bunun farklÄ± hali olarak bir "**statement(deyim)**" birden fazla satÄ±ra da yayÄ±lmÄ±ÅŸ olabilir. "**statement**" varlÄ±klarÄ± "**Declaration**" ve "**Executable**" olarak iki tÃ¼re ayrÄ±lmaktadÄ±r. 

1. "**Declaration Statement(Bildirim Olan Deyimler)**": Kodda kullanÄ±lacak **adlarÄ±n(identifier)** ne olduÄŸunu belirten **statement**'lara "**Declaration Statement**" denilmektedir. `int y = 23;` bu **statement** bÃ¼nyesinde `y` adÄ±ndaki **identifier**  tÃ¼rÃ¼nÃ¼n ne olduÄŸu belirtildiÄŸi iÃ§in buna "Declaration Statement" denilmektedir.

2. "**Non Declaration Statement(Executable Statement)(Bildirim Olmayan Deyimler)**": **executable statement** terimi C dilin standardÄ±nda olmayan bir terimdir, `y = 45 + 4;` gibi bir **deyim(statement)** bÃ¼nyesindeki "y" **identifier(ad)**'Ä±nÄ±n  tÃ¼rÃ¼nÃ¼n ne olduÄŸunun bildirilmediÄŸi sadece atama iÅŸleminin yapÄ±ldÄ±ÄŸÄ± "**statement**" tÃ¼rÃ¼dÃ¼r.

â—â—â— C ve C++ dillerinde yazÄ±lmÄ±ÅŸ olan programlarÄ± doÄŸru anlayabilmek iÃ§in **declaration statement** ve **non declaration statement(executable statement)** tanÄ±mlamalarÄ±nÄ±n iyi bilinmesi ayrÄ±ca aralarÄ±ndaki farkÄ±n ne olduÄŸunun iyi bilinmesi gerekiyor.
- `int value = 123;` bu "**statement**" tÃ¼r olarak "**declaration**" tÃ¼rÃ¼ndendir Ã§Ã¼nkÃ¼ "value" tanÄ±mÄ±nÄ±n ne olduÄŸunun bildirimi yapÄ±lÄ±yor.
- `value += 45;` bu "**statement**" tÃ¼r olarak "**executable**" tÃ¼rÃ¼ndendir Ã§Ã¼nkÃ¼ bir bildirim iÃ§ermemekte, bildirim iÃ§ermiyorsa **executable statement** olarak nitelendiriliyor.

â—â—â— Derleme iÅŸleminin Ã¶yle bir sÃ¼reci var ki derleyici bu sÃ¼reÃ§te kodda kullanÄ±lan adlarÄ±n hangi varlÄ±klarÄ±n adlarÄ± olduÄŸunu anlamaya(bulmaya) Ã§alÄ±ÅŸÄ±r, bu sÃ¼rece "**Name Lookup**" denmektedir. 

â—â—â— "**Name Lookup**" terimi Ã¶nemli bir terimdir, derleyici bu aÅŸamada dosyada kullanÄ±lan **identifier(ad)**'larÄ±n hangi varlÄ±klarÄ±n adlarÄ± olduÄŸunu anlamaya/bulmaya Ã§alÄ±ÅŸÄ±r, bu aÅŸamaya "**name lookup**" denir. "**name lookup**" terimi programlamada genel olarak kullanÄ±lan bir terimdir C ve C++ standardÄ±nda kullanÄ±lan bir ifade deÄŸildir.

â—â—â— Derleyici ilk Ã¶nce her bir dosyayÄ± ayrÄ± ayrÄ± ele alÄ±p iÅŸlemektedir. Bu iÅŸlem sÄ±rasÄ±nda her bir dosya iÃ§in ilk Ã¶nce "**lexical analysis(tokenizing)**" iÅŸlemini yapar ve dosyadaki "**token**"larÄ± belirler. ArdÄ±ndan "**name lookup**" iÅŸlemini yapar. Daha sonra "**context control**" iÅŸlemi yapÄ±lÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda sÄ±rasÄ±yla **name lookup** ve **context control** iÅŸlemlerinin nasÄ±l yapÄ±ldÄ±ÄŸÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
int x(int);

int main(void)
{
    x = 5; // Burada 'name lookup' aÅŸamasÄ±nda 'x' adÄ± bir fonksiyonun adÄ± olarak tespit edileceÄŸi iÃ§in sÃ¶zdizim(sentaks) hatasÄ± oluÅŸacaktÄ±r.
}
```


>â”
> 
> Sorulan soru; 
> 
> X bir identifier anladÄ±ÄŸÄ±m kadarÄ±yla. Yani derleyici "Identifier"Ä±n ne olduÄŸunu (deÄŸiÅŸken? fonksiyon?) anlamak iÃ§in "name lookup" eylemini gerÃ§ekleÅŸtiriyor. Bir tarafta identifier, Ã¶teki tarafta name geÃ§iyor. Bu bir tutarsÄ±zlÄ±k deÄŸil mi terminolojik aÃ§Ä±dan?
> 
> Cevap;
>
> **Name lookup** terimi programlama jargonuna iliÅŸkin genel terimdir, **name lookup** terimi C dilinin standardÄ±nÄ±n kullandÄ±ÄŸÄ± bir terim deÄŸil.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.21-10.40 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦
Bundan sonra ilk ara 10.20'de 20 dk ve ikinci ara da 12.00'de 10 dk olacakmÄ±ÅŸ.

==================================================
***

### Expression(Ä°fade)

C dilinin **sÃ¶zdiziminde(syntax)** en Ã§ok kullanÄ±lan terim **expression(ifade)** kavramÄ±dÄ±r.

â—â—â— DeÄŸiÅŸkenler, sabitler, operatÃ¶rler biraraya gelerek **expression(ifade)** yapÄ±larÄ±nÄ± oluÅŸturur. </br>
C dilinin yarÄ±sÄ± **expression(ifade)**'dan oluÅŸmaktadÄ±r. AÅŸaÄŸÄ±da listelenler **expression(ifade)** olarak tanÄ±mlanÄ±r; 
- x
- 10 
- x + y 
- x + y *z > 25 
- x + y *z > (10 -a)

YukarÄ±da listelenen **Expression(Ä°fade)**'lar incelendiÄŸinde bir **Expression(Ä°fade)**'Ä±n bir ya da daha alt **Expression(Ä°fade)** iÃ§erebileceÄŸi gÃ¶rÃ¼lÃ¼r ve bunlara **Sub-Expression** denilmektedir.


â—â—â— C dilinde her **ifade(expression)** aÅŸaÄŸÄ±da listelenen tanÄ±mlara sahiptir;
1. Her **ifadenin(expression)** bir **veri tÃ¼rÃ¼(Data Type)** vardÄ±r.
2. Her **ifadenin(expression)** deÄŸer kategorisi vardÄ±r("**L Value / R Value**" olarak iki tÃ¼re ayrÄ±lÄ±r).
3. Her **ifadenin(expression)** bir deÄŸeri vardÄ±r(`void` tÃ¼rÃ¼nden olmayan her ifadenin bir deÄŸeri vardÄ±r). 


>â”
> 
> Sorulan soru; 
> 
> Az Ã¶nce kullandÄ±ÄŸÄ±mÄ±z misalde her operatÃ¶rÃ¼n olduÄŸu alan ayrÄ± bir ifade mi yoksa tek bir ifade olarak mÄ± kabul edeceÄŸiz?
> 
> Cevap;
> 
> `x + y * z > 20` bu bir ifadedir ayrÄ±ca bir ifade alt ifadelerden oluÅŸur.
> `x + y * z > 20` bu ifade bÃ¼nyesindeki `y * z`, `x + y * z`, `20`, `x`, `y`, `z` kÄ±sÄ±mlarÄ± da birer ifadedir.
> 
> ProgramcÄ±larÄ±n C dilini Ã¶ÄŸrenirken yaptÄ±ÄŸÄ± en tipik hatalardan biri **ifade(expression)** ve **deyimi(statement)** birbirine karÄ±ÅŸtÄ±rmaktÄ±r.
> `x = 10` bir **ifadedir(expression)**, `x = 10;` bu bir **deyimdir(statement)**


ğŸš€ **Deyimler(statement)** C dilinin cÃ¼mleleridir ÅŸeklinde bir benzetim yapÄ±labilir.


### Deyimler(statement) Devam

**Deyimler(statement)** temelde dÃ¶rde ayrÄ±lmaktadÄ±r, bunlar aÅŸaÄŸÄ±da listelenmiÅŸtir; 
1. **Expression Statement(Ä°fade Deyimi)**: `y++;`, `printf("Hello");`, `x = 5.345;`, `c = 5;` vb. kullanÄ±mlar
2. **Compound Statement(BileÅŸik Deyim, Bloklu Deyim)**: `{}` bloÄŸunu kapsayan alana verilen addÄ±r, bu blok iÃ§erisinde birden fazla farklÄ± tÃ¼rde **Statement** olabilir.
3. **Null Statement(BoÅŸ Deyim)**: `;` ÅŸeklindeki **Statement** **Null Statement** olarak adlandÄ±rÄ±lmaktadÄ±r. `;;`, `;;;;;;;` vb. ÅŸekilde **Statement** yazÄ±labilir. 
4. **Control Flow Statement(AkÄ±ÅŸ Kontrol Deyimi)**: Kendi iÃ§erisinde bir Ã§ok farklÄ± **Statement** tanÄ±mÄ±na ayrÄ±lÄ±r, aÅŸaÄŸÄ±da detaylÄ± olarak incelenecektir.

ğŸš€ EÄŸer bir **expression(ifade)** varsa ve bu **expression(ifade)** sonuna **terminator** olarak adlandÄ±rÄ±lan **;** **token**'Ä±nÄ± eklersek bir **deyim(statement)** elde ederiz ve bu deyimlere **expression statement(ifade deyimi)** deniyor.

#### Expression Statement(Ä°fade Deyimi)

>â”
> 
> Sorulan soru; 
> 
> Ä°fadeler tokenizing sÃ¼reciyle mi statamet haline dÃ¶nÃ¼yor ?
> 
> Cevap;
> 
> HayÄ±r, tokenizing sÃ¼recinden sonra.
> Ä°fadeler derleyicinin **sÃ¶zdizim aÄŸacÄ±(syntax tree)** denilen bir veri yapÄ±sÄ±nÄ± oluÅŸturmasÄ± sÃ¼recinde ortaya Ã§Ä±kÄ±yor. 
> Tokenizing sÃ¼reci sadece token'larÄ± birbirinden ayÄ±rmaktadÄ±r.
> Ä°fadelerin anlaÅŸÄ±lmasÄ± **sÃ¶zdizim aÄŸacÄ±(syntax tree)** oluÅŸturma aÅŸamasÄ±nda anlaÅŸÄ±lÄ±yor.



â—â—â— "**Ä°fade geÃ§erli deyim geÃ§erli.**" cÃ¼mlesi C ve C++ dilinde yazÄ±lan programlardaki kaynak dosyalarda yazÄ±lan ifadelerin ne olduÄŸuna diÄŸer dillere nazaran daha Ã§ok dikkat etmek gerektiÄŸini belirtmek iÃ§in kullanÄ±lÄ±yor. </br>
â—â—â— C ve C++ dillerinde bir ifade ya da deyim geÃ§erli olabilir ama kullanÄ±lmasÄ± mantÄ±klÄ± olmayabilir(kullanÄ±lan ifadeler **sÃ¶zdizim(syntax)** kurallarÄ±na uygun olabilir ama kullanÄ±lmalarÄ± bazÄ± sorunlara neden olabilir).


ğŸ‘‡ AÅŸaÄŸÄ±daki programda "Ä°fade geÃ§erli deyim geÃ§erli." cÃ¼mlesinin anlaÅŸÄ±lmasÄ± iÃ§in kod satÄ±rlarÄ± ve yorumlar incelenebilir.
```C
#include <stdio.h>

int main(void)
{
  int x = 56;

  x; // Bu deyim geÃ§erlidir ama kullanÄ±lmasÄ±nÄ±n bir anlamÄ± yoktur.
  6; // Bu deyim geÃ§erlidir ama kullanÄ±lmasÄ±nÄ±n bir anlamÄ± yoktur.
  x == 5; // Bu deyim geÃ§erlidir ama 'x = 5;' yerine yanlÄ±ÅŸlÄ±kla kullanÄ±lmÄ±ÅŸ gibi duruyor.
  x += 12; // Bu deyim geÃ§erlidir ve mantÄ±klÄ±dÄ±r.

  // AÅŸaÄŸÄ±daki 'if statement' bÃ¼nyesindeki 'x > 3.5' ifadesi geÃ§erlidir ve bu kullanÄ±mda mantÄ±k hatasÄ± da yoktur.
  if(x > 3.5){

  }

  // AÅŸaÄŸÄ±daki 'if statement' bÃ¼nyesindeki 'x > 3,5' ifadesi geÃ§erlidir ve bu kullanÄ±mda mantÄ±k hatasÄ± vardÄ±r, ifade '(x > 3), (5)' bu ÅŸekilde yorumlanÄ±r ve her zaman doÄŸru deÄŸer Ã¼retir(bu kÄ±sÄ±m ileriki derlerde anlaÅŸÄ±labilecek)
  if(x > 3,5){

  }
}
```

> "**Expression(Ä°fade) GeÃ§erli, Statement(Deyim) GeÃ§erli**" cÃ¼mlesinde anlatÄ±lmak istenen ÅŸudur: C ve C++ dilinde yazÄ±lan kodlarda herhangi bir sÃ¶zdizim hatasÄ±(syntax error) olmasa bile(yani yazÄ±lan kod legal olsabile) bu durum koddaki her bir **Statement(Deyim)**'Ä±n yazÄ±lmasÄ±nÄ±n mantÄ±klÄ± olmasÄ± anlamÄ±na gelmeyecektir.
> 
>> AÅŸaÄŸÄ±da listelenen durumlar incelenerek yukarÄ±daki tanÄ±mlama anlaÅŸÄ±labilir;
>> - `x + 7` bu bir **Expression(Ä°fade)**.
>> - `x + 7;` bu bir **Statement(Deyim)** ve Ã¶zel olarak **Expression Statement(Ä°fade Deyimi)** olarak adlandÄ±rÄ±lÄ±r fakat buradaki kodun bir mantÄ±ÄŸÄ± yok ve muhtemelen derleyici "Diagnostic(Bulgu iletisi)" uyarÄ±sÄ± verecektir.
>> `printf("Hello")` bu bir **Expression(Ä°fade)**. `printf("Hello");` bu bir **Statement(Deyim)** ve Ã¶zel olarak **Expression Statement(Ä°fade Deyimi)** olarak adlandÄ±rÄ±lÄ±r.
> 


#### Compound Statement(BileÅŸik Deyim, Bloklu Deyim) 

ğŸ‘‡ AÅŸaÄŸÄ±daki programda **compound statement** kullanÄ±mÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
// AÅŸaÄŸÄ±da ayrÄ± ayrÄ± Ã¼Ã§ farklÄ± 'expression statement' vardÄ±r.
x++;
y = x;
foo(x, y);

// AÅŸaÄŸÄ±da 'compound statement' kullanÄ±mÄ± gÃ¶rÃ¼lebilir.
{
  x++;
  y = x;
  foo(x, y);
}
```

**Curly Brace**: **Compound Statement(BileÅŸik Deyim, Bloklu Deyim)** yapÄ±sÄ± `{ ... }` ÅŸeklinde iki adet parantez iÃ§inde kullanÄ±lÄ±r. `{` karakterine **opening brace** ya da **left brace** denmektedir. `}` karakterine **closing brace** ya da **right brace** denmektedir.

ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã¼Ã§ farklÄ± **kapsam(blok)** vardÄ±r, bunlar incelenebilir.
```C
#include <stdio.h>

int main(void)
{
  int x = 67;

  if(x > 10){
    printf("evet");
  }
  else{
    printf("hayir");
  }
}
```

#### Null Statement(BoÅŸ Deyim)  

ğŸ‘‡ AÅŸaÄŸÄ±daki programda birden fazla **null statement** kullanÄ±lmÄ±ÅŸtÄ±r, bu program legaldir ama bÃ¶yle bir programÄ±n bir anlamÄ± yoktur.
```C
#include <stdio.h>

int main(void)
{
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
}
```

ğŸ‘‡ AÅŸaÄŸÄ±daki program bundan sonraki birkaÃ§ misal programdaki durumlarÄ± anlayabilemk iÃ§in incelenmek istenebilir.
```C
#include <stdio.h>

int main(void)
{
  int x = 67;

  if(x > 10)
    printf("evet dogru.");  
}
```

ğŸ‘‡ AÅŸaÄŸÄ±daki program **null statement**'Ä±n kullanÄ±lmasÄ±ndan dolayÄ± **if statement** kontrolÃ¼nÃ¼n nasÄ±l atlanmasÄ±na neden olduÄŸunu anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>

int main(void)
{
  int x = 67;

  if(x > 10);
    printf("evet dogru.");
  
}
```

ğŸ‘‡ AÅŸaÄŸÄ±daki program **null statement**'Ä±n yanlÄ±ÅŸ yerde kullanÄ±lmasÄ±ndan kaynaklanan **sÃ¶zdizim hatasÄ±nÄ±(syntax error)** anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>

int main(void)
{
  int x = 67;

  if(x > 10);
    printf("evet dogru.\n");
  else
    printf("hayir yanlis.\n");
  
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki **null statement** kullanÄ±mÄ± bilerek isteyerek kullanÄ±lmÄ±ÅŸtÄ±r, buradaki kullanÄ±m ileriki derslerde anlÄ±ÅŸÄ±lacaktÄ±r.
```C
#include <stdio.h>

int main(void)
{
  int ch;

  while((ch = getchar()) != '\n')
  ; // null statement
}
```

#### Control Flow Statement(AkÄ±ÅŸ Kontrol Deyimi) 

**Control Flow Statement** aÅŸaÄŸÄ±daki Ã¶zelliklere sahiptir;
- Ã–nceden belirlenmiÅŸ bir **sÃ¶zdizimine(syntax)** sahiptirler.
- Bu **sÃ¶zdizim(syntax)** gereÄŸi en az bir **keyword** iÃ§erirler
- AkÄ±ÅŸ biÃ§imini deÄŸiÅŸtirirler.

**Control Flow Statement** tÃ¼rleri aÅŸaÄŸÄ±da listelenmiÅŸtir;
1. if Statement(selection statement)

2. while Statement(Iteration/loop Statement)
3. do while Statement(Iteration/loop Statement)
4. for Statement(Iteration/loop Statement)

5. break Statement(jump statement)
6. continue Statement(jump statement)
7. return Statement(jump statement)

8. switch Statement(selection statement)
9. goto Statement(jump statement)

âš ï¸ C dilinin en Ã§ok yapÄ±lan hatasÄ± ÅŸudur: YazÄ±lan kodun "**Syntax**" olarak geÃ§erli olsa da "**Semantik**" olarak doÄŸru olmayan bir kod yazÄ±labilmesidir, C ve C++ dillerinde diÄŸer dillerde "**Syntax**" hatasÄ± olacak kodlarÄ±n bu dillerde "**Syntax**" hatasÄ± oluÅŸturmamasÄ±ndan kaynaklanmaktadÄ±r.

âš ï¸ KullanÄ±lan terimler standardÄ±n da kullandÄ±ÄŸÄ± terimler ya da gÃ¶zde(popÃ¼ler) terimler olarak ikiye ayrÄ±lÄ±r, "**statement**", "**object**", "**expression**" standardÄ±n kullandÄ±ÄŸÄ± terimlerdir, "**name lookup**" terimi standardÄ±n kullandÄ±ÄŸÄ± bir terim deÄŸildir(ama diÄŸer programlama dillerinde de bir karÅŸÄ±lÄ±ÄŸÄ± vardÄ±r).

Buraya kadar anlatÄ±lanlar C dilini Ã¶ÄŸrenebilmek iÃ§in bilinmesi gereken terminolojiyi Ã¶ÄŸrenebilmek iÃ§in anlatÄ±lmÄ±ÅŸtÄ±r, bir sÃ¼re daha bu anlatÄ±m davamedecektir.


## C dilindeki Object(Nesne) KavramÄ± 

**C dilindeki Object(Nesne)**: C dilinde standard olarak **variable** terimi yerine kullanÄ±lan terim "**object**" terimidir denebilir ama **variable** terimi ilk baÅŸta bir programcÄ±nÄ±n zihninde bir **identifier(ad)** Ã§aÄŸrÄ±Ä±mÄ± yapar ama bir **object** olmasÄ± iÃ§in bir **identifier(ad)** olmasÄ± gerekmiyor(tabi bir **variable** olmasÄ± iÃ§in de bir **identifier(ad)** olmasÄ± gerekmiyor). C dilinde bellekte bir yerde(bir bellek adresinde) yer kaplayan ÅŸeyler **Object(Nesne)** olarak ifade edilmektedir.

â— `*(int *)0X1AC3` bu bir **ifadedir(expression)** ve bu **ifade(expression)** bir **nesneye(object)** karÅŸÄ±lÄ±k gelmektedir ama bu **nesneye(object)** bir **identifier(ad)** ile temsil edilmemektedir. Buradan da ÅŸu anlaÅŸÄ±lmaktadÄ±r "**Bir nesneye(object) bir identifier(ad) ile temsil edilmek zorunda deÄŸildir. DeÄŸerleri tutan varlÄ±klarÄ±n hepsine nesne(object) denmektedir.**".
â— `"5"` buradaki **string literal** ifadesi(expression) bir **object(nesne)**'tir ama bu sonradan Ã¶ÄŸrenilecek. 
â— EÄŸer bir **nesne(object)** varsa C dilinin kurallarÄ±na gÃ¶re onun adresinden bahsedebiliriz ama **nesne(object)** olmayan **ifadelerin(expression)** adreslerinden bahsedemeyiz.


â—â—â— C dilinde bir **nesnenin(object)** hafÄ±zada kapladÄ±ÄŸÄ± yere "**Storage(alan)**" denilmektedir. 

â—â—â— C dilinde bir **nesnenin(object)** hafÄ±zada kapladÄ±ÄŸÄ± yerdeki 0 ve 1'lerin hangi veri tÃ¼rÃ¼ne ait olduÄŸu bilgisini belirtmek iÃ§in **Data Type** terimi kullanÄ±lÄ±yor. **Data Type** bilgisi bir **nesnenin(object)** bellekte kaÃ§ byte yer kaplayacaÄŸÄ± bilgisini belirlemektedir. Fakat **nesnenin(object)** hafÄ±zada kapladÄ±ÄŸÄ± alan sadece deÄŸerini iÃ§eriyor. 


â—â—â— C dilinde bir **nesnenin(object)** olmazsa olmaz Ã¶zelliÄŸi **Data Type** Ã¶zelliÄŸidir ve bu Ã¶zellik ÅŸunlarÄ± belirler; 
1. Nesnenin bellekte kaÃ§ byte yer kaplayacaÄŸÄ±nÄ± belirler.
2. O byte'larda bulunan bitler **nesnenin(object)** deÄŸerinin ne olduÄŸunu ifade eder.
3. O **nesnenin(object)** hangi operatÃ¶r'lerin operandÄ± olabileceÄŸini(hangi iÅŸlemlere girebileceÄŸini) belirler.

â— "**Data Type**" konusu C dili Ã¶ÄŸrenilmeye baÅŸlanacaÄŸÄ± zaman ilk Ã¶ÄŸrenilmesi gereken konudur ve Ã§ok Ã¶nemlidir.


â—â—â— C ve C++ dillerinde bir "**Type System**" var bu sistem iki gruba ayrÄ±lmaktadÄ±r, **Data Type** gruplarÄ± aÅŸaÄŸÄ±daki gibidir; 
1. **Basic Types**: Dil tarafÄ±ndan hazÄ±r olarak sunulan, Ã¶zellikleri dil tarafÄ±ndan belirlenmiÅŸ **Tam sayÄ±(Naturel Number)** ya da **Rasyonel sayÄ±(Rational number)** veri tÃ¼rleridir. **Basic Types** terimi C standardÄ±nÄ±n kullandÄ±ÄŸÄ± terimdir, bu terim baÅŸka yerlerde **Fundamentals Types**, **Build-in Types**, **Default Types**, **Primitive Types** olarak adlandÄ±rÄ±labiliyor, buradaki terimler aynÄ± ÅŸey iÃ§in kullanÄ±lmaktadÄ±r.
2. **User Defined Types**: C dilinde ÅŸu **struct**, **union**, **enum** Ã¼Ã§ farklÄ± **keyword** kullanÄ±larak **User Defined Types** oluÅŸturulabilir, C++ dilinde bunlarÄ±n yanÄ±na "**class**" adÄ±ndaki **keyword** de eklenmektedir. Kursun son Ã§eyreÄŸinde "**User Defined Types**" iÃ§eriÄŸi iÅŸlenecektir.

â— "**int**" tÃ¼rÃ¼ primitive tÃ¼rÃ¼dÃ¼r fakat bu tÃ¼rÃ¼n bellekte kaplayacaÄŸÄ± alanÄ±n deÄŸeri kullanÄ±lan **compiler(derleyici)** belirlemektedir.

â— "**int32_t**" tanÄ±mÄ± her derleyicide 32 bit boyutunda tam sayÄ± tÃ¼rÃ¼nÃ¼ belirtmektedir, bu tanÄ±mlama ile her derleyicinin bu tÃ¼rÃ¼ aynÄ± ÅŸekilde iÅŸlemesi saÄŸlanmÄ±ÅŸ olur. Bu tÃ¼r kullanÄ±mlar "**Type Alias**" olarak adlandÄ±rÄ±lÄ±yor.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.00-12.10 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


>â”
> 
> Sorulan soru;
> 
> Diyelim ki birinin yazdÄ±ÄŸÄ± kodlarÄ± aldÄ±k ve o kiÅŸi int diye tanÄ±mladÄ± ve onun derleyicisini bilmiyoruz ve bizim derleyici yanlÄ±ÅŸ yorumladÄ±ÄŸÄ± iÃ§in yanlÄ±ÅŸ sonuÃ§lar Ã§Ä±karsa o zaman ne yapmamÄ±z lazÄ±m?
> 
> Cevap;
> 
> Derleyicinin yanlÄ±ÅŸ yorumlamasÄ± ÅŸeklinde bir durum doÄŸru deÄŸil.
> Derleyici kodun anlamÄ± neyse ona gÃ¶re kodlarÄ± yorumlayacaktÄ±r.
> Burada asÄ±l sorulmak istenen ÅŸu muhtemelen: "Benim derleyicimde 4 byte olan **int** tÃ¼rÃ¼ baÅŸka bir derleyici de 2 byte olarak yorumlanacaksa bu durumda sorun oluÅŸur mu?"
> Bu sorunun cevabÄ± da ÅŸu olacaktÄ±r: 
> Evet bÃ¶yle bir durumda bazÄ± sorunlar Ã§Ä±kabilir fakat bÃ¶yle durumlarÄ±n oluÅŸabileceÄŸi programÄ±n Ã¼retimi aÅŸamasÄ±nda Ã¶ngÃ¶rÃ¼lÃ¼p kodlar ona gÃ¶re yazÄ±lmalÄ±dÄ±r, her derleyicide **int** tÃ¼rÃ¼nÃ¼n 4 byte olarak yorumlanmasÄ± isteniyorsa o zaman **int** tÃ¼rÃ¼ kullanÄ±lacaÄŸÄ± yerlerde "**int32_t**" "**type alias**" kullanÄ±labilir.


>â”
> 
> SorduÄŸum soru; 
> 
> "Bir nesne(object)'nin bellekte kapladÄ±ÄŸÄ± alan sadece o nesne(object)'nin deÄŸerini iÃ§eriyorsa bellek Byte'larÄ±nda yer alan 0-1 dizisinin hangi tÃ¼re ait olduÄŸu bilgisi tam olarak nerede saklanÄ±yor bunu tam anlamadÄ±m fakat bu detaya ileriki derslerde deÄŸinilecek olabilir?" 
> 
> Cevap;
> 
> Sorunun kÄ±sa cevabÄ±: Bu bilgi **run-time**'da hiÃ§bir yerde saklanmÄ±yor. 
> YazÄ±lmÄ±ÅŸ bir kod derleyici tarafÄ±ndan **assambly** koduna ya da doÄŸrudan **makina koduna** dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼yor, bir kod doÄŸrudan ya da dolaylÄ± olarak makina koduna dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmektedir.
> yazÄ±lmÄ±ÅŸ olan program derleyici tarafÄ±ndan Ã¼zerinde Ã§alÄ±ÅŸacaÄŸÄ± mikroÃ§ip'in makine komutlarÄ±na dÃ¶nÃ¼ÅŸtÃ¼rÃ¼ldÃ¼ÄŸÃ¼nde bir tÃ¼rÃ¼n Ã§alÄ±ÅŸma anÄ±nda hangi tÃ¼r olarak iÅŸleneceÄŸi ve bellekte ne kadar yer kaplayacaÄŸÄ± bilgisi makine komutlarÄ±nda yeralmaktadÄ±r.


â—â—â— Bir **nesnenin(object)** adresinden bahsediliyorsa o **nesnenin(object)** bellekte nerede tutulduÄŸundan bahsediliyordur, bu bilgi Ã¶nemlidir.


## Expression Types(ifade TÃ¼rleri) 

**Ä°fadelerin(expression)** iki Ã¶nemli Ã¶zelliÄŸi var, biri **ifadelerin(expression)** **tÃ¼rÃ¼(type)** diÄŸeri **ifadelerin(expression)** **value category** Ã¶zelliÄŸidir;
1. NasÄ±l **nesnelerin(object)** tÃ¼rleri varsa **expression(ifade)**'larÄ±n da tÃ¼rleri(types) vardÄ±r. `x > 9` ifadecinin tÃ¼rÃ¼ C dilinde **int** ve C++ dilinde tÃ¼rÃ¼ **boolean**. **Expression(ifade)**'larÄ±n tÃ¼rleri(types) o **expression(ifade)**'larla neler yapabileceÄŸimizi ve onlarÄ± yaparken ne olacaÄŸÄ±nÄ± belirliyor.
2. C standardÄ±nda bu ÅŸekilde belirtilmese de C dilinde bir **ifadenin(expression)** **value category** Ã¶zelliÄŸi ya **L value** ya da **R value** deÄŸerlerinden biri olmak zorundadÄ±r.
  1. **L value expression**: Bir ifadenin bir **nesneye(object)** karÅŸÄ±lÄ±k gelmesi anlamÄ±na geliyor. 
  2. **R value expression**: Bir ifadenin bir **nesneye(object)** karÅŸÄ±lÄ±k gelmemesi anlamÄ±na geliyor.

Dilin en zor anlaÅŸÄ±lan kÄ±sÄ±mlarÄ±ndan biri ÅŸudur(bu gÃ¼nkÃ¼ dersin de en Ã¶nemli konusu denilebilir): Her **expression(ifade)** bir **value category**'ye aittir.
Bu kategoriler de **L Value** ve **R Value** olarak ikiye ayrÄ±lÄ±r.
Bir ifadenin **value Category** deÄŸeri ya **L Value** ya da **R Value** olmak zorundadÄ±r aynÄ± anda ikisine de ait olamaz.
Bir ifadenin **value Category** deÄŸeri bilinmiyorsa kodlama hatalarÄ± yapÄ±labilir.


â—â—â— AÅŸaÄŸÄ±daki maddeler Ã¶nemlidir, iyi anlaÅŸÄ±ldÄ±ÄŸÄ±ndan emin ol;
- Bir **ifadenin(expression)** **L Value** olmasÄ± o ifadenin bir **nesne(object)**'ye karÅŸÄ±lÄ±k gelmesi anlamÄ±na geliyor, yani bellekte ayrÄ±lmÄ±ÅŸ bir yerin olmasÄ± anlamÄ±na geliyor.
- Bir **ifadenin(expression)** **R Value** olmasÄ± o ifadenin bir **nesne(object)**'ye karÅŸÄ±lÄ±k gelmemesi anlamÄ±na geliyor.
- DeÄŸiÅŸken(variable) adlarÄ±nÄ±n oluÅŸturduÄŸu **ifadeler(expression)** her zaman **L Value** olacaktÄ±r.
- Aritmetik ya da karÅŸÄ±laÅŸtÄ±rma operatÃ¶rleriyle(operands) oluÅŸturulmuÅŸ **ifadeler(expression)** her zaman **R Value** olacaktÄ±r Ã§Ã¼nkÃ¼ bu ifadeler Ã§alÄ±ÅŸma anÄ±nda bellekte yer kaplamazlar.
- Atama operatÃ¶rÃ¼nÃ¼n sol operandÄ± olabilen bir **ifade(expression)** **L value** olur diyebilir miyiz? -> HayÄ±r bÃ¶yle bir genelleme yapamayÄ±z. Mesela `"string value"` gibi string tÃ¼rÃ¼nden bir **ifade(expression)** atama operatÃ¶rÃ¼nÃ¼n sol operandÄ± olamaz ama bir string tÃ¼rÃ¼ **L value** tÃ¼rÃ¼ndedir. C ile ilgili bazÄ± kaynaklarda ÅŸu ÅŸekilde "_Atama operatÃ¶rÃ¼nÃ¼n sol operandÄ± olan ifadeler L-value Ã¶zelliÄŸindedir._" bir tanÄ±m yapÄ±ldÄ±ÄŸÄ± gÃ¶rÃ¼lebilir ama bu tanÄ±m yanlÄ±ÅŸtÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programdan atama operatÃ¶rÃ¼nÃ¼n sol operandÄ± olamayan ama **L value** kategorisinde olan bir **ifade(expression)** nasÄ±l oluyor incelenebilir.
```C
#include<stdio.h>
#include<stdint.h>

int main(void)
{
  const int x = 8; 

  x = 10; // Buradaki 'x' ifadesi 'L-value' Ã¶zelliktedir ama atama operatÃ¶rÃ¼nÃ¼n sol operandÄ± yapÄ±ldÄ±ÄŸÄ±nda sÃ¶zdizim hatasÄ±(syntax error) oluÅŸmaktadÄ±r.

  "yazi degeri" =  // Buradaki '"yazi degeri"' ifadesi 'L-value' Ã¶zelliktedir ama atama operatÃ¶rÃ¼nÃ¼n sol operandÄ± yapÄ±ldÄ±ÄŸÄ±nda sÃ¶zdizim hatasÄ±(syntax error) oluÅŸmaktadÄ±r.

  int ary[25];
  ary = // Buradaki 'ary' ifadesi 'L-value' Ã¶zelliktedir ama atama operatÃ¶rÃ¼nÃ¼n sol operandÄ± yapÄ±ldÄ±ÄŸÄ±nda sÃ¶zdizim hatasÄ±(syntax error) oluÅŸmaktadÄ±r.
}
```


â—â—â— Adres operatÃ¶rÃ¼nÃ¼n(`&` operatÃ¶rÃ¼) kullanÄ±labildiÄŸi tÃ¼m **ifadeler(expression)** **L-value** Ã¶zellikte olacaktÄ±r diyebiliriz, Ã§Ã¼nkÃ¼ bir **expression(ifade)** ile adres operatÃ¶rÃ¼ kullanÄ±labiliyorsa zaten o ifade bellekte yer kaplÄ±yor demektir.

â—â—â— C ve C++ dillerinde operatÃ¶rlerle, fonksiyonlarla vb. yapÄ±larla ilgili bir Ã§ok kural **ifadelerin(expression)** **Value Category** Ã¶zelliÄŸiyle ilgilidir.


ğŸ‘‡ AÅŸaÄŸÄ±daki program R-value/L-value Ã¶zelliÄŸini anlamak iÃ§in incelenebilir.
```C
#include<stdio.h>
#include<stdint.h>

int main(void)
{
  int x = 8; // Buradaki 'int x = 8' ifadesi 

  x; // Buradaki 'x' ifadesi bellekte yer kaplayan bir nesne olduÄŸu iÃ§in 'L-value' Ã¶zelliktedir.

  x + 6; // Buradaki 'x + 6' ifadesi bellekte yer kaplamayacaktÄ±r ve 'R-value' Ã¶zelliktedir.

  int arrayA[8]; // 'arrayA' ifadesi bir 'int' dizinin tanÄ±mlamasÄ±dÄ±r ve bir dizi 'L-value' Ã¶zelliktedir.
  
  int* ptr = &x; // Bu satÄ±r 'x'in adres operatÃ¶rÃ¼nÃ¼ alabildiÄŸini gÃ¶stermek iÃ§in yazÄ±ldÄ± zaten 'x' 'L-value' Ã¶zelliktedir.
}
```



**Expression(ifade)**'larÄ±n sahip olduÄŸu Ã¼Ã§ Ã¶nemli Ã¶zellik aÅŸaÄŸÄ±daki gibidir;
1. Ä°fadelerin bir **Data Type**'Ä± vardÄ±r(int, double, long, unsigned int vb.)
2. Ä°fadelerin bir **Value Category**'si vardÄ±r(R/L value)
3. Ä°fadelerin bir deÄŸeri vardÄ±r. Programlamayla yeni tanÄ±ÅŸanlar bu cÃ¼mleyi duyunca ÅŸaÅŸÄ±rÄ±yorlarmÄ±ÅŸ.



**Constand(sabit)** ve **Constand Expression(Sabit Ä°fadesi)** terimleri birbirinden farklÄ±dÄ±r.
BazÄ± ifadelerin deÄŸerleri derleme anÄ±nda belli oluyor bu ifadelere **constand expression(sabit ifadesi)** deniliyor.
Bir ifadenin **constand expression(sabit ifadesi)** olup olmadÄ±ÄŸÄ±nÄ± **C dilinin kurallarÄ±(C Draft/Specification)** anlatmaktadÄ±r.

â—â—â— Neden **constand expression(sabit ifadesi)** terimi Ã¶nemlidir: Dilin kurallarÄ± iÃ§inde Ã¶yle yerler var ki o yerlerde **constand expression(sabit ifadesi)** kullanÄ±lmasÄ± gerekiyor, diÄŸer tÃ¼rlÃ¼ hata oluÅŸacaktÄ±r. AÅŸaÄŸÄ±daki C kod alanÄ±nda buradaki durumlar iÃ§in aÃ§Ä±klamalara bakabilirsin.

â—â—â— C dilinde bir **ifade(expression)** ya **sabit ifadesidir(constand expression)** ya da **sabit ifadesi deÄŸildir(non constand expression)**.

ğŸ‘‡ AÅŸaÄŸÄ±daki program **constand expression(sabit ifadesi)** durumunu anlamak iÃ§in incelenebilir.
```C
#include<stdio.h>
#include<stdint.h>

int main(void)
{
  int x = 10; 
  
  10 * 4 + 3; // Buradaki '10 * 4 + 3' expression(ifade) bir constand expression(sabit ifadesi)'dÄ±r.
  x + 9; // Buradaki 'x + 9' expression(ifade) bir constand expression(sabit ifadesi) deÄŸildir.

  int array[x + 20]; // Buradaki 'x + 20' expression(ifade) C dilinde bir constand(sabit) olarak gÃ¶rÃ¼lmemektedir. 'Expression must have a constant value' derleme hatasÄ± oluÅŸacaktÄ±r.
  
  int a = 1, b = 3, c = 6;

  switch(x){
    case a: ; // Buradaki 'case a' expression(ifade) C dilinde bir constand(sabit) olarak gÃ¶rÃ¼lmemektedir. 'Expression must have a constant value' derleme hatasÄ± oluÅŸacaktÄ±r.
    case b: ; // Buradaki 'case b' expression(ifade) C dilinde bir constand(sabit) olarak gÃ¶rÃ¼lmemektedir. 'Expression must have a constant value' derleme hatasÄ± oluÅŸacaktÄ±r.
  }  
}
```

ğŸ‘‡ AÅŸaÄŸÄ±daki program henÃ¼z erken olan ama sorulan bir soru iÃ§in deÄŸinilen C'de **const** iÅŸaretlenen bir deÄŸiÅŸkenin **constand expression(sabit ifadesi)** oluÅŸturmadÄ±ÄŸÄ±nÄ± anlamak iÃ§in incelenebilir ama C++ dilinde tam tersi durum sÃ¶z konusudur.
```C
#include <stdio.h>

int main(void)
{
  const int x = 10;

  int a[x]; // Buradaki kullanÄ±mda C dilinde 'x' ifadesi sabit ifadesi deÄŸildir ve senteks hatasÄ± oluÅŸacaktÄ±r ama C++ dilinde 'x' ifadesi sabit ifadesidir.
}
```

## SayÄ± Sistemleri 

Bu konuyu iyi anlayabilmek iÃ§in matematikteki **Taban AritmetiÄŸi** konusunun iyi bilinmesi gerekmektedir.
Bir sayÄ±nÄ±n **sayÄ± tabanÄ±(base)** ve **sayÄ± basamaÄŸÄ±(digit)** bulunmaktadÄ±r.
Bilgisayar sistemlerinde **ikilik(binary)**, **sekizlik(octal)**, **onluk(decimal)**, **onaltÄ±lÄ±k(hexadecimal)** olarak dÃ¶rt farklÄ± sayÄ± tabanÄ± kullanÄ±lmaktadÄ±r.
**bit** terimi muhtemelen "**Binary digit**" ifadesinin kÄ±saltmasÄ± olarak ortaya Ã§Ä±kmÄ±ÅŸtÄ±r.


Mesela on sayÄ± tabanÄ±nda bir sayÄ± olan "6174" sayÄ±sÄ± on tabanÄ±nda ÅŸu ÅŸekilde gÃ¶sterilir "$6 . 10^3 + 1 . 10^2 + 7 . 10^1 + 4 . 10^0$"


â—â—â— Bir sonraki dersin ikinci saatinden itibaren C dilinin Ã¶ÄŸrenilmesine geÃ§iÅŸ yapÄ±lacak, ÅŸu ana kadar yapÄ±lan derslerin amacÄ± C Ã¶ÄŸrenebilmek iÃ§in bir yazÄ±lÄ±m bilgisi/terminolojisi zemini oluÅŸturmaktÄ±, bu zeminin oluÅŸturulmasÄ± iÃ§in 13 saatlik(aralar dahil) bir zaman harcanmÄ±ÅŸ olacak.


Ders sonu ...
