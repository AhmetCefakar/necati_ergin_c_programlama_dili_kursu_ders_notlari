# 10.Ders 09.02.2025 ğŸ•˜

Derse 17(09:01)-19(09:02)-27(09:10)-30(09:25)-32(09:48)-30(10:04)-31(12:32)-30(12:46) kiÅŸi katÄ±ldÄ±.
---

Kursun baÅŸlarÄ±nda **token(atom)** kavramÄ±ndan bahsedilmiÅŸti, yeniden hatÄ±rlamak iÃ§in token tÃ¼rleri aÅŸaÄŸÄ±daki gibidir;
- Keywords
- Identifiers
- Operators
- Constant
- String literals
- Delimeters

## Operators(OperatÃ¶rler, Ä°ÅŸleÃ§)

OperatÃ¶rler iÅŸlem yaptÄ±ran token'lardÄ±r.

C dilinde 45 tane operatÃ¶r vardÄ±r. C operatÃ¶r yoÄŸun bir dildir. 

âš ï¸ Bu konu baÅŸlangÄ±Ã§ta zorlayÄ±cÄ± olabilir.

C dili gÃ¶rece olarak daha dÃ¼ÅŸÃ¼k seviyeli bir dil olduÄŸu iÃ§in C#, Java gibi dillerde olmayan operatÃ¶rlere sahiptir.

Ä°lk Ã¶nce operatÃ¶r terimleri incelenecek sonra detaylÄ± olarak operatÃ¶rler iÅŸlenecek.


### OperatÃ¶r Terimleri

Bir operatÃ¶rÃ¼n Ã¼zerinde iÅŸlem yaptÄ±ÄŸÄ± ifadelere(expression) operatÃ¶rÃ¼n operandlarÄ± denilmektedir. Mesela `a + b` ifadesinde(expression) "+" operatÃ¶rdÃ¼r, "a" ve "b" operand'dÄ±r.

- BazÄ± operatÃ¶rler tek karakter iÃ§erir: `+`, `-`, `*`, `/` vb.
- BazÄ± operatÃ¶rler iki karakter iÃ§erir: `>=`, `--`, `++` vb.
- BazÄ± operatÃ¶rler Ã¼Ã§ karakter iÃ§erir: `>>=`, `<<=`, vb.
- "**sizeof**" hem bir keyword hem de bir operatÃ¶rdÃ¼r.
- OperatÃ¶rler aldÄ±klarÄ± operand sayÄ±sÄ±na gÃ¶re aÅŸaÄŸÄ±daki ÅŸekilde gruplanÄ±r;
    1. **Unary Operant**: Tek operanda sahip operatÃ¶rler iÃ§in yapÄ±lan tanÄ±mlamadÄ±r.
    2. **Binary Operant**: Ä°ki operanda sahip operatÃ¶rler iÃ§in yapÄ±lan tanÄ±mlamadÄ±r.
    3. **Ternary Operant**: Ä°ki operanda sahip operatÃ¶rler iÃ§in yapÄ±lan tanÄ±mlamadÄ±r. BÃ¶yle tek bir operatÃ¶r vardÄ±r.
- OperatÃ¶rler kullanÄ±ldÄ±ÄŸÄ± konuma gÃ¶re aÅŸaÄŸÄ±daki ÅŸekilde gruplanÄ±r;
    1. Prefix Operands(Ã–n ek operatÃ¶rler) : `++x`, `--y`
    2. Postfix Operands(Son ek operatÃ¶rler) : `x++`, `z--`
    3. Infix Operands(Ara ek operatÃ¶rler) : `x < y`
- OperatÃ¶rler adlandÄ±rÄ±lÄ±rken Ã§oÄŸunlukla operatÃ¶rÃ¼n operand sayÄ±sÄ± ve kullanÄ±ldÄ±ÄŸÄ± konum bilgisi birlikte kullanÄ±larak adlandÄ±rÄ±lÄ±r.
    1. `x = 23` bu ifadedeki(expression) `=` operatÃ¶rÃ¼.
    2. `++x` bu ifadedeki(expression) `++` operatÃ¶rÃ¼ "**Unary Prefix Operand**" olarak adlandÄ±rÄ±lÄ±r.
    3. `x--` bu ifadedeki(expression) `--` operatÃ¶rÃ¼ "**Unary Postfix Operand**" olarak adlandÄ±rÄ±lÄ±r.
- OperatÃ¶rlerin oluÅŸturduÄŸu **expression(ifade)**'larÄ±n  deÄŸerleri vardÄ±r(value).
- OperatÃ¶rlerin oluÅŸturduÄŸu **expression(ifade)**'lar **L value** ya da **R value** olabilir, bunun bilinmesi Ã¶nemlidir!
- Bir operatÃ¶rÃ¼n Ã¼reteceÄŸi deÄŸeri(value) tanÄ±mlamak iÃ§in ÅŸu sÃ¶zcÃ¼kler kullanÄ±labilir;
    1. **Generate**
    2. **Return**(buterim "return statement" ile karÄ±ÅŸtÄ±rÄ±lmamalÄ±dÄ±r!)
    3. **Yield**
- Bir operatÃ¶r **Side Effect(Yan Etki)** sahip olabilir ya da olmayabilir.

`int x = 4; +x;` bu kÄ±sa koddaki `+x` ifadesinin value kategorisi **R-value** durumundadÄ±r ama bir ifadenin value kategori tÃ¼rÃ¼ dilden dile gÃ¶re deÄŸiÅŸebiliyor. 

â— C ve C++ dillerinde tÃ¼rÃ¼ **void** olan ifadeler(expression) dÄ±ÅŸÄ±ntaki tÃ¼m ifadelerin(expression) bir **data type(int, double vb.)** ve **value category(R/L value)** Ã¶zelliÄŸi vardÄ±r.


BazÄ± operatÃ¶rlerin operandlarÄ±nÄ±n **tÃ¼rleri(data type)** konusunda bir kÄ±sÄ±tlama vardÄ±r. Mesela `a % b` ifadesindeki `%` operatÃ¶rÃ¼nÃ¼n operandlarÄ±nÄ±n sadece tam sayÄ± tÃ¼rÃ¼nden olmasÄ±na izin veriliyor. 
BazÄ± operatÃ¶rlerin operandlarÄ±nÄ±n **value category** konusunda bir kÄ±sÄ±tlama vardÄ±r. Mesela `++` operatÃ¶rÃ¼nÃ¼n alacaÄŸÄ± operandÄ±n sadece **L value expression** olmasÄ±na izin veriliyor.

OperatÃ¶rlerin ne olduklarÄ±, nasÄ±l iÅŸlem yaptÄ±klarÄ±, hangi operandlarÄ± alabilecekleri gibi durumlar dilin tasarÄ±mÄ±na ve kurallarÄ±na baÄŸÄ±mlÄ±dÄ±r, bir dilde olan Ã¶zellikler baÅŸka bir dilde olmayabilir.


**Side Effect(Yan Etki)**: Bu tanÄ±m programda bir scope iÃ§erisinde kullanÄ±lmÄ±ÅŸ olan bir deÄŸiÅŸkenin deÄŸerinin deÄŸiÅŸmesine neden olabilecek olan iÅŸlemleri belirtmek iÃ§in kullanÄ±lÄ±yor. Ã‡alÄ±ÅŸan bir programda(Process) **side effect(yan etki)** olmasÄ± demek durum deÄŸiÅŸikliÄŸi olmasÄ± demektir, durum deÄŸiÅŸikli olmasÄ± demek te bir varlÄ±ÄŸÄ±n durum bilgisinin(ya da deÄŸerinin) deÄŸiÅŸmesi demektir. BazÄ± operatÃ¶rlerin **yan etkisi(side effect)** vardÄ±r ama bazÄ± operatÃ¶rlerin yoktur.
- `v1 > v2` buradaki `>` operatÃ¶rÃ¼nÃ¼n **yan etkisi(side effect)** yoktur Ã§Ã¼nkÃ¼ iÅŸlem sonrasÄ±nda "v1" ve "v2" deÄŸiÅŸkenlerinin deÄŸerleri deÄŸiÅŸmiyor.
- `a++` buradaki ``++` operatÃ¶rÃ¼nÃ¼n **yan etkisi(side effect)** vardÄ±r Ã§Ã¼nkÃ¼ "a" deÄŸiÅŸkeninin deÄŸerini deÄŸiÅŸtiriyor.
- `x += 4;` buradaki ifadedeki(expression) `+=` operatÃ¶rÃ¼nÃ¼n **yan etkisi(side effect)** vardÄ±r Ã§Ã¼nkÃ¼ "x" deÄŸiÅŸkeninin deÄŸerini deÄŸiÅŸtiriyor.

DeÄŸiÅŸkenlerdeki(variable) durum(state) deÄŸiÅŸiklikleri deÄŸiÅŸkenlerin deÄŸerlerinin deÄŸiÅŸmesi anlamÄ±na gelmektedir.


### Operator Priority/Precedence(OperatÃ¶r Ã–nceliÄŸi) 

OperatÃ¶r Ã¶nceliÄŸi konusu genellikle yanlÄ±ÅŸ anlaÅŸÄ±lÄ±yormuÅŸ.

Bir ifade iÃ§inde birden fazla operatÃ¶r varsa hangi operatÃ¶rÃ¼n Ã¼rettiÄŸi deÄŸerin hangi operatÃ¶rÃ¼n operandÄ± olacaÄŸÄ±nÄ±n belirlenmesine operatÃ¶r Ã¶nceliÄŸi deneilmektedir.

- `int x = function1() + function2() * 5` ifadesinde derleyicinin "function1" ve "function2" fonksiyonlarÄ±ndan hangisine yapÄ±lacak fonksiyon Ã§aÄŸrÄ±sÄ± makine kodunu Ã¶nce Ã¼reteceÄŸi belli deÄŸildir ve aynÄ± derleyici iÃ§in her derleme iÅŸleminde bu sÄ±ra deÄŸiÅŸe de bilir.
- `x * y - 3` ifadesinde iki tane operatÃ¶r(`*` ve `-`) vardÄ±r ve `*` operatÃ¶rÃ¼ `-` operatÃ¶rÃ¼nden daha Ã¶nceliklidir.


#### OperatÃ¶r Ã¶ncelik tablosu 

C standardÄ±nda operatÃ¶r Ã¶ncelik tablosu yoktur ama bu tablo mantÄ±ken C standardÄ±ndan Ã§Ä±karÄ±labilir. 

Bir Ã§ok kaynakta bu operatÃ¶r sÄ±ralamasÄ±nÄ±n ufak farklÄ± olduÄŸu yerler olabiliyormuÅŸ ama oluÅŸturulan bu tablolarÄ±n yorumlarÄ± aynÄ± olduÄŸu sÃ¼rece sorun olmayacaktÄ±r.

ğŸ§­ Necati Ergin operatÃ¶rleri 15 Ã¶ncelik seviyesine ayÄ±rÄ±yormuÅŸ, bu kategoriler aÅŸaÄŸÄ±da gÃ¶rÃ¼lebilir, bu operatÃ¶rlerin hepsinin Ã§ok iyi bilinmesi gerekiyor;

| Precedence Level | Operators                                          | Associativity      | Description                                                   | 
|:-----------------|:---------------------------------------------------|:------------------:|:--------------------------------------------------------------| 
| 1                | `()` `[]` `.` `->`                                 |   Left-to-right    | function call, array subscript, member access                 | 
| 2                | `+` `-` `++` `--` `(type)` `&` `*` `sizeof` `!` `~`|   Right-to-left    |                                                               | 
| 3                | `*` `/` `%`                                        |   Left-to-right    | Multiplicative operators (multiplication, division, remainder)| 
| 4                | `+` `-`                                            |   Left-to-right    | Additive operators (addition and subtraction)                 | 
| 5                | `>>` `<<`                                          |   Left-to-right    | Bitwise shift operators                                       | 
| 6                | `>` `>=` `<` `<=`                                  |   Left-to-right    | Relational operators                                          |    
| 7                | `==` `!=`                                          |   Left-to-right    | Equality operators                                            | 
| 8                | `&`                                                |   Left-to-right    | Bitwise AND                                                   | 
| 9                | `^`                                                |   Left-to-right    | Bitwise XOR (exclusive OR)                                    | 
| 10               | `\|`                                               |   Left-to-right    | Bitwise OR (inclusive OR)                                     | 
| 11               | `&&`                                               |   Left-to-right    | Logical AND                                                   | 
| 12               | `\|\|`                                             |   Left-to-right    | Logical OR                                                    | 
| 13               | `?:`                                               |   Right-to-left    | Conditional (ternary) operator                                |
| 14               | `=` `+=` `-=` `*=` `/=` `>>=` `<<=` `&=` `^=` `\|=`|   Right-to-left    | Assignment and compound assignment operators                  | 
| 15               | `,`                                                |   Left-to-right    | Comma operator (sequential evaluation)                        |



**Associativity(Ã–ncelik YÃ¶nÃ¼)**: OperatÃ¶rlerle yapÄ±lan iÅŸlemlerde hangi taraftan iÅŸleme baÅŸlanacaÄŸÄ±nÄ± belirtiyor. iki tÃ¼re ayrÄ±lmaktadÄ±r;
- **Left Associativity**  
- **Right Associativity** 


AÅŸaÄŸÄ±da bazÄ± birden fazla operatÃ¶r iÅŸeren ifadelerin iÅŸlem Ã¶nceliklerinin ne olduÄŸu incelenebilir;
- `x % y / a * b` ifadesinde(expression) `*`, `/`, `%` operatÃ¶rleri kullanÄ±lmÄ±ÅŸ ve tabloda 3. seviyededir, bu operatÃ¶rler soldan saÄŸa Ã¶nceliÄŸe sahipler, buna gÃ¶re bu ifade ÅŸu `((x % y) / a) * b` ÅŸeklinde iÅŸlenecektir.
- `!~x++` ifadesinde(expression) `++`, `!`, `~` operatÃ¶rleri kullanÄ±lmÄ±ÅŸ ve tabloda 2. seviyededir, ve bu operatÃ¶rler saÄŸdan sola Ã¶nceliÄŸe sahipler, buna gÃ¶re bu ifade ÅŸeklinde `!(~(x++))` iÅŸlenecektir.


ğŸ§­ KÄ±yaslama yapabilmek iÃ§in internetten elde edilen ayrÄ± bir C'deki operatÃ¶r Ã¶nceliÄŸi tablosu;

| Precedence Level | Operators                                                                              | Associativity  | Description                                                                                |
|:----------------:|:---------------------------------------------------------------------------------------|:--------------:|:------------------------------------------------------------------------------------------:|
| 1                | `()`, `[]`, `.`, `->`, postfix `++`, postfix `--`                                      | Left-to-right  | Primary expressions (function call, array subscript, member access, and postfix inc./dec.) |
| 2                | Prefix `++`, prefix `--`, unary `+`, unary `-`, `!`, `~`, `(type)`, `*`, `&`, `sizeof` | Right-to-left  | Unary operators, type cast, pointer dereference, address-of, and size-of                   |
| 3                | `*`, `/`, `%`                                                                          | Left-to-right  | Multiplicative operators (multiplication, division, remainder)                             |
| 4                | `+`, `-`                                                                               | Left-to-right  | Additive operators (addition and subtraction)                                              |
| 5                | `<<`, `>>`                                                                             | Left-to-right  | Bitwise shift operators                                                                    |
| 6                | `<`, `<=`, `>`, `>=`                                                                   | Left-to-right  | Relational operators                                                                       |
| 7                | `==`, `!=`                                                                             | Left-to-right  | Equality operators                                                                         |
| 8                | `&`                                                                                    | Left-to-right  | Bitwise AND                                                                                |
| 9                | `^`                                                                                    | Left-to-right  | Bitwise XOR (exclusive OR)                                                                 |
| 10               | `\|`                                                                                   | Left-to-right  | Bitwise OR (inclusive OR)                                                                  |
| 11               | `&&`                                                                                   | Left-to-right  | Logical AND                                                                                |
| 12               | `\|\|`                                                                                 | Left-to-right  | Logical OR                                                                                 |
| 13               | `?:`                                                                                   | Right-to-left  | Conditional (ternary) operator                                                             |
| 14               | `=`, `*=`, `/=`, `%=`, `+=`, `-=`, `<<=`, `>>=`, `&=`, `^=`, `\|=`                     | Right-to-left  | Assignment and compound assignment operators                                               |
| 15               | `,`                                                                                    | Left-to-right  | Comma operator (sequential evaluation)                                                     |


â— C programlarÄ±ndaki parantezler kullanÄ±ldÄ±klarÄ± yere gÃ¶re farklÄ± anlamlara gelmektedir.
- Dilin **sÃ¶zdiziminin(syntax)** bir bileÅŸeni olabilir.
- Fonksiyon Ã§aÄŸrÄ± operatÃ¶rÃ¼ olabilir.
- Ã–ncelik parantesi olabilir.


ğŸ‘‡ AÅŸaÄŸÄ±daki program parantezlerin Ã¼Ã§ farklÄ± durumda nasÄ±l kullanÄ±ldÄ±ÄŸÄ± ve ne anlama geldiÄŸi incelenebilir.
```C
int foo() // Buradaki parantezler function definition(tanÄ±m) iÅŸleminde dilin sÃ¶zdiziminin(syntax) bir bileÅŸenidir.
{
    // some code here
}

int main(void)
{
    int x = 3;
    int y = 3 * (x + 7); // Buradaki parantezler Ã¶ncelik parantezidir.

    int z = foo(); // Buradaki parantezler 'function call' operatÃ¶rÃ¼dÃ¼r. 
}
```


>â”
> 
> SorduÄŸum soru;
> 
> OperatÃ¶r Ã¶ncelik tablosunda "+" ve "-" operatÃ¶rleri hem 2. hem de 4. seviyede bulunuyor bunun bir nedeni var mÄ±ydÄ±?
> 
> Cevap;
> 
> BazÄ± operatÃ¶rlerin token'larÄ± aynÄ± olsa da aslÄ±nda baÅŸka operatÃ¶rler olabiliyorlar.
> - **asterisk(*)** token'Ä± operatÃ¶r olarak iki farklÄ± iÅŸlem iÃ§in kullanÄ±labiliyor, `x * y` ifadesindeki operatÃ¶r **multiplication** ve `*ptr` ifadesindeki operatÃ¶r **dereferencing** operatÃ¶rÃ¼dÃ¼r.
> - `+x` ifadesindeki operatÃ¶r **(sign operator +)** ve `a + c` ifadesindeki operatÃ¶r **addition operator**.
> - `-x` ifadesindeki operatÃ¶r **(sign operator -)** ve `x - z` ifadesindeki operatÃ¶r **subtraction operator**.
> - `&x` ifadesindeki operatÃ¶r **(address of operator)** ve `x & z` ifadesindeki operatÃ¶r **bitwise and operator**.
> 
> YukarÄ±da aÃ§Ä±klanan `+ - * &` operatÃ¶rleri aynÄ± token olarak iki farklÄ± operatÃ¶r olarak iÅŸlem gÃ¶rmektedir, derleyici hangi operatÃ¶r olduÄŸunu iÅŸlemin **Unary Operant** ya da **Binary Operant** almasÄ±ndan anlamaktadÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki program C++ dilinde operatÃ¶r olan `or`, `and`, `not`, `bitand`, `bitor` operatÃ¶rlerinin kullanÄ±mÄ± ve bu operatÃ¶rlerin C dilinde olmadÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 5, y = 7;

    // AÅŸaÄŸÄ±daki if'e ait expression bÃ¼nyesindeki 'not' ve 'and' token'larÄ± C dilinde yoktur ama makro olarak varmÄ±ÅŸ gibi kullanÄ±labilir.
    if(not x and y){

    }
}
```


>â”
> 
> Sorulan soru;
>  
> Bol bol parantez kullanmanÄ±n sakÄ±ncasÄ± var mÄ±, bu Ã¶ncelikleri ezberlemektense?
> 
> Cevap;
> 
> OperatÃ¶r Ã¶ncelikleri C kodu yazdÄ±kÃ§a/okudukÃ§a istenmese bile ezberlenecektir.
> Sorunun ikinci kÄ±smÄ± iÃ§in parantezlerin gereksiz yere kullanÄ±lmasÄ± Ã§irkin bir gÃ¶rÃ¼ntÃ¼ oluÅŸturacaktÄ±r.
> Ã–ncelik parantezi kullanÄ±lmasÄ± iÅŸlem hatasÄ±nÄ± Ã¶nlemek iÃ§in(bu duurm operatÃ¶r Ã¶nceliÄŸinin iyi bilinmediÄŸi durumlar iÃ§in geÃ§erlidir) kullanÄ±labilir, hatalÄ± iÅŸlem olacaÄŸÄ±na Ã¶ncelik parantezi kullanÄ±lmasÄ± doÄŸru olur. 
> Ä°ÅŸlem Ã¶ncelik parantezi kullanÄ±lmasÄ± gereken durumlarda kullanÄ±lmalÄ± ama aÅŸÄ±rÄ±ya gidilmeden kullanÄ±lmalÄ±dÄ±r.


### OperatÃ¶r TÃ¼rleri 

ğŸ§­ OperatÃ¶rlerin tÃ¼rleri aÅŸaÄŸÄ±dan incelenebilir;
- Aritmetik operatÃ¶rler 
    `++` `--`
    `+` `-`
    `*` `/` `%`  
- Comparison Operators
    - Relational Operators
        - `>` `>=` `<` `<=` 
    - Equality Operators
        - `==` `!=`
- Logical Operators 
     - `!` `&&` `\|\|`
- Assignment Operators 
    - `=` `+=` `-=` `/=` `>>=` `<<=` `&=` `^=` `|=`
- Comma Operator
    - `,`
- Pointer Operators(Adreslerle ilgili operatÃ¶rler)
    - `&` `*` `[]` `->`
- Bitwise Operators(Bitsel OperatÃ¶rler)[Kursun 3. Ã§eyreÄŸinde incelenecek]: Tam sayÄ±larÄ±n bitleri Ã¼zerinde iÅŸlem yapan operatÃ¶rlerdir.
    - `<<` `>>` `&` `\|` `^`


## Idiom/Pattern(Dile Ã–zgÃ¼ YapÄ±lar) 

**Idiom(dile baÄŸlÄ±)**/**Idiomatik**: Bu terimler dile baÄŸlÄ± olan bazÄ± yapÄ±larÄ±/kullanÄ±mlarÄ±/durumlarÄ± belirtmek iÃ§in kullanÄ±lÄ±r. 
C ve C++ dillerinde profesyonel seviyede bir kod yazÄ±lÄ±p yazÄ±lmadÄ±ÄŸÄ±nÄ± kodda kullanÄ±lan **Idiom/Idiomatic** yapÄ±lara bakÄ±larak anlaÅŸÄ±labilir.

**Pattern(Ã–rÃ¼ntÃ¼, Desen, KalÄ±p)**: Bu terim diller Ã¼zerinde olan bazÄ± yapÄ±larÄ±/kullanÄ±mlarÄ±/durumlarÄ± belirtmek iÃ§in kullanÄ±lÄ±r.
Mesela **singleton** terimi herhangi bir dilde uygulanabilecek bir desendir.

ğŸ‘‡ AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ kullanÄ±mlarÄ± C dilinde Ã§ok kullanÄ±lan idiomatic yapÄ±lardandÄ±r.
```C
// 'n kez dÃ¶nen bir dÃ¶ngÃ¼'
while(n--){
    // do somethings
}

while(*p1++ = *p2++);
```

>â”
>
> Sorulan soru;
> 
> OperatÃ¶rlerin anlami ve Ã¶nceligi c++ ile ne kadar benzer %?
>
> Cevap;
> 
> C ile C++ operatÃ¶rleri bÃ¼yÃ¼k Ã¶lÃ§Ã¼de benzerdir sadece bazÄ± durumlarda birbirinden ayrÄ±lmaktadÄ±r.
> BazÄ± operatÃ¶rlerin oluÅŸturacaÄŸÄ± deÄŸerler farklÄ± olabiliyor. `a > b` expression deÄŸeri C'de "int" tÃ¼rÃ¼dÃ¼r ve C++ dilinde "bool" tÃ¼rÃ¼dÃ¼r.
> BazÄ± operatÃ¶rlerle oluÅŸturulan ifadelerin(expression) **R/L value category** deÄŸerleri farklÄ±dÄ±r. Mesela `++x` C'de "R value" ama C++'ta "L value" olmaktadÄ±r.
> C dilindeki operatÃ¶rlerin hepsi C++ dilinde vardÄ±r fakat C++ dilindeki operatÃ¶r sayÄ±sÄ± C dilindekinden daha fazladÄ±r. Mesela `::`, `typeid`, `static_cast` sadece C++ dilinde olan operatÃ¶rlerdir.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.35-10.55 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


## OperatÃ¶rlerin DetaylÄ± Ä°ncelenmesi


### `+`(addition) and `-`(subtraction) Operands(Toplama/Ã‡Ä±kartma OperatÃ¶rleri) 

Bu operatÃ¶rler **Binary Infix** Ã¶zelliÄŸindedir yani iki operand alÄ±r ve operandlarÄ±n arasÄ±nda yer alÄ±r. 

Bu operatÃ¶rlerin **side effect** Ã¶zelliÄŸi yoktur.

â— Bu operatÃ¶rler ile yapÄ±lan iÅŸaretli tam sayÄ±lardaki toplama/Ã§Ä±karma iÅŸlemlerindeki iÅŸaretli tam sayÄ±larda taÅŸma durumu dilin standardÄ± tarafÄ±ndan **ub(undefined behavior)** olarak tanÄ±mlanmÄ±ÅŸtÄ±r.

â— **ub(undefined behavior)** durumlarÄ±nda programÄ±n Ã§alÄ±ÅŸma zamanÄ±nda nasÄ±l bir sonuÃ§ Ã¼retileceÄŸi belirsizdir, **ub** durumlarÄ±nda 


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `+(addition)` ve `-(subtraction)` operatÃ¶rlerin kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x, y;

    printf("iki tam sayi giriniz: ");
    scanf("%d%d", x, y);

    printf("%d + %d = %d", x, y, x + y);
    printf("%d - %d = %d", x, y, x - y);
    

    // AÅŸaÄŸÄ±daki statement yazÄ±lsa da yazÄ±lmasa da C99 standardÄ±ndan sonraki standartlarda aÅŸaÄŸÄ±daki statement derleyici tarafÄ±ndan programÄ±n main fonksiyonunun sonuna eklenmektedir.
    // return 0;
}
```


â—â—â— TanÄ±msÄ±z davranÄ±ÅŸa neden olan durumlar rastgele sayÄ± Ã¼retiminde kullanÄ±lmamaktadÄ±r ve kullanÄ±lamaz da, hatta "**ub**" durumlarÄ± hhiÃ§ bir yerde kullanÄ±lmamalÄ±dÄ±r yoksa beklenmedik bir anda programÄ±n Ã§alÄ±ÅŸan hali olan process(es) Ã§Ã¶kebilir.


>â”
> 
> Sorulan soru;
> 
> Tam sayÄ±larda toplama/Ã§Ä±karma neden **ub** oluyor? SonuÃ§ta taÅŸtÄ±ktan sonra ne deÄŸer alacaÄŸÄ± belli deÄŸil mi?
> 
> Cevap;
> 
> Bu sorunun cevabÄ± buraya sÄ±ÄŸmayacak kadar bÃ¼yÃ¼ktÃ¼r ama aÅŸaÄŸÄ±daki gibi kÄ±saca cevap verilebilir;
> Ä°lk olarak C dilinde neyin **ub** olup olmayacaÄŸÄ±nÄ± dilin standardÄ± belirler.   
> Ä°kinci olarak iÅŸaretli tam sayÄ±lardaki iÅŸlemlerde taÅŸma olduÄŸunda Ã¼retilecek deÄŸerin ne olacaÄŸÄ± belirsizdir(iÅŸlemcinin o andaki durumuna gÃ¶re sonuÃ§ deÄŸiÅŸebilir) 



> â”
> 
> Sorulan soru;
> 
> AklÄ±ma bir soru takÄ±ldÄ± operatÃ¶rler ile ilgili unsigned int x = -12; Bu hatalÄ± bir ifade midir?
> 
> Cevap;
> 
> Bu gÃ¼zel bir soru ama bu dersin konusu deÄŸil, bazÄ± sorulara ekenden cevap verilirse kursa katÄ±lanlarÄ±n akÄ±llarÄ± karÄ±ÅŸÄ±r.
> ğŸ‘‡ AÅŸaÄŸÄ±daki programda C dilinde sÄ±k kullanÄ±lan bir **idiomatic** yazÄ± incelenebilir. 
> ```C
> #define _CRT_SECURE_NO_WARNINGS
> 
> #include <stdio.h>
> 
> int main(void)
> {
>     unsigned int x = -1; // bu tanÄ±mlama **ub** deÄŸildir, buradaki kod ile 'x' deÄŸiÅŸkeni alabileceÄŸi en bÃ¼yÃ¼k deÄŸeri alÄ±r ve bu kullanÄ±m C dilinin bir 'idiomatic' kullanÄ±mÄ±dÄ±r.
> 
>     printf("x = %u", x);
> }
> ```


### `+`(sign operator plus) and `-`(sign operator minus) Operands(`+` ve `-` Ä°ÅŸaret OperatÃ¶rleri) 


Bu operatÃ¶rler **Unary Prefix** Ã¶zelliÄŸindedir yani tek operand alÄ±r ve operandÄ±n Ã¶nÃ¼nde yer alÄ±r.

Bu operatÃ¶rler C ve C++ dillerinde **R value** Ã¶zelliÄŸinde operatÃ¶rlerdir, kullanÄ±ldÄ±klarÄ± operandÄ± **R value** yaparlar.
- `-54` ifadesinde(expression) bir sabit(constant) vardÄ±r ve bu sabit(constant) `54`tÃ¼r, buradaki `-` sadece iÅŸaret operandÄ± durumundadÄ±r.
- `+x` ifadesi **L value** olan ifadeyi **R value** olarak deÄŸiÅŸtirir yani `x` tek baÅŸÄ±na **L value** Ã¶zelliktedir fakat `+x` **R value** Ã¶zelliktedir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iÅŸaret operatÃ¶rlerinin kullanÄ±lmasÄ± 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 5;
    int y = 9;
    
    y = -x - y; // Buradaki ifadede(expression) hem Ã§Ä±karma operatÃ¶rÃ¼ hem de eksi iÅŸareti birlikte kullanÄ±lmÄ±ÅŸtÄ±r.
    
    char c1 = 64;
    char c2 = 9;

    c; // Buradaki ifadenin tÃ¼rÃ¼ 'char'

    +c; // Buradaki ifadenin tÃ¼rÃ¼ 'int'. Burada 'Integral Promotion' vardÄ±r.
    
    c1 + c2; // Buradaki ifadenin tÃ¼rÃ¼ 'int' Ã§Ã¼nkÃ¼ 'char' tÃ¼rleriyle toplama iÅŸlemi yapÄ±lmadan Ã¶nce bu tÃ¼rlerin deÄŸerleri 'int' tÃ¼rÃ¼ne yÃ¼kseltiliyor(Integral Promotion)
    
    return 0;
}
```



ğŸ§  **Integral Promotion(Tam SayÄ±ya YÃ¼kseltme)**: int tÃ¼rÃ¼nden daha kÃ¼Ã§Ã¼k **rank(veri tÃ¼rÃ¼nÃ¼n boyutu denilebilir)**'teki ifadeler(expression) bir operatÃ¶rÃ¼n operandÄ± olduÄŸunda Ã¶rtÃ¼lÃ¼ olarak **int** tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r. [Ä°lerisinin konusuymuÅŸ ama kÄ±saca bahsediliyor] 


â— Ä°ÅŸaret operatÃ¶rleri aÅŸaÄŸÄ±daki iki durum iÃ§in kullanÄ±lmaktadÄ±r;
1. L-value bir ifadeyi(expression) R-value bir ifadeye(expression) dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in kullanÄ±lÄ±r.
2. **Integral Promotion(Tam SayÄ±ya YÃ¼kseltme)** kuralÄ±ndan yararlanmak iÃ§in kullanÄ±lÄ±r.


>â”
> 
> Sorulan soru;
> 
> Bir de +x kullanÄ±m olarak. x in -5 olduÄŸu durumda -1 ile Ã§arpÄ±p, x in  +5 olasÄ±nÄ± saÄŸlamÄ±yor mu? KullanÄ±m olarak.
> 
> Cevap;
> 
> Burada sorulan soru yanlÄ±ÅŸ. FÄ±rÃ§aaaaaa :)


### `*` `/` `%` Multiplicative Operators 


Bu operatÃ¶rler **Binary Infix** Ã¶zelliÄŸindedir yani iki operand alÄ±r ve operand'larÄ±n arasÄ±nda yer alÄ±r.

Bu operatÃ¶rlerin **side effect** Ã¶zelliÄŸi yoktur.

Bu operatÃ¶rler iÃ§indeki `%` mod alma operatÃ¶rÃ¼nÃ¼n alabileceÄŸi operand'larÄ±n tÃ¼rÃ¼ sadece tam sayÄ± tÃ¼rÃ¼ olmak zorundadÄ±r, diÄŸer tÃ¼rlÃ¼ **sÃ¶zdizim hatasÄ±(syntax error)** oluÅŸacaktÄ±r(derleme zamanÄ± hatasÄ± oluÅŸur).

1. `*` operatÃ¶rÃ¼ tÄ±pkÄ± toplama operatÃ¶rÃ¼nde olduÄŸu gibi iÅŸaretli tam sayÄ± tÃ¼rlerinde oluÅŸacak taÅŸma durumu tanÄ±msÄ±z davranÄ±ÅŸ olacaktÄ±r.
2. `/` operatÃ¶rÃ¼ operandlar tam sayÄ± tÃ¼rÃ¼ndense bÃ¶lme iÅŸleminin sonucu da tam sayÄ± tÃ¼rÃ¼nden olacaktÄ±r, bu iÅŸlem yapÄ±lÄ±rken oluÅŸan kÃ¼sÃ¼rrat kÄ±smÄ± atÄ±lmaktadÄ±r.
3. `/` ve `%` operatÃ¶rlerinin saÄŸ operandÄ±nÄ±n tam sayÄ± tÃ¼rÃ¼nde `0` deÄŸerine sahip olmasÄ± **ub(undefined Behavior)** olmaktadÄ±r. Burada saÄŸ oerant tÃ¼rÃ¼ **floating point** ve deÄŸeri 0 olmasÄ± durumunda doÄŸrudan **ub** kabul edilmiyor, bu konuya ileride deÄŸinilecek.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda girilen deÄŸerler iÃ§in `* / %` iÅŸlemleri yapÄ±ldÄ±ÄŸÄ±nda Ã¼retilen sonuÃ§lar incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x, y;  
    
    printf("iki sayi giriniz: ");
    scanf("%d%d", &x, &y);
    
    printf("%d * %d = %d\n", x, y, x * y);
    printf("%d / %d = %d\n", x, y, x / y);
    printf("%d %% %d = %d\n", x, y, x % y);
    
    return 0;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda mod doperatÃ¶rÃ¼nÃ¼n(`%`) kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int hour;  
    int n;  

    printf("saat kac: ");
    scanf("%d", &hour);
    
    printf("kac saat sonra: ");
    scanf("%d", &n);

    printf("saat %d ve %d saat sonra saat %d olacak\n", hour, n, (hour + n) % 12);

    return 0;
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã¶ncelikleri aynÄ± olan soldan saÄŸa doÄŸru Ã§alÄ±ÅŸtÄ±rÄ±lacak olan operatÃ¶rlerde Ã¶ncelik parantezi kullanÄ±p kullanmamanÄ±n bir deÄŸiÅŸiklik yapmadÄ±ÄŸÄ± durum belirtilmiÅŸtir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x;

    printf("dÃ¶rt basamakli bir sayi giriniz: \n");
    scanf("%d", &x);
    
    printf("%d sayisinin binler basamagi '%d'.\n", x, x / 1000);
    printf("%d sayisinin yÃ¼zler basamagi '%d'.\n", x, x / 100 % 10);
    printf("%d sayisinin yÃ¼zler basamagi '%d'.\n", x, (x % 1000) / 100);
    printf("%d sayisinin yÃ¼zler basamagi '%d'.\n", x, x % 1000 / 100);
    printf("%d sayisinin onlar basamagi '%d'.\n",  x, x / 10 % 10);
    printf("%d sayisinin onlar basamagi '%d'.\n",  x, (x % 100) / 10);
    printf("%d sayisinin onlar basamagi '%d'.\n",  x, x % 100 / 10);
    printf("%d sayisinin birler basamagi '%d'.\n", x, x % 10);
    
    return 0;
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda mod alma iÅŸleminin C99 ve sonrasÄ± standartlarda Ã§alÄ±ÅŸÄ±ldÄ±ÄŸÄ±nda nasÄ±l olduÄŸu incelenebilir.
Mod alma iÅŸleminin iÅŸareti ilk operandÄ±n iÅŸareti olarak kabul edilir, buna gÃ¶rÃ¼ kodun Ã§Ä±ktÄ±sÄ± "**1 -1 -1**" olacaktÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    printf("%d\n", 5 % -2); // 1 Ã§Ä±ktÄ±sÄ± Ã¼retilir
    printf("%d\n", -5 % 2); // -1 Ã§Ä±ktÄ±sÄ± Ã¼retilir
    printf("%d\n", -5 % -2); // -1 Ã§Ä±ktÄ±sÄ± Ã¼retilir
    
    return 0;
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda girilen sayÄ± "2368" ise "8632", "1000" ise "1", "1020" ise "201" vb. ÅŸekilde yazacaktÄ±r.
ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã¶nemli olan nokta Ã¶ncelik parantezi kullanÄ±lmasa bile C dilinin standardÄ±nda belirtilen kurallardan dolayÄ± operatÃ¶r Ã¶nceliÄŸinin Ã§alÄ±ÅŸma sÄ±rasÄ± C dilinin tÃ¼m derleyicilerinde aynÄ± olacaktÄ±r.
ğŸ‘‡ AÅŸaÄŸÄ±daki programda gÃ¶rsel olarak karmaÅŸÄ±k durmaktadÄ±r bu nedenle parantez kullanÄ±lmasÄ± doÄŸru olacaktÄ±r, bu misal operatÃ¶r Ã¶nceliÄŸini incelemek iÃ§in bu ÅŸekilde yazÄ±lmÄ±ÅŸtÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x;
    
    printf("dÃ¶rt basamakli bir sayi giriniz: \n");
    scanf("%d", &x);

    printf("%d sayisinin basamaksal tersi %d\n", x,  x % 10 * 1000 + x % 100 / 10 * 100 + x % 1000 / 100 * 10 + x / 1000 );
    
    return 0;
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.00-12.12 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


### `++`(increment) and `--`(decrement) Operands


Bu operatÃ¶rler standart dÄ±ÅŸÄ± olarak "++(plus plus)", "--(minus minus)" olarak adlandÄ±rÄ±labiliyormuÅŸ.

Bu operatÃ¶rlerin operand'Ä± "**L-value**" olmak zorundadÄ±r. 

Bu operatÃ¶rler **side effect** oluÅŸturur.

ğŸš€ C++ dilinin adÄ±nÄ±n sonundaki "++" karakterleri increment operatÃ¶rÃ¼nden gelmektedir.

Bu iki operatÃ¶rÃ¼n tek tek iki farklÄ± kullanÄ±mÄ± vardÄ±r, bunlar;
1. Prefix increment operator  : `++ x`
2. Postfix increment operator : `x ++`
3. Prefix decrement operator  : `-- x`
4. Postfix decrement operator : `x --`


ğŸ‘‡ AÅŸaÄŸÄ±daki programda increment/decrement operatÃ¶rlerinin sadece L-value operand alabileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 6;

    // ++(x + 5); // Bu kullanÄ±m '(x + 5)' ifadesi R-value olduÄŸu iÃ§in 'sÃ¶zdizim hatasÄ±(syntax error)' oluÅŸturacaktÄ±r.

    // ++23; // Bu kullanÄ±m '23' ifadesi R-value olduÄŸu iÃ§in 'sÃ¶zdizim hatasÄ±(syntax error)' oluÅŸturacaktÄ±r.

    // -- +x; // Bu kullanÄ±m '+x' ifadesi R-value olduÄŸu iÃ§in 'sÃ¶zdizim hatasÄ±(syntax error)' oluÅŸturacaktÄ±r.
}
```

â— increment/decrement operatÃ¶rlerinin Ã¼rettiÄŸi deÄŸer ile **side effect** Ã¶zelliklerini birbirine karÄ±ÅŸtÄ±rmamak gerekiyor, aÅŸaÄŸÄ±daki ufak programlar bu durumu incelemek iÃ§in yazÄ±lmÄ±ÅŸtÄ±r.

ğŸ‘‡ AÅŸaÄŸÄ±daki program `++x`, `x++`, `x = x + 1`, `x += 1` ifadelerinin hepsinin aynÄ± **side effect** oluÅŸturacaÄŸÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 6;
    
    printf("x = %d\n", x);

    ++x;
    printf("x = %d\n", x);

    x++;
    printf("x = %d\n", x);
    
    x = x + 1;
    printf("x = %d\n", x);

    x += 1;
    printf("x = %d\n", x);
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda temel seviyede increment/decrement operatÃ¶rlerinin nasÄ±l operand deÄŸerlerini deÄŸiÅŸtirdiÄŸini anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 5;
    int y = 9;

    // foo(++x); // Burada 'foo' fonksiyonuna argÃ¼man olarak '6' deÄŸeri gÃ¶nderilir.
    // bar(x++); // Burada 'bar' fonksiyonuna argÃ¼man olarak '5' deÄŸeri gÃ¶nderilir.
    
    int z = ++x + ++y; // Burada 'z' deÄŸeri '16' olacaktÄ±r.
    
    printf("x = %d\n", x); // Konsola 'x = 6' yazar
    printf("y = %d\n", y); // Konsola 'y = 10' yazar
}
```



â— OperatÃ¶rÃ¼n Ã¼rettiÄŸi deÄŸer baÅŸka bir kavram, operatÃ¶rÃ¼n operandÄ± Ã¼zerinde oluÅŸturduÄŸu **yan etki(side effect)** baÅŸka bir kavtamdÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda operatÃ¶rÃ¼n increment/decrement operatÃ¶rlerinin **yan etkileri(side effect)** incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 5;
    int y = 9;

    // x++; // Buradaki `x++` ifadesinin deÄŸeri '5'tir
    // y--; // Buradaki `x++` ifadesinin deÄŸeri '9'dur
    
    int z = --y + x++; // Burada 'z' deÄŸiÅŸkeninin deÄŸeri '13' olacaktÄ±r.

    printf("x = %d\n", x); // Konsola 'x = 6' yazar. 
    printf("y = %d\n", y); // Konsola 'y = 8' yazar.
    printf("z = %d\n", z); // Konsola 'z = 13' yazar.
}
```


â— EÄŸer increment/decrement operatÃ¶rlerinin Ã¼rettiÄŸi deÄŸer kullanÄ±lmÄ±yorsa bu operatÃ¶rlerin Ã¶n-ek ya da son-ek olarak kullanÄ±lmasÄ± arasÄ±nda bir fark yoktur.

â— EÄŸer increment/decrement operatÃ¶rlerinin Ã¼rettiÄŸi deÄŸer kullanÄ±lÄ±yorsa bu operatÃ¶rlerin Ã¶n-ek ya da son-ek olarak kullanÄ±lmasÄ± arasÄ±nda tamamen fark olurdu.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 8;
    int y = 8;

    if(x++ > y){ // Burada eÅŸitlik '9 > 9'olacaktÄ±r ve '0' deÄŸer oluÅŸup 'if' kÄ±smÄ±na girilmeyip 'else' kÄ±smÄ±na girilecektir
        print("dogru");
    }
    else{
        print("yanlis");
    }
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki program incelendiÄŸinde .1 kullanÄ±mlar ile .2 kullanÄ±mlar aynÄ± iÅŸi yapmaktadÄ±r.
C programcÄ±larÄ± buradaki gibi durumlarda .2 kullanÄ±mlarÄ± tercih eder ve bu kullanÄ±mlar C dilinde **idiomatic** yapÄ±dadÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 8;
    int y = 8;

    // 1.1 kullanÄ±m
    x = y;
    y = y +1;
    
    // 1.2 kullanÄ±m
    x = y++;


    // some code here

    int a = 7;
    
    // 2.1 kullanÄ±m
    foo(a);
    a = a + 1;

    // 2.2 kullanÄ±m
    foo(a++);


    // some code here

    int i = 0;

    // 3.1 kullanÄ±m
    while(i < 10){
        a[i] = b[k];
        i = i + 1;
        k = k + 1;
    }
    
    // 3.2 kullanÄ±m
    while(i < 10){
        a[i++] = b[k++];
    }
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda 1. ve 2. kullanÄ±mlardaki ÅŸartlar sayÄ±nÄ±n tek olma durumunu kontrol eder. 
Burada ÅŸu Ã¶nemli: AÅŸaÄŸÄ±daki hangi kullanÄ±m tercih edilirse edilsin derleyicinin optimization modÃ¼lÃ¼ en maliyetsiz kullanÄ±ma kodu Ã§evirecektir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 84705347;

    // 1. kullanÄ±m
    //if(x % 2 != 0){ printf("dogru"); }

    // 2. kullanÄ±m
    //if(x & 1){ printf("dogru"); }
}
```


ğŸ§  **volatile** keyword kullanÄ±lmasÄ±nÄ±n nedeni: Bu anahtar sÃ¶zcÃ¼k derleyiciye bir deÄŸerin program dÄ±ÅŸÄ±ndan da deÄŸiÅŸtirilebileceÄŸini bildirmek iÃ§in kullanÄ±lÄ±r.

ğŸ§  Bir deÄŸiÅŸken **volatile** keyword ile iÅŸaretlendiÄŸinde derleyici bu deÄŸiÅŸkenin kullanÄ±ldÄ±ÄŸÄ± yerlerdeki iyileÅŸtirmeleri(optimization) Ã§ok kÄ±sÄ±tlÄ± olarak yapabilir.

ğŸ§  `volatile int x = 12313;` gibi bir kodlamada 'x' deÄŸerinin program Ã§alÄ±ÅŸÄ±rken herhangi bir anda dÄ±ÅŸarÄ±dan deÄŸiÅŸtirilebileceÄŸini belirtir.


ğŸ‘‡ AÅŸaÄŸÄ±daki program Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda ekrana alt alta '5 7 7 9' yazar.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 5;

    printf("%d\n", x++);
    printf("%d\n", ++x);
    printf("%d\n", x++);
    printf("%d\n", ++x);

    return 0;
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki program Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda ekrana alt alta '1 0 1' yazar.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 9;
    int y = 3;

    printf("%d\n", ++x % y++); // '1' yazar
    printf("%d\n", x++ % ++y); // '0' yazar
    printf("%d\n", x % y); // '1' yazar
}
```


Ders sonu ...
