# 49.Ders 12.07.2025 🕘

Derse 11(09:01)-12(09:06)-13(09:11)-14(09:19)-14(09:29)-16(09:33)-15(10:22)-14(10:51)-14(11:1)-14(12:16)-14(12:59) kişi katıldı.
---

## Bağlı Listeler Veri Yapısı Devam (Linklist Data Structure) 🌟


❗❗❗ Bir algoritmanın karmaşıklığı, üzerinde işlem yapılan verinin büyüklüğüyle de ilişkilidir. </br>
Bir algoritmanın karmaşıklığı o algoritmanın işlem maliyeti hakkında fikir verse de üzerinde işlem yapılan verinin büyüklüğü de çalışmas süresini etkileyecektir. </br>
Yani düşük sayıdaki veri üzerinde çalışacak olan algoritmalar, algoritmik karmaşıklıklarından beklendiği gibi performanslı çalışmayabilir. </br>
Mesela az sayıdaki elemanı sıralamak için $O(n^2)$ karmaşıklığındaki bir algoritma $O(n)$ karmaşıklığındaki algoritmadan daha hızlı çalışabilir, bunun temel nedeni $O(n)$ karaşıklığındaki algoritmanın kendi kodundan üretilecek olan makine kodlarının işlem sayısının fazlalığı olduğu bilinmelidir.

❗❗❗ Bazı durumlarda(yazılımın üzerinde çalışacağı donanım vb.) $O(n)$ karmaşıklığında ama **linked list** kullanılan bir algoritma yerine $O(n^2)$ karmaşıklığında **dynamik array** kullanılan bir algoritmanın seçilmesi gerekebilir. </br>
Aynı işi farklı karmaşıklıkta yapan iki algoritma yazıldıktan sonra hangisini kullanmanın ilgili durumda daha doğru olduğunu anlamak için **Benchmarker** ya da **Profiler** denilen programları kullanmak gerekebilir. </br>
Dinamik dizide öğelerin bellekte ardışık olması, dinamik dizide veri yapısının **cache friendly** olması(yani işlemcilerin önbellek mekanizmasına daha iyi uyum sağlaması), dinamik dizi veri yapısında modern işlemcilerde bulunan **SIMD(Single Instruction, Multiple Data)** komutlarının kullanılabilmesi algoritmanın daha yüksek karmaşıklığına karşın yine de dinamik dizi veri yapısının daha performanslı olmasını sağlayabilir. </br>
Bu durumda programlamayla yeni karşılaşanlar ya da pek bilgi sahibi olmayanlar "_Ne önemi kaldı ki algoritma karmaşıklığının_" diyebiliyorlar, algoritmik karmaşıklığın fayda sağlayabilmesi için üzerinde işlem yapılan öğe yasının belirli belirli bir miktarı geçmesi gerekecektir.



❗❗❗ **Dynamic array** ve **Linked list** arasındaki farklar aşağıdaki gibidir;
1. İndeksini bildiğimiz elemana erişim;
    - **Dynamic array**     $O(1)$
    - **Linked list**       $O(n)$
2. Değer ile erişim 
    - **Dynamic array**     $O(n)$
    - **Linked list**       $O(n)$
3. Ekleme işlemleri
    - **Dynamic array** yalnızca sondan ekleme yapılırsa $O(1)$, sondan olmayan bir konumdan ekleme $O(n)$
    - **Linked list** konumu bilinen bir yerden ekleme işlemi $O(1)$ karmaşıklıkta.
4. Silme işlemleri
    - **Dynamic array** yalnızca sondan silme yapılırsa $O(1)$, sondan olmayan bir konumdan silme $O(n)$
    - **Linked list** konumu bilinen bir yerden silme işlemi $O(1)$ karmaşıklıkta.


### Bağlı Listelerin Olabilecek Yararları 

Herhangi bir konumdan ekleme ve silme işlemlerinin **constan-time($O(1)$)** olması. </br>
**Fragmentation** durumana karşı dirençli olması. </br>
**Değiş tokuş(swap)** işlemlerinin yapılmasının kolay olması(sadece pointer değişikliğiyle bu sağlanabildiği için) </br>
**Splice** işlemlerinde hızlıdır(pointer değişikleri üzerinden işlem yapıldığı için).

📌 Neden veri yapısı kullanıyoruz diye düşünülürse, o veri yapısını üzerinde belirli algoritmaların çalıştırılması ve işlemler yapılması için algoritma kullanırız.


Bazı algoritmelar **değiş tokuş(swap)** işlemleri yaparlar;
- Sorting algorithms
- Merge algorithms
- Pertition
- Unique
- Reverse



Dinamik dizilerde **takas(swap)** işlemleri verilerin bellek bloklarının kopyalanmasını gerektirir. </br>
Bağlı listelerde **takas(swap)** işlemleri verinin kopyalanması yerine veriyi tutan düğüm içindeki göstericilerin kopyalanması ile yapılır.



C++ standardında **Splice** olarak adlandırılan aynı türden veri yapılarındaki öğelerden birinin bir veri yapısından çıkartılıp diğer veri yapısına eklenmesi işlemine verilen addır. 

C dilinin standardında sadece **static array** veri yapısı desteği vardır, diğer temel veri yapılarına destek bulunmamaktadır, diğer veri yapılarını kullanabilmek için ya kendimiz yazacağız ya da üçüncü taraf bir kütüphaneyi kullanmamız gerekecektir.


Yazılım mülakatlarında programlama dilinden bağımsız olarak temel veri yapılarının **gerçekleştiriminin(implementetion)** yapılması istenebilir.


## `personlist` Modülünün Gerçekleştirimi 

Person nesneleri bir veri yapısında tutalım. </br>
Bütün ekleme işlemleri baştan ve bütün silme işlemleri yine baştan yapılacak.


✍️ Burada `personlist` adındaki kendi modülümüzün başlık dosyasını aşağıdaki gibi yazıyoruz.
```C
// Yazılan 'personlist.h' dosyasına eklenenler.

#ifndef PERSONLIST_H
#define PERSONLIST_H

#include "person.h" 

struct Person;

// 'get_first' fonksiyonu kendisine geçilen 'Person' türünden göstericiye listedeki ilk nesnenin adresini atar.
void get_first(Person*);

void push_front(const Person*);
void pop_front(void);
int get_list_size(void);
int is_empty(void);
void make_empty(void);
void print_list(void);

#endif
```


👇 Aşağıdaki programda ilk sınama programı görülebilir, `person` listesine n tane person ekleyelim, ve `printlist` fonksiyonuyla eklenen öğeleri yazdıralım.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "personlist.h"
#include "nutility.h"

int main(void)
{
    int n;

    printf("listeye kaç kişi eklenecek: ");
    scanf("%d", &n);

    randomize();
    Person per;

    for(int i = 0; i < n; ++i){
        set_random_person(&per);
        print_person(&per);
        push_front(&per);
    }

    printf("listede %d kisi var\n", get_list_size());
    print_list();

    make_emptt();
    printf("listede %d kisi var\n", get_list_size());
    print_list();
}
```



👇 Aşağıdaki programda ikinci sınama programı görülebilir, `person` listesine n tane person ekleyelim, ve `printlist` fonksiyonuyla eklenen öğeleri yazdıralım.
```C
#include <stdio.h>
#include <time.h>
#include "personlist.h"
#include "nutility.h"

int main(void)
{
    int n;

    printf("listeye kaç kişi eklenecek: ");
    scanf("%d", &n);

    randomize();
    Person per;

    printf("ekleme islemi basladi.\n");
    clock_t start = clock();

    for(int i = 0; i < n; ++i){
        set_random_person(&per);
        print_person(&per);
        push_front(&per);
    }

    clock_t end = clock();
    printf("ekleme islemi bitti %f saniye\n", (double)(end - start) / CLOCK_PER_SEC);
    (void)getchar(); // Program burada kullanıcıdan bir tuşa basması beklenilerek durduruluyor.

    printf("listede %d kisi var\n", get_list_size());
    print_list();

    make_emptt();
}
```


👇 Aşağıda üçüncü sınama programı görülebilir, `person` listesine n tane person ekleyelim, ve `printlist` fonksiyonuyla eklenen öğeleri yazdıralım.
```C
#include <stdio.h>
#include <time.h>
#include "personlist.h"
#include "nutility.h"

int main(void)
{
    randomize();
    
    int n = rand() % 10 + 10;

    Person per;

    for(int i = 0; i < n; ++i){
        set_random_person(&per);
        push_front(&per);
    }

    while(!is_empty()){
        printf("listede %d kisi var.\n", get_list_size());
        print_list();
        pop_front();
        (void)getchar(); // Program burada kullanıcıdan bir tuşa basması beklenilerek durduruluyor.
    }
}
```



✍️ Burada `personlist` adındaki kendi modülümüzün kaynak dosyasını aşağıdaki gibi yazıyoruz.
```C
// Yazılan 'personlist.c' dosyasına eklenenler.

#include <stddef.h>
#include <stdlib.h>
#include "person.h"
#include "personlist.h"


typedef struct Node {
    Person per;
    struct Node* pnext;
} Node; 

// 'static' olarak bildirilen yapı üyeleri kaynak dosya dışından erişime kapatılmıştır.

static Node* gphead = NULL; // Listedeki ilk düğümün adres değerini tutacak olan global değişken tanımı.
static int gcount = 0; // Veri yapısındaki eleman sayısı tutacak olan global değişken tanımı.

static Node* create_node(void)
{
    Node* p = (Node*)malloc(sizeof(Node));
    if(!p){
        printf("cannot allocate memory!\n");
        exit(EXIT_FAILURE);
    }

    return p;
}

int is_empty()
{
    return gcount == 0;
    // return gphead == NULL;
    // return !gphead;
}

int get_list_size(void)
{
    return gcount;
}

void printf_list(void)
{
    // İlk düğümden başlanılarak gösterici 'NULL pointer' olana kadar tüm düğümler gezilip 'print_person' fonksiyonu kullanılarak yazdırılıyor.
    for(Node* p = gphead; p != NULL; p = p->pnext){
        print_person(&p->per);
    }

    printf("~~~~~~~~~~~~~~~~");
}

void get_fist(Person* p)
{
    if(is_empty()){
        printf("bos liste hatasi.\n");
        exit(EXIT_FAILURE);
    }

    *p = gphead->per;
}

// Listenin başına eleman ekleme işlemini yapan fonksiyon.
void push_front(const Person* p)
{
    Node* pnewnode = create_node();
    pnewnode->per = *p;
    pnewnode->pnext = gphead;
    gphead = pnewnode;

    ++gcount;
}

void pop_front(void)
{
    if(is_empty()){
        printf("bos listeden pop hatasi.\n");
        exit(EXIT_FAILURE);
    }

    Node* ptemp = gphead;
    gphead = gphead->pnext;

    free(ptemp); // Silinen düğüm nesnesinin bellek alanı iade ediliyor.
    --gcount;
}

void make_empty(void)
{
    while(!is_empty())
        pop_front();
}
```



👇 Aşağıda dördüncü sınama programı görülebilir, `person` listesine n tane person ekleyelim, ve `printlist` fonksiyonuyla eklenen öğeleri yazdıralım ama bu defa standart olmayan `system` fonksiyonu ile konsolu temizleyelim.
```C
#include <stdio.h>
#include <time.h>
#include "personlist.h"
#include "nutility.h"

int main(void)
{
    randomize();
    
    int n = rand() % 10 + 10;

    Person per;

    for(int i = 0; i < n; ++i){
        set_random_person(&per);
        push_front(&per);
    }

    while(!is_empty()){
        printf("listede %d kisi var.\n", get_list_size());
        print_list();
        pop_front();
        (void)getchar(); // Program burada kullanıcıdan bir tuşa basması beklenilerek durduruluyor.
        system("cls"); // Burada konsoldaki karakterlerin hepsi siliniyor, 
    }
}
```


👆 Yukarıda yazılan sınama kodlarını çalıştırıp incelemelisin, yoksa liste yapısını incelemek için yazılmış olan kodları anlayamazsın.


***
==================================================

✦✦✦✦✦ 10.35-10.51 birinci ara verildi. ✦✦✦✦✦

==================================================
***


👆 Yukarıda yazdığımız `personlist` adındaki modül bu haliyle sadece tek bir **Signly Linked List(Tekli Bağlı Liste)** kullanımına izin vermektedir, bu modül ile birbirinden ayrı olarak iki ayrı **Signly Linked List(Tekli Bağlı Liste)** nesneler oluşturamayız.


## Handle Tekniği


C kütüphanelerinin büyük çoğunluğunda **handle tekniği** kullanılıyor, bu başlık altında **handle tekniği** nedir, neden önemli, nasıl kullanılır bu tekniği inceleyeceğiz. </br>
**Handle tekniği** temelde oluşturulacak bir yapı nesnesinin belleğe alınması ve bellekten silinmesi işlemlerini yönetmek için iki ayrı fonksiyon kullanılması tekniğidir. C++, C#, Java gibi dillerde olan **class(sınıf)** aracındaki **constructor** ve **deconstructor** fonksiyonları **handle tekniğinin** ileri bir kullanımı olarak düşünülebilir. </br>
C++ dilinde bulunan C dilindeki **struct(yapı)** aracından daha fazla özelliğe sahip olan **class(sınıf)** aracı bulunuyor, sınıfların **constructor** ve **deconstructor** adında özel üye fonksiyonları bulunuyor, bu fonksiyonlar **class(sınıf)** türünden nesneleri belleğe çıkarmak ve bellekten silmek için kullanılmaktadır.


Yukarıda yazdığımız `personlist` modülü sadece tek bir **instance** oluşturulabilecek durumda ama aynı anda birden fazla `personlist` türünden farklı **instance** oluşturulabilmesi kullanışlılık açısından önemlidir, bunun için **Handle Tekniğini** kullanacağız. Bu başlığın anlaşılması çok önemli.



📌 Öyle bir gerçekleştirim yapalım ki müşteri kodlar diledikleri zaman diledikleri kadar `Person` türünden liste oluşturabilsinler.



**Cleanup Code**: **Handle tekniği** ile oluşturulan kütüphenelerde kullanıcı kodun ilgili kütüpheneden ürettiği neslelerle işi bittiğinde sistemden alınan kaynakların iade edilmesi gerekiyor, işte bu kaynak iade işlemini yapacak kodlara "**cleanup Code**" deniliyor. **Handle tekniğinde** bu işlemi **deconstructor** durumundaki fonksiyondur.

Kullanıcı(client) kodların **handle tekniği** ile oluşturulan yapı nesneleri ile işi bittikten sonra alınan bellek alanlarının iade edilmesi, açılan dosyaların kapatılması vb. işlemlerini yapmak gerekiyor. 

❗❗❗ **Handle tekniğinde** iki tane önemli fonksiyon var, bunlar;
- Nesneyi oluşturmak için kullanılan fonksiyon(bu fonksiyonun yaptığını C dilini temel alan OOP dillerinde yapan **constructor** olarak nitelenen fonksiyonu bulunmaktadır)
- Nesneyle işlemler bittikten sonra kullanılan kaynakları iade etmek için kullanılan fonksiyon(bu fonksiyonun yaptığını C dilini temel alan OOP dillerinde yapan **deconstructor** olarak nitelenen fonksiyonu bulunmaktadır)


❗❗❗ **Handle tekniğinde** bulunan iki tane önemli fonksiyonun adlandırılmasında uyulan yaklaşımlar aşağıdaki gibidir;
- Baştatıcı fonksiyona içinde **create** geçen ad vermek ve sonlandıran fonksiyona içinde **destroy** geçen ad vermek.
- Baştatıcı fonksiyona içinde **open** geçen ad vermek ve sonlandıran fonksiyona içinde **close** geçen ad vermek.



❗❗❗ Linux/Unix sistem programlama tarafında nerdeyse bütün sistem **handle tekniği** üzerine kuruludur.


👇 Aşağıdaki programdan, sonraki derslerde göreceğimiz dosya işlemlerinin yapılmasını sağlayan kütüphane modülünde **handle tekniği** kullanıldığı incelenebilir.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include "personlist.h"
#include "nutility.h"

int main(void)
{
    File* f = fopen("filex.txt", "w"); // Dosya işleminin yapılmasını sağlayan nesnenin adresini almak için 'fopen' fonksiyonu kullanılıyor.
    
    fprint(f, "naber");

    fclose(f); // Dosya işleminin yapılmasını sağlayan nesne ile yapılan işlemler bittikten sonra kaynakları iade etmek içins 'fclose' fonksiyonu kullanılıyor.
}
```


✍️ Burada `personlist` adındaki kendi modülümüzün başlık dosyasını yeniden **handle tekniği** ile yazıyoruz.
```C
// Yazılan 'personlist.h' dosyasına eklenenler.

#ifndef PERSONLIST_H
#define PERSONLIST_H

#include "person.h" 

struct Person;

// 'get_first' fonksiyonu kendisine geçilen 'Person' türünden göstericiye listedeki ilk nesnenin adresini atar.
void get_first(Person*);

typedef struct List List; // Burada 'struct List' türü 'incomplate type' durumundadır ve bu nedenle 'person.h' arayüzünü kullanacak kullanıcı kodlar 'struct List' türünün öğelerini bilmediği için kullanamaz.
typedef struct List* ListHandle;

ListHandle create_list(void);
void destroy_list(ListHandle);

// Tüm fonksiyonların ilk parametreleri 'ListHandle' tür eş adı olacak biçimde güncelleme yapıyoruz, bu yöntemle modülümüz birden fazla farklı tekli bağlı listeye hizmet verebilece hale geliyor.
void get_first(ListHandle, const Person*);
void push_front(ListHandle, const Person*);
void pop_front(ListHandle);
int get_list_size(ListHandle);
int is_empty(ListHandle);
void make_empty(ListHandle);
void print_list(ListHandle);

#endif
```



✍️ Burada `personlist` adındaki kendi modülümüzün kaynak dosyasını yeniden **handle tekniğini** ile yazıyoruz.
```C
// Yazılan 'personlist.c' dosyasına eklenenler.

#include <stddef.h>
#include <stdlib.h>
#include "person.h"
#include "personlist.h"


typedef struct Node {
    Person per;
    struct Node* pnext;
} Node; 


// Birden fazla farklı liste oluşturulabilmesi için eklenen modül öğesi, herbir liste nesnesini ayırabilmek için 'gphead' ve 'gcount' değişkenleri bir yapıda toplandı. 
struct List {
    Node* gphead; // Listedeki ilk düğümün adres değerini tutacak olan global değişken tanımı.
    int gcount; // Veri yapısındaki eleman sayısı tutacak olan global değişken tanımı.
};


// 'personlist' modülünü kullanırken nesne oluşturmak için kullanılacak olan kurucu fonksiyon.
ListHandle create_list(void)
{
    ListHandle h = (ListHandle)malloc(sizeof(struct List));
    if(!h)
        return NULL;

    h->gphead = NULL;
    h->gcount = 0;

    return h;
}


static Node* create_node(void)
{
    Node* p = (Node*)malloc(sizeof(Node));
    if(!p){
        printf("cannot allocate memory!\n");
        exit(EXIT_FAILURE);
    }

    return p;
}


int is_empty(ListHandle h)
{
    return h->gcount == 0;
    // return h->gphead == NULL;
    // return !h->gphead;
}


int get_list_size(ListHandle h)
{
    return h->gcount;
}


void printf_list(ListHandle h)
{
    // İlk düğümden başlanılarak gösterici 'NULL pointer' olana kadar tüm düğümler gezilip 'print_person' fonksiyonu kullanılarak yazdırılıyor.
    for(Node* p = h->gphead; p != NULL; p = p->pnext){
        print_person(&p->per);
    }

    printf("~~~~~~~~~~~~~~~~");
}


void get_fist(ListHandle h, Person* p)
{
    if(is_empty(h)){
        printf("bos liste hatasi.\n");
        exit(EXIT_FAILURE);
    }

    *p = h->gphead->per;
}


// Listenin başına eleman ekleme işlemini yapan fonksiyon.
void push_front(ListHandle h, const Person* p)
{
    Node* pnewnode = create_node();
    pnewnode->per = *p;
    pnewnode->pnext = h->gphead;
    h->gphead = pnewnode;

    ++h->gcount;
}


void pop_front(ListHandle h)
{
    if(is_empty(h)){
        printf("bos listeden pop hatasi.\n");
        exit(EXIT_FAILURE);
    }

    Node* ptemp = h->gphead;
    h->gphead = h->gphead->pnext;

    free(ptemp); // Silinen düğüm nesnesinin bellek alanı iade ediliyor.
    --h->gcount;
}


void make_empty(ListHandle h)
{
    while(!is_empty(h))
        pop_front(h);
}

void destroy_list(ListHandle h)
{
    make_empty(h);
    free(h);
}
```



👇 Aşağıdaki programda en son **handle tekniğine** göre oluşturduğumuz `personlist` kütüphane modülümüzü sınama işlemleri incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "person.h"
#include "personlist.h"

void bar(void)
{
    printf("bar cagirildi.\n");
    printf("Person listesi oluşturuluyor.\n");

    ListHandle h = create_list();
    Person p;
    
    for(int i = 0; i < 5; ++i){
        set_random_person(&p);
        push_front(h, &p);
    }

    printf("var'daki listede %d kisi var.\n", get_list_size(h));
    print_list(h);
    destroy_list(h);
    printf("bar sona erdi.\n");
    (void) getchar();
}


void foo(void)
{
    printf("foo cagirildi.\n");
    printf("Person listesi oluşturuluyor.\n");

    ListHandle h = create_list();
    Person p;
    
    for(int i = 0; i < 5; ++i){
        set_random_person(&p);
        push_front(h, &p);
    }
    bar();

    printf("foo 'daki listede %d kisi var.\n", get_list_size(h));
    print_list(h);
    destroy_list(h);
    printf("foo sona erdi.\n");
    (void) getchar();
}


int main(void)
{
    printf("main cagirildi.\n");
    printf("Person listesi oluşturuluyor.\n");

    ListHandle h = create_list();
    Person p;
    
    for(int i = 0; i < 16; ++i){
        set_random_person(&p);
        push_front(h, &p);
    }

    foo();

    printf("main'deki listede %d kisi var.\n", get_list_size(h));
    print_list(h);
    destroy_list(h);
    printf("bar sona erdi.\n");
    (void) getchar();
}
```



👇 Aşağıdaki programda 1000 tane liste nesnesinin nasıl oluşturulup kullanıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "person.h"
#include "personlist.h"


#define SIZE 1000

int main(void)
{
    ListHandle handles[SIZE];

    randomize();

    for(int i = 0; SIZE; ++i){
        handles[i] = create_list();
    }

    // Her listeye 5-25 arasında Perfon nesnesi ekleyelim.
    Person per;

    for(int i = 0; SIZE; ++i){
        int n = rand() % 20 + 5;
        while(n--){
            set_random_person(&per);
            pust_front(handles[i], &per);
        }
    }

    for(int i = 0; SIZE; ++i){
        print("%d. listede %d kisi var.\n ", i + 1, get_list_size(handles[i]));
        print_list(handles[i]);
        (void) getchar();
        ststem("cls"); // Ekran siliniyor.
    }

    // Momoer leak oluşmaması için bellek kaynağı iade ediliyor.
    for(int i = 0; SIZE; ++i){
        destroy_list(handles[i]);
    }
}
```



❗❗❗ Bir yapının elemanlarını gizlemek için en sık kullanılan yöntemlerden biri başlık dosyasında ilgili değişkenlerin **incomplate type** yapılmasıdır.


👇 Aşağıdaki programda `ListHandle` türünün `personlist.h` başlık dosyasında **incomplate type** durumda olmasından kaynaklı alınacak sözdizim hatası incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "person.h"
#include "personlist.h"

int main(void)
{
    ListHandle h = create_list();

    h->gpfirst(); // Burada sözdizimi hatası alınacaktır çünkü 'incomplate type' bir nesneye erişilmeye çalışılıyor.
}
```


***
==================================================

✦✦✦✦✦ 11.53-12.00 ikinci ara verildi. ✦✦✦✦✦

==================================================
***


## Alignment(Hizalama)

Değişkenler oluşturulduğunda, derleyiciyi bu değişkenlere bellekten yer ayarlar ve derleyicinin değişkenlere ayırdığı yerin adresleri var, derleyici hansi sistem(donanım + varsa işletim sistemi) için derleyici ise o sistemin gereklerine uygun biçimde bellekten yer ayarlamaktadır. </br>
Her derleyici derlediği kaynak dosyadaki değişkenlerin bellekteki adreslerinin ne olacağına derleme işlemini yaptığı sistemin kurallarına göre belirlemektedir.



❗❗❗
**Alignment Requirement(Hizalama gereksinimleri)**: Derleyicilerin sistemin gereklerine göre kaynak dosyalardaki değişkenlerin bellekte bulunacağı adreslerin ne olacağına(başlangış adresi) karar verirken, bazı değişkenleri herhangi bir adrese, bazı değişkenleri sadece ikinin katı olan adreslere, bazı değişkenleri sadece dördün katı olan adreslere, bazı değişkenleri sadece sekizin katı olan adreslere vb. yerleştirmesi durumuna verilen addır.

Bazı durumlarda **alignment requirement(hizalama gereksinimleri)** kurallarına uyulması donanımsal zorunluluktan dolayı mecburidir, bazı donanımlarda belirli değişkenlerin belirli bir belleğe yerleştirilmesi gerekiyor, aksi halde çalışma zamanında işlemcide hata oluşacaktır. </br>
Bazı durumlarda **alignment requirement(hizalama gereksinimleri)** kurallarına uyulması donanımsal zorunluluk olmamakla birlikte derlenmiş kodun donanım üzerinde yavaş çalışmasına neden olabilir.


Bütün sistemlerde **alignment requirement(hizalama gereksinimleri)** var ama kurallar sistemden sisteme farklıdır, mesela `int` türünün 2'nin katı olan yoksa 4'ün katı olan bir belleğe yerleştirilmesinin gerekmesi durumu sistemden sisteme değişebilir.



**Absract Binary Interface**: **Alignment requirement(hizalama gereksinimleri)** kurallarının dokümente edildiği yerdir. Her bir derleyicinin üzerinde çalışacağı sisteme(donanım + varsa işletim sistemi) özel olarak ayrı ayrı **absract binary interface** dokümanı mevcuttur.


Mesela Microsoft C derleyicisinde `int` türü için **Alignment Requirement** 4'ün katları olan bellek alanlarına yerleştirilmektedir.


C99 standardından önce **alignment requirement(hizalama gereksinimleri)** değerini elde etmenin standart bir yolu yoktu, C99 standardıyla dile eklenen bir operatör ile bir türün **alignment requirement(hizalama gereksinimleri)** değerinin ne olduğu öğrenilebiliyor.

`_Alignof` ve `_Alignas` operatörleri C99 standardıyla dile eklenmiştir. Ayrıca `stdalign.h` başlık dosyasında `_Alignof` operatörü için `alignof` ve `_Alignas` operatörü için `aligas` tür eş adı bulunmaktadır, `sizeof` operatörü gibi bu operatörler de derleme zamanı operatörleridir.




👇 Aşağıdaki programda `alignof` kullanımı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdalign.h>
#include <stdio.h>

int main(void)
{
    printf("%zu\n", alignof(int));
    printf("%zu\n", alignof(double));
    printf("%zu\n", alignof(char));
}
```



👇 Aşağıdaki programda `int` türünün göstericisinin adres değerini bir tam sayı türünden değişkende veri kaybı olmaksızın tutmak için C99 ile dile eklenen `uintptr_t` tür eş adının kullanılabileceği görülebilir.
```C
#include <stdio.h>
#include <stdint.h> // uintptr_t için eklendi.

int main(void)
{
    int x  = 30;
    int* ptr = &x;

    printf("%p\n", ptr); // 'ptr' pointer değişkenin değeri olan adres standart çıktı akımına gönderiliyor.
    printf("Adress in decimal: %ju\n", (uintmax_t)(uintptr_t)ptr); // 'ptr' pointer değişkenin adres değerini tam sayı türünden kayıpsız biçimde elde edebilmek için ilk önce 'uintptr_t' türüne çevriliyor, ardından 'uintmax_t' tür eş adı sistemdeki tam sayı türlerinden en büyüğünü temsil etmektedir.

    double dval  = 232.534;
    printf("Adress in decimal: %ju\n", (uintmax_t)(uintptr_t)&dval); // 'dval' değişkeninin adresini tam sayı türünden kayıpsız biçimde elde edebilmek için ilk önce 'uintptr_t' türüne çevriliyor, ardından 'uintmax_t' tür eş adı sistemdeki tam sayı türlerinden en büyüğünü temsil etmektedir.
}
```



👇 Aşağıdaki programda `double` ve `long double` türlerinin **alignment requirement(hizalama gereksinimleri)** değerlerinin ne olduğu incelenebilir.
```C
#include <stdio.h>
#include <stdint.h> // uintptr_t için eklendi.
#include <stdalign.h>

int main(void)
{
    printf("%zu\n", alignof(double));
    printf("%zu\n", alignof(long double));
}
```



👇 Aşağıdaki programda `Nec` adındaki yapı türünün **alignment requirement(hizalama gereksinimleri)** değerlerinin ne olduğu incelenebilir.
```C
#include <stdio.h>
#include <stdint.h>
#include <stdalign.h>

typedef struct {
    int x, y;
    double d;
    short s;
} Nec;


int main(void)
{
    printf("%zu\n", alignof(Nec)); // 'Nec' yapısının 'alignment requirement' değeri standart çıktı akımına gönderiliyor.
}
```



❗❗❗ Yapı türlerinin **alignment requirement(hizalama gereksinimleri)** değerleri, yapının öğesi olan en büyük **alignment requirement(hizalama gereksinimleri)** değerlerine sahip olan türün **alignment requirement(hizalama gereksinimleri)** değerleridir.



**Alignment Requirement** neden ilgilendiriyor;
- Yapı türlerinin bellekte hangi adreslere konumlandırılabileceği bilgisi açısından bizi ilgilendiriyor. 
- Bazı işlemcilerde bazı işlemci komutlarından yararlanabilmek için sıradan bir türün **alignment requirement(hizalama gereksinimleri)** değerlerinin üzerinde bir **alignment requirement(hizalama gereksinimleri)** değerlerinin kullanılması gerekiyor, mesela programın üzerinde çalışacağı bir işlemcide olan **SIMD(Single Instruction Multiple Data)** komutlarından yararlanabilmek için **alignment requirement(hizalama gereksinimleri)** değerlerinin en az 8 olması gerekebilir. Bu kullanım bu kursun kapsamını biraz aşmaktadır, daha derin bilgi için ayrıca araştırabilirsin.


**Padding Bytes or Hole Bytes**: **alignment requirement(hizalama gereksinimleri)** değerlerinden dolayı bellekte tutulan veri türlerinin bellekte hizalanmasında aralarda bırakılan kullanılmayan boş byte değerleridir.



❗❗❗ 👇 Aşağıdaki programda farklı yapı türlerinin bellekte ne kadar yer kaplayacakları görülebilir. </br> 
Bu programı anlamak bu dersin en önemlim noktalarından biridir.
```C
#include <stdio.h>
#include <stdint.h>
#include <stdalign.h>

// 'Nec1' türünden bir yapı nesnesi, sistemde int türü 4 byte ise, bellekte 12 byte yer kaplayacaktır.
typedef struct {
    char c1;
    int i;
    char c2;
} Nec1;


// 'Nec2' türünden bir yapı nesnesi, sistemde int türü 4 byte ise, bellekte 8 byte yer kaplayacaktır.
typedef struct {
    char c1;
    char c2;
    int i;
} Nec2;


// 'Nec3' türünden bir yapı nesnesi, sistemde int türü 4 byte ise, bellekte 8 byte yer kaplayacaktır.
typedef struct {
    char c1;
    char c2;
    char c3;
    int i;
} Nec3;


// 'Nec4' türünden bir yapı nesnesi, sistemde int türü 4 byte ise, bellekte 8 byte yer kaplayacaktır.
typedef struct {
    char c1;
    char c2;
    char c3;
    char c4;
    int i;
} Nec4;


// 'Nec5' türünden bir yapı nesnesi, sistemde int türü 4 byte ise, bellekte 12 byte yer kaplayacaktır.
typedef struct {
    char c1;
    int i;
    char c2;
    char c3;
    char c4;
    char c5;
} Nec5;


// 'Nec6' türünden bir yapı nesnesi, sistemde int türü 4 byte ise, bellekte 12 byte yer kaplayacaktır.
typedef struct {
    char c1;
    char c2;
    int i;
    char c3;
    char c4;
} Nec6;


// 'Nec7' türünden bir yapı nesnesi, sistemde int türü 4 byte ise, bellekte 28 byte yer kaplayacaktır.
typedef struct {
    char c1;
    int i1;
    char c2;
    int i2;
    char c3;
    int i3;
    char c4;
} Nec7;


int main(void)
{
    printf("sizeof(Nec1) = %zu\n", sizeof(Nec1));
    printf("sizeof(Nec2) = %zu\n", sizeof(Nec2));
    printf("sizeof(Nec3) = %zu\n", sizeof(Nec3));
    printf("sizeof(Nec4) = %zu\n", sizeof(Nec4));
    printf("sizeof(Nec5) = %zu\n", sizeof(Nec5));
    printf("sizeof(Nec6) = %zu\n", sizeof(Nec6));
    printf("sizeof(Nec7) = %zu\n", sizeof(Nec7));
}
```


❗❗❗ 👆 Yukarıdaki program detaylı bir biçimde incelenirse, o programdan şu sonuca varılacaktır: Bir yapı türünün öğeleri **alignment requirement(hizalama gereksinimleri)** değerlerleri göz önüne alınarak sıralanırsa o yapın nesnesinin bellekte kaplayacağı alan ve o yapı nesnesinin bellek alanındaki **Padding Bytes** o kadar az olacaktır.


⚠️⚠️⚠️ Bazı derleyiciler **compiler switch** ayarları ile ya da `#pragma` makrolar ile değişkenlerin **alignment requirement(hizalama gereksinimleri)** değerlerini dikkate almaması sağlanabiliyor, ama bu duruma programın üzerinde koşacağı donanımın izin veriyor olması gerekir ve programın da bu duruma göre yazılmış olması gerekir.



👇 Aşağıdaki programda Microsoft C derleyicisinde `#pragma` kullanımı ile derleye değişkenlerin **alignment requirement(hizalama gereksinimleri)** değerlerini dikkate almadan belleğe çıkartması söylenebileceği incelenebilir.
```C
#include <stdio.h>
#include <stdint.h>
#include <stdalign.h>

#pragma pack(1) // Microsoft C derleyicisinde geçerli

typedef struct {
    char c1;
    int i;
    char c2;
} Nec;


int main(void)
{
    printf("sizeof(Nec) = %zu\n", sizeof(Nec));
}
```



❗❗❗ C dilinin standardı bir yapı türünden bir yapı nesnesinin ilk elemanının adresi ile yapı nesnesinin kendi adresinin(sayısal olarak) aynı olacağını belirtir, yani bir yapı nesnesinin ilk öğesinin adresinin yapı türüne tür dönüşümü yapılması kullanılan bir yöntemdir.



👇 Aşağıdaki programda `#pragma pack(1)` makrosunun kullanımı ile **Padding Bytes** oluşmadan makine kodu üretileceği incelenebilir.
```C
#include <stdio.h>
#include <stdint.h>
#include <stdalign.h>

#pragma pack(1) // Microsoft C derleyicisinde geçerli

typedef struct {
    int x, y;
    double z;
} Nec;


int main(void)
{
    Nec nec1 = { 4, 6, 4.2342 };
    printf("%d\n", *(int)&nec1);
}
```



👇 Aşağıdaki programda `#pragma pack(1)` makrosunun kullanımı ile **Padding Bytes** oluşmadan makine kodu üretileceği incelenebilir.
```C
#include <stdio.h>
#include <stdint.h>
#include <stdalign.h>

#pragma pack(1) // Microsoft C derleyicisinde geçerli

typedef struct {
    double z;
    int x, y;
} Nec;


int main(void)
{
    Nec nec1 = { 6.2761, 4, 6 };
    printf("%f\n", *(double*)&nec1);
}
```


❗❗❗ 👆 Yukarıdaki iki programdan anlaşılabileceği gibi bir yapı nesnesinin başına **Padding Bytes** bulunmaz.

 
> ❔ 
> 
> Sorulan soru;
> 
> Ayni sekilde alignmenti 4 olan bir nec nesnesini dinamik olarak yaratirken derleyici baslangic adresini 4'e bölünencek sekilde secer diyebilir miyiz?
> 
> Cevap;
> 
> Evet.



### **Padding Bytes** Bizi Neden İlgilendiriyor 

**Padding Bytes** bilgisinin ne anlama geldiği aşağıda maddeler haline dizilenmiştir, inceleyebilirsin;

1. Bir Yapı nesnesinin bir elemanının adresinden haraketle bir başka elemanına erişirken **pedding byte** durumundaki byte'lar dikkate alınmak zorundadır. Özellikle gömülü sistem programlama tarafında bu durum dikkate alınmadığı için sık hata yapılmaktadır.

    
    👇 Aşağıdaki program bir yapı nesnesinin ilk değişkeninden haraketle **pedding byte** durumundaki byte'ların dikkate alındığı ve alınmadığı durumda ne olacağını anlamak için incelenebilir.
    ```C
    #include <stdio.h>
    #include <stdint.h>
    #include <stdalign.h>

    typedef struct {
        char c1;
        int ival;
        char c2;
    } Nec;

    int main(void)
    {
        Nec nec1 = { 1, 3, 5 };
        char * p1 = &nec1.c1;

        printf("%d\n", *(int*)(p1 + 1)); // Buradaki pointer ariptmetiği 'pedding bytes' durumundan dolayı 'ub' durumuna neden olacaktır.
        printf("%d\n", *(int*)(p1 + 4)); // 'pedding bytes' değerleri atlanarak yapı nesnesinin 'int' türünden olan 'ival' değişkenine erişiliyor.
    }
    ```

    
    ❗❗❗ Standart `offsetof` fonksiyonel makrosu C mülakatlarında sıklıkla sorulmaktadır. 

2. Bir Yapı türünden oluşturulacak olan nesnelerin bellek boyutunun hesaplandığı durumlarda **pedding byte** durumunun hesaba katılması gerekecektir, `sizeof` operatörü bunu hesaba kattığı için türlerin bellek boyutunu hesaplamak için `sizeof` operatörü kullanılmalıdır.

3. İki yapı nesnesi byte seviyesinde karşılaştırılırken eğer yapı nesnelerinde **pedding byte** bulunuyorsa ve bu byte'lar temizlenmediyse tüm elemanlarının değeri birbirine eşit olan yapılar birbirine eşit değilmiş gibi gözlemlenecektir.

    
    👇 Aşağıdaki programda iki yapı nesnesinin eşitliğini sınarken **pedding byte** dikkat edilmesi gerektiği incelenebilir.
    ```C
    #include <stdio.h>
    #include <stdint.h>
    #include <stdalign.h>
    #include <string.h>

    typedef struct {
        char c1;
        int ival;
        char c2;
    } Nec;

    int main(void)
    {
        // Aşağıda oluşturulan 'Nec' yapı türünden olan nesnelerda 'pedding bytes' olacaktır ve o byte'lar çöp değerdedir.
        Nec nec1 = { 'a', 34242423, 'b' };
        Nec nec2 = { 'a', 34242423, 'b' };

        // Aşağıdaki nesne karşılaştırması doğru çalıştırılacaktır ama bu kullanım değişken adlarının yanlış yazılma hatasına açıktır.
        if(nec1.c1 == nec2.c1 && nec1.ival == nec2.ival && nec1.c2 == nec2.c2){
            printf("evet esit.\n");
        }
        else{
            printf("hayir esit degil.\n");
        }

        // 'memcmp' fonksiyonu 'pedding bytes' bilgisinden anlamadığı için eşitlik karşılaştırması doğru çalışmayacaktır.
        if(memcmp(&nec1, &nec2, sizeof(nec1))) {
            printf("evet esit.\n");
        }
        else{
            printf("hayir esit degil.\n");
        }
    }
    ```


    
    👇 Aşağıdaki programda iki yapı nesnesinin eşitliğini sınarken **pedding bytes** dikkat edilmesi gerektiği incelenebilir.
    ```C
    #include <stdio.h>
    #include <stdint.h>
    #include <stdalign.h>
    #include <string.h>

    typedef struct {
        char c1;
        int ival;
        char c2;
    } Nec;


    int main(void)
    {
        // Aşağıda oluşturulan 'Nec' yapı türünden olan nesnelerda 'pedding bytes' olacaktır ve o byte'lar çöp değerdedir.
        Nec nec1, nec2;

        // Yapı nesnelerinin byte değerleri 0 yapılıyor.
        memset(&nec1, 0, sizeof(nec1)); 
        memset(&nec2, 0, sizeof(nec2));

        nec1.c1 = nec2.c1 = 56;
        nec1.c2 = nec2.c2 = 32;
        nec1.ival = nec2.ival = 214453242;

        // 'memcmp' fonksiyonu 'pedding bytes' bilgisinden anlamıyor ama o byte'lar 0 olduğu için eşitlik karşılaştırması doğru çalışacaktır.
        if(memcmp(&nec1, &nec2, sizeof(nec1)){
            printf("evet esit.\n");
        }
        else{
            printf("hayir esit degil.\n");
        }
    }
    ```

    
    👇 Aşağıdaki programda iki yapı nesnesinin eşitliğini sınarken **pedding bytes** alanlarının ilk baştan temizlenmesinden dolayı yapı nesnelerinin karşılaştırmasının doğru olacağı görülmelidir.
    ```C
    #include <stdio.h>
    #include <stdint.h>
    #include <stdalign.h>
    #include <string.h>

    #define clear_struct(x)         memset(&x, 0, sizeof(x))

    typedef struct {
        char c1;
        int ival;
        char c2;
    } Nec;


    int main(void)
    {
        // Aşağıda oluşturulan 'Nec' yapı türünden olan nesnelerda 'pedding bytes' olacaktır ve o byte'lar çöp değerdedir.
        Nec nec1, nec2;

        // Yapı nesnelerinin byte değerleri 0 yapılıyor.
        clear_struct(nec1);
        clear_struct(nec2);

        nec1.c1 = nec2.c1 = 56;
        nec1.c2 = nec2.c2 = 32;
        nec1.ival = nec2.ival = 214453242;

        // 'memcmp' fonksiyonu 'pedding bytes' bilgisinden anlamıyor ama o byte'lar 0 olduğu için eşitlik karşılaştırması doğru çalışacaktır.
        if(memcmp(&nec1, &nec2, sizeof(nec1)){
            printf("evet esit.\n");
        }
        else{
            printf("hayir esit degil.\n");
        }
    }


Ders sonu ...
