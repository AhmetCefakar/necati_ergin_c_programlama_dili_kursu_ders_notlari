# 47.Ders 05.07.2025 🕘

Derse 9(09:01)-10(09:05)-11(09:28)-13(09:34)-13(10:01)-13(11:12)-12(12:06)-11(12:23)-11(12:54) kişi katıldı.
---

## Complete Types and Incomplate Types Kavramları 🌟

Eğer derleyici bir türün sadece bildirimini görüyor ama o türün tamamını göremiyorsa bu türlere **incomplate type** denilmektedir. </br>
Kullanıcı tanımlı türler(user defined types) **tamamlanmış tür(complate type)** ve **tamamlanmamış tür(incomplate type)** olarak iki kısıma ayrılmaktadır. </br>
**İlkel(primitive)** türlerden sadece __void*__ türü **tamamlanmamış tür(incomplate type)** durumdadır. </br>
Derleyici bir türün tanımını görebiliyorsa o türe **tamamlanmış tür(complate type)** tür denilmektedir, bir türün tanımının görülmesi demek te o türün tüm bileşenlerinin derleyici tarafından görülebilir olmasıdır.


**Tamamlanmamış(incomplate)** tür ile neler yapılabilir;
1. Pointer değişken tanımlanabilir. Derleyici için herhangi türden bir değişkenin gösterici bellek büyüklüğü önceden bellidir.
    
    👇 Aşağıdaki program parçasında **incomplate type** durumundaki yapı türünün kullanılabildiği görülebilir.
    ```C
    struct Data; // Buradaki 'struct Data' türü üyelerinin tamanı bilinmediği için 'incomplate type' durumundadır.

    struct Nec{
        int x;
        struct Data* necptr; 
    };

    int main(void)
    {
        struct Data* ptr1;
        struct Nec* ptr2;
    }
    ```

2. Tür eş adı bildirimlerinde bildirilen türler **incomplate type** olabilir.

    👇 Aşağıdaki program parçasında **incomplate type** yapı türü üzerinden bildirimleri yapılan tür eş adları incelenebilir.
    ```C
    struct Data; // Buradaki 'struct Data' türü üyelerinin tamanı bilinmediği için 'incomplate type' durumundadır.

    typedef struct Data Data; // Burada 'incomplate type' bir yapı türüne eş ad veriliyor.
    typedef struct Data* DataPtr; // Burada 'incomplate type' bir yapı türünün göstericisine tür eş ad veriliyor.

    int main(void)
    {
        
    }
    ```

3. `extern` değişken bildirimlerinde **incomplate type** kullanılabilir.

    👇 Aşağıdaki program parçasında `extern` ile bildirilen türlerin **incomplate type** olabileceği görülebilir.
    ```C
    struct Data; // Buradaki 'struct Data' türü üyelerinin tamanı bilinmediği için 'incomplate type' durumundadır.

    extern struct Data gdata; // Burada 'extern' anahtar sözcüğü ile başka bir kaynak dosyada tanımlanmış olan global bir 'gdata' adındaki değişkenin varlığı derleyiciye tanıtılıyor, 'extern' anahtar sözcüğü ile derleyiciye bu bildirim için bellekten yer ayrılmayacağı belirtilmiş oluyor.
    
    // Aşağıdaki gibi bir dizi değişkeni 'extern' ile derleyiciye tanıtılabilir, derleyici 'extern' bildirilen bir değişken için bellekten yer ayırmadğı için dizinin eleman sayısının belirtilmesi gerekmemektedir.
    extern struct Data gAry1[20]; // Burada 'extern' anahtar sözcüğü ile başka bir kaynak dosyada tanımlanmış olan global bir 'gAry1' adındaki değişkenin varlığı derleyiciye tanıtılıyor, 'extern' anahtar sözcüğü ile derleyiciye bu bildirim için bellekten yer ayrılmayacağı belirtilmiş oluyor.
    extern struct Data gAry2[]; // Burada 'extern' anahtar sözcüğü ile başka bir kaynak dosyada tanımlanmış olan global bir 'gAry2' adındaki değişkenin varlığı derleyiciye tanıtılıyor, 'extern' anahtar sözcüğü ile derleyiciye bu bildirim için bellekten yer ayrılmayacağı belirtilmiş oluyor.
    ```

    
    **Non-defined decleration**: C standardının kullandığı bir terim olmayan ama programcılar arasında `extern struct Data gdata;` gibi `extern` anahtar sözcüğüyle yapılan bir bildirimi tanımlamak için kullanılan bir terimdir. 

4. Fonksiyon bildirimlerindeki türler **incomplate type** olabilir.

    👇 Aşağıdaki program parçasında fonksiyon bildirimlerindeki parametre ve geri dönüş türlerinin **incomplate type** olbileceği görülmelidir.
    ```C
    struct Data; // Buradaki 'struct Data' türü üyelerinin tamanı bilinmediği için 'incomplate type' durumundadır.

    // Aşağıdaki fonksiyon bildirimlerindeki parametre ve geri dönüş türleri 'incomplate type' durumundadır.
    struct Data foo(struct Data);
    struct Data* bar(struct Data*);
    ```


👇 Aşağıdaki programdan `list.h` dosyasında bildirilen **incomplate type** durumundaki değişkenlerin `source_file_1.c` dosyasından kullanılabileceği ve bu biçimde programın derlenebileceği görülmelidir, eğer **incomplate type** bildirimlerin tanımları yoksa bağlama aşamsında hata oluşacaktır.
```C
// 'list.h' dosyasının içeriği aşağıdaki gibidir.
struct List;
typedef struct List* ListHandle; // 'ListHandle' adı 'struct List*' türünün tür eş adıdır.

ListHandle create_list(void);
void add_list(ListHandle, int);
void pop_front(ListHandle);
void destroy_list(ListHandle);

// ...
// ...


// 'source_file_1.c' dosyasının içeriği aşağıdaki gibidir.
#include "list.h"

void foo(void)
{
    ListHandle handle = create_list(); // Burada bir pointer değişkene bir adresle ilk değer veriliyor.
    add_list(handle, 12); // Burada bir adres bir fonksiyona argüman olarak gönderiliyor.
    add_list(handle, 23); // Burada bir adres bir fonksiyona argüman olarak gönderiliyor.
    
    // ... 

    destroy_list(handle);
}
```



**Complate type** kullanılması gereken durumlar;

1. **Incomplate type** ile değişken tanımlayamayız. Bir yapı türünden bir değişken tanımlamak için kesinlikle **complate type** kullanmak gerekmektedir.

    👇 Aşağıdaki programdan **incomplate type** durumundaki bir tür ile değişken tanımlanamayacağı görülebilir.
    ```C
    struct List; // Buradaki 'struct List' türü üyelerinin tamanı bilinmediği için 'incomplate type' durumundadır.

    int main()
    {
        struct List x; // Illegal, 'incomplate type' durumundaki bir tür ile değişken bildirmeye çalışmak sözdizim(syntax) hatasıdır.
    }
    ```

2. `sizeof` operatörünün operandı olabilen değişkenler sadece **incomplate type** durumunda olan değişkenlerdir.

    👇 Aşağıdaki programdan **incomplate type** durumdaki değişkenlerin `sizeof` operatörünün operandı yapılmasının **sözdizim(syntax)** hatasına neden olacağı görülmelidir.
    ```C
    struct List; // Buradaki 'struct List' türü üyelerinin tamanı bilinmediği için 'incomplate type' durumundadır.

    int main()
    {
        struct List* p = NULL; // Buradaki gösterici değişken bildiriminde hata yoktur.

        size_t sz1 = sizeof(struct List*); // Legal, buradaki ilk değer verme işleminde hata yoktur.
        size_t sz2 = sizeof(p); // Legal, buradaki ilk değer verme işleminde hata yoktur.

        size_t sz3 = sizeof(struct List); // illegal, buradaki ilk değer verme işleminde sözdizim(syntax) hatası oluşur.
        size_t sz4 = sizeof(*p); // illegal, buradaki ilk değer verme işleminde sözdizim(syntax) hatası oluşur.
    }
    ```

3. Yapıların elemanlarına erişim ifadelerinde **incomplate type** durumdaki türler kullanılamamaktadır. 

    👇 Aşağıdaki programdan **incomplate type** durumundaki bir yanının elemanları üzerinde işlem yapılmaya çalışılmasının **sözdizim(syntax)** hatasına neden olacağı incelenebilir.
    ```C
    struct List; // Buradaki 'struct List' türü üyelerinin tamanı bilinmediği için 'incomplate type' durumundadır.
    struct List* create_list(void);
    void destroy_list(struct List*);

    int main()
    {
        struct List* p1 = create_list();
        struct List* p2 = create_list();

        // some code here ...

        destroy_list(p1);

        // Aşağıdaki atama işlemleri sözdizim(syntax) hatasıdır çünkü derleyici 'struct List' türünün tanımını bilmiyor ve yapının üyelerini bilmiyor.
        *p1 = *p2;
        (*p1).x =23;
        p1->x = 13;
    }
    ```

4. Yapıların üyelerinin türü **incomplate type** olamaz. 

    👇 Aşağıdaki programdan **incomplate type** durumundaki bir tür ile değişken tanımlanamayacağı görülebilir.
    ```C
    struct List; // Buradaki 'struct List' türü üyelerinin tamanı bilinmediği için 'incomplate type' durumundadır.

    struct Data {
        int x;
        struct List a; // Buradaki bildirim sözdizim(syntax) hatasıdır çünkü tamamlanmamış bir tür yapının bir üyesinin tüür yapılmak isteniyor.
    };
    ```



❗❗❗ C ve C++ dillerinde şu ilke kabul görür: "_Bir **incomplate type** işini gördüğü sürece **complate type** kullanma._". Bir türü sadece mecbur olunduğunda zaman **complate type** haline getirmek tercihedilir.

❗❗❗ **Incomplate type** kullanıldığında gereksiz bağımlılıkların oluşmasının önüne geçilmektedir, bu önemli bir bilgidir ve ilerideki derslerde ve C programlarını yazarken önemli olacaktır.




👇 Aşağıdaki programdan C ve C++ dillerinde **incomplate type** bildirimi yapılmayan yapı türünden değişkenlerin yine **incomplate type** olarak yorumlandığı incelenebilir.
```C
struct List foo(struct List); // Burada 'struct List' kullanılmasından dolayı derleyici 'struct List' türünü bildirilmiş gibi yorumlar.

int main(void)
{
    struct Nec* p; // Burada 'struct Nec*' kullanılmasından dolayı derleyici 'struct Nec' türünü bildirilmiş gibi yorumlar.

}   
```

## C++ ya da OOP Tarzı Kütüphene Kullanımı 


❗❗❗ Yapının elemanları iki farklı biçimde olabilir, bunların aşağıdaki gibidir;
- C tarzı kütüphanelerde yapıların elemanları **müşteri(client)** kodlara tamamen açıktır ve yapıyı kullanacak yazılımcıların kullandıkları yapıların üyeleriyle ilgili derin bilgiye sahip olması gerekiyor. 
- OOP tarzı kütüphanelerde yapının elemanları client code tarafından kullanılmaz;
    1. Yapının elemanları görünür, kullanılması sözdizimi(snytax) hatası oluşturmaz ancak kütüphenenin dokümanında bildirdiği biçimde sözleşme gereği(hizmet veren kodla hizmet alan kod arasındaki bir sözleşme gereği) kullanıcı kodlar yapının elemanlarına erişmez.
    2. Yapının elemanları zaten client koda gösterilmez, bu yolla kullanıcı kod ilgili yapının dışayıya kapalı olan üyelerine erişemez ya da onları göremez.


👇 Aşağıdaki programdan C tarzı kütüphene özelliğinde `struct tm` türünün kullanımı incelenebilir.
```C
#include <stdio.h>
#include <time.h>

int main(void)
{
    struct tm x;

    x.tm_mon = 1; // Yapının 'tm_mon' üyesinin değerleri '[0,11]' arasında bir değerde olması gerekiyor ve '1' değeri de şubat ayına karşılık gelmektedir, programcı bu bilgiyi bilmek zorundadır yoksa yapıyı doğru kullanamaz.
    x.tm_year = 2025 - 1900; // Yapının 'tm_year' üyesinin değerleri '1900' yılından sonraki yılları ifade etmektedir, programcı bunu bilmezse programı doğru biçimde yazamaz.
}
```



👇 Aşağıdaki programda olduğu gibi sadece bildirimi olan bir yapı kullanıcı kod(client) tarafından kullanılamaz.
```C
struct List;

struct List* add_list(struct List*, int);
```



👇 Aşağıdaki programda olduğu gibi bir yapı türünün bildirimi görülebiliyordur ama `void*` türünden üyelere sahipse bu durumda üyelere erişilebilir ama `void*` türü dereferencing operatörünün operandı yapılamayacağı için kullanıcı kod(client) tarafından kullanılamaz.
```C
struct List{
    void* vptr;
};

int main(void)
{
    struct List myList;

    // 'myList.vptr' üyesine erişilip kullanılamaz.
}
```



📌 Bu derste tarih bilgilerini işleyip yönetebilmek için kendi tarih kütüphanemizi yazacapız.



❗❗❗ OOP biçiminde kütüpheneler kullanılarak aşağıdaki faydalar elde edilmektedir;
- Öğrenme yükü azalıyor.
- Tutarsız değerler oluşturulması sorunu engellenebiliyor, kütüphanedeki yapı nesnelerinin üyelerinin detaylı bilgisine sahip olunması gerekmeyecektir.
- En önemli fayda ise: Elemanlar değişirse elemanları kullanan kodun değişmesi gerekmeyecek ve bir çok durumda kaynak kodun **yeniden derlenmesi(recompile)** gerekmeyecektir. Büyük projelerde bağımlılıklar yüzünden kaynak kodların tekrar tekrar derlenmesinin gerekmesi gereksiz zaman kaybına neden olmaktadır.

❗❗❗ OOP biçiminde kütüpheneler kullanıldığında yapıların elemanlarının dışarıdan gizlenmesi ya da dışarıdan erişiminin dokümantasyon ile kısıtlanması araya ayrıca bir soyutlama katmanı eklenmesi anlamına geleceği için bazı durumlarda maliyeti arttırabilir. </br>
Elemanları göstermemenin en sıradan maliyeti: Bazı nesnelerin daha önce öğrenilen `malloc` fonksiyonu ile oluşturulma zorunluluğunu gerektirmesi ve bu biçimdeki bir işlemin dinamik bellek yönetimi gerektirmesinden dolayı maliyete sahip olmasıdır.


## Kendi `date` Kütüphanemizi C Tarzı Bir Kütüphane Olarak Oluşturalım 🌟 

Bugünkü dersimizin tamamı yazacağımız kendi kütüphanemizin C tarzı `date` modülüyle ilgili olacak. </br>
Bugünkü dersimiz kod yazma ağırlıklı olacak. Geçmişte işlenen derslerde işlenilen bir çok bilgiyi kod yazarak uygulamalı olarak göreceğiz cw bu bilgilerin üzerine bazı yeni bilgileri de ekleyeceğiz. </br>
Burada bir modül oluşturacağız ama modülü oluştururken yazacağımız kodlar bizim daha önce öğrendiğimiz C dilinin sözdizimine ilişkin ya da genel olarak programlamaya ilişkin bilgilerimizi pekiştirmemizi sağlayacak. </br>
İleriki derslerde bir yapının elemanlarının gizlenmesi konusuna geldiğimizde burada yazdığımız `date` modülünü kullanacağız ve gizlemenin nasıl hangi yollarla yapılacağını irdeleyeceğiz. </br>
Burada yazacağımız `date` modülünün bir başka önemli yanı bundan sonraki konu başlıklarımız, mesela buraya kadar bir yapı türünün üyelerinin başka yapı türleri olabileceği söylendi ama bu derin olarak incelenmedi. </br>
Burada yazılacak olan modüldeki `struct date` türünü oluşturacağımız başka modüllerdeki yapı nesnelerinin üye değişkenlerinin türü yaparak bir yapının üyesinin başka bir yapı türü olabileceği durum detaylı olarak incelenebilecektir. </br>
Yapılar konusundan sonra önemli alt başlıklarımız olacak, mesela dosya işlemleri ve dosya işlemlerinde burada oluşturacağımız `struct date` yapı değişkenini kullanacağız.



⚠️ Kursun sonuna yaklaştık ama bazı konular henüz tamamlanmadı, eksik kalan konuları tamamlayabilmek için bu günden itibaren en az altı derse ihtiyacımız var, yani 50. dersten sonra en az üç ders günü daha eklenmesi gerekecek. Bu kurs 50 ders değil en az 53 ders sürecektir.



❗❗❗ C dilinde bir kütüphane modülünü yazarken çok özel bir durum yoksa iki ayrı dosya oluşturuyoruz;
1. **Kullanıcı(client)** kodlar için oluşturulan, **kullanıcı(client)** kodların kullanması için bildirimleri içeren **başlık(header)** dosyası.
2. Kodun kendisini içeren **kaynak(implementation, code, source)** dosyası.


📌 C programlarında yazılan modüllerin önemli bir yönü de **yeniden kullanılabilirliği(reusable)** sağlamasıdır.



❗❗❗ Yazılmış olan bir modülün başkaları tarafından kullanılabilmesini sağlamak için iki farklı yol izlenebilir, bunlar;
1. Mesela "date" modülü paylaşılacaksa `date.h` dosyasının kendisi ve `date.c` kaynak dosyanın sadece derlenmiş hali verilebilir. Bu yöntemde modülü kullanacak programcıya kaynak kod dosyası verilmediği için progrmacı kaynak dosyada değişiklik yapamaz.
2. Mesela "date" modülü paylaşılacaksa `date.h` dosyasının kendisi ve `date.c` kaynak dosyanın kendisi verilebilir. Bu yöntemde modülü kaynak kodlarıyla birlikte alan programcı modülü istediği gibi kullanıp kaynak kod üzerinde istediği gibi değişiklikler yapabilir. Bu yöntemde kaynak kod **open source** olarak paylaşılmış olur. Açık kaynak olan kodların kullanım koşulları kodun lisansına bağlıdır ama kod lisanslarına bu derste değinilmeyecektir.



❗❗❗Bir kütüphane modülünü yazmaya başlarken en tipik hatalardan biri modülün yazımına ilk önce gerçekleştirim dosyasının("**.c**") yazımıyla işe başlanmasıdır, ilk önce yapılması gereken bir arayüz oluşturan başlık dosyasının yazımından başlanmasıdır.



❗❗❗ Bir başlık dosyası oluşturduğumuzda mutlaka ve mutlaka bir başlık dosyasını bir client code tarafından birden fazla defa **dahil edilmesini(include)** önlemek için önlem almalıyız. Birden fazla defa aynı "**.h**" dosyasının eklenmesi sözdizimi(syntax) hatasına neden olur.


❗❗❗ C programlarında yazılmış olan bir modül birden fazla kaynak dosyaya dahil edilmiş olabilir, bu durumda iç içe bir yapıda farklı dosyalar aynı kaynak dosyayı eklemek isteyecektir, eğer kütüphanelerin başlık dosyalarında **Multiple Include Guards(Header Include Guards)** uygulanmadıysa bu sözdizim(syntax) hatasına neden olacaktır.



👇 Aşağıdan **Multiple Include Guards(Header Include Guards)** durumunu incelemek için `date`, `student` ve `employee` adındaki modüller üzerinden inceleme yapılabilir;



**Multiple Include Guards(Header Include Guards)** uygulanırken kullanılan makronun adı belirlenirken en sık kullanılan yöntemler(convension) aşağıdaki gibidir;
- Başlık dosyasının adının tüm harflerini büyük yazdıktan sonra `_H` karakterleriyle sonlandırılabilir, mesele `DATE_H`.
- Başlık dosyasının adının tüm harflerini büyük yazdıktan sonra `INCLUDED` karakterleriyle sonlandırılabilir, mesele `DATE_INCLUDED`.


```C
// 'date.h' dosyası

// #pramga once // Buradaki tek bir ön işlemci programı komutuyla 'multiple inclusion guard' sağlanmış oluyor ama bu yöntem standart olmadığı için herderleyici desteklemeyebilir, bu nedenle biz klasik yöntemi kullanacağız.

#ifndef DATE_H // Buradaki 'multiple inclusion guard' kullanımı tüm derleyicilerde desteklenmektedir.
#define DATE_H

// Aşağıdaki dört farklı 'struct' türü bildirimi de en sonunda aynı işi yapmaktadır ama ilk kullanımda modülü kullanacak programcı sadece 'Date' adıyla yapıyı kullanmaya zorlanmaktadır.
// ! Yapının elemanlarını bilerek gizlemedik, ancak client kodların yapının elemanlarını kullanmasını istemiyoruz, bunun için de sık bir kullanım olarak(convernsion) dışarıdan değiştirilmemesi istenilen yapı değişkenlerinin adlarının sonuna '_' karakteri ekleniyor. 
typedef struct{
    int d_;
    int m_;
    int y_;
} Date;


// Aşağıdaki gibi bir yapı bildirimi yapıldığında, 'client code' hem 'struct Date' hem de 'Date' identifier(ad) ile burada bildirilen yapıyı kullanabilir.
// typedef struct Date{
//     int d_;
//     int m_;
//     int y_;
// } Date;


// Aşağıdaki gibi bir yapı bildirimi ile bu yapı türünün 'typedef' adı ile 'struct' adı birbirinden farklı yapılmış oluyor, 'client code' hem 'struct Date_' hem de 'Date' identifier(ad) ile burada bildirilen yapıyı kullanabilir.
// typedef struct Date_{
//     int d_;
//     int m_;
//     int y_;
// } Date;


// Aşağıdaki gibi bir yapı bildirimi ile bu yapı türünün 'typedef' adı ile 'struct' adı birbirinden farklı yapılmış oluyor, 'client code' hem 'struct tag_Date' hem de 'Date' identifier(ad) ile burada bildirilen yapıyı kullanabilir.
// typedef struct tag_Date{
//     int d_;
//     int m_;
//     int y_;
// } Date;


// C dilinde bir yapının değerlerini değiştiren fonksiyonlar 'set function', 'setter', 'mutater(daha çok C++ tarafında)' olarak adlandırılabiliyor. 
// Eğer fonksiyona gönderilmesi gereken değerler doğru değilse buna 'dab argument' denmektedir. Bu durumda iki yaklaşım vardır; 
// 1) Doğru argümanların geçilmesi sorumluluğu fonksiyonu çağıran koda yüklenir.
// 2) Fonksiyona geçilen argümanların doğruluğu fonksiyon içinde kontrol edile de bilir, bu durumda fonksiyona ek maliyet yüklenmiş olur.
void set_date(Date*, int d, int m, int y);

// Date* set_date2(Date*, int d, int m, int y);

#endif
```


`student` adında bir modülün yazılması.
```C
// 'student.h' dosyası

#ifndef STUDENT_INCLUDED 
#define STUDENT_INCLUDED

#include "date.h"

struct Student {
    char name[30];
    int id;
    struct Date bdate; // Bir yapı türünün üyesi 'incomplate type' olamaz, 'struct Date' türünün bildirimini derleyicinin görebilmesi için 'date.h' başlık dosyası ekleniyor.
};

#endif
```


```C
// 'student.c' dosyası


// some code here ... 
```


`employee` adında bir modülün yazılması.
```C
// employee.h dosyası

#ifndef STUDENT_INCLUDED 
#define STUDENT_INCLUDED

#include "date.h"

struct Employee {
    char name[30];
    int m_id;
    struct Date employment_date; // Bir yapı türünün üyesi 'incomplate type' olamaz, 'struct Date' türünün bildirimini derleyicinin görebilmesi için 'date.h' başlık dosyası ekleniyor.
};

#endif
```


```C
// 'employee.c' dosyası


// some code here ... 
```


👇 Aşağıdaki programda yukarıda yazılmış olan modüllerin nasıl birlikte kullanıldığı incelenebilir.
```C
// 'main.c' dosyası

#include "date.h"

// Aşağıdaki başlık dosyalarının ikisinde de 'date.h' başlık dosyası eklenmiştir, bu dosyalarda 
#include "student.h"
#include "employee.h"

int main(void)
{
    Date mydate;
    set_date(&mydate, 5, 6, 1995);
}
```



C dilinde yapı türlerinin elemanları varsayılan olarak dışaradan erişilebilir. C dilince **sık bir kullanım olarak(convension)** bir yapının elemanlarının adlarını sonuna `_` karakterinin eklenmesi o nesnelerin yapı dışından değiştirilmesinin istenmediği anlamına gelmektedir.



👇 Aşağıdaki programda `Date` tür eş adı üzerinden tanımlanan `myDate` adındaki değişkene doğrudan yapının üyelerine erişerek ilk değer verildiği durum incelenebilir.
```C
#include "date.h"

int main(void)
{
    Date myDate = { 3, 5, 1983 }; // Burada yapının üyelerine doğrudan erişilerek ilk değer veriliyor.
}
```



👇 Aşağıdaki programda `Date` tür eş adı üzerinden tanımlanan `myDate` adındaki değişkene dolaylı yoldan `set_date` fonksiyonu kullanılarak değer verildiği durum incelenebilir. </br>
Buradaki `Date` türünün sadece üç tane üyesi olmak zorunda olmadığı ve dışarıdan erişime kapalı başka üyelerinin de olabileceği görülmelidir.

```C
#include "date.h"

int main(void)
{
    Date myDate; // 'myDate' adında 'Date' türünden(esasında tür eş adı) bir yapı nesnesi tanımlanıyor(tanımlanıyor çünkü derleyici bu değişken için bellekte yer ayıracaktır).

    // Aşağıdaki gibi bir kullanımda fonksiyona yapılan çağrı işlemi olacağından dolayı, derleyici fonksiyona giriş kodlarıyla fonksiyondan çıkış kodlarını üretecektir bu da kodun işlem maliyetini yükseltir. 
    // Buradaki kullanımın bir önceki programdaki kullanıma kıyasla daha maliyetli olacağı görülmelidir.
    // Derleyici 'set_date' fonksiyonunun tanımını görmediği için herhangibi iyileştirme(optimizasyon) yapamaz.  
    set_date(&myDate, 3, 5, 1983); // Bu fonksiyon bildirimi ile 'myDate' değişkeninin değerleri verilmektedir.
}
```



🔥🔥🔥🔥🔥 Aşağıdaki bilgileri tam olarak anlamak çok önemlidir, burayı tam anlamadan programlama konusunda daha üst bir seviyeye çıkılamaz, buradaki bilgiyi anlamak OOP yaklaşımının neyi getirip neyi götürdüğünü anlamak için bir temel oluşturacaktır;
❗❗❗ C dilinde yapı türlerinden elde edilen nesnelerin üyelerinin dışarıdan erişime kısıtlanması durumunda soyutlamayı arttırmış oluruz ve böylece sadece soyutlamayı arttırmış olmuyoruz aynı zamanda üretilecek makine kodununda olacak işlem sayısını da arttırmış oluyoruz. </br>
❗❗❗ Yukarıdaki nedenlerden dolayı C dilinde soyutlamayı arttırdığımız zaman sadece soyutlamayı arttırmış olmuyoruz aynı zamanda maliyeti de arttırıyoruz, işte bu nedenden dolayıdır ki **sistem programlama**, **ağ(networking) programlama**, **oyun programlama**, **yoğun performanslı işlem gerektiren programlamalarda** yapının elemanları gizlenmemektedir çünkü soyutlamadan oluşacak fazladan makine kodlarını istenmemektedir.



❗❗❗ C++ dilinin bazı araçları(C dilinde de benzer bazı araçlar var) bir yapının elemanlarına erişmeyi hem kısıtlarken aynı zamanda çok verilmi bir kodun oluşturmasını sağlayabiliyor.



👇 Aşağıdaki programdan `set_date` fonksiyonuna hatalı değerler ile nasıl istek yapıldığı görülebilir.
```C
#include "date.h"

int main(void)
{
    Date myDate; // 'myDate' adında 'Date' türünden(esasında tür eş adı) bir yapı nesnesi tanımlanıyor(tanımlanıyor çünkü derleyici bu değişken için bellekte yer ayıracaktır).

    set_date(&myDate, 48, 4, 1012); // Burada 'set_date' fonksiyonuna çağrı yapan yerde argüman olarak geçilen değerler hatalı, bu durumda izlenebilecek iki durum var, bunların ne olduğunu aşağıdaki açıklamada görebilirsin.
}
```



❗❗❗ Bir fonksiyona yapılan bir çağrıda fonksiyona geçilmek istenilen argümanlar hatalı olduğu durumlarda izlenecek iki yol var, bunlar;
1. Hatalı değ geçilen fonksiyon çağrısı kendi modülümüze aitse o zaman hatalı fonksiyon çağrısının yapıldığı yerin bulunması ardından da düzeltilmesi gerekir.
2. Hatalı değ geçilen fonksiyon çağrısı **kullanıcı(client) kodlardan** geliyorsa bu durumda da iki farklı seçenekten biri tercih edilebilir;
    1. Hatalı fonksiyon çağrılarının yapılmasının sorumluluğu **kullanıcı(client) koda** bırakılabilir, bu durumda modülde bir işlem yapılması gerekmeyecektir ve kullanıcı hatalı değerler gönderdiğinde bu **ub** durumuna da neden olabilir.
    2. Hatalı fonksiyon çağrılarının yapılması durumlarını modülün fonksiyonunda yapabiliriz, bu durumda fonksiyona geçilen argümanlar tek tek kontrol edilecek ve değerler hatalı olsa bile bir düzenleme yapılabiliyorsa düzenleme yapıldıktan sonra fonksiyon işlemine devam edip bitirecek ama işleme devam edilemezse bunun da **kullanıcı(client) koda** bildirilmesi gerekiyor.


❗❗❗ Bir fonksiyondan geriye fonksiyonun yaptığı işlemin başarılı ya da başarısız olması durumunu fonksiyon çağrısını yapan koda bildirmek gerekiyor, peki bunu nasıl bildirecek diye düşünülürse bu başka bir dersin konusu ve bunu yapmak için birden fazla farklı yol var. </br>
Mesela en çok kullanılan **yaklaşım(convension)** olarak böyle `Date* set_date2(Date*, int d, int m, int y);` bir **setter fonksiyon** bildiriminde fonksiyona değerleri atanması için geçilen nesne tekrardan geriye döndürülebilir, fonksiyondan geriye dönen adres kendisine geçilen adres ile aynı ise işlem başarılı ama **NULL pointer** ise işlem başarısız anlamına gelecektir.



👇 Aşağıdaki programdan `set_date2` fonksiyon çağrısı yapıldığında işlem başarılı olmama durumunda nasıl bir kod yazılabileceği incelenebilir.
```C
#include "date.h"

int main(void)
{
    Date myDate; // 'myDate' adında 'Date' türünden(esasında tür eş adı) bir yapı nesnesi tanımlanıyor(tanımlanıyor çünkü derleyici bu değişken için bellekte yer ayıracaktır).

    // 'set_date2' fonksiyonu işini başarılı biçimde yapamazsa geriye 'NULL pointer' dönecek ve bu durumda hata olduğu anlaşılacak ve ona göre yapılacak bazı işlemler yapılabilir.
    if(!set_date2(&myDate, 48, 4, 1012)){
        // error handling code 
    }
}
```

❗❗❗ 👆 Yukarıdaki programdaki `set_date2` fonksiyon çağrısında olduğu gibi her seferinde hata var mı yok mu diye kontrol ettirilmesi kodu çok daha karmaşık hale getirecektir, bu C'nin küçük bir dil olmasının sonuçlarından biri bu, C++, Java, C# gibi dillerin standardında **exception handing** aracıyla bu gibi durumlar daha kolay ele alınabilmektedir.

Yazacağımız kütüphanelerimizin hataları nasıl işleyeceğine karar vermek bize düşüyor, hataları işleyip işlememeyi seçmek bize kalıyor. 


***
==================================================

✦✦✦✦✦ 10.50-11.17 birinci ara verildi. ✦✦✦✦✦

==================================================
***


✍️ Burada `date` adındaki kendi modülümüzün başlık dosyasını aşağıdaki gibi yazıyoruz.
```C
// Yazılan 'date.h' dosyası

// İlerleyen derslerde bir modülün nasıl dokümantasyonunun yazılacağı ve adlandırma yaklaşımlarından(naming convensions) bahsedileceği belirtildi.

#ifndef DATE_H // Buradaki 'multiple inclusion guard' kullanımı tüm derleyicilerde desteklenmektedir.
#define DATE_H

// ! Yapının elemanlarını bilerek gizlemedik, ancak client kodların yapının elemanlarını kullanmasını istemiyoruz, bunun için de sık bir kullanım olarak(convernsion) dışarıdan değiştirilmemesi istenilen yapı değişkenlerinin adlarının sonuna '_' karakteri ekleniyor. 
typedef struct{
    int d_;
    int m_;
    int y_;
} Date;

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Set functions(mutaters)

Date* set_date(Date* p, int d, int m, int y);
Date* set_date_str(Date* p, const char* pstr);
Date* set_date_today(Date* p);
Date* set_random_date(Date* p);
Date* set_year(Date* p, int y);
Date* set_month(Date* p, int m);
Date* set_month_day(Date* p, int d);

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Get functions, getters, accessors

int get_year(const Date* p);
int get_month(const Date* p);
int get_month_day(const Date* p);
int get_week_day(const Date* p); // 0: Pazar, 1: Pazartesi ...
int get_year_day(const Date* p);

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Formatet input-output functions

void print_date(const Date* p); // '05 Temmuz 2025 Cumartesi'
Date* scan_date(Date* p); 

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/    
// Utility functions

int cmp_date(const Date* p1, const Date* p2);
int date_diff(const Date* p1, const Date* p2); 
Date* ndays_after(Date* pdest, const Date* psource, int n); 
Date* ndays_before(Date* pdest, const Date* psource, int n); 

#endif
```



👇 Aşağıdaki programda `date.h` dosyasındaki mutater fonksiyonların nasıl test edileceği görülebilir.
```C
#include "date.h"

int main(void)
{
    Date date1;
    set_date(&date1, 5, 6, 1955);
    set_date_str(&date1, "02-09-2044");

    set_year(&date1, 1994);
    set_month(&date1, 11);
    set_month_day(&date1, 24);

    printf("yil = %d\n", get_year(&date1));
    printf("yilin %d. ayi\n", get_month(&date1));
    printf("ayin %d. gunu\n", get_month_day(&date1));
    printf("haftanin %d. gunu\n", get_week_day(&date1) + 1);
    printf("yilin %d. gunu\n", get_year(&date1));
}
```



👇 Aşağıdaki programda `date.h` dosyasındaki `print_date`, `cmp_date`, `set_random_date`, `print_date` fonksiyonlarını test etmek için nasıl bir program yazılabileceği incelenebilir. </br> 
Bu programda önceden öğrendiğimiz dilin araçlarını kullanacağız. 
```C
#include "date.h"
#include <stdio.h>
#include <stdlib.h> // 'qsort' fonksiyonunu kullanmak için eklenen başlık dosyası.
#include <time.h> // İşlem süresini ölçmek için eklenen başlık dosyası.
#include <conio.h> // Standart olmayan bir modül


// cmp_date fonksiyonunu test etmek icin aşağıdaki işlemleri afım adım yazalım;
// a) Dinamik bir 'Date' dizisini oluştur
// b) Dizinin elemanlarını rastgele değerler ile doldur.
// c) Diziyi standart C fonksiyonu olan 'qsort' ile küçükten büyüğe doğru sırala.
// d) Sıralanmış diziyi standar output'a gönder.
// e) dizinin bellek alanını serbest bırak.


// 'qsort' fonksiyonu için kullanılan sarmalayıcı fonksiyon.
static int wdcmp(const void* vp1, const void* vp2)
{
    return cmp_date((const void*)vp1, (const void*)vp2);
}


// Elemanları 'Date' türünden olan bir diziyi rastgele değerlerle dolduran bir fonksiyon, bunu cliend code kendi yazıyor.
// Aşağıdaki fonksiyonda 'int', 'double' vb. türlerden dizilerle birlikte nasıl gösterici aritmetiği kullanıldıysa burada da yapı türünden bir dizi için gösterici aritmetiği kullanılmıştır.
Date* set_date_array(Date* p, size_t size)
{
    Date* ptemp = p; // Burada fonksiyondan geriye döndürülecek olan dizinin adresinin kaybedilmemesi için o adres değerinin 'ptemp' değişkenine ilk değer olarak veriliyor.

    // Aşağıdaki döngü dizinin elemana sayısı kadar dönecektir.
    while(size--){
        set_random_date(p++);
    }

    return ptemp;
}

// Elemanları 'Date' türünden olan bir diziyi 'print_date' fonksiyonu ile formatlı olarak standart çıktı akımına gönderen fonksiyon.
void print_date_array(const Date* p, size_t size)
{
    while(size--){
        print_date(p++);
    }
}


int main(void)
{
    size_t size;

    printf("kac elemanli bir dizi olsun: ");
    scanf("%zu", &size);

    Date* pd = (Date*)malloc(size * sizeof(Date));
    if(!pd){
        fprintf(stderr, "bellek yetersiz!\n"); // bu fonkisyon çağrısına sonradan değinilecek. 
        return 1;
    }

    printf("siralama basladi.\n");
    clock_t start = clock();
    qsort(pd, size, sizeof(*pd), &wdcmp);
    clock_t end = clock();
    printf("siralama bitti %.2f saniye.\n", (double)(end - start) / CLOCKS_PER_SEC);
    _getch(); // Programı burada durdurmak için kullanılan 'conio.h' modülündeki standart olmayan fonksiyon çağrısı yapılıyor.
    print_date_array(pd, size); 

    free(pd);
}
```



👇 Aşağıdaki programdan `data.h` dosyasındaki `scan_date` fonksiyonunun nasıl test edildiği görülebilir.
```C
#include "date.h"
#include <stdio.h>

int main(void)
{
    Date date;

    printf("bir tarih girin: ");
    scan_date(&date);
    print_date(&date);
}
```



👇 Aşağıda programdan `data.h` dosyasındaki `date_diff` fonksiyonunun nasıl sınandığı görülebilir.
```C
#include "date.h"   
#include <stdio.h>

int main(void)
{
    Date bdate;

    printf("bedenlenis tarihinizi giriniz: ");
    scan_date(&bdate);
    printf("bedenlenis tarihiniz: ");
    print_date(&bdate);

    Date today;
    set_date_today(&today);
    printf("bugunun  tarihi: ");
    print_date(&today);
    printf("bugun varolusunuzun %d. gunu, anlamini bulabildin mi?\n", date_diff(&today, &bdate));
}
```



👇 Aşağıdaki programdan `data.h` dosyasındaki `ndays_after` fonksiyonunun nasıl test edildiği görülebilir.
```C
#include "date.h"
#include <stdio.h>

int main(void)
{
    printf("bugunden kac gun sonrasi: ");
    int n;
    scan_date("%d", n);

    Date today;
    set_date_today(&today);
    printf("bugun: ");
    print_date(&today);

    Date future_date;

    for(int i = 0; i <= 1'000'000'000; i *= 10){ // Buradaki `'` ile büyük sayıların basamaklarının okunaklı olması için ayrılması bir 'compiler extension' ve bu kullanıma 'digit seperator' deniliyor. 
        printf("%-15d gun sonrasi : ", i);
        ndays_after(&future_date, &today, i);
        print_date(&future_date);
    }
}
```



❗❗❗ C kursunda bir kaç defa tekrarlanan bir farkındalık olarak "**_KOD TEKRARI FELAKETTİR_**" tümcesine dikkat edilmelidir; </br>
Bir kodun kalitesinin ne olduğunu kodun ne kadar az tekrarlı olduğuna bakarak anlayabiliriz(kod tekrarı bazı özel durumlarda gerekli olabiliyor). </br>
Tekrar eden kodun sorunları;
- Kodun tekrar ettiği her yerde ayrı ayrı bağlamlarda her takrar eden yer için ayrı bir test kodu yazılması gerekecektir.
- Kodda bir değişiklik(lojik) yapılması ya da koda bir ekleme yapılması gerekirse o kadar fazla kod yazılması gerekecektir, bu da gereksiz iş yükü anlamına gelmektedir.
- Kodun tekrar etmesi aynı kod bir kaç farklı yerde olduğu için değişiklik yapılması gerektiğinde bazı yerlerde değişiklik yapılıp bazı yerlerde o değişikliğin yapılması yapılmazsa hatalara neden olacaktır.
- Kod tekrar kullanılabilir(reusable) yapılmamış olur, tekrar eden kod kendisini iyi açıklayamaz ve mecburen yorum satırlarıyla açıklamak gerekecektir, eğer tekrar eden kod bir fonksiyona alınırsa fonksiyon adından ilgili kodun ne iş yaptığı anlaşılabilir durumda olabilirdi.

**Self explanatory**: Bir kodun kendi kendini açıklayabilir durumda olması durumu açıklamak için kullanılan terimdir.


❗❗❗ Tekrar eden kodu bir yere toplayıp sıklıkla o kodu bir fonksiyon haline getirmek yüksek seviyede soyutlama sağlayacaktır, bu da İngilizce olarak "_**abstraction at a higher level**_" biçiminde ifade edilir.



Ortak kodun bir yere toplamak iki farklı biçimde olabilir;
1. Baştan ortak kodun ne olacağı bellidir, bu durumda 
2. Baştan ortak kodun ne olacağı belli değildir, üretimde çoğunluklada bu biçimde olmaktadır.



**Refactoring(Kodun iyileştirilmesi)**: Programın gözden geçirilip düzenlenmesine verilen addır. **Refactoring** kavramı önemlidir, bu konuyla ilgili kaliteli kaynaklar okunması önerilir. 


**Refactoring(Kodun iyileştirilmesi)** nasıl yapılır;
1. Programda kullanılan fonksiyonların, modüllerin, değişken adlarının, tür eş adlarının vb. kendilerini daha iyi anlatacak adlara sahip olacak biçimde değiştirilmesi.
2. Ortak kodların bir yere toplanıp tekilleştirilmesi iyi bir davranıştır, bu biçimde kod daha kolay yönetilebilir durumda olacaktır.
3. Kodun daha okunabilir ve anlaşılır hale gelmesini sağlamak iyi bir davranıştır.
4. Özellikle C ve C++ programlarını daha ablaşılır kılmak için bu dillerdeki **deyimsel(idiyomatik)** yapıların kullanılması iyi bir davranıştır.
5. Yazılan programda mümkün mertebe standart kütüphenenin sağladığı fonksiyonları kullanılmasını sağlamak 
6. Programın daha hızlı çalışması sağlamak için(optimization) değişiklikler yapılması.
7. Programın bazı yerlerinde kullanılan değişken türlerinde ya da veri yapılarında değişiklikler yapılması.



Kendi yazdığımız `date` modülündeki tüm fonksiyonlarımız `Date` türünden(esasında tür eş adı) bir yapı nesnesini kullanmaktadır ve bu nedenle bu yapının değerlerinin doğruluğunu test edeceksek bu işlem çoğu fonksiyonda ortak bir işlem olacaktır.



C++ dilinin standardı yükseldikçe dilde yapılan değişikliklerle ön işlemci program giderek devre dışı yapılma eğilimi vardır. C++ dilinin imkanları neredeyse ön işlemci programa ihtiyacı ortadan kaldıracak noktaya gelmiştir denilebilir. 
C dili C++ dilinden farklı olarak ön işlemci program kullanılmasın diye bir eğilim yoktur, C dilinde gerekli olan yerlerde makrolar dikkatli bir biçimde kullanılmalıdır. 



✍️ Burada `date` adındaki kendi modülümüzün kaynak dosyasını aşağıdaki gibi yazıyoruz.
```C
// Yazılan 'date.h' dosyası

#include "date.h"
#include <stdbool.h> // Kodun okunurluğunu arttırmak için 'bool' gibi makroların kullanılabilmesi için eklendi. 
#include <stdio.h>

#define YEARBASE    1900

#define ISLEAP(Y) (((Y) % 4 == 0) && ( ((Y) % 100 != 0) || ((Y) % 400 == 0)))
#define MONTHDAYS(Y, M) (daytabs[ISLEAP(Y)][M])

// Bir yıldaki aylarda olan günlerin sayısı bilgisine erişmek için kullanılabilecek olan arama(lookup) tablosunun aşağıdaki gibi olabileceğini ilk defa 'The C Programing Language' kitabında 'Dennis Ritchie' önermiştir.
static const int daytabs[][13] = {
    { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
    { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
};


// 'is_valid_date' fonksiyonu kendisine geçilen gün, ayi, yıl değerlerinin geçerli bir tarih olup olmadığını sınayan bir fonksiyondur.
static bool is_valid_date(int d, int m, int y)
{
    // İlk yazılan fonksiyon gövdesi aşağıdaki gibidir. 
    // return y >= YEARBASE && 
    //     m > 0 && m <= 12 && daytabs[ISLEAP(y)][m];

    return y >= YEARBASE && 
        m > 0 && m <= 12 && MONTHDAYS(y, m);
} 


// 'set' adındaki fonksiyonu sadece bu kaynak dosyada kullanacağız dışarıdan erişimi olmayacak bu nedenle adı genel olan bir sözcük olarak verildi.
// 'set' fonksiyonu kütüphanemizdeki diğer fonksiyonların 'Date' türünün üyelerini atama işlemini yapmak için kullanılacak.
// 'set' fonksiyonunun adı kendisini anlatmaktadır.
static Date* set(Date* p, int d, int m, int y)
{
    if(!is_valid_date(d, m, y))
        return NULL;

    p->d_ = d;
    p->m_ = m;
    p->y_ = y;

    return p;
}


// Devam edecek...
```



❗❗❗ Fonksiyonlara birden fazla görev verilmemelidir, İsviçre çakısı gibi fonksiyonlar yazılmamalıdır, verilirse aşağıdaki gibi sorunlarla karşılır;
- Fonksiyonun adı yaptığı işi açıklayamayacak hale gelecektir.
- Fonksiyon birden fazla işi yaptığı için o fonksiyonu kullanan koda kullanmak istemeyaceği bazı işlemlerin zorla kullandırılması gibi istenmeyen bir durum oluşacaktır.
- Fonksiyonu test etmek için daha fazla test kodunun yazılması gerekecektir.
- **Takrar kullanılabilirlik(reusability)** olumsuz etkilenecektir.




✍️ Burada `date` adındaki kendi modülümüzün kaynak dosyasını aşağıdaki gibi yazıyoruz, burada yukarıdaki halinden farklı olarak okunurluğu arttırmak için `PRIVATE` ve `PUBLIC` makroları eklendi.
```C
// Yazılan 'date.h' dosyası

#include "date.h"
#include <stdbool.h> // Kodun okunurluğunu arttırmak için 'bool' gibi makroların kullanılabilmesi için eklendi. 
#include <stdio.h>

#define YEARBASE    1900
#define PRIVATE     static
#define PUBLIC      

#define ISLEAP(Y) (((Y) % 4 == 0) && ( ((Y) % 100 != 0) || ((Y) % 400 == 0)))
#define MONTHDAYS(Y, M) (daytabs[ISLEAP(Y)][M])

// Bir yıldaki aylarda olan günlerin sayısı bilgisine erişmek için kullanılabilecek olan arama(lookup) tablosunun aşağıdaki gibi olabileceğini ilk defa 'The C Programing Language' kitabında 'Dennis Ritchie' önermiştir.
PRIVATE const int daytabs[][13] = {
    { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
    { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
};


// 'is_valid_date' fonksiyonu kendisine geçilen gün, ayi, yıl değerlerinin geçerli bir tarih olup olmadığını sınayan bir fonksiyondur.
PRIVATE bool is_valid_date(int d, int m, int y)
{
    // İlk yazılan fonksiyon gövdesi aşağıdaki gibidir. 
    // return y >= YEARBASE && 
    //     m > 0 && m <= 12 && daytabs[ISLEAP(y)][m];

    return y >= YEARBASE && 
        m > 0 && m <= 12 && MONTHDAYS(y, m);
} 


// 'set' adındaki fonksiyonu sadece bu kaynak dosyada kullanacağız dışarıdan erişimi olmayacak bu nedenle adı genel olan bir sözcük olarak verildi.
// 'set' fonksiyonu kütüphanemizdeki diğer fonksiyonların 'Date' türünün üyelerini atama işlemini yapmak için kullanılacak.
// 'set' fonksiyonunun adı kendisini anlatmaktadır.
PRIVATE Date* set(Date* p, int d, int m, int y)
{
    if(!is_valid_date(d, m, y))
        return NULL;

    p->d_ = d;
    p->m_ = m;
    p->y_ = y;

    return p;
}


PUBLIC Date* set_date(Date* p, int d, int m, int y)
{
    return set(p, d, m, y);
}

// Devam edecek...
```


Ders sonu ...
