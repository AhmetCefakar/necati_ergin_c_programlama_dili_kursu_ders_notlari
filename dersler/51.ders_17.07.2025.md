# 51.Ders 17.07.2025 ğŸ•˜

Derse 9(19:31)-10(19:58)-11(20:26)-8(21:28)-9(21:30)-8(22:11)-9(22:32) kiÅŸi katÄ±ldÄ±.
---


## Bitsel OperatÃ¶rler(Bitwise Operations)

â—â—â— Bitsel iÅŸlemler daha Ã§ok iÅŸaretsiz tam sayÄ±lar Ã¼zerinde yapÄ±lÄ±yor ama iÅŸaretli tam sayÄ±lar Ã¼zerinde bitsel iÅŸlem yapÄ±lamaz diye bir kural yoktur fakat bitsel iÅŸlemler Ã§ok bÃ¼yÃ¼k oranda iÅŸaretli tam sayÄ±lar Ã¼zerinde yapÄ±lmaktadÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda kendi `nutility.h` baÅŸlÄ±k dosyamÄ±za eklediÄŸimiz `bprint` fonksiyonu ile kullanÄ±cÄ±dan alÄ±nacak `unsigned int` tÃ¼rÃ¼nden bir sayÄ±nÄ±n bitlerinin yazdÄ±rÄ±lÄ±ÅŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = 8795;

    printf("Bir tam sayi giriniz: ");
    scanf("%u", &x);

    bprint(x);
}
```


### `~` Bitwise Not Operator 

**Bitsel deÄŸil(`~`)** operatÃ¶rÃ¼ **uniry prefix** ve yan etkisi olmayan bir operatÃ¶rdÃ¼r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda **Bitsel deÄŸil(`~`)** operatÃ¶rÃ¼nÃ¼n nasÄ±l bir deÄŸer Ã¼rettiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    printf("Bir tam sayi giriniz: ");
    scanf("%u", &x);

    bprint(x);
    bprint(~x);
    printf("x = %u\n", x);

    bprint(~~x); // Bir tam sayÄ±nÄ±n bitsel deÄŸilinin deÄŸili kendisidir.
    printf("x = %u\n", x);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iÅŸaretsiz en bÃ¼yÃ¼k tam sayÄ±nÄ±n elde edilme yollarÄ±ndan biri incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    printf("isaretsiz 'int' turunun alabilecegi en buyuk deger = %u\n", ~0u);
}
```


### `>>` and `<<` Bitwise Right Shift Operator and Bitwise Left Shift Operator 

Bu iki operatÃ¶r **binary infix** ve yan etkisi olmayan operatÃ¶rlerdir. </br>
Bitsel operatÃ¶rlerin operantlarÄ±nÄ±n tÃ¼rleri ondalÄ±klÄ± sayÄ± olamaz sadece tam sayÄ± olabilir.


#### `<<` OperatÃ¶rÃ¼nÃ¼n Ä°nceleniÅŸi


`x << y` ifadesinde, sol operandÄ±n bitleri kaydÄ±rÄ±lacak, saÄŸ operand kaydÄ±rma iÅŸlemindeki pozisyon sayÄ±sÄ±nÄ± belirten operanttÄ±r. </br>
`17 << 3` ifadesi legaldir, sol operand **L-value** olmak zorunda deÄŸildir.


â—â—â— Hem sola hem de saÄŸa kaydÄ±rma iÅŸlemlerinde, saÄŸ operandÄ±n iÅŸlemin yapÄ±lacaÄŸÄ± tam sayÄ± tÃ¼rÃ¼nÃ¼n bit sayÄ±sÄ±na eÅŸit ya da bundan bÃ¼yÃ¼k olmasÄ± ya da negatif deÄŸerde olmasÄ± **tanÄ±msÄ±z davranÄ±ÅŸtÄ±r(ub)**.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **tanÄ±msÄ±z davranÄ±ÅŸ(ub)** olan bitsel sola kaydÄ±rma iÅŸlemi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int x = 1234;
    int y = 32;

    x << y; // Buradaki ifadedede 'ub' vardÄ±r Ã§Ã¼nkÃ¼ 'int' tÃ¼rÃ¼ 32 bit ve buradaki sola kaydÄ±rma iÅŸleminin saÄŸ operandÄ±nÄ±n deÄŸeri 32 deÄŸerine eÅŸit olamaz.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda yukarÄ±daki ifadelere gÃ¶re ilk bakÄ±ÅŸta **ub** olacaÄŸÄ± dÃ¼ÅŸÃ¼nÃ¼len bitsel sola kaydÄ±rma iÅŸleminin neden **ub** olmadÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    short x = 1234;
    int y = 19;

    x << y; // Buradaki ifadede 'integral promotiom' olmasÄ±ndan dolayÄ± 'ub' yoktur, 'x' deÄŸiÅŸkeninin tÃ¼rÃ¼ 'short' olsa bile bu deÄŸiÅŸken iÅŸlem yapÄ±lÄ±rken 'int' tÃ¼rÃ¼ne yÃ¼kseltilir.
}
```


[19:35.20]
â—â—â— Bitsel sola kaydÄ±rma iÅŸleminde iÅŸaretli tÃ¼rden negatif tam sayÄ±larÄ±n sola kaydÄ±rÄ±lmasÄ± **tanÄ±msÄ±z davranÄ±ÅŸtÄ±r(ub)**.


[19:36.30]
ğŸ‘‡ AÅŸaÄŸÄ±daki programda "1" deÄŸerine sahip `unsigned int` tÃ¼rÃ¼nden bir bir deÄŸiÅŸkenin deÄŸerinin her dÃ¶ngÃ¼ adÄ±mÄ±nda bir sola kaydÄ±rÄ±lmasÄ± iÅŸlemi sonucunda nsÄ±l bir sayÄ±ya dÃ¶nÃ¼ÅŸtÃ¼ÄŸÃ¼ incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    unsigned x = 1; // Burada 'x' deÄŸiÅŸkeninin tÃ¼rÃ¼nÃ¼n 'unsigned int' olduÄŸunu hatÄ±rla!

    while(x){
        bprint(x);
        x <<= 1; //Buradaki ifade 'x = x << 1' ifadesine denktir. 
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir tam sayÄ±ya sola kaydÄ±rma iÅŸlemi uygulandÄ±ÄŸÄ±nda nasÄ±l bir sayÄ± elde edileceÄŸini ve sayÄ±nÄ±n saÄŸ tarafÄ±ndan yapÄ±lan beslemenin hangi bitle yapÄ±lacaÄŸÄ±nÄ± gÃ¶rmek iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = 235397u;

    printf("x = %u\n", x);

    unsigned int y = x << 5; 

    printf("x = %u\n", x);

    bprint(x);
    bprint(y);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda tÃ¼m bitleri "1" olan bir tam sayÄ±nÄ±n beÅŸ bit sola kaydÄ±rma iÅŸlemi sonucundaki bitlerinin gÃ¶rÃ¼nÃ¼mÃ¼ incelenebilir, saÄŸa eklenen bitler 0 olacaktÄ±r. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = -1; // Bu kullanÄ±m C dilinde en Ã§ok kullanÄ±lan idiyomlardan biridir.

    bprint(x);
    bprint(x << 5);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda ilk baÅŸta "1" deÄŸerine sahip bir iÅŸaretsiz bir tam sayÄ±nÄ±n dÃ¶ngÃ¼ ile bitlerinin her adÄ±mda bir sola kaydÄ±rmasÄ± sonucunda sayÄ± sÄ±fÄ±r deÄŸerine aship olana kadar ikinin kuvvetlerini deÄŸer olarak alacaÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    unsigned x = 1;

    while(x){
        printf("%u\n", x);
        x <<= 1;
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `sizeof` operatÃ¶rÃ¼nÃ¼n operandÄ± olan ilk bakÄ±ÅŸta **ub** olan ifadenin tanÄ±msÄ±z davranÄ±ÅŸa neden olmayacaÄŸÄ± gÃ¶rÃ¼lmelidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    size_t sz = sizeof(1 << 78); // Burada 'sizeof' operatÃ¶rÃ¼ iÅŸlem kodu Ã¼retmediÄŸi iÃ§in burada 'ub' yoktur.
}
```


#### `>>` OperatÃ¶rÃ¼nÃ¼n Ä°nceleniÅŸi 

Bitsel saÄŸa kaydÄ±rma iÅŸleminde soldan yapÄ±lacak **besleme(feeding)**, sol operand iÅŸaretsiz tam sayÄ± ise "0" ile yapÄ±lacaÄŸÄ± kesindir(her derleyici iÃ§in geÃ§erlidir).

Bitsel saÄŸa kaydÄ±rma iÅŸleminde soldan yapÄ±lacak **besleme(feeding)**, sol operand iÅŸaretli pozitif bir tam sayÄ± ise "0" ile yapÄ±lacaÄŸÄ± kesindir(her derleyici iÃ§in geÃ§erlidir).

Bitsel saÄŸa kaydÄ±rma iÅŸleminde soldan yapÄ±lacak **besleme(feeding)**, sol operand iÅŸaretli negatif bir tam sayÄ± ise "0" ya da "1" ile yapÄ±labilir(derleyiciye baÄŸlÄ±dÄ±r).




ğŸ‘‡ AÅŸaÄŸÄ±daki programda sol operand iÅŸaretsiz bir tam sayÄ± olduÄŸunda bitsel saÄŸa kaydÄ±rma iÅŸleminde saÄŸdan eklenen bitlerin her derleyici iÃ§in "0" olacaÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <limits.h>

int main(void)
{
    unsigned int x = UINT_MAX;
    bprint(x);
    bprint(x >> 5);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda sol operand iÅŸaretli pozitif bir tam sayÄ± olduÄŸunda bitsel saÄŸa kaydÄ±rma iÅŸleminde saÄŸdan eklenen bitlerin her derleyici iÃ§in "0" olacaÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int x = 65535;
    bprint(x);
    bprint(x >> 3);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda sol operand iÅŸaretli negatif bir tam sayÄ± olduÄŸunda bitsel saÄŸa kaydÄ±rma iÅŸleminde saÄŸdan eklenen bitlerin ne olacaÄŸÄ±nÄ±n derleyiciye baÄŸlÄ± olduÄŸu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    int x = -1;

    bprint(x);
    bprint(x >> 2); // Burada soldan yapÄ±lacak besleme derleyiciye baÄŸlÄ±dÄ±r, bir derleyicide '1' ile bir baÅŸka derleyicide '0' ile besleme yapÄ±labilir.
}
```



> â” 
> 
> Sorulan soru;
> Ä°ÅŸaretli bir poz. sayiyi sayiyi sola kaydirdigimizda takip eden bit 1 ise nasil olur?
> 01011 << 1
>
> Cevap;
> 
> AÅŸaÄŸÄ±daki program Ã¼zerinden sorulan durum incelenebilir.
> 
> 
> ğŸ‘‡ AÅŸaÄŸÄ±daki programda iÅŸaretli `x` deÄŸiÅŸkeninin iÅŸaretinin korunacaÄŸÄ± dÃ¼ÅŸÃ¼nÃ¼lmesinin doÄŸru olmayacaÄŸÄ± gÃ¶rÃ¼lmelidir, iÅŸlem sonucunda pozitif olan sayÄ± negatif olmaktadÄ±r.
> ```C
> #define _CRT_SECURE_NO_WARNINGS
> 
> #include <stdio.h>
> #include <limits.h>
> #include "nutility.h"
> 
> int main(void)
> {
>     int x = 0b0000'1111'0101'0100'0000'1111'0101'0100;
>     
>     bprint(x);
>     printf("x = %d\n", x);
> 
>     x <<= 5;
>     bprint(x);
>     printf("x = %d\n", x);
> }
> ```




â—â—â—
Sola kaydÄ±rma iÅŸlemi iki ile Ã§arpmaya eÅŸdeÄŸerdir fakat bu ikiyle Ã§arpma iÅŸleminin sola kaydÄ±rma operandÄ± ile yapÄ±lacaÄŸÄ± anlamÄ±na gelmemektedir.
1 ile beslemeye **aricmetic feeding** deniliyor.
0 ile beslemeye **logic feeding** deniliyor.




ğŸ‘‡ AÅŸaÄŸÄ±daki programda sola kaydÄ±rma iÅŸleminin ikiyle Ã§arpmaya denk olduÄŸunu gÃ¶rmek Ã¶nemlidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = 17;

    printf("%u %u %u\n", x, x << 1, x << 2); // Buradaki kullanÄ±mda olduÄŸu gibi bir sayÄ±nÄ±n ikiyle Ã§arpma iÅŸlemine tabi tutmak iÃ§in bitsel sola kaydÄ±rma iÅŸleminin yapÄ±lmamasÄ± gerekir, derleyici zaten optimizasyonla Ã§arpma iÅŸlemini hÄ±zlandÄ±rÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda 32 bitlik sadece en saÄŸ biti bir olan(bu iÅŸaretli en kÃ¼Ã§Ã¼k tam sayÄ± deÄŸeridir) tam sayÄ±nÄ±n elde edilme yollarÄ±ndan biri(makro kullanÄ±mÄ± ile) gÃ¶rÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = (unsigned)INT_MIN;
    bprint(x);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda 32 bitlik sadece en saÄŸ biti bir olan(bu iÅŸaretli en kÃ¼Ã§Ã¼k tam sayÄ± deÄŸeridir) tam sayÄ±nÄ±n estetik bir biÃ§imde elde edilme yolu(C idiom ile) gÃ¶rÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = ~(~0u >> 1);
    bprint(x);
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda saÄŸa kaydÄ±rma(right shift) iÅŸlemiyle ikinin farklÄ± kuvvetlerinin deÄŸerinin nasÄ±l hesaplandÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void) {
    printf("isaretsiz 'int' turunun alabilecegi en buyuk  deger = %u\n", ~0u);

    unsigned int x = ~(~0u >> 1); // 2^31 sayÄ±sÄ± elde ediliyor.

    printf("2^31 = %u\n", x);
    printf("2^10 = %u\n", x >> (31 - 10));
    printf("2^5 = %u\n", x >> (31 - 5));
    printf("2^12 = %u\n", x >> (31 - 12));

    printf("\n~~~~~~~~~~~~~~~~~~\n");

    for(size_t i = 31; i > 0; --i){
        printf("2^%d = %u\n", i, x >> (31 - i));
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda 32 bitlik sadece en saÄŸ biti bir olan(bu iÅŸaretli en kÃ¼Ã§Ã¼k tam sayÄ± deÄŸeridir) tam sayÄ±nÄ±n adÄ±m adÄ±m bir bit saÄŸa kaydÄ±rÄ±lmasÄ± sonucunda elde edilen sayÄ±lar incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    bprint(~(~0u >> 1));

    unsigned int x = ~(~0u >> 1);

    while(x){
        bprint(x);
        x >>= 1;
    }
}
```


â—â—â— MikroiÅŸlemcilerin komut setlerinde **bitsel ters Ã§evirme(bitwise rotate)** iÅŸlemi vardÄ±r ama bu iÅŸlemin C dilinde bir operatÃ¶rÃ¼ yoktur. C dilini yeni Ã¶ÄŸrenenler **bitwise shift(bitsel kaydÄ±rma)** ile **bitwise rotate(bitsel dÃ¶ndÃ¼rme)** iÅŸlemlerini birbirine karÄ±ÅŸtÄ±rma eÄŸilimindeymiÅŸ.


###  `&` `|`  `^` Operators 

Bu iki operatÃ¶r **binary infix** ve yan etkisi olmayan operatÃ¶rlerdir. </br>
Bu operatÃ¶rler iki deÄŸerin bitlerini karÅŸÄ±lÄ±klÄ± olarak bitsel iÅŸleme sokmaktadÄ±r.
- Bitsel ve(`&`) operatÃ¶rÃ¼ 
- Bitsel veya(`|`) operatÃ¶rÃ¼
- Bitsel Ã¶zel veya(`^`) operatÃ¶rÃ¼

Bu operatÃ¶rlerin **kÄ±sa devre davranÄ±ÅŸÄ±(short circuit behavior)** yoktur.


#### `&` OperatÃ¶rÃ¼nÃ¼n Ä°nceleniÅŸi


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `&` operatÃ¶rÃ¼nÃ¼n kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned x, y;

    printf("iki tam sayi giriniz: ");
    scanf("%u%u", &x, &y);

    bprint(x);
    bprint(y);
    bprint(x & y);

    printf("x = %u\n", x);
    printf("y = %u\n", y);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `&&` operatÃ¶rÃ¼ yerine `&` operatÃ¼rÃ¼nÃ¼n kullanÄ±mÄ±ndan kaynaklanan hata durumu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned x, y;

    printf("iki tam sayi giriniz: ");
    scanf("%u%u", &x, &y);

    if(x && y)
        printf("dogru\n");
    else
        printf("yanlis\n");


    // AÅŸaÄŸÄ±daki if koÄŸulunda '&&' yerine '&' operatÃ¶rÃ¼nÃ¼n yanlÄ±ÅŸlÄ±kla kullanÄ±mÄ± gÃ¶rÃ¼lmelidir. 
    if(x & y)
        printf("dogru\n");
    else
        printf("yanlis\n");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `&` operatÃ¶rÃ¼nde etkisiz ve yutan eleman durumlarÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned x, y;

    printf("iki tam sayi giriniz: ");
    scanf("%u%u", &x, &y);

    bprint(x);
    bprint(y);
    bprint(x & y);
}
```



â—â—â— Bir tam sayÄ±yÄ± bir eksiÄŸi ile `&` iÅŸlemine sokarsak sayÄ±nÄ±n en saÄŸdaki ilk bir bitini sÄ±fÄ±rlamÄ±ÅŸ oluruz. </br>
â—â—â— Ä°kinin katÄ± olan bir sayÄ±yÄ± kendisinin bir eksiÄŸi ile `&` iÅŸlemine tabi tutarsak sayÄ±yÄ± sÄ±fÄ±rlamÄ±ÅŸ oluruz. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir tam sayÄ±nÄ±n bir eksiÄŸiyle bitsel ve iÅŸlemine sokulmasÄ± sonucunda elde edilen sayÄ±nÄ±n bitlerinin deÄŸeri incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned x;

    printf("bir tam sayi giriniz: ");
    scanf("%u", &x);

    bprint(x);
    bprint(x & (x - 1));    
}
```


#### `|` OperatÃ¶rÃ¼nÃ¼n Ä°nceleniÅŸi 


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `|` operatÃ¶rÃ¼nde etkisiz ve yutan eleman durumlarÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned x;

    printf("bir tam sayi giriniz: ");
    scanf("%u", &x);

    bprint(x);
    bprint(y);
    bprint(x | y);
}
```



â—â—â— ProgramcÄ±lar Ã§oÄŸunlukla operatÃ¶r Ã¶nceliÄŸi kurallarÄ±na hakim olsalar da aÅŸaÄŸÄ±daki nedenlerden dolayÄ± bir ifade de birden fazla operatÃ¶r varsa Ã¶ncelik parantezi kullanÄ±rlar;
1. Kodun daha kolay okunmasÄ± iÃ§in.
2. Hata yapma riskini azaltmak iÃ§in.
Mesela `x << 3 > y` ifadesi `(x << 3) > y` ifadesine denktir ama okunmasÄ± daha kolay olduÄŸu iÃ§in 



#### `^` OperatÃ¶rÃ¼nÃ¼n Ä°nceleniÅŸi 

Ä°ki bit birbirinden farklÄ± ise sonuÃ§ true aynÄ± ise sonuÃ§ false olacaktÄ±r.

Bu operatÃ¶r(`^`) "**Exclusive Or(Ã–zel Veya)**" sÃ¶zcÃ¼klerinin kÄ±saltmasÄ±ndan **exor** olarak adlandÄ±rÄ±lmaktadÄ±r, Necati Ergin bu operatÃ¶rÃ¼ TÃ¼rkÃ§eye "**DÄ±ÅŸlayan Veya**" olarak Ã§eviriyormuÅŸ.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `^` operatÃ¶rÃ¼nde etkisiz ve yutan eleman durumlarÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned x, y;

    printf("bir tam sayi giriniz: ");
    scanf("%u%u", &x, &y);

    bprint(x);
    bprint(y);
    bprint(x ^ y);
}
```



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir tam syÄ±nÄ±n kendisiyle `^` iÅŸlemine tabi tutarsak tÃ¼m bitlerin 0 olacaÄŸÄ± gÃ¶rÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned x = 131312;
    bprint(x ^ x);
}
```



Programlama dilinden baÄŸÄ±msÄ±z olarak yazÄ±lÄ±m mÃ¼lakatlarÄ±nÄ±n en klasik sorularÄ±ndan biri gÃ¶rÃ¼lebilir. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki dizide tek bir tam sayÄ± eleman haricinde diÄŸer tam sayÄ± elemanlar ikizdir(o tam sayÄ±dan sadece iki tane vardÄ±r), dizideki ikizi olmayan elemanÄ± tespit ediniz.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    int ar[] = { 2, 7, 9, 5, 7, 8, -3, 2, 9, -3, 5 };

    unsigned int result = 0;

    for(size_t i = 0; i < ASIZE(ar); ++i){
        result ^= ar[i];
        bprint(result);
        (void)getchar(); // Ä°nceleyebilmek iÃ§in program burada durduruluyor.
    }

    printf("%u\n", rasult);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan `x` ve `y` deÄŸiÅŸkenlerinin deÄŸerleri ne olursa olsun iki defa xor iÅŸlemine tabi tutulduÄŸunda iÅŸlem uygulanan deÄŸiÅŸkenin ilk deÄŸerine dÃ¶ndÃ¼ÄŸÃ¼ gÃ¶rÃ¼lmelidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned x = 87234u;
    unsigned y = 9834543u;

    printf("x = %u", x);
    x ^= y;
    printf("x = %u", x);
    x ^= y;
    printf("x = %u", x);
    
}
```



ğŸ“Œ BazÄ± basit ÅŸifreleme algoritmalarÄ±nda rastgele sayÄ± Ã¼reten bir algoritmayÄ± kullanarak dosyanÄ±n her bir byte deÄŸeri Ã¼retilen rastgele sayÄ± zincirindeki bir deÄŸer ile sÄ±rayla xor iÅŸlemine tabi tutulur ve bÃ¶ylece ÅŸifrelenmiÅŸ olur, ÅŸifreyi Ã§Ã¶zmek iÃ§in de aynÄ± tohum deÄŸeri ile aynÄ± rastgele sayÄ± Ã¼reten algoritmanÄ±n deÄŸerlerinin sÄ±rasÄ±yla dosyanÄ±n byte deÄŸerleriyle xor iÅŸlemine sokulmasÄ± sonucunda ÅŸifre Ã§Ã¶zÃ¼lmÃ¼ÅŸ olur.



MÃ¼laktlarda sorulan bir soru, iki tam sayÄ± deÄŸiÅŸkeni Ã¼Ã§Ã¼ncÃ¼ bir deÄŸiÅŸken kullanmadan takas ediniz biÃ§imindedir. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki program iki tam sayÄ± deÄŸiÅŸkenin Ã¼Ã§Ã¼ncÃ¼ bir deÄŸiÅŸken kullanÄ±lmadan nasÄ±l takas edildiÄŸini gÃ¶rmek iÃ§in incelenebilir, bu iÅŸlemi programcÄ±lar genellikle **xor swap** olarak adlandÄ±rÄ±yorlar.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned x, y;

    printf("bir tam sayi giriniz: ");
    scanf("%u%u", &x, &y);

    printf("x = %d   y = %d\n", x, y);

    x ^= y; // 'x = x ^ y'
    y ^= x; // 'y = y ^ x' ya da 'y = x ^ y'
    x ^= y; // 'x = x ^ y'

    printf("x = %d   y = %d\n", x, y);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **xor swap** iÅŸleminin bir makro ile nasÄ±l kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

#define XORSWAP(a, b)   ((a) ^= (b), (b) ^= (a), (a) ^= (b))

int main(void)
{
    unsigned x, y;

    printf("bir tam sayi giriniz: ");
    scanf("%u%u", &x, &y);

    printf("x = %d y = %d\n", x, y);

    XORSWAP(x, y);

    printf("x = %d y = %d\n", x, y);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda aynÄ± nesnenin **xor swap** iÅŸlemine tabi tutulmasÄ± sonucunda ilgili tam sayÄ± nesnesinin deÄŸerinin 0 olacaÄŸÄ± gÃ¶zlemlenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

#define XORSWAP(a, b)   ((a) ^= (b), (b) ^= (a), (a) ^= (b))

int main(void)
{
    int x = 10;
    int* p1 = &x;
    int* p2 = &x;

    XORSWAP(*p1, *p2); // Burada makroya geÃ§ilen iki nesne aynÄ± nesne olduÄŸu iÃ§in ve tÃ¼m bitlerin aynÄ± olmasÄ± durumunda yapÄ±lacak xor iÅŸleminin sonucunda tÃ¼m bitler 0 olacaÄŸÄ± iÃ§in sayÄ±yÄ± sÄ±fÄ±rlamÄ±ÅŸ oluruz.

    printf("x = %d\n", x);
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 21.02-21.21 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


## Bitsel OperatÃ¶rler Hangi AmaÃ§larla KullanÄ±lÄ±yor


Bitsel operatÃ¶rler aÅŸaÄŸÄ±daki nedenlerle kullanÄ±lmasÄ±yla sÄ±klÄ±kla karÅŸÄ±laÅŸÄ±lmaktadÄ±r;
1. Bir tam sayÄ±nÄ±n bir bitini belirlemek(**To set the bit**, **To turn the bit**)
2. Bir tam sayÄ±nÄ±n bir bitini sÄ±fÄ±rlamak(**To reset the bit**, **To clear the bit**)
3. Bir tam sayÄ±nÄ±n bir bitini deÄŸiÅŸtirmek(**To tootgle the bit**, **To flip the bit**)
4. Bir tam sayÄ±nÄ±n bir bitini sÄ±namak yani 1 mi yoksa 0 mÄ± olduÄŸunu Ã¶ÄŸrenmek(**To get the bit**, **To test the bit**)


### Bir tam sayÄ±nÄ±n bir bitini belirlemek(**To set the bit**, **To turn the bit**)

â—â—â— Mesela bir tam sayÄ±nÄ±n 5. bitini 1 yapmak iÃ§in o sayÄ±yÄ±, sadece 5. biti 1 olan bir sayÄ±yla **bitsel veya(bitwise or)** iÅŸlemine tabi tutmak yeterli olacaktÄ±r;
- `0010'0101'1110'0110'1100'1101'1110'1011` --> 5. bitini 1 yapmak istediÄŸimiz tam sayÄ±nÄ±n bit dizilimi.
- `0000'0000'0000'0000'0000'0000'0010'0000` --> Sadece tek bir biti 1 diÄŸer bitleri 0 olan tam sayÄ±nÄ±n bit dizilimi.
- `0010'0101'1110'0110'1100'1101'1100'1011` --> YukarÄ±daki iki tam sayÄ±nÄ±n **bitsel veya(bitwise or)** iÅŸlemine tabi tutulduktan sonra elde edilen sayÄ±.


**Bitmask**: Bir biti 1 diÄŸer bitleri 0 olan sayÄ±lara verilen addÄ±r.


[21.29:00]
ğŸ‘‡ AÅŸaÄŸÄ±daki programda deÄŸeri 0 olan bir tam sayÄ±nÄ±n istenilen herhangi bir bitinin nasÄ±l 1 yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = 0;
    int n;

    printf("kacinci bit");
    scanf("%d", %n);

    bprint(x);
    bprint(x | (1 << n));
}
```


[21.30:20]
ğŸ‘‡ AÅŸaÄŸÄ±daki programda ilk deÄŸeri 0 olan `unsigned int` tÃ¼rÃ¼nden bir tam sayÄ±nÄ±n sÄ±rayla tÃ¼m bitlerinin nasÄ±l 1 yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <conio.h> // '_getchar' fonksiyonu iÃ§in eklendi.
#include "nutility.h"

int main(void)
{
    unsigned int x = 0;

    for(int i = 0; i < sizeof(int) * 8; ++i){
        x |= (1 << i);
        bprint(x);
        (void)_getchar();
    }
}
```


### Bir tam sayÄ±nÄ±n bir bitini sÄ±fÄ±rlamak(**To reset the bit**, **To clear the bit**) 

â—â—â— Mesela bir tam sayÄ±nÄ±n 5. bitini 0 yapmak iÃ§in o sayÄ±yÄ±, sadece 5. biti 0 olan bir sayÄ±yla **bitsel ve(bitwise and)** iÅŸlemine tabi tutmak yeterli olacaktÄ±r;
- `0010'0101'1110'0110'1100'1101'1110'1011` --> 5. bitini 1 yapmak istediÄŸimiz tam sayÄ±nÄ±n bit dizilimi.
- `1111'1111'1111'1111'1111'1111'1101'1111` --> Sadece tek bir biti 0 diÄŸer bitleri 1 olan tam sayÄ±nÄ±n bit dizilimi, bu tam sayÄ± `0000'0000'0000'0000'0000'0000'0010'0000'` tam sayÄ±sÄ±nÄ±n bitsel deÄŸilidir.
- `0010'0101'1110'0110'1100'1101'1100'1011` --> YukarÄ±daki iki tam sayÄ±nÄ±n **bitsel ve(bitwise and)** iÅŸlemine tabi tutulduktan sonra elde edilen sayÄ±.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda deÄŸeri iÅŸaretsiz bir tam sayÄ±nÄ±n en bÃ¼yÃ¼k deÄŸeri olan bir tam sayÄ±nÄ±n istenilen herhangi bir bitinin nasÄ±l 0 yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <conio.h> // '_getchar' fonksiyonu iÃ§in eklendi.
#include "nutility.h"

int main(void)
{
    unsigned int x = ~0u;
    int n;

    printf("kacinci bit");
    scanf("%d", %n);

    bprint(x);
    bprint(x & ~(1 << n));
}
```


[21.34:30]
ğŸ‘‡ AÅŸaÄŸÄ±daki programda ilk deÄŸeri 0 olan `unsigned int` tÃ¼rÃ¼nden bir tam sayÄ±nÄ±n sÄ±rayla tÃ¼m bitlerinin nasÄ±l 0 yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = ~0u;

    for(int i = 0; i < sizeof(int) * 8; ++i){
        x &= ~(1 << i);
        bprint(x);
        (void)_getchar();
    }
}
```

### Bir tam sayÄ±nÄ±n bir bitini deÄŸiÅŸtirmek(**To tootgle the bit**, **To flip the bit**) 

Bir bit deÄŸerini deÄŸiÅŸtirme iÅŸlemi genel olrak **bitwise NOT** iÅŸlemi olarak bilinmektedir.

â—â—â— Mesela bir tam sayÄ±nÄ±n 5. bitini deÄŸiÅŸtirmek(0 ise 1, 1 ise 0 yapmak) iÃ§in o sayÄ±yÄ±, sadece 5. biti 1 olan bir sayÄ±yla **bitsel Ã¶zelveya(bitwise exor)** iÅŸlemine tabi tutmak yeterli olacaktÄ±r;
- `0010'0101'1110'0110'1100'1101'1110'1011` --> 5. bitini deÄŸiÅŸtirmek istediÄŸimiz tam sayÄ±nÄ±n bit dizilimi.
- `0000'0000'0000'0000'0000'0000'0010'0000` --> Sadece tek bir biti 1 diÄŸer bitleri 0 olan tam sayÄ±nÄ±n bit dizilimi.
- `0010'0101'1110'0110'1100'1101'1100'1011` --> YukarÄ±daki iki tam sayÄ±nÄ±n **bitsel Ã¶zelveya(bitwise exor)** iÅŸlemine tabi tutulduktan sonra elde edilen sayÄ±.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iÅŸaretsiz bir tam sayÄ±nÄ±n sadece 5. bitinin nasÄ±l deÄŸiÅŸtirildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = 0b0010'0101'1110'0110'1100'1101'1110'1011;

    bprint(x);

    bprint(x ^ (1 << 5)); // '1 << 5' bu ifadede deÄŸeri '1' olan 'R-value' varlÄ±ÄŸÄ±n iÅŸlem sÄ±rasÄ±nda 'integral promotiom' ile 'int' tÃ¼rÃ¼ne yÃ¼kseltildiÄŸini 
}
```


### Bir tam sayÄ±nÄ±n bir bitini sÄ±namak yani 1 mi yoksa 0 mÄ± olduÄŸunu Ã¶ÄŸrenmek(**To get the bit**, **To test the bit**) 

â—â—â— Mesela bir tam sayÄ±nÄ±n 5. bitini ne olduÄŸunu Ã¶ÄŸrenmek iÃ§in o sayÄ±yÄ±, sadece 5. biti 1 olan bir sayÄ±yla **bitsel ve(bitwise and)** iÅŸlemine tabi tutmak yeterli olacaktÄ±r;
- `0010'0101'1110'0110'1100'1101'1110'1011` --> 5. bitini deÄŸiÅŸtirmek istediÄŸimiz tam sayÄ±nÄ±n bit dizilimi.
- `0000'0000'0000'0000'0000'0000'0010'0000` --> Sadece tek bir biti 1 diÄŸer bitleri 0 olan tam sayÄ±nÄ±n bit dizilimi.
- `0000'0000'0000'0000'0000'0000'0010'0000` --> YukarÄ±daki iki tam sayÄ±nÄ±n **bitsel ve(bitwise and)** iÅŸlemine tabi tutulduktan sonra elde edilen sayÄ±.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iÅŸaretsiz bir tam sayÄ±nÄ±n bitlerinin ne olduÄŸunun nasÄ±l Ã¶ÄŸrenildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = 0b0010'0101'1110'0110'1100'1101'1110'1011;

    bprint(x);

    int n;

    printf("kacinci bit");
    scanf("%d", %n);

    if(x & (1 << n))
        printf("1\n");
    else
        printf("0\n");
}
```


## Bitsel OperatÃ¶rlerdeki DÃ¶rt Temel Ä°ÅŸlemden Haraketle Daha KarÅŸaÅŸÄ±k Ä°ÅŸlemlerin YapÄ±lmasÄ± 


Bitsel operatÃ¶rlerin kullanÄ±m nedenlerinin hangi bitsel iÅŸlemlerle uygulandÄ±ÄŸÄ±nÄ± aÅŸaÄŸÄ±da Ã¶zetleyelim, aÅŸaÄŸÄ±daki dÃ¶rt temel iÅŸlem ile daha karmaÅŸÄ±k iÅŸlemleri yapabiliriz;
1. Bir tam sayÄ±nÄ±n bir bitini belirlemek(**To set the bit**, **To turn the bit**) iÃ§in: `x |= (1 << n)` ifadesi kullanÄ±lÄ±r, buradaki `n` bir sabit tam sayÄ± deÄŸeridir.
2. Bir tam sayÄ±nÄ±n bir bitini sÄ±fÄ±rlamak(**To reset the bit**, **To clear the bit**) iÃ§in: `x &= ~(1 << n)` ifadesi kullanÄ±lÄ±r, buradaki `n` bir sabit tam sayÄ± deÄŸeridir.
3. Bir tam sayÄ±nÄ±n bir bitini deÄŸiÅŸtirmek(**To tootgle the bit**, **To flip the bit**) iÃ§in: `x ^= ~(1 << n)` ifadesi kullanÄ±lÄ±r, buradaki `n` bir sabit tam sayÄ± deÄŸeridir.
4. Bir tam sayÄ±nÄ±n bir bitini sÄ±namak yani 1 mi yoksa 0 mÄ± olduÄŸunu Ã¶ÄŸrenmek(**To get the bit**, **To test the bit**) iÃ§in: `if(x &= (1 << n))` ifadesi kullanÄ±lÄ±r, buradaki `n` bir sabit tam sayÄ± deÄŸeridir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir tam sayÄ±nÄ±n tek/Ã§ift sÄ±namasÄ±nÄ±n iki farklÄ± biÃ§imde nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int x = 5;

    if(x % 2 != 0)
        printf("tek sayi\n");

    if(x & 1)
        printf("tek sayi\n");
}
```



MÃ¼lakatlarda sÄ±k sorulan bir soru olarak, bir tam sayÄ±nÄ±n bitlerini yazdÄ±ran bir fonksiyon yazÄ±nÄ±z. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir tam sayÄ±nÄ±n bitlerini yazdÄ±ran bir fonksiyon nasÄ±l olabileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"


void bitprint(unsigned int x)
{
    // 'CHAR_BIT' object-like makrosu 'limits.h' baÅŸlÄ±k dosyasÄ±nda bulunan ve sistemdeki 1 byte'ta bulunan bit sayÄ±sÄ±nÄ± tutmaktadÄ±r.
    for(int i = sizeof(int) * CHAR_BIT - 1; i >= 0; --i){
        putchar(x >> i & 1 ? '1' : '0');
    }
    putchar('\n');
}


void bitprint2(unsigned int x)
{
    unsigned int mask = ~(~0u >> 1);

    while(mask){
        putchar(mask & x ? '1' : '0');
        mask >>= 1; 
    }
    putchar("\n");
}


int main(void)
{
    unsigned x;
    printf("bir tam sayi giriniz: ");
    scanf("%zu", &x);

    bprint(x);
    bitprint(x); 
    bitprint2(x);
}
```



En Ã§ok yapÄ±lan iÅŸlemlerden biri bir tam sayÄ±nÄ±n 1 olan bitlerini sayma iÅŸlemidir. </br>
Bu iÅŸlemi yapmak iÃ§in **Kernighan Algorithm** algoritmasÄ± var, bu algoritma Ã§ok zekice veÃ§ok hÄ±zlÄ± Ã§alÄ±ÅŸÄ±yor.



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir tam sayÄ±daki kaÃ§ bitin 1 deÄŸerinde olduÄŸunun nasÄ±l hesaplandÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

// Parametre olarak aldÄ±ÄŸÄ± iÅŸaretsiz bir tam sayÄ±nÄ±n kaÃ§ bitinin 1 olduÄŸu bilgisini geriye dÃ¶ndÃ¼ren fonksiyon.
void sbc1(unsigned int x)
{
    unsigned int mask = ~(~0u >> 1);
    int count = 0;

    while(mask){
        if(mask & x);
            ++count;
        mask >>= 1;
    }
}

// Parametre olarak aldÄ±ÄŸÄ± iÅŸaretsiz bir tam sayÄ±nÄ±n kaÃ§ bitinin 1 olduÄŸu bilgisini geriye dÃ¶ndÃ¼ren fonksiyon(Kernighan Algorithm kullanÄ±lÄ±yor).
void sbc2(unsigned int x)
{
    int cnt = 0;

    while(x){
        ++cnt;
        x &= (x - 1); // Burada sayÄ± kendisinin bir eksiÄŸi ile ve iÅŸlemine tabi tutulduÄŸunda her dÃ¶ngÃ¼ adÄ±mÄ±nda sayÄ±nÄ±n bitlerindeki bir tane 1 biti 0 olarak deÄŸiÅŸmektedir.
    }

    return cnt;
}


int main(void)
{
    unsigned x;
    printf("bir tam sayi giriniz: ");
    scanf("%zu", &x);

    bprint(x);
    
    printf("%d biti 1\n", sbc1(x));
    printf("%d biti 1\n", sbc2(x));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda maskelerin deÄŸerinin ne olduÄŸu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

#define MASK1   (1 << 5) // Buradaki makronun deÄŸeri `0000'0000'0000'0000'0000'0000'0010'0000` olacaktÄ±r.
#define MASK2   (1 << 9) // Buradaki makronun deÄŸeri `0000'0000'0000'0000'0000'0010'0000'0000` olacaktÄ±r.

int main(void)
{
    unsigned int x = 0;

    // AÅŸaÄŸÄ±daki Ã¼Ã§ fonksiyon Ã§aÄŸrÄ±sÄ± ile makrolarÄ±n deÄŸerlerinin bitsel gÃ¶rÃ¼nÃ¼mÃ¼ yazdÄ±rÄ±lmaktadÄ±r.
    bprint(MASK1);
    bprint(MASK2);
    bprint(MASK1 | MASK2);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda maskeler kullanÄ±larak bir sayÄ±nÄ±n bitlerinin nasÄ±l 1 yapÄ±labildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

#define MASK1   (1 << 5) // Buradaki makronun deÄŸeri `0000'0000'0000'0000'0000'0000'0010'0000` olacaktÄ±r.
#define MASK2   (1 << 9) // Buradaki makronun deÄŸeri `0000'0000'0000'0000'0000'0010'0000'0000` olacaktÄ±r.

int main(void)
{
    unsigned int x = 0;

    x |= (MASK1 | MASK2);

    bprint(x); // x deÄŸiÅŸkeninin deÄŸeri `0000'0000'0000'0000'0000'0010'0010'0000` olacaktÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda, elinizde 16 bitlik tam sayÄ± var ve ortadaki iki byte'Ä±nÄ±n elde edilmesi isteniyorsa bu byte'larÄ±n nasÄ±l elde edilebileceÄŸi incelenebilir.  
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = 0b1010'0111'0011'0100;

    bprint(x << 4 >> 8); // Burada ilk Ã¶nce sayÄ± 4 bit saÄŸa kaydÄ±rÄ±lÄ±yor ve en yÃ¼ksek anlamlÄ± byte'Ä±ndan kurtulunuyor, ardÄ±ndan 8 bit saÄŸa kaydÄ±rÄ±larak deÄŸeri Ã¶ÄŸrenilmek istenilen byte'lar en dÃ¼ÅŸÃ¼n anlamlÄ± byte'lara alÄ±nmÄ±ÅŸ oluyor.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda, elinizde 16 bitlik tam sayÄ± var ve bu sayÄ±nÄ±n en dÃ¼ÅŸÃ¼k anlamlÄ± dÃ¶rt bitini almak istiyorsa bunun iÃ§in nasÄ±l bir iÅŸlem yapÄ±lmasÄ± gerektiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = 8723423u;

    bprint(x);

    bprint(x & 15); // Burada sayÄ± son dÃ¶rt biti bir olan sayÄ± ile bitsel ve iÅŸlemine tabi tutulursa sonuÃ§ olarak sayÄ±nÄ±n en dÃ¼ÅŸÃ¼k anlamlÄ± dÃ¶rt biti elde edilmiÅŸ olur.
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda, elinizde 16 bitlik tam sayÄ± var ve bu sayÄ±nÄ±n en dÃ¼ÅŸÃ¼k anlamlÄ± dÃ¶rt bitini almak istiyorsa bunun iÃ§in nasÄ±l bir iÅŸlem yapÄ±lmasÄ± gerektiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = 1034509u;

    // AÅŸaÄŸÄ±daki fonksiyon Ã§aÄŸrÄ±larÄ± standart Ã§Ä±ktÄ± akÄ±mÄ±na aÅŸaÄŸÄ±daki veriyi gÃ¶nderecektir.
    // 00000000000011111100100100001101
    // 00000000000000000000000011111111
    // 00000000000000000000000000001101
    bprint(x);
    bprint((unsigned int)255);
    bprint(x & 255); // Burada iÅŸlemle sayÄ±nÄ±n ilk byte'Ä± elde ediliyor.
}
```



> â” 
> 
> Sorulan soru;
> 
> Derleyicinin desteklemedigi durumlarda decimal yazilan sayinin binary halini okunabilrlik acisindan comment satirina yazmak bad practice msisidir?
> 
> Cevap;
>
> 2 tabanda yazmak yerine 16 tabanÄ±nda yazmayÄ± tercih etmek daha iyi bir yaklaÅŸÄ±m olacaktÄ±r, 2 tabanÄ± gÃ¶sterini hem standard'ta yok hem de okunmasÄ± zor, 16 tabanÄ± daha kolay okunabiliyor.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda 32 bitlik tam sayÄ±nÄ±n bitlerini lookup table kullanarak nasÄ±l sayÄ±labildiÄŸinin inceleyebilmek iÃ§in lookup table'Ä±n elemanlarÄ±nÄ± oluÅŸturacak program gÃ¶rÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int sbc(int x)
{
    int cnt = 0;

    while(x){
        ++cnt;
        x &= x - 1;
    }

    return cnt;
}

int main(void)
{
    int ary[256];
    
    for(int i = 0; i < 256; ++i){
        if(i && i % 16 == 0)
            printf("\n");
        printf("%d, ", sbc(i));
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda 32 bitlik tam sayÄ±nÄ±n bitlerini lookup table kullanarak nasÄ±l sayÄ±labildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

const int a[] = { 
    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,  
};

int main(void)
{
    unsigned int x;

    printf("tam sayi girin: ");
    scanf("%u", &x);

    bprint(x);
    printf("%d\n", a[x & 255] + a[x >> 8 & 255] + a[x >> 16 & 255] + a[x >> 24 & 255]); // Burada look-up table kullanÄ±larak 'unsigned int' tÃ¼rÃ¼nden bir tam sayÄ±nÄ±n kaÃ§ bitinin bir olduÄŸu hesaplanmÄ±ÅŸ olacak.
}
```


âœï¸ Burada `nutility` adÄ±ndaki kendi modÃ¼lÃ¼mÃ¼ze rastgele ad ve soyad soyad Ã¼retecek ayrÄ± ayrÄ± iki fonksiyon ekliyoruz.
```C
// YazÄ±lan 'nutility.h' dosyasÄ±na eklenenler.

#define SETBITCNT       (sbc_[(x) & 255] + sbc_[(x) >> 8 & 255] + sbc_[(x) >> 16 & 255] + sbc_[(x) >> 24 & 255])

extern const int sbc_[]; // Dizi adÄ± "Set Bit Count" sÃ¶zcÃ¼klerinden gelmektedir.
```


```C
// YazÄ±lan 'nutility.c' dosyasÄ±na eklenenler.

const int sbc_[] = { 
    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,  
};
```


> â” 
> 
> Sorulan soru;
> 
> Bu diziyi calisma zamaninda olustursak, diger dosyalarla paylasma sansimiz olmuyor gibi degil mi hocam?
> 
> Cevap;
> 
> ÅÃ¶yle olabilir `external` bir deÄŸiÅŸken kullanÄ±labilir ve diÄŸer kaynak dosyalar bu `external` deÄŸiÅŸken pointer deÄŸiÅŸkene eriÅŸir(bunun nasÄ±l yapÄ±lacaÄŸÄ± baÅŸka bir derste analtÄ±labilir), program Ã§alÄ±ÅŸmaya baÅŸladÄ±ÄŸÄ±nda Ã¶nce o pointer kendi deÄŸerini alÄ±r(yani look-up table'o o pointer gÃ¶sterir) ve bu `external` pointer deÄŸiÅŸken vasÄ±tasÄ± ile diÄŸer kaynak dosyalar da o look-up tanle'a eriÅŸebilir. </br>
> Burada main fonskiyonu Ã§alÄ±ÅŸmaya baÅŸladÄ±ÄŸÄ±nda ilk iÅŸ olarak o dinamik dizinin oluÅŸturulmasÄ± gerekiyor, bunu yapmanÄ±n da yÃ¶ntemleri var.


Ders sonu ...
