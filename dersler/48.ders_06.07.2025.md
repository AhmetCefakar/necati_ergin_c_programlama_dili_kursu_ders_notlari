# 48.Ders 06.07.2025 🕘

Derse 5(09:02)-7(09:05)-9(09:18)-10(09:22)-11(09:35)-12(09:55)-12(10:05)-11(10:25)-11(10:50)-12(11:30)-13(11:41)-13(12:05)-11(12:52) kişi katıldı.
---


Bir önceki derste kendi `date` kütüphenemizi oluşturmuştuk, bu derste de bir önceki derste yazılan kütüphanemizi tamamlayacağız.



👇 Aşağıdaki programdan `set_date` fonksiyonunun nasıl sınandığı görülebilir.
```C
#include "date.h"
#include <stdio.h>

int main(void)
{
    Date date1;

    if(set_date(&date1, 29, 2, 2017) == NULL){
        printf("gecersiz bir tarih.\n");
        return 1;
    }

    printf("gecerli bir tarih.\n"); // Burada gizli 'else' kullanımı vardır.
}
```


✍️ Burada `date` adındaki kendi modülümüzün kaynak dosyasını yazmaya aşağıdaki gibi devam ediyoruz.
```C
#define _CRT_SECURE_NO_WARNINGS

#include "date.h"
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h> // İlk olarak 'atoi' fonksiyonunu kullanmak için eklendi.
#include <time.h>

#define YEARBASE            1900
#define PRIVATE             static
#define PUBLIC              
#define RANDOM_YEAR_MIN     1950
#define RANDOM_YEAR_MAX     2024

#define ISLEAP(Y)           (((Y) % 4 == 0) && ( ((Y) % 100 != 0) || ((Y) % 400 == 0)))
#define MONTHDAYS(Y, M)     (daytabs[ISLEAP(Y)][M])

#define GET_YEAR(D)         ((D).y_)
#define GET_MOUNT(D)        ((D).m_)
#define GET_MOUNT_DAY(D)    ((D).d_)


PRIVATE const int daytabs[][13] = {
    { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
    { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
};

// Tanımı aşağıda ama bir çok fonksiyon bu fonksiyonları çağırdığı için fonksiyonların bildirimleri buraya eklenmiştir.
PRIVATE Date* set(Date* p, int d, int m, int y);
PRIVATE int day_of_week(int d, int m, int y);
PRIVATE bool is_valid_date(int d, int m, int y);
PRIVATE int totaldays(const Date* p);
PRIVATE Date* from_tdays_to_date(Date* p, int tdays);


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Set functions(mutaters)

PUBLIC Date* set_date(Date* p, int d, int m, int y)
{
    return set(p, d, m, y);
}


// Kendisine geçilen yazı formatındaki 'pstr' nesnesini(object) ki "14-06-2021" benzeri bir tarih değeri geçilecek, 'Date' türüne dönüştürüp geriye dönmektedir. 
PUBLIC Date* set_date_str(Date* p, const char* pstr)
{
    int d = atoi(pstr);
    int m = atoi(pstr + 3);
    int y = atoi(pstr + 6);

    return set(p, d, m, y);
}



PUBLIC Date* set_date_today(Date* p)
{
    time_t sec;
    time(&sec);
    struct tm* tp = localtime(&sec);

    int d = tp->tm_mday;
    int m = tp->tm_mon + 1; // 'struct tm' türünde ay bilgisi indeks olarak '0'dan başlıyor. 
    int y = tp->tm_year + 1900; // 'struct tm' türündeki yıl bilgisi '1900' yılından sonrası için tutuluyor. 

    return set(p, d, m, y);
}



PUBLIC Date* set_random_date(Date* p)
{
    int y = rand() % (RANDOM_YEAR_MAX - RANDOM_YEAR_MIN + 1) + RANDOM_YEAR_MIN;
    int m = rand() % 12 + 1;

    int d = rand() % MONTHDAYS(y, m) + 1;

    return set(p, d, m, y);
}


PUBLIC Date* set_year(Date* p, int y)
{
    return set(p, GET_MONTH_DAY(*p), GET_MOUNT(*p), y);
}

PUBLIC Date* set_month(Date* p, int m)
{
    return set(p, GET_MONTH_DAY(*p), m, GET_YEAR(*p));
}

PUBLIC Date* set_month_day(Date* p, int d)
{
    return set(p, d, GET_MOUNT(*p), GET_YEAR(*p));
}


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Get functions, getters, accessors

PUBLIC int get_week_day(const Date* p)
{
    return day_of_week(GET_MOUNT_DAY(*p), GET_MOUNT(*p), GET_YEAR(*p));
}

//  
// Girilen tarihin yılın kaçıncı günü olduğu bilgisini geriye dönen fonksiyon
PUBLIC int get_year_day(const Date* p)
{
    int sum = GET_MOUNT_DAY(*p); // Bulunulan ayın kaçıncı günü olduğu bilgisi 'sum' değişkenine alınıyor.
    int m = GET_MOUNT(*p);
    int y = GET_YEAR(*p);

    for(int i = 1; i < m; ++i)
        sum += MONTHDAYS(y, i);
    
    return sum;
}


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Formatet input-output functions



PUBLIC void print_date(const Date* p)
{
    // Ayları dizinin indis değeriyle eşitlemek için dizinin 0. elemanı boş yazı yapılıyor.
    static const char* const pmons[] = { "", "Ocak", "Subat", "Mart", "Nisan", "Mayis", "Haziran", "Temmuz", "Agustos", "Eylul", "Ekim", "Kasim", "Aralik", };
    
    static const char* const pdays[] = { "Pazar", "Pazartesi", "Sali", "Carsamba", "Persembe", "Cuma", "Cumartesi", };

    printf("%02d %s %d %s\n", GET_MONTH_DAY(*p), pmons[GET_MONTH(*p)], GET_YEAR(*p), pdays[get_week_day(p)]);
}



PUBLIC Date* scan_date(Date* p)
{
    int d, m, y;
    scanf("%d%d%d", d, m, y);
    return set(p, d, m, y);
}


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Utility functions

// İki datihi karşılaştıran fonksiyon. 
int cmp_date(const Date* p1, const Date* p2)
{
    // Sırasıyla yıl, ay ve gün kıyaslaması yapılacak ve bu yöntemle;
    // İlk tarih ikinciden büyükse pozitif değeri geriye döndürülecektir.
    // İlk tarih ikinciden küçükse negatif değeri geriye döndürülecektir.
    // İlk tarih eşitse '0' değeri geriye döndürülecektir.

    int y1 = GET_YEAR(*p1);
    int y2 = GET_YEAR(*p2);

    if(y1 != y2)
        return y1 - y2;
    
    int m1 = GET_MONTH(*p1);
    int m2 = GET_MONTH(*p2);

    if(m1 != m2)
        return m1 - m2;
    
    return GET_MONTH_Day(*p1) - GET_MONTH_Day(*p2);
}

// İki tarih arasındaki gün farkını hesaplayan fonksiyon. 
PUBLIC date_diff(const Date* p1, const Date* p2)
{
    return totaldays(p1) - totaldays(p2);
}

// Bulunulan tarihten 'n' gün sonraki tarihin ne olacağını hesaplayan fonksiyon. 
PUBLIC Date* ndays_after(Date* pdest, const Date* psource, int n)
{
    return from_tdays_to_date(pdest, totaldays(psource) + n);
}

// Bulunulan tarihten 'n' gün önceki tarihin ne olacağını hesaplayan fonksiyon. 
PUBLIC Date* ndays_before(Date* pdest, const Date* psource, int n)
{
    return from_tdays_to_date(pdest, totaldays(psource) + n);
}


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// PRIVATE functions

PRIVATE Date* set(Date* p, int d, int m, int y)
{
    p->d_ = d;
    p->m_ = m;
    p->y_ = y;

    return p;
}

// Aşağıdaki programda 'Tomahako Sakamota' algoritması kullanılmıştır.
// Bu fonksiyondan geriye dönen değer 0: Pazar, 1: Pazartesi, 2: Sali ... 6: Cumartesi
PRIVATE int day_of_week(int d, int m, int y)
{
    static const int tb[] = { 0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4 };

    if(m < 3)
        --y;
    
    return ((y + y / 4 - y / 100 + y / 400 + tb[m - 1] + d) % 7);
}

PRIVATE bool is_valid_date(int d, int m, int y)
{
    // return y >= YEARBASE && 
    //     m > 0 && m <= 12 && daytabs[ISLEAP(y)][m];

    return y >= YEARBASE && 
        m > 0 && m <= 12 && MONTHDAYS(y, m);
}

// 1 1 YEARBASE'den sonra geçen gün sayısı.  
PRIVATE int totaldays(const Date* p)
{
    int sum = get_year_dat(p); // Fonksiyona geçilen tarihin yılındaki gün sayısı elde ediliyor.
    int y = GET_YEAR(*p); // Fonksiyona geçilen tarihin yılı bilgisi elde ediliyor.

    for(int i = YEARBASE; i < y; ++i){
        sum += ISLEAP(i) ? 366 : 365;
    }

    return sum;
}


// 'tdays' değeriyle çeçilen gün sayısı '1.1.1900' tarihinden sonra geçen gün sayısı olarak kabul edilip o günün tarihini geriye döndüren fonksiyon. 
PRIVATE Date* from_tdays_to_date(Date* p, int tdays)
{
    int y = YEARBASE;

    while(tdays > (ISLEAP(y) ? 366 : 365)){
        tdays -= ISLEAP(y) ? 366 : 365;
        ++y;
    }

    int m = 1;

    while(tdays > MONTHDAYS(y, m)){
        tdays -= MONTHDAYS(y, m);
        ++m;
    }

    int d = tdays;

    return set(p, d, m, y);
}
```



👇 Aşağıdaki program `get_year_day` fonksiyonunu sınamak için yazılmıştır.
```C
#define _CRT_SECURE_NO_WARNINGS

#include "date.h"
#include <stdio.h>

int main(void)
{
    Date date1;

    set_date(&date1, 31, 1, 2025);
    printf("%d\n", get_year_day(&date1)); // '31' çıktısı üretilmeli
    
    set_date(&date1, 31, 12, 2025);
    printf("%d\n", get_year_day(&date1)); // '365' çıktısı üretilmeli

    set_date(&date1, 31, 12, 2028);
    printf("%d\n", get_year_day(&date1)); // '366' çıktısı üretilmeli
}
```



👇 Aşağıdaki program `print_date` fonksiyonunu sınamak için yazılmıştır.
```C
#define _CRT_SECURE_NO_WARNINGS

#include "date.h"
#include <stdio.h>

int main(void)
{
    Date date1;

    set_date(&date1, 31, 12, 2028);
    print_date(&date1); // '31 Aralik 2028' çıktısı üretilmeli
    
    set_date_today(&date1);
    print_date(&date1); // Programın çalıştırılacağı tarihin çıktısı üretilmeli
}
```



👇 Aşağıdaki program `scan_date` fonksiyonunu sınamak için yazılmıştır.
```C
#define _CRT_SECURE_NO_WARNINGS

#include "date.h"
#include <stdio.h>

int main(void)
{
    Date date1;

    printdf("dogum yilinizi giriniz: ");
    scan_date(&date1);
    print_date(&date1);
}
```



👇 Aşağıdaki programda yazdığımız `date` kütüphene modülünüdeki `set_date`, `set_date_str`, `set_year`, `set_month`, `set_month_day` fonksiyonları sınamak için yazılanlar görülebilir.
```C
#include "date.h"

int main(void)
{
    Date date1;
    set_date(&date1, 5, 6, 1955);
    print_date(&date1);
    set_date_str(&date1, "02-09-2044");
    print_date(&date1);

    set_year(&date1, 1994);
    print_date(&date1);
    set_month(&date1, 11);
    print_date(&date1);
    set_month_day(&date1, 24);
}
```



👇 Aşağıdaki programda `date.h` dosyasındaki `set_random_date` fonksiyonunu sınamak için yazılmıştır.
```C
#include "date.h"

int main(void)
{
    // Aşağıdaki döngü çalıştığında rastgele 'dd MonthDay yyy Day' biçiminde tarihlerin çıktı olarak üretiliyor olması gerekiyor.
    for(int i = 0; i < 100; ++i){
        Date x;
        set_random_date(&x);
        print_date(&x);
    } 
}
```


[10:01:45-10-09-00]
👇 Aşağıdaki programda `date.h` dosyasındaki `print_date`, `cmp_date`, `set_random_date` fonksiyonlarının nasıl sınandığı incelenebilir. </br> 
Bu programda önceden öğrendiğimiz dilin araçlarını kullanacağız. 
```C
#include "date.h"
#include <stdio.h>
#include <stdlib.h> // 'qsort' fonksiyonunu kullanmak için eklenen başlık dosyası.
#include <time.h> // İşlem süresini ölçmek için eklenen başlık dosyası.
#include <conio.h> // Standart olmayan bir modül


// cmp_date fonksiyonunu sınamak icin aşağıdaki işlemleri afım adım yazalım;
// a) Dinamik bir 'Date' dizisini oluştur
// b) Dizinin elemanlarını rastgele değerler ile doldur.
// c) Diziyi standart C fonksiyonu olan 'qsort' ile küçükten büyüğe doğru sırala.
// d) Sıralanmış diziyi standar output'a gönder.
// e) dizinin bellek alanını serbest bırak.


// 'qsort' fonksiyonu için kullanılan sarmalayıcı fonksiyon.
static int wdcmp(const void* vp1, const void* vp2)
{
    return cmp_date((const void*)vp1, (const void*)vp2);
}


// Elemanları 'Date' türünden olan bir diziyi rastgele değerlerle dolduran bir fonksiyon, bunu cliend code kendi yazıyor.
// Aşağıdaki fonksiyonda 'int', 'double' vb. türlerden dizilerle birlikte nasıl gösterici aritmetiği kullanıldıysa burada da yapı türünden bir dizi için gösterici aritmetiği kullanılmıştır.
Date* set_date_array(Date* p, size_t size)
{
    Date* ptemp = p; // Burada fonksiyondan geriye döndürülecek olan dizinin adresinin kaybedilmemesi için o adres değerinin 'ptemp' değişkenine ilk değer olarak veriliyor.

    // Aşağıdaki döngü dizinin elemana sayısı kadar dönecektir.
    while(size--){
        set_random_date(p++);
    }

    return ptemp;
}

// Elemanları 'Date' türünden olan bir diziyi 'print_date' fonksiyonu ile formatlı olarak standart çıktı akımına gönderen fonksiyon.
void print_date_array(const Date* p, size_t size)
{
    while(size--){
        print_date(p++);
    }
}


int main(void)
{
    size_t size;

    printf("kac elemanli bir dizi olsun: ");
    scanf("%zu", &size);

    Date* pd = (Date*)malloc(size * sizeof(Date));
    if(!pd){
        fprintf(stderr, "bellek yetersiz!\n"); // bu fonkisyon çağrısına sonradan değinilecek. 
        return 1;
    }

    set_date_array(pd, size); // Bir önceki derste yazılmış olan sınama kodunda buradaki fonksiyon çağrısının yazılması unutulmuş, şimdi ekliyoruz.

    printf("siralama basladi.\n");
    clock_t start = clock();
    qsort(pd, size, sizeof(*pd), &wdcmp);
    clock_t end = clock();
    printf("siralama bitti %.2f saniye.\n", (double)(end - start) / CLOCKS_PER_SEC);
    _getch(); // Programı burada durdurmak için kullanılan 'conio.h' modülündeki standart olmayan fonksiyon çağrısı yapılıyor.
    print_date_array(pd, size); 

    free(pd);
}
```



👇 Aşağıda programdan `data.h` dosyasındaki `date_diff` fonksiyonunun nasıl sınandığı görülebilir.
```C
#include "date.h"
#include <stdio.h>

int main(void)
{
    Date bdate;

    printf("bedenlenis tarihinizi giriniz: ");
    scan_date(&bdate);
    printf("bedenlenis tarihiniz: ");
    print_date(&bdate);

    Date today;
    set_date_today(&today);
    printf("bugunun tarihi: ");
    print_date(&today);
    printf("bugun varolusunuzun %d. gunu, anlamini bulabildin mi?\n", date_diff(&today, &bdate));
}
```



👇 Aşağıdaki programdan `data.h` dosyasındaki `ndays_after` fonksiyonunun nasıl test edildiği görülebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include "date.h"
#include <stdio.h>

int main(void)
{
    printf("bugunden kac gun sonrasi: ");
    int n;
    scan_date("%d", n);

    Date today;
    set_date_today(&today);
    printf("bugun: ");
    print_date(&today);

    Date future_date;
    ndays_after(&future_date, &today, n);
    print_date(&future_date);
}
```


***
==================================================

✦✦✦✦✦ 10.30-10.50 birinci ara verildi. ✦✦✦✦✦

==================================================
***


## Yapıların Elemanlarının Yapı Türlerinden Olması 

Programlamada bir **kullanıcı tanımlı türün(user defined type)** elemanının yine başka bir **kullanıcı tanımlı türün(user defined type)** olmasına **composition** denilmektedir.


👇 Aşağıdaki programdan yapı türünden üyeye sahip bir yapının bellek boyutunun ne olcağı incelenebilir.
```C
#include <stdio.h>

struct Member {
    int x, y, z;
};

// Aşağıdaki 'struct Owner' türünün bir elemanı başka bir yapı olan 'struct Member' yapı türünden değişkene sahiptir.
struct Owner {
    int a, b;
    struct Member mx;
};

int main(void)
{
    printf("sizeof(struct Member) = %zu", sizeof(struct Member));
    printf("sizeof(struct Owner) = %zu", sizeof(struct Owner));
}
```


⚠️ Bu başlıktaki bundan sonra yazılan programların herbiri önemlidir, dikkatle incelenmeli ve özümsenmelidir.



👇 Aşağıdaki programdan yapı türünden üyeye sahip bir yapının elemanlarına nasıl erişilebileceği incelenebilir.
```C
#include <stdio.h>


struct Member {
    int x, y, z;
};

struct Owner {
    int a, b;
    struct Member mx;
};


int main(void)
{
    struct Owner x;

    // 'x' ifadesinin türü 'struct Owner' türüdür ve bu ifade 'L-value' özelliktedir.
    // 'x.a' ifadesinin türü 'int' türüdür ve bu ifade 'L-value' özelliktedir.
    // 'x.mx' ifadesinin türü 'struct Member' türüdür ve bu ifade 'L-value' özelliktedir.

    // Aşağıdaki atama işlemlerinin sol operantlarındaki ifadelerde birden fazla '.' operatörü kullanıldığı görülecektir, bazı ifadelerde 'n' tane '.' operatörü kullanıldığı durumlarla karşılaşılabilir.
    x.mx.z = 5;
    (x.mx).z = 5; // Buradaki statament bir üstteki statement ile denktir.
}
```



👇 Aşağıdaki programdan yapı türünden üyeye sahip bir yapıya nasıl ilk değer verilebileceği incelenebilir.
```C
#include <stdio.h>

struct Member {
    int x, y, z;
};

struct Owner {
    int a, b;
    struct Member mx;
};


int main(void)
{
    struct Owner s1 = { 10, 20, { 3, 4, 6 } };
    struct Owner s2 = { .mx = { 4, 5, 6 } };
}
```



👇 Aşağıdaki programdan yapı türünden üyeye sahip bir yapı türünden olan dizilere nasıl ilk değer verilebileceği incelenebilir.
```C
#include <stdio.h>

struct Member {
    int x, y, z;
};

struct Owner {
    int a, b;
    struct Member mx;
};


int main(void)
{
    struct Owner ar[] = { { 2, 4, {1, 1, 1 } }, { 3, 6, { 2, 2, 2 } } };
    struct Owner ar[10] = { [5] = { .mx = { 2, 1, 0} }, [7] = { 2, 3, { 0, 2, 7 } } }; // 'Designated initializer' ile ilk değer veriliyor.
}
```





👇 Aşağıdaki programdan bir yapı nesnesinin başka bir yapı nesnesinin göstericisi türünden üyeye(kendi türünden göstericiye de sahip olabilir) sahip olabileceği görülmelidir.
```C
#include <stdio.h>

struct Member {
    int x, y, z;
};

struct Owner {
    int a, b;
    struct Member* pm;
};


int main(void)
{
    struct Owner x;
    struct Owner* p = &x;

    // some code here ...

    // Aşağıdaki gibi birden fazla '.' ve '->' operatörü içeren ifadeler kullanılabileceği görülmelidir.
    x.pm->y = 5;
    p->pm->z = 2;
}
```



👇 Aşağıdaki programdan bir yapı nesnesi dizisi nesnesi üzerinden yapı üyelerine nasıl erişilebileceği incelenebilir.
```C
#include <stdio.h>

struct Member {
    int x, y, z;
};

struct Owner {
    int a, b;
    struct Member* pm;
};


int main(void)
{
    struct Owner ar[5];

    // some code here ...

    ar[4].pm->z = 5; // Burada aynı ifade içinde '[]', '.', '->' operatörlerinin kullanılışı incelenebilir.
}
```



👇 Aşağıdaki programdan bir yapı nesnesi üyesinin bir fonksiyon göstericisi olabileceği görülmelidir.
```C
#include <stdio.h>

struct Member {
    int x, y, z;
    int (*fp)(void); // 'fp' adındaki yapı üyesi 'int (*)(void)' türünden bir fonksiyon göstericisidir.
};

struct Owner {
    int a, b;
    struct Member* pm;
};


int main(void)
{
    struct Owner ar[5];

    // some code here ...

    // Ağağıdaki iki ifade de aynı anlama gelmektedir.
    ar[4].pm->fp();
    (((ar[4]).pm)->fp)();
}
```



❗❗❗ Bir yapının elemanı, kendi türünden olamaz, bunun nedeni bu biçimdeki bir kullanımda yapının kendi türünden üyenin **incomplate type** durumunda olmasıdır. </br>
❗❗❗ Bir yapının elemanı, kendi türünden gösterici olabilir.
```C
#include <stdio.h>

struct Nec1 {
    int x, y;
    struct Nec1 nc; // 'struc Nec' is an incomplate type here. Burada sözdizim(syntax) hatası vardır.
};

struct Nec2 {
    int x, y;
    struct Nec2* p; 
};

int main(void)
{
    
}
```


**Self Referential Structures**: Kendi kendisinin göstericisi türünden üyesi olan yapılar için kullanılan bir terimdir, bu terimi C standardı kullanmamaktadır, programcıların yoğun olarak kullandığı bir terimdir.



❗❗❗ Bazı veri yapılarının(linked-list, tree vb.) gerçekleştirimlerinde dinamik olarak oluşturulmuş yapı nesnelerinin kendi türünden bir nesnenin pointer üyesi olduğu durumlar sıklıkla kullanılmaktadır.


**Node(Düğüm)**: Veri yapılarında, dizi veri yapısı türleri dışında kendi türünü bir biçimde göstermesi gereken veri yapısı türlerinde o veri yapısının her bir elemanını belirtmek için kullanılan bir terimdir.



👇 Aşağıdaki programda bir yapı nesnesinin elemanlarından birinin kendi türünün göstericisi olabileceği görülebilir.
```C
#include <stdio.h>

// Aşağıdaki 'struct Node' türüne benzer biçimde kendi türünün gösterisisi türünden üyeye sahip yapılar veri yapılarının gerçekleştirimlerini yaparken sıklıkla kullanılmaktadır.
struct Node {
    int x, y;
    struct Node* p; 
};

int main(void)
{
    struct Node* px;

    px->p;
}
```




⚠️⚠️⚠️ C ve C++ dilleri arasında bazı **sözdizim(syntax)** farklılıkları var.



👇 Aşağıdaki programda iç içe yapı içeren yapı türünden bir türün bellek boyutunun ne olacağı incelenebilir.
```C
#include <stdio.h>

// nested type
// member type
// nested structure
struct Nec {
    int x, y;

    // Aşağıdaki yapı bildiriminde üyenin adı verilmemiştir, bu yapı bildirimi C11 ve sonrası için geçerlidir(C++ dilinde çok öncelerden beri standarttır) ve C11 öncesinde de çoğu derleyicinin extenson olarak desteklediği bir kullanımdır.
    struct Erg {
        int a, b, c;
    };
};

int main(void)
{
    printf("sizeof(struct Erg) = %zu\n", sizeof(struct Erg)); // 32 bitlik sistemde standart çıktı akımına en az(alignment'dan dolayı) 'sizeof(struct Erg) = 12\n' gönderilir.
    printf("sizeof(struct Nec) = %zu\n", sizeof(struct Nec)); // 32 bitlik sistemde standart çıktı akımına en az(alignment'dan dolayı) 'sizeof(struct Nec) = 20\n' gönderilir.
}
```


👇 Aşağıdaki programda iç içe yapı içeren yapı türünün elemanlarına nasıl erişilebildiği incelenebilir.
```C
#include <stdio.h>

struct Nec {
    int x, y;

    // İç yapı bildiriminde, bildirilen yapıdan bir değişken adı belirtilmektedir.
    struct Erg {
        int a, b, c;
    }erg; 
};

int main(void)
{
    struct Nec nec1;

    // 'struct Nec' türünün 'struct Erg' türünden 'erg' üyesi üzerinden 'struct Erg' türünün üyelerine erişilmektedir.
    nec1.erg.a;
    nec1.erg.b;
    nec1.erg.c;
}
```


👇 Aşağıdaki programda iç içe yapı içeren yapı türünün elemanlarına nasıl erişilebildiği incelenebilir.
```C
#include <stdio.h>

struct Nec {
    int x, y;

    // İç yapı bildiriminde, bildirilen yapıdan bir değişken adı belirtilmemektedir.
    struct Erg {
        int a, b, c;
    }; 
};

int main(void)
{
    struct Nec nec1;

    // 'struct Nec' türünün 'struct Erg' türünden 'erg' üyesi üzerinden 'struct Erg' türünün üyelerine erişilmektedir.
    nec1.a;
    nec1.b;
    nec1.c;
}
```



👇 Aşağıdaki programda bir yapının sahip olduğu bir iç yapı türünden üç tane değişken bildirildiğinde en kapsayıcı yapının bellek boyutunun ne olacağı görülebilir.
```C
#include <stdio.h>

struct Nec {
    int x, y;

    struct Erg {
        int a, b, c;
    }e1, e2, e3; 
};

int main(void)
{
    printf("sizeof(struct Nec) = %zu\n", sizeof(struct Nec)); // 32 bitlik sistemde standart çıktı akımına en az(alignment'dan dolayı) 'sizeof(struct Nec) = 44\n' gönderilir.

    struct Nec nec;
    nec.a;
}
```



👇 Aşağıdaki programda bir yapının sahip olduğu bir iç yapı türünden iki tane gösterici değişken bildirildiğinde en kapsayıcı yapının bellek boyutunun ne olacağı görülebilir.
```C
#include <stdio.h>

struct Nec {
    int x, y;

    // Aşağıda 'struct Erg' türünden bir yapıyı gösteren iki farklı değişken bildirilmiştir, her 'object-like pointer' nesnenin bellekte kapladığı alan sabittir, burayı iyi anlamak ve bu projede main fonksiyonunda standart çıktıya gönderilen değeri iyi anlamak gerekiyor.
    struct Erg {
        int a, b, c;
    }*p1, *p2; 
};

int main(void)
{
    printf("sizeof(struct Nec) = %zu\n", sizeof(struct Nec)); // 32 bitlik sistemde standart çıktı akımına en az(alignment'dan dolayı) 'sizeof(struct Nec) = 16\n' gönderilir.
}
```



👇 Aşağıdaki programda iç içe yapı kullanımında içteki yapıya değişken adı verilmediğinde içteki yapının üyelerine nasıl erişildiği incelenebilir.
```C
#include <stdio.h>

struct Nec1 {
    int x, y;

    struct Erg1 {
        int a, b, c;
    }; 
};

struct Nec2 {
    int x, y;

    struct Erg2 {
        int a, b, c;
    }erg; 
};


// int '4 byte' ise 'struct Erg' bellek büyüklüğü en az '12 byte' olacaktır.
// int '4 byte' ise 'struct Nec1' bellek büyüklüğü en az '20 byte' olacaktır.

int main(void)
{
    struct Nec1 nec1;
    nec1.a;
    nec1.b;
    nec1.c;


    struct Nec2 nec2;
    nec2.erg.a;
    nec2.erg.b;
    nec2.erg.c;
}
```



❗❗❗ 👇 Aşağıdaki programda iç içe yapı kullanımının daha sade bir hali incelenebilir.
```C
#include <stdio.h>

struct Nec1 {
    int x, y;

    // Aşağıdaki yapı nested olarak C11 standardından sonra adı olmadan da tanımlanabilmektedir. 
    struct {
        int a, b, c;
    };

    // En önemli soru, peki neden aşağıdaki gibi kullanmıyoruz da yukarıdaki gibi kullanıyoruz, arada ne fark var, bu sorunun cevabını 'union' konusuna gelince öğreneceğiz.
    // struct {
    int a, b, c;
    // }; 
};

// int '4 byte' ise 'struct Erg' bellek büyüklüğü en az '12 byte' olacaktır.
// int '4 byte' ise 'struct Nec1' bellek büyüklüğü en az '20 byte' olacaktır.

int main(void)
{
    printf("sizeof(struct Nec) = %zu\n", sizeof(struct Nec));

    struct Nec1 nec1;
    nec1.a;
    nec1.b;
    nec1.c;
}
```


> ❔ 
> 
> Sorulan soru;
> 
> Peki `struct Nec` türüne ait bir değişken oluşturunca bu 5 değişken için ardışık olarak mı bellekte yer ayrılacak?
> 
> Cevap;
> 
> Bir yapı nesnesinin elemanlarının bellekte sıralı olarak yerleştirileceği kesin olarak dilin standardı tarafından belirtilmiştir.


❗❗❗ C dilinin standardo bir yapının üyelerinin bellekte sıralı olacağını kesin olarak belirtmektedir. </br>
👇 Aşağıdaki programda yukarıdaki kesinliğin doğruluğu görülebilir.
```C
#include <stdio.h>

struct Nec1 {
    int x;
    double y;
    char str[20];
};

int main(void)
{
    struct Nec nec;

    printf("%p\n", &nec.x);
    printf("%p\n", &nec.y);
    printf("%p\n", nec.str); // Burada 'array decay' uygulanıyor ve 'nec.str' ifadesi '&nec.str[0]' ifadesine dönüştürülüyor.

    // Aşağıda yazdırılan iki ifadenin de adresi sayısal olarak aynı olmak zorundadır.
    printf("%p\n", &nec);
    printf("%p\n", &nec.x);
}
```



❗❗❗ 👇 Aşağıdaki programdaki gösterilen **alignment(hizalama)** konusu incelenebilir, bu kavran sonraki derslerde detaylı olarak incelenevektir. 
```C
#include <stdio.h>

struct Nec {
    char c1;
    int i;
    char c2;
};

int main(void)
{
    printf("sizeof(struct Nec) = %zu\n", sizeof(struct Nec)); // Burada 'struct Nec' türünden nesnenin elemanlarının bellekte sıralı olacağı kesin ama 'alignment(hizalama)' durumundan dolayı bellek boyutu beklenenden büyük olabilir.
}
```

**Alignment(hizalama)**: Derleyicilerin yapıların değerlerini daha kolay her tür sabit bir temel veri boyutunda olması için arada bazı türlerden sonra kullanılmayan byte'ların yapı nesnesinin bellek alanına eklenmesi durumuna verilen tanımlamadır.

**Padding Bytes or Hole Bytes**: Alignment(hizalama) durumlarında veri tutulmayan byte alanlarını belirtmek için kullanılan terimdir.



❗❗❗ 👇 Aşağıdaki programda iç içe bildirilen yapılardan iç yapının ad arama(name lookup) işleminde görünür olduğu her yerde de görünür olduğu anlaşılmalıdır.
```C
#include <stdio.h>

struct Nec {
    int x, y;

    struct Erg {
        int a, b, c;
    }e1; 
}

struct Erg e1, e2;  // Bu biçimde değişken bildirimi C dilinde legal ama C++ dilinde legal değildir.

int main(void)
{
    struct Erg x; // Bu biçimde değişken bildirimi C dilinde legal ama C++ dilinde legal değildir.
    struct Erg* ptr;  // Bu biçimde değişken bildirimi C dilinde legal ama C++ dilinde legal değildir.

    // struct Nec::Erg; // Bu kullanım C++ dilinde legaldir.
}
```


## Bir Yapının Elemanının Başka Bir Türden Yapı Olması Durumu 

Bir yapının başka bir yapı türünü içermesi durumuna **composition** deniliyor.


✍️ Burada `Person` adındaki kendi modülümüzün başlık dosyasını aşağıdaki gibi yazıyoruz.
```C
// Yazılan 'person.h' dosyası.

#pragma one // Çoğu derleyicinin desteklediği makro kullanımı.

#include "date.h"

typedef struct{
    int id;
    char name[20];
    char surname[24];
    Date bdate;
}Person;

Person* set_random_person(Person*);
void print_person(const Person*);
int cmp_person(const Person* p1, const Person* p2);
```



✍️ Burada `Person` adındaki kendi modülümüzün kaynak dosyasını aşağıdaki gibi yazıyoruz.
```C
// Yazılan 'person.c' dosyası.

#include "person.h"
#include "nutility.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

Person* set_random_person(Person* p)
{
    p->id = rand() + 1000;
    strcpy(p->name, random_name());
    strcpy(p->surname, random_surname());
    set_random_date(&p->bdate);

    return p;
}

void print_person(const Person* p)
{
    printf("%-8d %-16s %-24s ", p->id, p->name, p->surname);
    print_date(&p->bdate);
}

// İki 'personel' nesnesi kıyaslanırken şu sıraya göre kıyaslama yapılacak: ad, soyad, doğum senesi, id
int cmp_person(const Person* p1, const Person* p2)
{
    int cmp_result = strcmp(p1->name, p2->name);
    if(cmp_result)
        return cmp_result;

    cmp_result = strcmp(p1->surname, p2->surname);
    if(cmp_result)
        return cmp_result;
    
    cmp_result = cmp_date(&p1->bdate, &p2->bdate);
    if(cmp_result)
        return cmp_result;
    
    return p1->id - p2->id;
}
```


✍️ Burada `nutility` adındaki kendi modülümüze rastgele ad ve soyad soyad üretecek ayrı ayrı iki fonksiyon ekliyoruz.
```C
// Yazılan 'nutility.h' dosyasına eklenenler.

#define RANDOM_ELEM(a)      (a[rand() % ASIZE(a)])

const char* random_name(void);
const char* random_surname(void);
```


```C
// Yazılan 'nutility.c' dosyasına eklenenler.

// Rastgele ad verisi almak için kullanılan fonksiyon. 
const char* random_name(void)
{
    static const char* const p[] = {
        "ata", "emrecan", "adem", "burhan", "korhan", "demir", "bilal", "emrecan", "celik", "zahide",
        "dost", "lale", "baran", "saniye", "poyraz", "saadet", "aynur", "yeliz", "berivan", "mukerrem",
        "melih", "necati", "cezmi", "muslum", "azize", "atif", "rupen", "alev", "haldun", "hulusi",
        "yelda", "billur", "yasemin", "tarcan", "yasar", "tarkan", "refik", "berk", "kenan", "izzet",
        "adnan", "sefa", "kazim", "gursel", "huseyin", "suheyla", "binnaz", "nusret", "aykut", "efecan"
        "esra", "tonguc", "kunter", "yurdanur", "abdi", "fugen", "ayse", "aydan", "edip", "nazli",
        "nucahit", "onat", "cumhur", "yalcin", "ziya", "ali", "ismail", "recep", "sarp", "yilmaz",
        "hilal", "atakal", "cemre", "emirhan", "ceylan", "sabriye", "necmettin", "nagehan", "muhsin", "perihan",
        "suleyman", "zeliha", "cahide", "beril", "askin", "zahit", "sevim", "ege", "utku", "ercument",
        "seyhan", "sadegul", "yenes", "sadi", "candan", "cemile", "tansel", "turgut", "sumeyye", "aylin",
        "hakan", "ferhunde", "cebnail", "nihat", "alparslan", "osman", "efa", "ece", "soner", "necmi",
        "polat", "daci", "pelinsu", "keram", "eylul", "beste", "mert", "akin", "kamile", "kerem",
        "bekir", "nalan", "bulent", "tijen", "durmus", "cansu", "sadri", "atil", "yesim", "sevilay",
        "furkan", "ediz", "helin", "sadettin", "gulden", "samet", "binnur", "celal", "murat", "sezer",
        "bilge", "yunus", "cem", "temel", "sefer", "petek", "haluk", "teoman", "aslican", "aycan",
        "azmi", "nazife", "nurullah", "yasin", "nedim", "abdulmuttalip", "gulsen", "devlet", "mahin", "tarik",
        "yurduagul", "nisan", "derya", "emre", "sade", "leyla", "fadime", "tamer", "julide", "busra",
        "feramuz", "dilek", "dilber", "tansu", "abdullah", "mehmet", "nuri", "gizem", "nefes", "yavuz",
        "demet", "zekai", "zerrin", "umit", "gul", "emine", "sezen", "ugur", "turhan", "aziz",
        "tuncer", "handan", "irkam", "lamia", "can", "kelami", "ceyhan", "cahit", "metin", "bilgin",
        "su", "tayyar", "ferhat", "nuriye", "cemal", "engin", "pelin", "yusuf", "garo", "iffet",
        "galip", "deniz", "belgin", "muzaffer", "hiyazi", "kayahar", "hulki", "kaya", "necmiye", "kasim",
        "hulya", "sidre", "esin", "suphi", "cengiz", "olcay", "rumeysa", "tugay", "asim", "yurdakul",
        "feraye", "derin", "cuneyt", "keriman", "nuriye", "esen", "tevfik", "naz", "gurbuz", "cetin",
        "bora", "taci", "sadullah", "gulsah", "menekse", "semsit", "burak", "fikret", "cahan", "ceyda",
        "selenay", "alicap", "figen", "hasullah", "oesim", "zubeyde", "sezai", "melike", "nurdan", "arda",
        "nazif", "fuat", "gunay", "tufan", "fahri", "handesu", "kezban", "halime", "beyhan", "ciler",
        "tayyip", "afacan", "mustafa", "kunthar", "tugra", "ahmet", "hasan", "hakkı", "metin", "dytac",
        "pinat", "selin", "kaan", "melisa", "sevde", "nihal", "nevsin", "pakize", "teslime", "tunc",
        "nahit", "ceyhun", "hismet", "ede", "malik", "ani", "cağan", "egemen", "hande", "hilmı",
        "muvvafet", "cemil", "diana", "tayfun", "zarife", "tekin", "murathan", "caner", "devrim", "agah",
        "kamil", "ayla", "papatya", "kayhan", "durriye", "melek", "tanuj", "sinem", "jade", "sadiye",
        "refika", "birhan", "sami", "orkun", "erdem", "ufuk", "dogan", "atalay", "fazilet",
        "tancer", "polathan", "bennur", "aslihan", "cihat",
    };

    return RANDOM_ELEM(p);
}

// Rastgele soyad verisi almak için kullanılan fonksiyon.
const char* random_surname(void)
{
    static const char* const p[] = {
        "acar", "acgoze", "acuka", "ademoglu", "adiguzel", "agaoglu", "akarsu", "akcalar", "akgunes", "akkay",
        "akkuyu", "aklikit", "aksakal", "akyildiz", "akyoldas", "alemdar", "alniacik", "altindag", "altinsik", "altinorak",
        "arcan", "aslan", "avci", "abyezay", "aylak", "azmak", "bahceli", "bakirci", "baklavaci", "barutcu",
        "baturalp", "bayraktar", "bekar", "belgeli", "beyaz", "bilgic", "bozkaya", "boztas", "canbay", "candamar",
        "cangoz", "cankoc", "canlikaya", "cansever", "cansiz", "celik", "celiker", "cengaver", "cevikkol", "cilingir",
        "comakci", "corbaci", "cubukay", "cuhadar", "daglarca", "damar", "degirmenci", "demirdogen", "demirel", "derin",
        "dingin", "dokmeci", "dokuzcan", "dosteli", "dumbuk", "dunyalik", "ecevit", "edepeli", "edepsiz", "efelik",
        "elebasi", "eliagir", "elibol", "elitemiz", "elkizi", "elmanli", "eloglu", "emirkulu", "engerek", "engereke",
        "erdogan", "ergin", "erim", "ersoy", "ertakan", "esereli", "esendur", "estererli", "etci", "ezgercer",
        "fakir", "fedai", "fincan", "firatonu", "fitrat", "gamsiz", "gedik", "geldik", "gilgamis", "girik",
        "gucusur", "gultekin", "gumus", "gurkas", "hamsikoylu", "harmanci", "haselici", "hepguler", "hurmaci", "iliksiz",
        "issiz", "jilet", "kabasakal", "kadersiz", "kahraman", "kalemsiz", "kalinkas", "kalpsiz", "kalpten", "kapan",
        "kapici", "kaplan", "kara", "karabatur", "karaduman", "karealmas", "karakis", "karakoyun", "karakuzyu", "karamuk",
        "karaorman", "karasaban", "karataban", "karayeyl", "kayabasi", "kazanci", "kecisakal", "kelepce", "kelleci", "keskin",
        "kesman", "kilicdar", "kilimci", "kilinc", "kiriboga", "kircisi", "koygirit", "kolcak", "komcu", "komurcu",
        "konak", "konca", "koralp", "korukcu", "kosnuk", "kotek", "koylu", "kucukkaya", "kulaksiz", "kurban",
        "kurtulus", "kusmen", "lalezar", "lokmaci", "lombak", "lufer", "maganda", "malazgirt", "malkaciran", "mazgirt",
        "merdane", "mertek", "merzifon", "mirza", "miskin", "miskinoglu", "muglali", "nazik", "nurtopu", "olmez",
        "oltu", "onan", "ongun", "ordulu", "ornancan", "ormanci", "ortaca", "osmaneli", "otaci", "ovacik",
        "oztoklu", "ozveneci", "pakdaman", "pirlanta", "polatkan", "portakol", "poturgeli", "reis", "renacan", "resimci",
        "saferikli", "safkan", "salca", "saldiray", "sallabas", "samanci", "saricakir", "sarikafa", "sarpdemir", "savaskan",
        "sefiloglu", "selercan", "semiz", "seney", "serce", "serinsun", "sessiz", "silahdar", "silifkeli", "simsek",
        "sivri", "sofougolu", "sonmez", "sonuzun", "soylu", "soysalan", "soybozuk", "sucu", "sulugoz", "supuren",
        "takes", "tamgun", "tamirci", "tantana", "tarumar", "tekinalp", "tekkaya", "tekkilic", "telek", "temiz",
        "temizel", "temizkalp", "tepecik", "tepsici", "tercan", "terlemez", "tertemiz", "tilki", "tokatci", "tombeki",
        "topatan", "topkapi", "tozkoparan", "tufancan", "tunali", "tuzcu", "tuztas", "ufukcu", "ugursuz", "ulakci",
        "uluocak", "umutsuz", "unalani", "unalmis", "unkapani", "uraz", "uslu", "uyar", "uzay", "uzunadam",
        "yagizeli", "yanardag", "yanardoner", "yangin", "yaracan", "yaradan", "yarama", "yasayavas", "yasli", "yasmek",
        "yavas", "yayasan", "yaygara", "yelden", "yeldirme", "yersiz", "yikilmaz", "yildirim", "yilgin", "yilmaz",
        "yolyapan", "yorganci", "yorgun", "yosun", "yurdakul", "yurekli", "yurekyakan", "yurtsuz", "zaimoglu", "zalim",
        "zengin", "zebani",
    };
    
    return RANDOM_ELEM(p);
}
```



👇 Aşağıdaki programda `person` modülünü sınamak için yapılan işlemler incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"
#include "person.h"

int main(void)
{
    printf("sizeof(Person) = %zu\n", sizeof(Person)); 

    randomize();
    
    Person p;
    set_random_person(&p);
    print_person(&p);

}
```


> ❔ 
> 
> Sorulan soru;
> 
> Bu fonksiyonlari person struct'i icine koyma sansimiz var mi? direkt olmasa da adres olarak?
> 
> Cevap;
> 
> C dilinde bir yapının üyesi bir fonksiyon olamaz. </br>
> Bir yapının elemanı bir fonksiyon göstericisi olabilir ama sadece bunun gerekeceği durumlarda kullanılmalıdır, diğer durumlarda gereksiz yere yapı nesnelerinin boyutu arttırılmış olur.



***
==================================================

✦✦✦✦✦ 12.05-12.15 ikinci ara verildi. ✦✦✦✦✦

==================================================
***



👇 Aşağıdaki program `nutility` modülüne eklenen `random_name` ve `random_surname` fonksiyonlarını sınamak için yapılmıştır.
```C
#include <stdio.h>
#include "nutility.h"
#include "person.h"

int main(void)
{
    randomize();

    for(int i = 0; i < 40; ++i){
        printf("%s %s\n", random_name(), random_name());
    }
}
```



👇 Aşağıdaki program `set_radom_person` fonksiyonunu sınamak için yapılmıştır.
```C
#include <stdio.h>
#include "nutility.h"
#include "person.h"

int main(void)
{
    randomize();

    Person p;

    for(int i = 0; i < 40; ++i){
        set_radom_person(&p);
        print_person(&p);
    }
}
```



👇 Aşağıdaki programda aşağıda listelenen işlemler yapılmıştır;
- 5 milyon elemanlı bir person dizisi oluşturun. 
- Dizinin elemanlarına rastgele değerler verin. 
- Diziyi küçükten büyüğe sıralayın(qsort).
- Sıralama süreci sonunda diziyi yazdırın.
- Dizinin belleğini iade edin.
```C
#include <stdio.h>
#include "nutility.h"
#include "person.h"
#include <stdlib.h>
#include <time.h>


static int wpcmp(const void* vp1, const void* vp2)
{
    return cmp_person((const Person*)vp1, (const Person*)vp2);
}

void set_person_array(const Person* pa, size_t size)
{
    Person* pret = pa;

    while(size--)
        set_random_person(pa++);

    return pret;
}

void print_person_array(const Person* pa, size_t size)
{
    while(size--)
        print_person(pa++);
}

int main(void)
{
    const int array_size = 1'000'000;

    Person* pd = (Person*)malloc(array_size * sizeof(Person));
    if(!pd){
        printf("bellek yetersiz.\n");
        return 1;
    }

    set_person_array(pd, array_size); 

    primtf("siralama basladi.\n");
    clock_t start = clock();
    qsort(pd, array_size, sizeof(Person), &wpcmp);
    printf("siralama bitti %f saniye\n", (double)(clock - start) / CLOCK_PER_SEC);
    (void)getchar(); // programı burada durdurmak için kullanıldı.

    print_person_array(pd, array_size);
}
```



📌 `CLOCK_PER_SEC` standart `time` modülünde bir makrodur, `CLK_TCK` ise Unix türevi işletim sistemlerinde standart olan bir öğedir, bir çok derleyici `CLK_TCK` makrosunu da vermektedir, `CLK_TCK` makrosu çoğu zaman `CLOCK_PER_SEC` makrosuna denktir.


📌 `Person` adındaki modülümüzü **composition** kullanımını anlamak için yazdık.


## Linklist Data Structure(Bağlı Listeler Veri Yapısı) 

📌 Kaliteli bir mülatata girildiğinde hangi programlama dili olursa olsun, programlamayla ilgili sorulardan bağlı listelere ilişkin bir ya da birkaç tane soru sorulur.


**Linked List(Bağlı liste)**: Bu veri yapısı dinamik dizilerden daha az kullanılmakla birlikte kullanılması gereken bir çok yer olduğu görülecektir.

Linked şist(bağlı liste) çeşitleri aşağıdaki gibidir;
- **Signly Linked List(Tekli Bağlı Liste)**
- **Doubly Linked List(Çifte Bağlı Liste)**
- **Rotating Linked List(dairesel bağlı liste)** ya da **Circular Linked List(dairesel bağlı liste)**



👇 Aşağıdaki sözde kodda bir bağlı liste veri yapısının nasıl gezileceği incelenebilir.
```bash

Node* pfirt = ilk_dugum_adresi;

for(Node* p = pfirt; p != NULL; p = p->pnext){
    p->data;
}
```



Bir veri yapısını dolaşmak, gezmek, eleman eleman gezmek anlamına gelen aşağıdaki terimleri bilmelisin;
- **Traverse** fiilinin ad hali **Traversal**
- **Navigate** 
- **Itarete**
- Bir dinamik diziyi dolaşıyorsak **dinamik array treversal** olarak niteleriz.
- Bir bağlı listeyi dolaşıyorsak **linked-list treversal** olarak niteleriz.


👇 Aşağıdaki program **Signly Linked List(Tekli Bağlı Liste)** ve **Doubly Linked List(Çifte Bağlı Liste)** 
```C
typedef struct Node{
    int data;
    struct Node* pnext;
};

typedef struct Node{
    int data;
    struct Node* pnext;
    struct Node* pprev;
};
```


Veri yapıları ve algoritmalar konusuyla ilgili olarak bir mülakatta sorulabilecek en temel sorulardan biri, **dynamic array(dinamik dizi)** ve **linked list(bağlı liste)** veri yapıları arasındaki farkın ne olduğudur.

🧭 1000 tane tam sayı(`int`) dağeri aşağıdaki veri yapılarında tutulduğunda ne gibi bir farklılık olacağı aşağıdan incelenebilir;
1. Bir dinamik dizide;
    - `sizeof(int) * 1000` kadarlık bellek alanı kaplayacaktır.
    - Eleman ekleme ve silme işleminde sürekli bellekten yer alınıp iade edilmesi gerekmemektedir, sadece dizi büyüklüğü değiştiğinde dinamik bellek yönetimi yapılacaktır.
2. Bir tekli bağlı listede;
    - En az `(sizeof(int) * sizeof(pointer)) * 1000` kadarlık bellek alanı kaplayacaktır.
    - Eleman ekleme ve silme işleminde sürekli bellekten yer alınıp iade edilmesi gereken bir veri yapısıdır.
3. Bir çift bağlı listede;
    - En az `(sizeof(int) * (sizeof(pointer) * 2)) * 1000` kadarlık bellek alanı kaplayacaktır.
    - Eleman ekleme ve silme işleminde sürekli bellekten yer alınıp iade edilmesi gereken bir veri yapısıdır.


Ders sonu ...
