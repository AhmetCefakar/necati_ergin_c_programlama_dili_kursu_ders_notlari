# 5.Ders 25.01.2025 ğŸ•˜

Derse 37-35 kiÅŸi katÄ±ldÄ±.

## DeÄŸiÅŸken AdlarÄ±nÄ±n Bildirilmesi

â—â—â— DeÄŸiÅŸken bildirimi iÃ§in aÅŸaÄŸÄ±daki gibi iki yol vardÄ±r; 
1. **Pure Syntax**: `Type variable;` ÅŸeklinde bildirim yapÄ±lÄ±yor.
2. **Initializing Expression(Initializer)**: `Type variable = value;` ÅŸeklinde bildirim yapÄ±lÄ±yor. "**Initialize, Initializing, Initializer**" kavramlarÄ± bu tÃ¼r tanÄ±mlamada kullanÄ±lan terimlerdir.

â—â—â— OndalÄ±klÄ± sayÄ±(floating point numbers) tÃ¼rlerinde iÅŸaretli/iÅŸaretsiz ayrÄ±mÄ± yoktur, mesela `signed float x;` ÅŸeklinde bir deÄŸiÅŸken bildirimi yapÄ±lamaz.

â—â—â— Tam sayÄ± tÃ¼rlerinin temel tÃ¼rÃ¼ `int` tÃ¼rÃ¼dÃ¼r.

â—â—â— KÃ¼suratlÄ± sayÄ±larÄ±n(floating point numbers) temel tÃ¼rÃ¼ `double` tÃ¼rÃ¼dÃ¼r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda bazÄ± legal ve legal olmayan deÄŸiÅŸken bildirimleri incelenebilir.
```C
int main(void)
{
   int long unsigned t; // Bu ÅŸekilde deÄŸiÅŸken bildirimi yapÄ±labiliyor ama Ã§ok tercih edilmemektedir.

   signed double x; // GeÃ§ersiz deÄŸiÅŸken bildirimi, sÃ¶zdizim hatasÄ±dÄ±r(syntax error).
}
```



Bir deÄŸiÅŸken adÄ±nÄ±n dilin kurallarÄ±na gÃ¶re "**legal**" olmasÄ±yla adÄ±n iyi tanÄ±mlanmÄ±ÅŸ olmasÄ± birbirinden farklÄ±dÄ±r. Bir deÄŸiÅŸken adÄ± "**legal**" olabilir fakat bu ad okunaklÄ± ve kolay anlaÅŸÄ±lÄ±r deÄŸilse adlandÄ±rma iyi yapÄ±lmadaÄŸÄ± anlamÄ±na gelir. 


ğŸ§­ Bir deÄŸiÅŸken adÄ± aÅŸaÄŸÄ±daki kurallara gÃ¶re verilmelidir;
1. Keyword olmamalÄ±dÄ±r.
2. Ä°lk karakter rakam olmamalÄ±dÄ±r.
3. A..Z -> Olarak 26 karakter(Ä°ngiliz alfabesindeki alfabe karakterleri) iÃ§erebilir.
4. a..z -> Olarak 26 karakter(Ä°ngiliz alfabesindeki alfabe karakterleri) iÃ§erebilir.
5. 0..9 -> Olarak 10 karakter iÃ§erebilir.
6. _    -> Olarak 1 karakter iÃ§erebilir.

â—â—â— Programlama dilleri "**case-senvitive**" ya da "**case-insenvitive**" olarak adlandÄ±rma kuralÄ±na sahip olabilir, C ve C++ "**case-senvitive**"dir. Bir dilin "**case-senvitive**" olmasÄ± demek "sum", "SUM", "suM" adlarÄ±nÄ±n her birinin farklÄ± bir ad olarak yorumlanmasÄ± demektir.


### AdlandÄ±rmalarda Dikkat Edilmesi Gereken Durumlar

1. Kodu okurken anlaÅŸÄ±lmasÄ± zor anlamsÄ±z(x, y, z _24323 vb.) adlar kullanÄ±lmamalÄ±dÄ±r, fakat matematiksel iÅŸlemler yapÄ±ldÄ±ÄŸÄ± durumlarda "x, y, z" adlandÄ±rmalarÄ± doÄŸru olabilir.

2. DeÄŸiÅŸken adlarÄ± global olarak anlaÅŸÄ±labilir olmasÄ± iÃ§in Ä°ngilizce adlandÄ±rma yapÄ±lmalÄ±dÄ±r. Burada Ä°ngilizce bilmeyenleri fÄ±rÃ§alÄ±yor! SonuÃ§ta haklÄ± yoksa Ã§alÄ±ÅŸma alanÄ±nda iyi yerlere gelmek iÃ§in Ä°ngilizce bilmek gerekiyor, Ä°ngilizce bilmeden ilerlemenin mÃ¼mkÃ¼n olmadÄ±ÄŸÄ±nÄ± belirtti.
   - En Ã§ok hataya neden olan kodlama hatalarÄ±ndan biri, adlandÄ±rmada farklÄ± varlÄ±klara birbirine yakÄ±n adlar verildiÄŸinde bir varlÄ±ÄŸÄ±n adÄ±nÄ± yazmak isterken yanlÄ±ÅŸlÄ±kla baÅŸka bir varlÄ±ÄŸÄ±n adÄ±nÄ±n yazÄ±lmasÄ±dÄ±r, bu hata logic(mantÄ±k) hatasÄ± oluÅŸturur ve derleyici bu hata tÃ¼rÃ¼nÃ¼ yakalayamaz.
   - ret: "Return value" kÄ±saltmasÄ± olarak kullanÄ±mÄ± yaygÄ±ndÄ±r.
   - cnt: "count" kÄ±saltmasÄ± olarak kullanÄ±mÄ± yaygÄ±ndÄ±r ve sayaÃ§larda kullanÄ±lÄ±yor genelde.

3. AdlandÄ±rmada uyulan kurallar kÃ¼meleri vardÄ±r bunlara "**Coding Convention**", "**Coding Style**" ya da "**Naming Conventions**" deniliyor(bu ileride bir dersin konusu olacaktÄ±r), bazÄ± "**coding convention**" kural kÃ¼meleri aÅŸaÄŸÄ±dakilerdir; 
   - **Snake case**: "**value_added_tax_increase_rate**" ÅŸeklinde. Bu adlandÄ±rma notasyonu Ã¶zellikle sistem programlamada sÄ±klÄ±kla tercih edilir.
   - **Camel case**: "**valueAddedTaxIncreaseRate**" 
   - **Pascal case**: "**ValueAddedTaxIncreaseRate**" 

4. C dilinde deÄŸiÅŸkenlere ve fonksiyonlara verilen adlar kÃ¼Ã§Ã¼k harf yoÄŸun olarak seÃ§ilir asla tamamÄ± bÃ¼yÃ¼k harf olan adlandÄ±rmalar seÃ§ilmez Ã§Ã¼nkÃ¼ tamamÄ± bÃ¼yÃ¼k harf olan adlar(**ALL_CAPS** ÅŸeklinde adlandÄ±rÄ±lÄ±r) baÅŸka varlÄ±klar(bu **macro** varlÄ±klardÄ±r) iÃ§in kullanÄ±lÄ±r. 
   - Ã–n iÅŸlemci programa tanÄ±tÄ±lan adlara "**macro**" denilmektedir ve "**macro**" adlarÄ± "**ALL_CAPS**" adlandÄ±rma yÃ¶ntemi ile adlandÄ±rÄ±lmaktadÄ±r, bu konuya dÃ¶rt saat ayrÄ±lacakmÄ±ÅŸ. FarklÄ± programlama dillerinde "**macro**" farklÄ± bir ÅŸeye karÅŸÄ±lÄ±k gelebilir.

5. **Scope** **identifier(ad)**'larÄ± ilgilendirir, **identifier(ad)**'larÄ±n **scope**'larÄ± geniÅŸledikÃ§e **identifier(ad)**'lar daha niteleyici olmalÄ±, global kapsamda kullanÄ±lan deÄŸiÅŸken adlarÄ± ne iÃ§in kullanÄ±ldÄ±klarÄ±nÄ± aÃ§Ä±klayÄ±cÄ± ÅŸekilde olmalÄ±dÄ±r.
   - **Block Scope**: C dilinde bir fonksiyonun iÅŸinde kalan alana verilen addÄ±r, bir fonksiyon iÃ§inde iÃ§ iÃ§e farklÄ± seviyelerde **Block Scope** bulunabilir.
   - **File Scope** : Bu alanda tanÄ±mlanan **identifier(ad)**'lar C dilinde yazÄ±lmÄ±ÅŸ olan bir projenin genelinde bulunan birden fazla dosyadan da kullanÄ±labileceÄŸi iÃ§in ad Ã§akÄ±ÅŸmasÄ±nÄ± Ã¶nlemek iÃ§in bu adlarÄ±n daha Ã¶zel olarak neyi ifade ettiÄŸi aÃ§Ä±k olacak ÅŸekilde adlandÄ±rÄ±lmalÄ±dÄ±r.

6. C dilinde birden fazla farklÄ± varlÄ±ÄŸa aynÄ± ad verilebilir mi sorusunun cevabÄ± "_Duruma gÃ¶re deÄŸiÅŸir_" olacaktÄ±r. 
   - "BaÄŸlam" sÃ¶zcÃ¼ÄŸÃ¼nÃ¼ "context" sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n karÅŸÄ±lÄ±ÄŸÄ± iÃ§in kullanÄ±lÄ±yor.
   - C dilinde Birden fazla farklÄ± varlÄ±ÄŸa aynÄ± adÄ±n verilmesi durumu "**Name Collision(ad Ã‡akÄ±ÅŸmasÄ±)**" olarak belirtilmektedir, bu durum "**name lookup**" iÅŸleminde oluÅŸacaktÄ±r.

7. C dilinin **sÃ¶zdiziminde(syntax)** "," token'Ä± **identifier(ad)**'larÄ± ayÄ±rmak iÃ§in `int x, y, z;` ÅŸeklinde sÄ±klÄ±kla kullanÄ±lmaktadÄ±r, bu kullanÄ±ma "**Comma Separated List**". Åu karakter "," **comma separator** olarak adlandÄ±rÄ±lÄ±r. 
   - `int value1, value2, value3` ÅŸeklinde tanÄ±mlamanÄ±n okunurluÄŸu azdÄ±r bu nedenle her deÄŸiÅŸken tanÄ±mÄ±nÄ±n ayrÄ± ayrÄ± olarak yapÄ±lmasÄ± daha doÄŸrudur.

8. **Initialization(Ä°lk deÄŸer vermek)** ile **Assignment(Atama)** kavramlarÄ± birbirinden farklÄ±dÄ±r. 
   - "**Initialization** is not an **assignment**." cÃ¼mlesi bir **Initialization(Ä°lk deÄŸer vermek)**'Ä±n bir **Assignment(Atama)** olmadÄ±ÄŸÄ±nÄ± belirtiyor.
   - `int value1 = 7;` bu **statement** "**Initialization**" olarak tanÄ±mlanmaktadÄ±r. Burada **name-lookup** iÅŸlemi yapÄ±lmamaktadÄ±r Ã§Ã¼nkÃ¼ `value1` **identifier(ad)**'Ä±nÄ±n tÃ¼rÃ¼ zaten bu **statement**'Ä±n kendisinde bellidir. `int value1 = 7;` bu **statement** Ã¶zel olarak "**Initialization Statement**" olarak tanÄ±mlanmaktadÄ±r. `int value1 = 7;` buradaki "=" operatÃ¶rÃ¼nÃ¼n saÄŸ tarafÄ± "**Initializer**" ya da "**Initializing Expression**" olarak adlandÄ±rÄ±lÄ±r.
   - `x = 3;` bu **statement**'taki durum "**assignment**" olarak tanÄ±mlanÄ±yor.
   - `x = 3;` bu **statement**'ta "x" deÄŸiÅŸkeninin ne olduÄŸunu anlamak iÃ§in derleyicinin **name-lookup** iÅŸlemi yapmasÄ±nÄ± gerektirir fakat `int i = 7;` **statement**'taki "i" deÄŸiÅŸkenine atama iÅŸlemi yapÄ±lmÄ±yor bu deÄŸiÅŸkenin **yaÅŸamÄ±na(life time, storage duration)** hangi deÄŸerle baÅŸlayacaÄŸÄ± belirtiliyor.


ğŸ§  DeÄŸiÅŸkenlerin ya da nesnelerin bellekte kalma sÃ¼relerine "**Storage Duration**" denilmektedir.

ğŸ§  Programlardaki deÄŸiÅŸkenler programÄ±n Ã§alÄ±ÅŸma zamanÄ± aÃ§Ä±sÄ±ndan baktÄ±ÄŸÄ±mÄ±zda bellekteki bir ve sÄ±fÄ±r dizilerinden baÅŸka bir ÅŸey deÄŸildir.

â—â—â— Bir program Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda programÄ±n akÄ±ÅŸÄ± bir deÄŸiÅŸkenin bildirildiÄŸi yere geldiÄŸinde o deÄŸiÅŸken iÃ§in bellekte bir yer tahsil edilir bu anda deÄŸiÅŸkenin hayatÄ± baÅŸlamÄ±ÅŸ olur ve bu deÄŸiÅŸken iÃ§in ayrÄ±lan bellek alanÄ± ne zaman o deÄŸiÅŸkenle iliÅŸkisi sonlandÄ±rÄ±lÄ±r o zaman deÄŸiÅŸkenin Ã¶mrÃ¼ son bulmuÅŸ olur. 

**Scope(Kapsam)** terimi **identifier(ad)**'larÄ± ilgilendiren bir kavramdÄ±r, bir **identifier(ad)**'Ä±n **Scope**'undna bahsetmek derleme zamanÄ±ndan bahsetmektir, koda *static** olarak bakmak demektir.

**Storage duration(Ã–mÃ¼r)** ise programÄ±n Ã§alÄ±ÅŸma zamanÄ±na ait bir kavramdÄ±r, program Ã§alÄ±ÅŸÄ±rken bellekte ne kadar yer kaplayacaÄŸÄ±yla ilgili bir kavramdÄ±r. Bu kavram Ã§ok Ã¶nemlidir!

**Storage duration(Ã–mÃ¼r)** tÃ¼rleri aÅŸaÄŸÄ±daki gibidir;
1. **Automatic Storage duration(Otomatik Ã¶mÃ¼r)**: Belirli bir kodun yÃ¼rÃ¼tÃ¼lmesi sÃ¼resince bellekte kalÄ±yor yani programÄ±n akÄ±ÅŸÄ± o koda geldiÄŸinde bellekte yerini alÄ±yor ve programÄ±n akÄ±ÅŸÄ± o koddan Ã§Ä±ktÄ±ÄŸÄ±nda bellekten boÅŸaltÄ±lÄ±yor. Bu **Storage duration(Ã–mÃ¼r)** kategorisine **Automatic Storage duration** denilmektedir. 
2. **Static Storage duration[Statik Ã¶mÃ¼r]**: ProgramÄ±n baÅŸÄ±ndan sonuna kadar deÄŸiÅŸkenin bellekte var olmasÄ± yani bellekte yer kaplamasÄ± demektir. Bir nesnenin programÄ±n Ã§alÄ±ÅŸma sÃ¼resi boyunca bellekte kalmasÄ± durumunu tanÄ±mlamak iÃ§in **Static Storage duration** tanÄ±mlamasÄ± yapÄ±lmaktadÄ±r. 
3. **Dynamic Storage duration(Dinamik Ã¶mÃ¼r)**: Bu konu kursun 3. Ã§eyreÄŸinde iÅŸlenecek Ã¶nemli bir konudur. ProgramcÄ± **run-time**'da istediÄŸi herhangi bir noktada deÄŸiÅŸkenin hayatÄ±nÄ± baÅŸlatabilir ve istediÄŸi herhangi bir noktada deÄŸiÅŸkenin hayatÄ±nÄ± sonlandÄ±rabilir. Buradaki Ã¶mre sahip deÄŸiÅŸkenler programÄ±n Ã§alÄ±ÅŸma zamanÄ±nda belirli zamanlarda bellekte yer alÄ±r ve yok olurlar. 
4. **Thread-local(Storage duration)**: Bu kullanÄ±m C11'de dilin standardÄ±na eklenmiÅŸtir. Bunu her derleyici desteklememektedir.

Bir deÄŸiÅŸkenin **Automatic** ya da **Static** Ã¶mre sahip olma durumu koda bakÄ±larak anlaÅŸÄ±labiliyor. AÅŸaÄŸÄ±daki maddelere bakarak bu Ã¶ÄŸrenilebilir;
- Bir deÄŸiÅŸkenin tanÄ±mlamasÄ± "**Global Scope**" alanÄ±nda tanÄ±mlanmÄ±ÅŸsa bu deÄŸiÅŸkenlere "**Global Variable**" denir ve bir "**Global Variable**"Ä±n Ã¶mrÃ¼ kesinlikle "**Static**" olacaktÄ±r. 
- Bir deÄŸiÅŸken bir fonksiyon yada bir scope iÃ§inde tanÄ±mlanÄ±yorsa bunlara "**Local Variable**" denir ve bu deÄŸiÅŸkenler duruma gÃ¶re ya "**Automatic**" ya da "**Static**" Ã¶mÃ¼rlÃ¼ olur, varsayÄ±lan olarak yerel(local) deÄŸiÅŸkenler "**Automatic**" Ã¶mre sahiptir. C dilinde eskiden "**auto**" anahtar sÃ¶zcÃ¼ÄŸÃ¼ bir deÄŸiÅŸkenin Ã¶mrÃ¼nÃ¼n "**Automatic**" belirlenmesi iÃ§in kullanÄ±lÄ±yormuÅŸ. Bir local deÄŸiÅŸken tanÄ±mlanÄ±rken "**static**" anahtarÄ± kullanÄ±ldÄ±ÄŸÄ±nda deÄŸiÅŸken program Ã§alÄ±ÅŸma sÃ¼resi boyunca sadece bir kere oluÅŸturulur.

â—â—â— Bir deÄŸiÅŸken "**static**" Ã¶mre sahipse program Ã§alÄ±ÅŸmasÄ± sÃ¼resince sadece bir defa hayatÄ±na baÅŸlar ve programÄ±n Ã§alÄ±ÅŸmasÄ± tamamlandÄ±ÄŸÄ±nda Ã¶mrÃ¼ sonlanÄ±r. Bir deÄŸiÅŸken "**automatic**" Ã¶mre sahipse programÄ±n akÄ±ÅŸÄ± deÄŸiÅŸkenin bildirildiÄŸi **kapsama(scope)** gelindiÄŸinde deÄŸiÅŸkene bellekte yer tahsisedilir ve deÄŸiÅŸkenin Ã¶mrÃ¼ baÅŸlar ve bu deÄŸiÅŸkenin Ã¶mrÃ¼ bildirildiÄŸi **kapsamdan(scope)** Ã§Ä±kÄ±ldÄ±ÄŸÄ±nda sonlanacaktÄ±r.

ğŸ‘‡ AÅŸaÄŸÄ±daki programda **global name space** ve **local name space** alanlarda tanÄ±mlanan deÄŸiÅŸkenlerin Ã¶mÃ¼rleri incelenebilir.
```C 
#include <stdio.h>

int g = 24; // BurasÄ± 'global name space' olduÄŸu iÃ§in 'g' deÄŸiÅŸkeninin Ã¶mrÃ¼ her zaman 'Static' olacaktÄ±r.

// AÅŸaÄŸÄ±daki fonksiyondaki 'static int x = 6;' statement ile tanÄ±mlanan 'x' deÄŸiÅŸkeninin belleÄŸe program Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda Ã§Ä±karÄ±lmasÄ± ile fonksiyonun ilk Ã§aÄŸÄ±rÄ±ldÄ± anda Ã§Ä±karÄ±lmasÄ± arasÄ±nda gÃ¶zlenebilir bir farklÄ±lÄ±k olmayacaÄŸÄ± iÃ§in kullanÄ±lan derleyiciye gÃ¶re hangi yÃ¶ntemin seÃ§ileceÄŸi farklÄ±lÄ±k gÃ¶sterebilir.
// C dilinin standardÄ±nÄ±n sÃ¶ylediÄŸi gibi "GÃ¶zlemlenen davranÄ±ÅŸ deÄŸiÅŸmediÄŸi sÃ¼rece derleyiciler yazÄ±lmÄ±ÅŸ kodu farklÄ± ÅŸekilde yorumlayabilirler."
void foo(void)
{
  static int x = 6; // Buradaki 'x' deÄŸiÅŸkeninin Ã¶mrÃ¼ 'Static' olacaktÄ±r. Buradaki 'x' deÄŸiÅŸkeni program Ã§alÄ±ÅŸmasÄ± sÃ¼resince sadece tek bir defa belleÄŸe alÄ±nacaktÄ±r.

  printf("x = %d\n", x);
  
  x += 10;
}

int main(void)
{
  int x = 8; // Buradaki 'x' deÄŸiÅŸkeninin Ã¶mrÃ¼ 'Automatic' olacaktÄ±r, varsayÄ±lanÄ± 'Automatic' Ã¶mÃ¼rdÃ¼r.

  auto int y = 4; // Buradaki 'y' deÄŸiÅŸkeninin Ã¶mrÃ¼ 'Automatic' olacaktÄ±r, bunu 'auto' anahtarÄ± saÄŸlar ama bu anahtar sÃ¶zcÃ¼k Ã§ok eskiden kullanÄ±lÄ±yordu.
 
  static int z = 45; // Buradaki 'z' deÄŸiÅŸkeninin Ã¶mrÃ¼ 'Static' olacaktÄ±r, bunu 'Static' anahtarÄ± saÄŸlamaktadÄ±r.
  
  foo(); // Bu fonksiyon Ã§alÄ±ÅŸÄ±nca ekrana 'x = 6' yazacaktÄ±r.
  foo(); // Bu fonksiyon Ã§alÄ±ÅŸÄ±nca ekrana 'x = 16' yazacaktÄ±r.
  foo(); // Bu fonksiyon Ã§alÄ±ÅŸÄ±nca ekrana 'x = 26' yazacaktÄ±r.
  
  return 0; // Buradaki ifade "Control Statement" olarak adlandÄ±rÄ±lmaktadÄ±r.
}
```

ğŸ‘‡ AÅŸaÄŸÄ±daki programda **global name space** ve **local name space** alanlarda tanÄ±mlanan deÄŸiÅŸkenlerin Ã¶mÃ¼rleri incelenebilir.
```C 
#include <stdio.h>

int x; // 'x' deÄŸiÅŸkeni 'static' Ã¶mre sahip deÄŸiÅŸkendir, 'static' Ã¶mÃ¼rlÃ¼ deÄŸiÅŸkenler hayatlarÄ±na '0' deÄŸeriyle baÅŸlar.

int main(void)
{
   int y = x; // 'y' deÄŸiÅŸkeni 'automatic' Ã¶mre sahip deÄŸiÅŸkendir, 

   printf("x = &d\n", x);
   printf("x = &d\n", x);
}
```

â—â—â— **Indetermined Value**: "**automatic**" Ã¶mre sahip deÄŸiÅŸkenlere ilk deÄŸerleri verilmediÄŸinde bu deÄŸiÅŸkenler bellekte kendilerine tahsis edilen alandaki deÄŸer ile Ã¶mÃ¼rlerine baÅŸladÄ±klarÄ±nda sahip olduklarÄ± ne olduÄŸu belli olmayan deÄŸeri belirtmek iÃ§in kullanÄ±lan bir terimdir, bu durum iÃ§in standardÄ±n kullanmadÄ±ÄŸÄ± "**garbage value(Ã§Ã¶p deÄŸer)**" tanÄ±mlamasÄ± da kullanÄ±labiliyor.


DeÄŸiÅŸkenlerin **Storage duration(Ã–mÃ¼r)** kavramÄ±yla ilgili olan bazÄ± Ã¶nemli durumlar aÅŸaÄŸÄ±da aÃ§Ä±klandÄ±ÄŸÄ± gibidir;
- **Static**" Ã¶mÃ¼rlÃ¼ deÄŸiÅŸkelere ilk deÄŸer verilmezse bu deÄŸiÅŸkelerin alacaÄŸÄ± ilk deÄŸer deÄŸiÅŸken sayÄ± veri tÃ¼rÃ¼ ise her zaman "0" olacaÄŸÄ± kesindir.
- "**Automatic**" Ã¶mÃ¼rlÃ¼ deÄŸiÅŸkelere ilk deÄŸer verilmezse bu deÄŸiÅŸkelere bellekte ayrÄ±lacak alanda hangi deÄŸer mevcutsa o deÄŸer deÄŸiÅŸkenin deÄŸeri olacaktÄ±r bu deÄŸere resmi olarak "**Indetermined Value**" denilmektedir. Bir deÄŸiÅŸkenin deÄŸeri "**Indetermined Value**" olacak ÅŸekilde bir kodlama yapÄ±lÄ±rsa bu duruma "**undefined Behavior**" denilmektedir ve bu durum tehlikeli bir durumdur Ã§Ã¼nkÃ¼ deÄŸiÅŸkenin deÄŸerinin ne olacaÄŸÄ± belirsizdir(bu nedenle C# gibi dillerde bu durumda hata verilmektedir).


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.48-11.06 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**static**" Ã¶mÃ¼rlÃ¼ bir deÄŸiÅŸkene verilen ilk deÄŸerin **constant expression** olmamasÄ±ndan kaynaklanan **sÃ¶zdizim hatasÄ±(syntax error)** incelenebilir.
```C
#include <stdio.h>

int x = 5;
int y = x; // C dilinde burada 'initializer element is not constant' hatasÄ± oluÅŸacaktÄ±r ama C++ dilinde legal'dir.

int main(void)
{
   printf("x = %d, y = %d\n", x, y);
}
```

ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**static**" Ã¶mÃ¼rlÃ¼ bir deÄŸiÅŸkene verilen ilk deÄŸerin **constant expression** olmamasÄ±ndan kaynaklanan **sÃ¶zdizim hatasÄ±(syntax error)** incelenebilir.
```C
#include <stdio.h>

int main(void)
{
   static int x = 5;
   static int y = x; // C dilinde burada 'initializer element is not constant' hatasÄ± oluÅŸacaktÄ±r ama C++ dilinde legal'dir.

   printf("x = %d, y = %d\n", x, y);
}
```

C dilinde bir **keyword**'Ã¼n kullanÄ±m yerine gÃ¶re farklÄ± anlama gelmesi durumu Ã§ok nadirdir, C++ dilinde bu durum daha fazladÄ±r. C dilinde "**static**" anahtarÄ± bu **keyword**'lerden biridir. </br>
Global deÄŸiÅŸkenlerin deÄŸiÅŸmeyecek ÅŸekilde "**static**" Ã¶mÃ¼rlÃ¼dÃ¼r ama global bir deÄŸiÅŸken "**static**" olarak nitelendirilirse bu "**linkage**" konusuyla ilgili bir durumu etkiliyor ama bu sonradan iÅŸlenecek bir konudur. </br>
C dilinde `int x = 4; int y = x;` kodu "**global scope**"'ta yazÄ±lÄ±yorsa bu durumda "x" ve "y" tÃ¼rleri "**static**" Ã¶mÃ¼rlÃ¼ deÄŸiÅŸkenler olacaktÄ±r ve "**static**" Ã¶mÃ¼rlÃ¼ deÄŸiÅŸkenlerde **initializing** iÅŸlemi yapÄ±lÄ±rken ilk atanan deÄŸerin "**Constant Expression(Sabit Ä°fade)**" olmasÄ± sorunludur. </br>
C dilinde "**static**" Ã¶mÃ¼rlÃ¼ deÄŸiÅŸkenlere ilk deÄŸer veren ifadelerin sabit ifadesi olmasÄ± zorunludur, `static int x = 4; static int y = x;` kodundaki `y = x` **expression(ifade)**' iÃ§erisindeki "x" deÄŸiÅŸkeni "**Constant Expression(Sabit Ä°fade)**" olarak kabul edilmediÄŸi iÃ§in derleme hatasÄ± oluÅŸacaktÄ±r.


## Alttaki TanÄ±mlamalarÄ± Bilmemek C Dilini HiÃ§ Bilmemek Demektir 

â—â—â— Bu baÅŸlÄ±k altÄ±nda anlatÄ±lanlar C dilinin Ã¶ÄŸrenilmesinde Ã§ok Ã¶nemlidir, buradaki bilgiler bilinmiyorsa C dilinin hiÃ§ bilinmediÄŸinin bilincinde olarak incelenmelidir.

ğŸ§­ AÅŸaÄŸÄ±daki terimler C ve C++ dÄ±ÅŸÄ±ndaki Ã§oÄŸu dilde(Java, C# vb.) bulunmamaktadÄ±r;
1. **Undefined behavior(tanÄ±msÄ±z davranÄ±ÅŸ)**
2. **Unspecified behavior(belirsiz davranÄ±ÅŸ)**
3. **Implementation defined behavior(derleyiciye baÄŸÄ±mlÄ±)**


### Undefined behavior(tanÄ±msÄ±z davranÄ±ÅŸ)["ub" diye kÄ±saltÄ±lÄ±yor] 

â—â—â— C standardÄ±(Draft, Specification, Belgesi, DokÃ¼manÄ±) bazÄ± kodlarÄ± "**ub**" olarak nitelendirmektedir.

â—â—â— C standardÄ±(Draft, Specification, Belgesi, DokÃ¼manÄ±) **Undefined behavior(tanÄ±msÄ±z davranÄ±ÅŸ)** terimini ÅŸu ÅŸekilde aÃ§Ä±klamaktadÄ±r: Ã–yle bir kod ki derleyicinin o kod karÅŸÄ±lÄ±ÄŸÄ±nda nasÄ±l bir makine kodu Ã¼reteceÄŸi konusunda hiÃ§ bir belirleme yoktur, yanÄ± "**ub**" durumunda bir kod yazÄ±lÄ±yorsa kod Ã§alÄ±ÅŸma zamanÄ±nda beklenildiÄŸi gibi Ã§alÄ±ÅŸabilir ya da Ã§alÄ±ÅŸmayabilir.

â—â—â— C standardÄ±(Draft, Specification, Belgesi, DokÃ¼manÄ±) tanÄ±msÄ±z davranÄ±ÅŸlarÄ±n hepsini belirtmektedir, tanÄ±msÄ±z davranÄ±ÅŸ olan kodlar asla yazÄ±lmamalÄ±dÄ±r.


âš ï¸ "**C++ Concurrency in Action**" kitabÄ±nda "**Anthony Williams**" tanÄ±msÄ±z davranÄ±ÅŸ iÃ§eren kodlarÄ±n yazÄ±lmamasÄ± gerektiÄŸini belirtmektedir. 

ğŸ§  C ve C++ dillerini Ã¶ÄŸrenmek demek "**ub**" olan durumlarÄ±n detaylÄ± Ã¶ÄŸrenilmesini gerektirmektedir.

Hangi kodlamanÄ±n "**ub**" olduÄŸu C ve C++ dillerinin standardÄ±nda(Draft, Specification) belirtilmektedir, bunlarÄ± iyi bilmek gerekiyor.



ğŸ‘‡ AÅŸaÄŸÄ±daki programÄ±n bir mÃ¼lakatta yorumlanmasÄ± istendiÄŸinde verilecek cevap "x" deÄŸiÅŸkeninin "**indetermined value**" deÄŸer alacaÄŸÄ± iÃ§in "**ub**" durumunun oluÅŸacaÄŸÄ±dÄ±r. </br>
ğŸ˜± AÅŸaÄŸÄ±daki gibi kodlar TÃ¼rkiye'deki bazÄ± firmalarÄ±n yaptÄ±ÄŸÄ± mÃ¼lakatlarda sorulduÄŸu oluyormuÅŸ ve bu kursu bitiren kiÅŸiler cevap olarak burada "**ub**" var diye cevap verdiklerinde mÃ¼lakatÄ± yapan kiÅŸi trajikomik ÅŸekilde "_**ub** de ne demek programlar deteministtir olmaz Ã¶yle ÅŸey._" diyorlarmÄ±ÅŸ!
```C
#include <stdio.h>

int main(void)
{
   int x;
   int y = x + 7; // Bu statement Ã§Ã¶p deÄŸere sahip 'x' eÄŸiÅŸkenini iÃ§erdiÄŸi iÃ§in 'ub'ye durumuna neden olacaktÄ±r.

   printf("x = %d, y = %d\n", x, y);
}
```


â— BazÄ± tanÄ±msÄ±z davranÄ±ÅŸlar iÃ§in derleyiciler uyarÄ± ya da hata verebilir ama bu her tanÄ±msÄ±z davranÄ±ÅŸ iÃ§in geÃ§erli deÄŸildir.

ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki "**ub**" durumlarÄ± incelenebilir.
```C
#include <stdio.h>

int main(void)
{
   int x, y; // Hem 'x' hem 'y' deÄŸiÅŸken bildirimleri 'local scope' alanÄ±nda yapÄ±lmasÄ± hem 'x' hem 'y' deÄŸerlerine ilk deÄŸeri atanmadÄ±ÄŸÄ± iÃ§in 'Undefined behavior' vardÄ±r.
   int i;
   
   i = x / y; // BÃ¶lme iÅŸleminde 'y' deÄŸiÅŸkeninin deÄŸeri '0' olmasÄ± durumundan dolayÄ± bÃ¶lme iÅŸleminde 'Undefined behavior' durumu oluÅŸacaktÄ±r.

   printf("x = %d, y = %d\n", x, y);
}
```

ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki "**ub**" durumlarÄ± incelenebilir.
```C
#include <stdio.h>

int main(void)
{
   int x, y; 
   // ... Bu aralÄ±kta x ve y depÄŸerlerine deÄŸer atanÄ±yor.
   int sum;

   sum = x + y; // Bu statement'ta eÄŸer 'x + y' deÄŸeri iÅŸaretli int tÃ¼rÃ¼nden bÃ¼yÃ¼k bir deÄŸer olursa 'Undefined behavior' durumu oluÅŸacaktÄ±r.

   printf("x = %d, y = %d, sum = %d\n", x, y, sum);
}
```

**singed int variable(iÅŸaretli tam sayÄ±lar)**'lardaki taÅŸma durumlarÄ± "**Undefined behavior**" olarak kabul edilirken, **unsinged int variable(iÅŸaretsiz tam sayÄ±lar)**'lardaki taÅŸma durumlarÄ± "**Undefined behavior**" deÄŸildir, bunu belirleyen C dilinin standardÄ±dÄ±r.



"**Undefined behavior**" felsefesi ve neden C dilinde "**Undefined behavior**" var?
- Bunun nedeni bÃ¼yÃ¼k Ã¶lÃ§Ã¼de derleyicilerin **Compiler Optimization** modÃ¼lÃ¼dÃ¼r, bu modÃ¼l yazÄ±lmÄ±ÅŸ kod dosyalarÄ±nÄ± **gÃ¶zlemlenebilir davranÄ±ÅŸ(observable behavior, as-if rule)** deÄŸiÅŸmeden daha iyileÅŸtirilmiÅŸ ÅŸekilde makine kodu Ã¼retilmesini saÄŸlÄ±yor.
- C ve C++ dillerinin kullanÄ±ldÄ±ÄŸÄ± yerler Ã¶zel verim kritik uygulamalar, hÄ±z kritik uygulamalar olduÄŸu iÃ§in bu dillerde derleyicinin yapacaÄŸÄ± optimizasyon Ã¶nemlidir. Derleyiciler kodu optimize ederken kodda bir tane bile "**Undefined behavior**" olmadÄ±ÄŸÄ±na gÃ¼venerek bu iÅŸlemi yapmaktadÄ±r.

ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki derleyici yazÄ±lmÄ±ÅŸ kodu tanÄ±msÄ±z davranÄ±ÅŸ olmayacak ÅŸekilde yorumlayÄ±p optimize ettiÄŸinde "if" bloÄŸuna girmeyeceÄŸi incelenebilir.
```C
#include <stdio.h>

void foo(void);

int main(void)
{
   int x, y, z;
   
   // ... Bu aralÄ±kta x ve y depÄŸerlerine deÄŸer atanÄ±yor.
   
   x = y / z;

   // Derleyici kodu derlerken yukarÄ±daki bÃ¶lme iÅŸleminde 'z' deÄŸiÅŸkeninin deÄŸeri '0' olmasÄ± durumunda 'ub' olacaÄŸÄ±nÄ± bilir ve kodun 'ub' olmayacak ÅŸekilde yazÄ±ldÄ±ÄŸÄ±nÄ± kabulettiÄŸi iÃ§in aÅŸaÄŸÄ±daki 'if' bloÄŸunun 'always false' olduÄŸu sonucuna varÄ±p hiÃ§ yazÄ±lmamÄ±ÅŸ gibi yorumlayabilir.
   if(z == 0){ // always false
      // code
      // code
      // code
   }
}
```


"**ub**" ile ilgili aÅŸaÄŸÄ±daki bilgiler Ã¶nemlidir;
- "**Undefined behavior**" olan durumlarda derleme zamanÄ± hatasÄ±nÄ±n oluÅŸma/oluÅŸmama durumu kullanÄ±lan derleyiciye gÃ¶re deÄŸiÅŸecektir.
- YazÄ±lmÄ±ÅŸ kodda "**Undefined behavior**" olup olmadÄ±ÄŸÄ± programÄ±n Ã§alÄ±ÅŸÄ±p Ã§alÄ±ÅŸmamasÄ±na bakÄ±larak anlaÅŸÄ±lamaz, kodda "Undefined behavior" olan durumlarÄ± gÃ¶rebilmek iÃ§in kodun okunmasÄ± gerekecektir.
- Derleyicilerin Optimizer alt-programlarÄ± kodu iÅŸlerken "**Undefined behavior**" durumlarÄ± yokmuÅŸ gibi Ã§alÄ±ÅŸmaktadÄ±r.
- "Undefined behavior" durumlarÄ±nÄ±n oluÅŸmasÄ±nÄ±n asÄ±l nedeni derleyicilerin Optimizer alt-programlarÄ±nÄ±n ham kodu iÅŸleyip kod Ã¼zerinde bazÄ± deÄŸiÅŸiklikler yapmalarÄ± ve bu iÅŸlemi yaparken "Undefined behavior" durumundaki kodlar iÅŸlenirken nasÄ±l yorumlanacaÄŸÄ± ve iyileÅŸtirme yapÄ±lacaÄŸÄ± belirsiz olacaÄŸÄ± iÃ§in sorunlar Ã§Ä±kacaktÄ±r.  Bu nedenlerden dolayÄ± da yazÄ±lan C ve C++ kodlarÄ±nda "**Undefined behavior**" oluÅŸturabilecek ÅŸekilde kodlama yapÄ±lmamasÄ± gerekmektedir.


### Unspecified behavior(belirsiz davranÄ±ÅŸ) 

Derleyiciler belirli durumlarda dilin standardÄ±nÄ±n kendilerine tanÄ±dÄ±ÄŸÄ± yetkiyle iki ya da daha farklÄ± ÅŸekilde makine kodu Ã¼retebilir, bu durumlarda derleyiciler farklÄ± ÅŸekilde makine kodu Ã¼retebilmesine **Unspecified behavior(belirsiz davranÄ±ÅŸ)** denilmektedir.

ğŸ‘‡ AÅŸaÄŸÄ±daki programda `x = foo() + bar() * 2;` statement'Ä±nda `foo()` fonksiyonunun mu yoksa `bar()` fonksiyonunun mu Ã¶nce Ã§aÄŸrÄ±lacaÄŸÄ± bu iki fonksiyon **pure function** olmasÄ± koÅŸuluyla Ã¶nemli deÄŸildir ve derleyicinin Ã¶nce hangi fonksiyonu Ã¶nce Ã§aÄŸÄ±rmasÄ± sonucu deÄŸiÅŸtirmeyecektir ve bu durum "**Unspecified behavior**" olarak adlandÄ±rÄ±lÄ±r fakat "foo" ve "bar" fonksiyonlarÄ±nÄ±n Ã¼rettikleri deÄŸerler birbirine baÄŸlÄ±ysa bu durumda hangi fonksiyonun Ã¶nce Ã§alÄ±ÅŸmasÄ± sonucu deÄŸiÅŸtireceÄŸi iÃ§in bu ÅŸekilde kod yazÄ±lmasÄ± durumunda dikkatli olunmasÄ± gerekecektir.
```C
#include <stdio.h>

int foo(void);
int bar(void);

int main(void)
{
   int x; 
   
   x = foo() + bar() * 2; // Burada 'Unspecified behavior' vardÄ±r.

   printf("x = %d", x);
}
```

ğŸ‘‡ AÅŸaÄŸÄ±daki programda `x = foo() + bar() * 2;` statement'Ä±ndaki fonksiyon Ã§aÄŸrÄ±larÄ±nÄ±n hangisinin Ã¶nce Ã§alÄ±ÅŸtÄ±rÄ±lacaÄŸÄ± belli deÄŸildir ve burada "**Unspecified behavior**" vardÄ±r ama programda `foo()` ve `bar()` fonksiyonlarÄ± **pure function** olmadÄ±ÄŸÄ± iÃ§in program Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda beklenmedik sonuÃ§ Ã¼retilebilir, bu durumda kodu "**Unspecified behavior**" durumlarÄ±nda istenildiÄŸi gibi Ã§alÄ±ÅŸacak ÅŸekilde yazmak gerekir.
```C
#include <stdio.h>

int g = 5;

int foo(void)
{
   return g + 3;
}

int bar(void);
{
   g = 40;
   return g;
}

int main(void)
{
   int x; 
   
   x = foo() + bar() * 2; // Burada 'Unspecified behavior' vardÄ±r.

   printf("x = %d", x);
}
```

ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**Unspecified behavior**" durumu ortadan kaldÄ±rÄ±lmÄ±ÅŸtÄ±r, `foo()` fonksiyonu `bar()` fonksiyonundan Ã¶nce Ã§aÄŸÄ±rÄ±lacaktÄ±r.
```C
#include <stdio.h>

int g = 5;

int foo(void)
{
   return g + 3;
}

int bar(void);
{
   g = 40;
   return g;
}

int main(void)
{
   int x; 
   
   int a = foo();
   int b = bar();
   x = a + b * 2;

   printf("x = %d", x);
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.02-12.16 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***

â—â—â— Ä°ÅŸaretsiz tam sayÄ±larda taÅŸma durumu "**undefined behavior**" deÄŸildir, Ä°ÅŸaretli tam sayÄ±larda taÅŸma durumu "**undefined behavior**" oluÅŸturmaktadÄ±r.

### Implementation defined behavior(derleyiciye baÄŸÄ±mlÄ±) 

Her bir "**Implementation defined behavior**" durumu "**Unspecified behavior**" durumunun bir alt kÃ¼mesidir.

"**Implementation defined behavior**" durumu ile "**Unspecified behavior**" durumu arasÄ±ndaki fark "**Implementation defined behavior**" durumlarÄ±nda derleyicinin Ã¼reteceÄŸi makine kodunu birden fazla farklÄ± ÅŸekilde Ã¼retebilir ama her seferinde sadece bir ÅŸekilde bunu yapabilir ve bu durumu belgelemek zorundadÄ±r, fakat "**Unspecified behavior**" durumlarÄ±nda derleyici aynÄ± kod iÃ§in her seferinde aynÄ± makine kodunu Ã¼retmek zorunda deÄŸildir duruma gÃ¶re her sefereinde farklÄ± ÅŸekilde kod Ã¼retebilir.

Mesela `char` tÃ¼rÃ¼nÃ¼n iÅŸaretli mi yoksa iÅŸaretsiz mi olarak kabul edileceÄŸi derleyiciden derleyiciye deÄŸiÅŸecektir ya da "**>>**" operatÃ¶rÃ¼ ile bitsel saÄŸa kaydÄ±rma iÅŸlemi `int x = -12323; x >> 3;` buradaki "x" tam sayÄ±sÄ±nÄ±n bitlerinin Ã¼Ã§ basamak saÄŸa kaydÄ±rÄ±lmasÄ± iÅŸleminde soldaki boÅŸa Ã§Ä±kan bitlere yapÄ±lacak beslemenin "0" ile mi yoksa "1" ile mi yapÄ±lacaÄŸÄ± derleyiciden derleyiciye deÄŸiÅŸecektir. Bir Ã¶nceki cÃ¼mlede verilen iki durum **Implementation defined behavior(derleyiciye baÄŸÄ±mlÄ±)** durum olarak adlandÄ±rÄ±lmaktadÄ±r.

â—â—â— Bu baÅŸlÄ±k altÄ±nda anlatÄ±lanlar aÅŸaÄŸÄ±daki gibi Ã¶zetlenebilir;
- "**Undefined behavior(tanÄ±msÄ±z davranÄ±ÅŸ)**" kaÃ§Ä±nÄ±lmasÄ± gereken zararlÄ± bir durumdur. 
- "**Unspecified behavior(belirsiz davranÄ±ÅŸ)**" bu durum kodun yazÄ±lmasÄ±na baÄŸlÄ± olarak programÄ±n Ã§alÄ±ÅŸmasÄ±nda mantÄ±k tutarsÄ±zlÄ±ÄŸÄ±na neden olabilen durumlardÄ±r.
- "**Implementation defined behavior(derleyiciye baÄŸÄ±mlÄ±)**" bu durum derleyiciden derleyiciye farklÄ± yorumlanan kodlarÄ± belirtmek iÃ§in kullanÄ±lmaktadÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda yapÄ±lan deÄŸiÅŸken bildirimlerinde bir hata yoktur bunlar incelenebilir.
```C
#include <stdio.h>

int main(void)
{
   int x1 = 5; 
   int y1 = x1 + 3;
   int z1 = x1 + y1 * 2;

   printf("x1 = %d, y1 = %d, z1 = %d", x1, y1, z1);

   int x2 = 5, y2 = x2 + 3, z2 = x2 + y2 * 2;

   printf("x2 = %d, y2 = %d, z2 = %d", x2, y2, z2);
}
```


C89'dan C99 standardÄ± geÃ§iÅŸinde pek Ã§ok deÄŸiÅŸiklik yapÄ±ldÄ± ve C99 standardÄ±nda C89 standardÄ±ndaki legal bazÄ± ÅŸeyler illegal ve illegal olan bazÄ± ÅŸeyler legal olarak belirlenmiÅŸtir. Mesela tek satÄ±r ile yorum satÄ±rÄ± oluÅŸturma("**//**" token'Ä± ile) C99 ile dile eklendi, `for` dÃ¶ngÃ¼sÃ¼nÃ¼n ilk ifadesinde(expression) deÄŸiÅŸken bildirimi yapabilme Ã¶zelliÄŸi C99 standardÄ±nda dile eklenmiÅŸtir. `_Bool` ve `long long` tÃ¼rleri C99 ile dile eklendi. C derleyicilerinin hepsi C99 standardÄ±nÄ± desteklemektedir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda main bloÄŸunda yazÄ±lan kod C99 standardÄ±nda legal(doÄŸru) ama C89 standardÄ±nda illegal(yanlÄ±ÅŸ) durumdadÄ±r. Bunun nedeni C89'da bir blokta yazÄ±lan ilk **declaration statement**'tan sonra **declaration statement** olmayan **statement**'lar yazÄ±lmÄ±ÅŸsa aynÄ± blok iÃ§inde sonradan yazÄ±lacak **declaration statement**'lar **sÃ¶zdizim(syntax)** hatasÄ±na neden olacaktÄ±r.
```C
#include <stdio.h>

int main(void)
{
   int x = 75; // Buradaki kod 'declaration'dÄ±r, 'declaration statement' ya da 'initialization declaration statement' olarak adlandÄ±rÄ±lmaktadÄ±r.

   ++x; // Buradaki kod 'declaration' deÄŸildir.

   int y = 10; // Buradaki kod 'declaration'dÄ±r.
}
```

ğŸ‘‡ AÅŸaÄŸÄ±daki program hem C89 hem C99 standardÄ±nda legaldir.
```C
#include <stdio.h>

int main(void)
{
   int x = 75; // Buradaki kod 'declaration'dÄ±r, 'declaration statement' ya da 'initialization declaration statement' olarak adlandÄ±rÄ±lmaktadÄ±r.
   int y = 10; // Buradaki kod 'declaration'dÄ±r.

   ++x; // Buradaki kod 'declaration' deÄŸildir.
}
```

ğŸ‘‡ AÅŸaÄŸÄ±daki program hem C89 hem C99 standardÄ±nda legaldir.
```C
#include <stdio.h>

int main(void)
{
   int x = 75; // Buradaki kod 'declaration'dÄ±r, 'declaration statement' ya da 'initialization declaration statement' olarak adlandÄ±rÄ±lmaktadÄ±r.

   ++x; // Buradaki kod 'declaration' deÄŸildir.
   
   {
      int y = 10; // Buradaki kod 'declaration'dÄ±r.

   }
}
```

â—â—â— C derleyicilerinin hepsi en dÃ¼ÅŸÃ¼k C99 standardÄ± desteÄŸi verdikleri iÃ§in yeni yazÄ±lacak C programlarÄ±nÄ±n en dÃ¼ÅŸÃ¼k C99 standardÄ±na gÃ¶re yazÄ±labilir.


## C Dilinde Scope(Kapsam) KavramÄ± 

**Scope(Kapsam)** kavramÄ± **identifier(ad)**'larÄ±n bir Ã¶zelliÄŸi(sadece deÄŸiÅŸkenlerle iliÅŸkili deÄŸildir, deÄŸiÅŸkenler de bir **identifier(ad)**'dÄ±r fakat fonksiyon adlarÄ± vb. baÅŸka **identifier(ad)** tÃ¼rleri de vardÄ±r) ve bu kavram derleme zamanÄ±na iliÅŸkin bir kavramdÄ±r ama **run-time** ile iliÅŸkili deÄŸildir, yazÄ±lmÄ±ÅŸ bir kodu okuyup **identifier(ad)**'larÄ±n **Scope(Kapsam)**'larÄ±nÄ±n ne olduÄŸu gÃ¶rÃ¼lebilir. 

C dilinin standardÄ±nda **name-lookup** iÅŸleminin nasÄ±l yapÄ±lacaÄŸÄ± belirtiliyor ve derleyiciler dilin standardÄ±ndaki kurallara gÃ¶re **name-lookup** iÅŸlemini yapÄ±yorlar.

Derleyicinin yaptÄ±ÄŸÄ± **name-lookup** iÅŸlemi **Scope(Kapsam)** sÄ±nÄ±rlarÄ±na gÃ¶re yapÄ±lmaktadÄ±r.


C dilinin standardÄ±nda scope tÃ¼rleri aÅŸaÄŸÄ±daki gibidir, bunlarÄ± bilmemek C dili hakkÄ±nda hiÃ§bir ÅŸey bilinmediÄŸi ÅŸeklinde yorumlanacaktÄ±r bu nedenle iyi bilinmelidir;
1. **File scope(Dosya kapsamÄ±)**: "**Global space**" alanÄ±nda bildirilen varlÄ±klar tanÄ±mlandÄ±klarÄ± satÄ±rdan tanÄ±mlandÄ±klarÄ± dosyanÄ±n sonuna kadar eriÅŸilebilirdir.
2. **Block scope(Blok kapsamÄ±)**: "**Local space**" alanÄ±nda bildirilen varlÄ±klar tanÄ±mlandÄ±klarÄ± satÄ±rdan tanÄ±mlandÄ±klarÄ± kapsamÄ±n(scope) sonuna kadar eriÅŸilebilirdir. DiÄŸer tÃ¼rlÃ¼ ifade edersek, bir fonksiyonun ana bloÄŸunda ve bu bloÄŸun iÃ§inde yer alan bloklarÄ±n kapsamÄ±dÄ±r(scope).
3. **Function Prototype scope(Fonksiyon prototip kapsamÄ±)**: `void foo(int x, int y);` ÅŸeklindeki kodda bulunun "(int x, int y)" **Scope(Kapsam)** aralÄ±ÄŸÄ±na **Function Prototype scope** denir.
4. **Function scope(Fonksiyon kapsamÄ±)**: **goto** ile kullanÄ±lan **label**'larla ilgili bir **scope** tÃ¼rÃ¼dÃ¼r.


ğŸš€ `typedef unsigned char Byte;` kod satÄ±rÄ± **global space** alanÄ±nda tanÄ±mlandÄ±ÄŸÄ±nda bu **identifier(ad)** bir **type alias declaration** olarak tanÄ±mlanÄ±r ve bu tanÄ±mlamadan sonraki yerlerde **Byte** adÄ±nÄ±n geÃ§tiÄŸi yerlerde **unsigned char** veri tÃ¼rÃ¼ kullanÄ±lmÄ±ÅŸ gibi olur.


ğŸ§  Bir fonksiyonun ana bloÄŸuna "**main block**" deniyor ve bu block iÃ§indeki bloklara da **nested block** deniliyor, "**main block**" ya da **nested block** iÃ§erisinde kullnaÄ±lan **identifier(ad)**'larÄ±n geÃ§erli olduÄŸu **kapsam(scope)** iÃ§in **block scope** deniliyor.


Ders sonu ...
