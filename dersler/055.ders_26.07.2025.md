# 55.Ders 26.07.2025 🕘

---

## Dosya Konum Göstericisi(File Pointer) Üzerinde İşlem Yapan Fonksiyonlar 🌟 

Bir dosyanın istenilen herhangi bir byte'ından itibaren okuma ya da yazma işleminin yapılmasını sağlayan fonksiyonlar bu başlık altında incelenecektir.

Bu işlemler için standart C kütüphenesi bize beş tane fonksiyon sağlamaktadır;
- `fseek`
- `rewind`
- `ftell`
- `fsetpos`
- `fsetpos`


### `fseek`, `rewind` ve `ftell` Fonksiyonları 

`fseek` fonksiyonunun prototipi `int fseek(FILE* _Stream, long _Offset, int _Origin);` biçimindedir, bu fonksiyon "dosyada aramak" anlamına gelen "**File Seek**" sözcüklerinden kısaltılarak elde edimiştir ve **dosya konum göstericisinin(file pointer)** değreini değiştirmek için kullanılan bir fonksiyondur. </br>
`rewind` fonksiyonunun prototipi `void rewind(FILE*);` biçimindedir, bu fonksiyon **dosya konum göstericisinin(file pointer)** değerini dosyanın başına çekmek için kullanılır. </br>
`ftell` fonksiyonunun prototipi `long ftell(FILE*);` biçimindedir, bu fonksiyon **dosya konum göstericisinin(file pointer)** değerini öğrenmek için kullanılır.



⚠️ C standart kütüphenesinin `stdio.h` başlık dosyasıyla ilgili şu eleştiri yapılabilir: `stdio.h` başlık dosyasındaki fonksiyonlardan dosyalar üzerinde işlem yapan fonksiyonların bazılarında `FILE*` türü ilk parametre bazısında son parametre, neden hep ilk pametre ya da son parametre değil. Bunun nedeni muhtemelen dosyalar üzerinde işlem yapan fonksiyonların zamanla tek tek dile eklenmesi ve fonksiyonları tasarlarken bir ortak yaklaşıma uyulmamasıdır.


`fseek` fonksiyonu **dosya konum göstericisinin(file pointer)** değerini belirleyen fonksiyondur, **dosya konum göstericisinin(file pointer)** değerini değiştirmek için çağrılabilecek üç tane fonkisyondan(diğer ikisi: `rewind` ve `fsetpos`) biridir. </br>
`fseek` fonksiyonu üçüncü parametresi çağroyı yapan koddan üç farklı değerden birini beklemektedir, bu seçenekler **object like makro** olarak mevcuttur, bu makrolar `stdio.h` başlık dosyasında bulunan `SEEK_SET`, `SEEK_CUR`, `SEEK_END` makrolarıdır. </br>
`fseek` fonksiyonunun üçüncü parametresine `SEEK_SET`, `SEEK_END`, `SEEK_CUR` değerlerinden hangisinin geçildiği konumlandırma işleminde hangi noktanın başlangıç(origin) olarak alınacağını belirlemektedir. </br>
`fseek` fonksiyonunun üçüncü parametresine `SEEK_SET` değeri geçildiğinde, **dosya konum göstericisinin(file pointer)** değeri dosyanın başından itibaren fonksiyona geçilen ikinci parametredeki değerin indeksine konumlandırılacaktır. </br>
`fseek` fonksiyonunun üçüncü parametresine `SEEK_END` değeri geçildiğinde, **dosya konum göstericisinin(file pointer)** değeri dosyanın sonundan itibaren fonksiyona geçilen ikinci parametredeki değerin indeksine konumlandırılacaktır, fakat bu durumda ikinci parametre negatif bir tam sayı olmalıdır. </br>
`fseek` fonksiyonunun üçüncü parametresine `SEEK_CUR` değeri geçildiğinde, **dosya konum göstericisinin(file pointer)** değeri dosya üzerinden yapılan okuma/yazma işlemlerinde **dosya konum göstericisinin(file pointer)** en son bulunduğu konuma göre fonksiyona geçilen ikinci parametredeki değerin indeksine konumlandırılacaktır, bu durumda ikinci parametre duruma göre pozitif ya da negatif bir değer alabilir. </br>
`fseek` fonksiyonu başarılı olması durumunda "0" değerini döndürür, başarısız olması durumunda ise "non-zero" değer döndürür.



`FILE *f; fseek(f, 0L, SEEK_SET);` gibi bir kullanım **dosya konum göstericisinin(file pointer)** değerini dosyanın ilk byte'ına çekmeyi sağlar. Bu işlemi yapmak için `rewind` fonksiyonu da kullanılabiliyor. </br>
`FILE *f; fseek(f, 100, SEEK_SET);` gibi bir kullanım **dosya konum göstericisinin(file pointer)** değerini dosyanın başından itibaren 100 indeksli konuma çekmeyi sağlar. </br>

`FILE *f; fseek(f, 0L, SEEK_END);` gibi bir kullanım **dosya konum göstericisinin(file pointer)** değerini dosyanın son byte'ına çekmeyi sağlar. Bu işlem iki farklı durum için kullanılabilir, bir dosyanın sonuna yazma işlemi yapabilmek için kullanılabilir(mesela append işleminde bu yapılmaktadır) ya da bir dosyanın byte olarak büyüklüğünü ne olduğunu öğrenmek için kullanılabilir(bunun için `ftell` fonksiyonu kullanılıyor). </br>
`FILE *f; fseek(f, -30L, SEEK_END);` gibi bir kullanım **dosya konum göstericisinin(file pointer)** değerini dosyanın sonundan 30 byte geri alınır.

`FILE *f; fseek(f, 102L, SEEK_CUR);` gibi bir kullanım **dosya konum göstericisinin(file pointer)** değerini son bulunulan konumdan 102 byte ileriye alınmış olur.



👇 Aşağıdaki programda en sade haliyle `ftell` kullanımı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    FILE* f = fopen("primes10000.dat", "rb");

    if(f == NULL){
        printf("dasya acilamadi.\n"); // Hata durumlarında böyle çıktı vermek yerine sorunlu durumun bir dosyaya yazdırılması daha iyi bir yaklaşımdır.
        // fprintf(stderr, "dasya acilamadi.\n", file_pointer); // Sorunlu durum bu kullanımla dosyaya yazdırılabilir.
        return 1;
    }

    printf("%ld\n", ftell(f)); // Burada dosya yeni açıldığı için 'file pointer' değeri '0' olacaktır.

    fclose(f);
}
```



👇 Aşağıdaki programda içeriğinde sırasıyla belirli bir sayıda asal sayılar tutulan bir dosyadan `fseek` fonksiyonu ile n. bir asal sayının nasıl tespit edilebildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    FILE* f = fopen("primes10000.dat", "rb");

    if(f == NULL){
        printf("dasya acilamadi.\n"); // Hata durumlarında böyle çıktı vermek yerine sorunlu durumun bir dosyaya yazdırılması daha iyi bir yaklaşımdır.
        // fprintf(stderr, "dasya acilamadi.\n", file_pointer); // Sorunlu durum bu kullanımla dosyaya yazdırılabilir.
        return 1;
    }

    int n;
    printf("kacinci asal sayi: ");
    scanf("%d", &n);
    fseek(f, (n - 1) * (long)sizeof(int), SEEK_SET);

    int x;
    fread(&x, sizeof(int), 1, f);
    printf("%d. asal sayi %d.\n", n, x);


    fclose(f);
}
```



👇 Aşağıdaki programda içeriğinde belirli bir sayıda `Person` türünden verinin tutulduğu bir dosyadan `fseek` fonksiyonu ile n. bir `Person` verisinin nasıl tespit edilebildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "person.h"

int main(void)
{
    FILE* f = fopen("people20000.dat", "rb");

    if(f == NULL){
        printf("dasya acilamadi.\n"); // Hata durumlarında böyle çıktı vermek yerine sorunlu durumun bir dosyaya yazdırılması daha iyi bir yaklaşımdır.
        // fprintf(stderr, "dasya acilamadi.\n", file_pointer); // Sorunlu durum bu kullanımla dosyaya yazdırılabilir.
        return 1;
    }

    int n;
    printf("kacinci kullanici kaydi: ");
    scanf("%d", &n);

    fseek(f, (n - 1) * (long)sizeof(Person), SEEK_SET);
    Person per;

    fread(&per, sizeof per, 1, f);
    printf_person(&per);

    fclose(f);
}
```



👇 Aşağıdaki programda içeriğinde belirli bir sayıda `Person` türünden verinin tutulduğu bir dosyadan `fseek` fonksiyonu ile n. bir `Person` verisinin nasıl tespit edilebildiği ve ardından dosyanın başındaki `Person` verisinin nasıl tespit edilebildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "person.h"

int main(void)
{
    FILE* f = fopen("people20000.dat", "rb");

    if(f == NULL){
        printf("dasya acilamadi.\n"); // Hata durumlarında böyle çıktı vermek yerine sorunlu durumun bir dosyaya yazdırılması daha iyi bir yaklaşımdır.
        // fprintf(stderr, "dasya acilamadi.\n", file_pointer); // Sorunlu durum bu kullanımla dosyaya yazdırılabilir.
        return 1;
    }

    int n;
    printf("kacinci kullanici kaydi: ");
    scanf("%d", &n);
    
    fseek(f, (n - 1) * (long)sizeof(Person), SEEK_SET);
    Person per;

    rewind(f); // 'fseek(f, 0L, SEEK_SET);' ile aynı işi yapan dosyanın başının gösterilmesini sağlayan fonksiyon çağrısı.
    
    fread(&per, sizeof per, 1, f);
    printf_person(&per);

    fclose(f);
}
```



👇 Aşağıdaki programda `fseek` ve `ftell` fonksiyonlarını kullanrak bir dosyanın düyüklüğünün nasıl elde edildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "person.h"

int main(void)
{
    FILE* f = fopen("people1000000.dat", "rb");

    if(f == NULL){
        printf("dasya acilamadi.\n"); // Hata durumlarında böyle çıktı vermek yerine sorunlu durumun bir dosyaya yazdırılması daha iyi bir yaklaşımdır.
        // fprintf(stderr, "dasya acilamadi.\n", file_pointer); // Sorunlu durum bu kullanımla dosyaya yazdırılabilir.
        return 1;
    }

    fseek(f, 0L, SEEK_END);
    printf("dosya buyuklugu %ld\n", ftell(f));

    fclose(f);
}
```



👇 Aşağıdaki programda içinde `Person` türünden verilerin olduğu bir dosyanın büyüklüğünün nasıl tespit edildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "person.h"

int main(void)
{
    FILE* f = fopen("people10000.dat", "rb");

    if(f == NULL){
        printf("dasya acilamadi.\n"); // Hata durumlarında böyle çıktı vermek yerine sorunlu durumun bir dosyaya yazdırılması daha iyi bir yaklaşımdır.
        // fprintf(stderr, "dasya acilamadi.\n", file_pointer); // Sorunlu durum bu kullanımla dosyaya yazdırılabilir.
        return 1;
    }

    printf("sizeof(Person) = %zu", sizeof(Person));
    fseek(f, 0L, SEEK_END);
    printf("dosya buyuklugu %ld\n", ftell(f));

    fclose(f);
}
```



👇 Aşağıdaki programda içinde `Person` türünden verilerin olduğu bir dosyanın büyüklüğünün nasıl tespit edildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "person.h"
#include "nutility.h"

int main(void)
{
    FILE* f = fopen("people10000.dat", "wb+"); // Dosyanın içeriğini silmeden dosyada yazma işlemi yapabilmek için dosynın 'write binary +' olarak açılması.

    if(f == NULL){
        printf("dasya acilamadi.\n"); // Hata durumlarında böyle çıktı vermek yerine sorunlu durumun bir dosyaya yazdırılması daha iyi bir yaklaşımdır.
        // fprintf(stderr, "dasya acilamadi.\n", file_pointer); // Sorunlu durum bu kullanımla dosyaya yazdırılabilir.
        return 1;
    }

    randomize();
    Person per;
    set_random_person(&per);
    printf_person(&per);

    fseek(f, 0L, SEEK_END); // 'file pointer' dosyanın sonunu gösterecek biçimde ayarlanıyor.

    fwrite(&per, sizeof Per, 1, f); // Burada dosyanın sonuna yeni üretilen 'Person' kaydı ekleniyor.

    fclose(f);
}
```



👇 Aşağıdaki programda içinde `Person` türünden verilerin olduğu bir dosyanın büyüklüğünün nasıl tespit edildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "person.h"
#include "nutility.h"

int main(void)
{
    FILE* f = fopen("people10000.dat", "rb+"); // Dosyanın içeriğini silmeden dosyada yazma ve okuma işlemlerini yapabilmek için dosynın 'read binary +' olarak açılması.

    if(!f){
        printf("dasya acilamadi.\n"); // Hata durumlarında böyle çıktı vermek yerine sorunlu durumun bir dosyaya yazdırılması daha iyi bir yaklaşımdır.
        // fprintf(stderr, "dasya acilamadi.\n", file_pointer); // Sorunlu durum bu kullanımla dosyaya yazdırılabilir.
        return 1;
    }

    fseek(f, 0L, SEEK_END); // 'file pointer' dosyanın sonunu gösterecek biçimde ayarlanıyor.
    printf("%ld\n", ftell(f)); // Dosyanın boyutu yazdırılıyor.

    // Dosyaya yeni bir kaydın eklenmsi.
    randomize();
    Person per;
    set_random_person(&per);
    print_person(&per);
    fwrite(&per, sizeof per, 1, f);

    rewind(f); // 'file pointer' dosyanın sonunu gösterecek biçimde ayarlanıyor.
    printf("%ld\n", ftell(f)); // Dosyanın boyutu yazdırılıyor.

    fclose(f); 
}
```



👇 Aşağıdaki programda kullanıcı bilgilerinin kayıtlı olduğu dosyanın verilerinin okunması işleminin bir fonksiyona alınması işleminin nasıl yapıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "person.h"
#include "nutility.h"
#include <stdlib.h> // 'exit' fonksiyonunu kullanmak için eklendi.

void print_records(const char* filename)
{
    FILE* f = fopen(filename, "rb");
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    Person per;

    // Dosyadaki tüm 'Person' türünden kayıtların dosyanın sonuna kadar yazdırılması işlemi.
    while(fread(&per, sizeof(Person), 1, f)){
        printf_person(&per);
    }

    fclose(f);
}

int main(void)
{
    print_records("people1000.dat");
    (void)getchar();
    print_records("people1000.dat");
}
```



👇 Aşağıdaki programda kullanıcı bilgilerinin kayıtlı olduğu dosyaya yeni veri ekleme ve dosyadaki verilerinin okunması işleminin birer fonksiyona alınarak nasıl kullanıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "person.h"
#include "nutility.h"
#include <stdlib.h> // 'exit' fonksiyonunu kullanmak için eklendi.

void print_records(const char* filename)
{
    FILE* f = fopen(filename, "rb");
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    Person per;

    // Dosyadaki tüm 'Person' türünden kayıtların dosyanın sonuna kadar yazdırılması işlemi.
    while(fread(&per, sizeof(Person), 1, f)){
        printf_person(&per);
    }

    fclose(f);
}

void add_record(const char* filename, const Person* p)
{
    FILE* f = fopen(filename, "ab"); // 'ab' modunda sadece dosyanın sonuna yazma işlemi yapılabilir biçimde dosya açılıyor.
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    fwrite(p, sizeof(Person), 1, f);

    fclose(f);
}

int main(void)
{
    randomize();

    Person per;
    set_random_person(&per);
    print_person(&per);
    add_record("people.dat", &per);

    print_records("people.dat");
}
```



👇 Aşağıdaki programda kullanıcı bilgilerinin kayıtlı olduğu dosyaya döngü ile yeni veriler eklenmesi ve dosyadaki verilerinin okunması işleminin birer fonksiyona alınarak nasıl kullanıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "person.h"
#include "nutility.h"
#include <stdlib.h> // 'exit' fonksiyonunu kullanmak için eklendi.

void print_records(const char* filename)
{
    FILE* f = fopen(filename, "rb");
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    Person per;

    // Dosyadaki tüm 'Person' türünden kayıtların dosyanın sonuna kadar yazdırılması işlemi.
    while(fread(&per, sizeof(Person), 1, f)){
        printf_person(&per);
    }

    fclose(f);
}

void add_record(const char* filename, const Person* p)
{
    FILE* f = fopen(filename, "ab"); // 'ab' modunda sadece dosyanın sonuna yazma işlemi yapılabilir biçimde dosya açılıyor.
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    fwrite(p, sizeof(Person), 1, f);

    fclose(f);
}

int get_record_count(const char* filename)
{
    FILE* f = fopen(filename, "rb"); // 'rb' modunda sadece dosyanın binary olarak okunabilmesi işlemini yapılabilir biçimde dosya açılıyor.
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    fseek(f, 0, SEEK_END); 

    int rec_cnt = (int)(ftell(f) / sizeof(Person));

    fclose(f);

    return rec_cnt;
}

int main(void)
{
    randomize();

    Person per;

    for(int i = 0; i < 1000; ++i){
        set_random_person(&per);
        add_record("people.dat", &per);
    }
    
    print_records("people.dat");

    printf("dosyadaki kayit sayisi: %d\n", get_record_count("people.dat"));
}
```



❗❗❗ `fseek` fonksiyonunun kullanımıyla ilgili çok sık yapılan ve **ub** ye neden olan durum şağıda belirtilmiştir. </br>
Eğer okuma işleminden sonra yazma işlemi yapılacaksa ya da tma tersi yazma işleminden sonra okuma işlemi yapılacaksa mutlama **dosya konum göstericisinin(file pointer)** konumlandırılması gerekir(`fflush` fonksiyonua yapılan çağrı da bunu sağlar). </br>
Okuma işleminden yazma işlemine geçerken ya da yazma işleminden okuma işlemine geçerken **Dosya konum göstericisinin(file pointer)** bulunduğu konumdan itibaren işlem yapılacak olsa bile mutlaka `rewind(f);` veya `fseek(f, 0L, SEEK_SET);` fonksiyon çağrıları yapılır.



***
==================================================

✦✦✦✦✦ 10.36-10.55 birinci ara verildi. ✦✦✦✦✦

==================================================
***



👇 Aşağıdaki programda dosyadan okunan belirli kayıtlardaki bilgilerin değiştirilerek yeniden aynı dosyaya nasıl yazdırıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "person.h"
#include "nutility.h"
#include <stdlib.h> // 'exit' fonksiyonunu kullanmak için eklendi.
#include <string.h> // 'strcmp' fonksiyonunu kullanmak için eklendi.

void print_records(const char* filename)
{
    FILE* f = fopen(filename, "rb");
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    Person per;

    // Dosyadaki tüm 'Person' türünden kayıtların dosyanın sonuna kadar yazdırılması işlemi.
    while(fread(&per, sizeof(Person), 1, f)){
        printf_person(&per);
    }

    fclose(f);
}

void add_record(const char* filename, const Person* p)
{
    FILE* f = fopen(filename, "ab"); // 'ab' modunda sadece dosyanın sonuna yazma işlemi yapılabilir biçimde dosya açılıyor.
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    fwrite(p, sizeof(Person), 1, f);

    fclose(f);
}

int get_record_count(const char* filename)
{
    FILE* f = fopen(filename, "rb"); // 'rb' modunda sadece dosyanın binary olarak okunabilmesi işlemini yapılabilir biçimde dosya açılıyor.
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    fseek(f, 0, SEEK_END); 

    int rec_cnt = (int)(ftell(f) / sizeof(Person));

    fclose(f);

    return rec_cnt;
}

// Dosyadaki kayıt ya da kayıtları değiştirmeye yönelik fonksiyon
int modify_records(const char* filename, const char* oldname, const char* newname)
{
    FILE* f = fopen(filename, "rb+"); // 'rb+' modunda dosyanın binary olarak hem okunabilir hem de yazılabilir biçimde dosya açılıyor.
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    Person per; // Dosyada okuma ve yazma işlemlerini yaparken kullanılacak olan değişken bildirimi yapılıyor.
    int count = 0;

    while(fread(&per, sizeof(Person), 1, f)){
        if(!strcmp(per.name, oldname)){
            strcpy(per.name, newname);
            fseek(f, -(long)sizeof(Person), SEEK_CUR); // Dosyaya yazma işlemi yapmadan önce üzerine yazılacak kaydın ayarlanması için 'file pointer' değeri ayarlarnıyor.
            fwrite(&per, sizeof(Person), 1, f); // Dosyada değiştirilecek kaydın üzerine yazma işlemi.
            fseek(f, 0L, SEEK_CUR); // Dosyaya yazma işleminden dosyadan okuma işlemine geçiş yapılacağı için 'file pointer' en son kaldığı yeri gösterecek biçimde ayarlanıyor.

            ++count;
        }
    }

    fclose(f);
    return count;
}

int main(void)
{
    int n = modify_records("people.dat", "hasan", "mete");

    printf("toplamda %d kayit degistirildi.\n", n);

    print_records("people.dat");
}
```


❗❗❗ Dosyalarla yapılan işlemlerde bir dosyadan veri silmek gibi bir işlem mevcut değil, bir dosya büyüyü bilir ama küçülemez. Bir dosyadan bazı veriler silinmek isteniyorsa yeni bir dosya oluşturulur eski dosyadaki verilerden silinecekler haricindekiler yeni dosyaya kopyalanır iki dosya kapatıldıktan sonra eski dosya silinir ve yeni dosyanın adı eski dosya ile aynı yapılır, böylece dosyadan istenmeyen veriler silinmiş olur.



👇 Aşağıdaki program dosyadaki belirli kayıtların bilgilerinin nasıl silindiğini anlamak için incelenebilir, burada belirli bir günde doğmuş olan kişilerin kayıtlarının dosyadan silinişini inceleyeceğiz.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "person.h"
#include "nutility.h"
#include <stdlib.h> // 'exit' fonksiyonunu kullanmak için eklendi.
#include <string.h> // 'strcmp' fonksiyonunu kullanmak için eklendi.

void print_records(const char* filename)
{
    FILE* f = fopen(filename, "rb");
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    Person per;

    // Dosyadaki tüm 'Person' türünden kayıtların dosyanın sonuna kadar yazdırılması işlemi.
    while(fread(&per, sizeof(Person), 1, f)){
        printf_person(&per);
    }

    fclose(f);
}

void add_record(const char* filename, const Person* p)
{
    FILE* f = fopen(filename, "ab"); // 'ab' modunda sadece dosyanın sonuna yazma işlemi yapılabilir biçimde dosya açılıyor.
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    fwrite(p, sizeof(Person), 1, f);

    fclose(f);
}

int get_record_count(const char* filename)
{
    FILE* f = fopen(filename, "rb"); // 'rb' modunda sadece dosyanın binary olarak okunabilmesi işlemini yapılabilir biçimde dosya açılıyor.
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    fseek(f, 0, SEEK_END); 

    int rec_cnt = (int)(ftell(f) / sizeof(Person));

    fclose(f);

    return rec_cnt;
}

// Dosyadaki kayıt ya da kayıtları değiştirmeye yönelik fonksiyon
int modify_records(const char* filename, const char* oldname, const char* newname)
{
    FILE* f = fopen(filename, "rb+"); // 'rb+' modunda dosyanın binary olarak hem okunabilir hem de yazılabilir biçimde dosya açılıyor.
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    Person per; // Dosyada okuma ve yazma işlemlerini yaparken kullanılacak olan değişken bildirimi yapılıyor.
    int count = 0;

    while(fread(&per, sizeof(Person), 1, f)){
        if(!strcmp(per.name, oldname)){
            strcpy(per.name, newname);
            fseek(f, -(long)sizeof(Person), SEEK_CUR); // Dosyaya yazma işlemi yapmadan önce üzerine yazılacak kaydın ayarlanması için 'file pointer' değeri ayarlarnıyor.
            fwrite(&per, sizeof(Person), 1, f); // Dosyada değiştirilecek kaydın üzerine yazma işlemi.
            fseek(f, 0L, SEEK_CUR); // Dosyaya yazma işleminden dosyadan okuma işlemine geçiş yapılacağı için 'file pointer' en son kaldığı yeri gösterecek biçimde ayarlanıyor.

            ++count;
        }
    }

    fclose(f);
    return count;
}

int delete_records(const char* filename, int mday)
{
    FILE* f = fopen(filename, "rb");
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    char tempname[L_tmpnam];
    tmpnam(tempname); // copya dosya adının eşsiz olması için dosya adı 'tmpnam' fonksiyonuyla elde ediliyor.

    FILE* fd = fopen(tempname, "wb");

    if(!fd){
        fprintf(strerr, "%s gecisi dosya olusturulamadi.\n", filename);
        fclose(fd);
        exit(EXIT_FAILURE);
    }

    Person per;

    int read_count = 0;
    int write_count = 0;

    while(fread(&per, sizeof(Person), 1, fs)){
        ++read_count;
        if(per.bdate.d_ != mday){ // Silinecek kayit degilse bloğa gir.
            fwrite(&per, sizeof(Person), 1, fd);
            ++write_count;
        }
    }

    // Dosyalar kapatılıyor
    fclose(fs);
    fclose(fd);

    // Eski dosya siliniyor.
    if(remove(filename)){
        fprintf(strerr, "%s dosyasi silinemedi.\n", filename);
        exit(EXIT_FAILURE);
    }

    // Yeni dosyanın adı değiştiriliyor.
    if(rename(tempname, filename)){
        fprintf(strerr, "%s dosya adi degistirilemedi.\n", filename);
        exit(EXIT_FAILURE);
    }

    return read_count - write_count;
}

int main(void)
{
    for(int i = 0; i <= 31; ++i){
        if(i % 10 != 0){ // 10 değerine bölünmeyen günlerde doğan kişi kayıtları dosyadan silinecek. 
            int n = delete_records("people.dat", i);
            printf("ayin %d. gununde dogan %d kayit silinde\n", i, n);
            (void)getchar(); // Kullanıcıdan bir tuşa basması için bekleniyor.
        }
    }

    printf("%d\n", get_records_count("people.dat"));
    (void)getchar(); // Kullanıcıdan bir tuşa basması için bekleniyor.
    print_records("people.dat"); 
}
```



👇 Aşağıdaki program `Person` kayıtlarının tutulduğu dosyadaki kayıtların nasıl sıralandığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "person.h"
#include "nutility.h"
#include <stdlib.h> // 'exit' fonksiyonunu kullanmak için eklendi.
#include <string.h> // 'strcmp' fonksiyonunu kullanmak için eklendi.

void print_records(const char* filename)
{
    FILE* f = fopen(filename, "rb");
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    Person per;

    // Dosyadaki tüm 'Person' türünden kayıtların dosyanın sonuna kadar yazdırılması işlemi.
    while(fread(&per, sizeof(Person), 1, f)){
        printf_person(&per);
    }

    fclose(f);
}

void add_record(const char* filename, const Person* p)
{
    FILE* f = fopen(filename, "ab"); // 'ab' modunda sadece dosyanın sonuna yazma işlemi yapılabilir biçimde dosya açılıyor.
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    fwrite(p, sizeof(Person), 1, f);

    fclose(f);
}

int get_record_count(const char* filename)
{
    FILE* f = fopen(filename, "rb"); // 'rb' modunda sadece dosyanın binary olarak okunabilmesi işlemini yapılabilir biçimde dosya açılıyor.
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    fseek(f, 0, SEEK_END); 

    int rec_cnt = (int)(ftell(f) / sizeof(Person));

    fclose(f);

    return rec_cnt;
}

// Dosyadaki kayıt ya da kayıtları değiştirmeye yönelik fonksiyon
int modify_records(const char* filename, const char* oldname, const char* newname)
{
    FILE* f = fopen(filename, "rb+"); // 'rb+' modunda dosyanın binary olarak hem okunabilir hem de yazılabilir biçimde dosya açılıyor.
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    Person per; // Dosyada okuma ve yazma işlemlerini yaparken kullanılacak olan değişken bildirimi yapılıyor.
    int count = 0;

    while(fread(&per, sizeof(Person), 1, f)){
        if(!strcmp(per.name, oldname)){
            strcpy(per.name, newname);
            fseek(f, -(long)sizeof(Person), SEEK_CUR); // Dosyaya yazma işlemi yapmadan önce üzerine yazılacak kaydın ayarlanması için 'file pointer' değeri ayarlarnıyor.
            fwrite(&per, sizeof(Person), 1, f); // Dosyada değiştirilecek kaydın üzerine yazma işlemi.
            fseek(f, 0L, SEEK_CUR); // Dosyaya yazma işleminden dosyadan okuma işlemine geçiş yapılacağı için 'file pointer' en son kaldığı yeri gösterecek biçimde ayarlanıyor.

            ++count;
        }
    }

    fclose(f);
    return count;
}

int delete_records(const char* filename, int mday)
{
    FILE* f = fopen(filename, "rb");
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    char tempname[L_tmpnam];
    tmpnam(tempname); // copya dosya adının eşsiz olması için dosya adı 'tmpnam' fonksiyonuyla elde ediliyor.

    FILE* fd = fopen(tempname, "wb");

    if(!fd){
        fprintf(strerr, "%s gecisi dosya olusturulamadi.\n", filename);
        fclose(fd);
        exit(EXIT_FAILURE);
    }

    Person per;

    int read_count = 0;
    int write_count = 0;

    while(fread(&per, sizeof(Person), 1, fs)){
        ++read_count;
        if(per.bdate.d_ != mday){ // Silinecek kayit degilse bloğa gir.
            fwrite(&per, sizeof(Person), 1, fd);
            ++write_count;
        }
    }

    // Dosyalar kapatılıyor
    fclose(fs);
    fclose(fd);

    // Eski dosya siliniyor.
    if(remove(filename)){
        fprintf(strerr, "%s dosyasi silinemedi.\n", filename);
        exit(EXIT_FAILURE);
    }

    // Yeni dosyanın adı değiştiriliyor.
    if(rename(tempname, filename)){
        fprintf(strerr, "%s dosya adi degistirilemedi.\n", filename);
        exit(EXIT_FAILURE);
    }

    return read_count - write_count;
}


// 'qsort' fonksiyonuna geçilecek olan sıralama işlemini yapacak fonksiyon.
static int pcmp(const void* vp1, const void* vp2)
{
   return cmp_person((const Person*)vp1, (const Person*)vp2);
}

// 'qsort' fonksiyonuna istek yapılıp 'Person' tründen dizinin sıralanmasını sağlayan sarmalayıcı fonksiyon. 
void sort_person_array(Person* p, size_t size)
{
    qsort(p, size, sizeof(*p), &pcmp);
}

void sort_records(const char* filename)
{
    FILE* f = fopen(filename, "rb+"); // 'rb+' modunda dosyanın binary olarak hem okunabilir hem de yazılabilir biçimde dosya açılıyor.
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        fclose(f);
        exit(EXIT_FAILURE);
    }

    fseek(f, 0L, SEEK_END);
    int record_count = (int) (ftell(f) / sizeof(Person));
    Person* pd = (Person*) malloc(record_count * sizeof(Person));
    if(!pd){
        fprintf(strderr, "bellek yetersiz.\n");
        exit(EXIT_FAILURE);
    }

    rewind(f); // 'file pointer' dosyanın başına çekildi.
    fread(pd, sizeof(Person), record_count, f);
    sort_person_array(pd, record_count);
    rewind(f);
    fwrite(pd, sizeof(Person), record_count, f);

    fclose();
    free(pd); // Dinamik bellek alanı iade ediliyor.
}

int main(void)
{
    sort_records("people.dat"); 

    print_recodrs("people.dat");
}
```


⚠️⚠️⚠️ Programlamada en kötü alışkanlığın biri çok büyük(kaylaşık 50 satırdan büyük fonksiyonları bu öbeğe dahil edebiliriz) fonksiyonların yazılmasıdır. </br>
Büyük fonksiyonlar aşağıdaki sorunlara neden olur;
1. Fonksiyonu incelemek ve debug etmek zorlaşır.
2. Okunması ve bakımı zor olur.


### `fsetpos` ve `fgetpos` Fonksiyonları 

`fsetpos` fonksiyonunun prototipi `int fsetpos(FILE*, const fpos_t *);` biçimindedir, **dosya konum göstericisinin(file pointer)** değerini değiştiren(setting operation) fonksiyondur. `FILE*` türünden argümandaki dosyanın **dosya konum göstericisinin(file pointer)** değerini `const fpos_t *` türündeki parametre nesnesinin değeriyle değiştirir. Geri dönüş değeri "0" olunca işlem başarılı "non-zero" olursa işlem başarısız anlamına geliyor. </br>
`fgetpos` fonksiyonunun prototipi `int fgetpos(FILE*, fpos_t *);` biçimindedir, **dosya konum göstericisinin(file pointer)** değerini dönen fonksiyondur. `FILE*` türünden argümandaki dosyanın **dosya konum göstericisinin(file pointer)** değerini `fpos_t *` türündeki parametre nesnesine atar ve bu nesne **out-prameter** olduğu için çağrı yaan kod değeri almış olur. Geri dönüş değeri "0" olunca işlem başarılı "non-zero" olursa işlem başarısız anlamına geliyor.

`fsetpos` ve `fgetpos` fonksiyonlarıyla işlem yaparken **dosya konum göstericisinin(file pointer)** değeri `fpos_t` tür eş adıyla temsil edilmiş, bu tür eş adıyla sistemdeki en büyük dosya byte boyutu karşılanmış olur, bu nedenden dolayı büyük dosyalarla çalışırken bu fonksiyonlar kullanılmalıdır. </br>
`fpos_t` bir tür eş dıdır ve hangi işaretli tam sayıya karşılık geldiği derleyiciye bırakılmıştır.

`fseek` fonksiyonu ile `fsetpos` fonksiyonu temelde aynı işlemi yapıyor yani **dosya konum göstericisinin(file pointer)** değerini değiştirmek için kullanılırlar, aralarındaki farklar;
1. `fseek` fonksiyonu ikinci parametre değişkeni `long` türündendir ama `fpos_t` tür eş adı en az `long` türünün boyutunda olacağı kesindir, bu nedenden dolayı büyük dosyalarda çalışırken `fsetpos` fonksiyonu tercihedilir.
2. `fsetpos` ve `fgetpos` fonksiyonları kullanıldığında dosya üzerinde ilk işleme vaşlandığı andaki **dosya konum göstericisinin(file pointer)** değerine dönmek kolaydır ve güvenlidir,  



👇 Aşağıdaki programda `fsetpos` ve `fgetpos` fonksiyonlarının kullanımı incelenebilir. 
```C
#include <stdio.h>
#include "person.h"

int main()
{
    FILE* f = fopen("people.dat", "rb");
    Person p;

    for(int i = 0; i < 100; ++i){
        fread(&per, sizeof(&per), 1, f);
    }

    fpos_t pos;
    fgetpos(f, &pos); // 'pos' nesnesine 'f' fonksiyonunun bu andaki 'file pointer' değeri atanıyor.

    // some code here.

    fsetpos(f, &pos); // Bu fonksiyon çağrsı ile 'f' fonksiyonunun 'file pointer' değeri yukarıdaki 'fgetpos' çağrısı yapıldığı andaki 'file pointer' değerine geri alınmış olacaktır.
}
```


***
==================================================

✦✦✦✦✦ 11.58-12.11 ikinci ara verildi. ✦✦✦✦✦

==================================================
***

### Eof and Error Flag

Öncelikle dosya işlemlerini yaparken artalanda yapılan bazı işlemleri bilmek gerekiyor;
Bir dosyadan okuma işlemi yapan bir fonksiyon çağırıldığında aslında o fonksiyon okuma işlemini yapmadan önce `FILE*` türünden değişken vasıtasıyla bit seviyesinde tutulan bir bayrağa bakıyor, bu bayrağa **Eof Flag** deniliyor.

Mülakatlarda dosya işlemleriyle ilgili olarak en çok sorulan sorulardan biri **Eof Flag** değerinin ne zaman 1 yapıldığıdır(set status), **Eof Flag** dosyadan okunacak byte kalmadı anda 1 yapılmaz, dosyayı okumak için istek yapıldığında dosyada okunacak byte kalmadığı ilk başarısız okuma işleminde 1 yapılır(set status), dosyadan okuma işlemlerinde **Eof Flag** değerine bakılır bu değer 1 ise dosyadan okuma yapılmaya çalışılmaz.

**Error Flag** okuma ya da yazma işleminin başarısız olmasının nedeni dosya sonuyla ilgili olmadığında(mesela sistem seviyesinde olan bir hata, bellek yetersiz olması durumu bu hataya neden olabilir ya da salt okuma amaçlı açılan dosyada yazma işlemi yapılında bu hataya neden olabilir) 

Bir dosya üzerinde okuma ya da yazma işleminin yapılabilmesi için **eof** ve **error** bayraklarının 0 olması gerekiyor, yoksa dosya üzerinde işlem yapılamaz.


### `foef`, `ferror`, `clearerr` Fonksiyonları 

`foef` fonksiyonunun prototipi `int foef(FILE*);` biçimindedir, bu fonksiyon geriye **Eof Flag** değerini döner.

`ferror` fonksiyonunun prototipi `int ferror(FILE*);` biçimindedir, bu fonksiyon geriye **Error Flag** değerini döner.

`clearerr` fonksiyonunun prototipi `void clearerr(FILE*);` biçimindedir, bu fonksiyon bir dosyanın hata bayraklarını sıfırlamak için kullanılır.



👇 Aşağıdaki programda `feof` fonksiyonunun kullanımı incelenebilir.
```C
#include <stdio.h>
#include "person.h"

int main()
{
    FILE* f = fopen("out.txt", "r");

    if(feod(f)){
        printf("eof bayragi set edilmis-1.\n");
    }
    else{
        printf("eof bayragi set edilmemis-1.\n");
    }

    fseek(f, 0L, SEEK_END);

    if(feod(f)){
        printf("eof bayragi set edilmis-2.\n");
    }
    else{
        printf("eof bayragi set edilmemis-2.\n");
    }

    int c = fgetc(f);
    printf("c = %d\n", c);

    if(feod(f)){
        printf("eof bayragi set edilmis-3.\n");
    }
    else{
        printf("eof bayragi set edilmemis-3.\n");
    }

    fclose(f);
}
```



❗❗❗ 👇 Aşağıdaki programda `feof` fonksiyonunun `while` döngüsüyle aşağıdaki gibi kullanımı hatalıdır çünkü `feof` fonksiyonu geriye dosya sonuna gelinip gelinmediği bilgisini dönmez, bu  fonksiyon geriye dosya sonuna gelindikten sonra dosya üzerinde yapılan ilk işlemde dosyada işlem yapılabilecek byte kalmadığındanda geriye "1" değerini döndürecektir.
```C
#include <stdio.h>

int main()
{
    FILE* f = fopen("out.txt", "r");

    while(!feof(f)){
        int c = fgetc(f);
        printf("%d ", c);
    }
    
    fclose(f);
}
```



❗❗❗ 👇 Aşağıdaki programda `feof` fonksiyonunun `while` döngüsüyle aşağıdaki gibi kullanımı doğru kullanımdır.
```C
#include <stdio.h>

int main()
{
    FILE* f = fopen("out.txt", "r");

    int c;
    while((c = fgetc(f)) != EOF){
        int c = fgetc(f);
        printf("%d ", c);
    }
    
    fclose(f);
}
```


❗❗❗ Eğer bir dosyada **eof** ya da **error** bayraklarının değeri 1 ise bu dosyalar üzerinde okuma ya da yazma işlemlerinin yapılabilmesi için ya hata bayraklarını sıfırlayan `clearerr` fonksiyonu çağırılmalı ya da dosyanın **dosya konum göstericisinin(file pointer)** değerini değiştiren fonksiyonlardan birinin(`fseek`, `rewind`, `fsetpos`) çağırılması ya da `fflush` fonksiyonuna çağrı yapılması gerekiyor, bu işlemler hata bayraklarını sıfırlar. 



👇 Aşağıdaki programda **eof** bayrağının nasıl temizlendiği incelenebilir.
```C
#include <stdio.h>

int main()
{
    FILE* f = fopen("out.txt", "r");

    int c;
    while((c = fgetc(f)) != EOF){
        int c = fgetc(f);
        printf("%d ", c);
    }
    printf("\n");

    if(feof(f))
        printf("eof bayragi set edilmis.\n");
    else
        printf("eof bayragi set edilmemis.\n");

    // Dosya hata bayraklarını sıfırlayan işlemler aşağıdan görülebilir.
    // rewind(f);
    // fseek(f, 0, SEEK_SET);
    clearerr(f);


    fclose(f);
}
```


❗❗❗ `feof` sadece bir dosyadan okuma yazma işlemi yapılması sırasında **dosya konum göstericisinin(file pointer)** değerinin dosya sonunu göstermesinden dolayı hata alınıp alınmadığı bilgisini edinmek için kullanılır, ilgili dosyada bu neden dışında bir sorundan dolayı okuma ya da yazma işleminde hata olmuşsa bu bayrak 1 yapılmaz.



👇 Aşağıdaki programda okuma amaçlı açılan bir dosyaya yazma işlemi yapılmasından dolayı **error** bayrağı 1 yapılacaktır ve bundan faydalanarak `ferror` fonksiyonunun kullanımı incelenebilir.
```C
#include <stdio.h>

int main()
{
    FILE* f = fopen("out.txt", "r");
    if(!f){
        printf("dosya acilamadi.\n");
        return 1;
    }

    // 'fputc' fonksiyonu başarısız olduğunda geri dönüş değer 'EOF' değeridir, başarılı olduğunda ise dosyaya yazdırılan karakterin kod değeridir. 
    if(fputc('X', f) == EOF){
        if(ferror(f)){
            printf("yazma hatasi olustu.\n");
            return 1;
        }
    }
    
    fclose(f);
}
```



👇 Aşağıdaki programda **error** bayrağının nasıl temizlendiği incelenebilir.
```C
#include <stdio.h>

int main()
{
    FILE* f = fopen("out.txt", "r");
    if(!f){
        printf("dosya acilamadi.\n");
        return 1;
    }

    fputc('X', f);

    if(ferror(f)){
        printf("error bayragi set edilmis.\n");
    }
    else{
        printf("error bayragi set edilmemis.\n");
    }
    
    // Dosya hata bayraklarını sıfırlayan işlemler aşağıdan görülebilir.
    rewind(f);
    // fseek(f, 0, SEEK_SET);
    // clearerr(f);

    if(ferror(f)){
        printf("error bayragi set edilmis.\n");
    }
    else{
        printf("error bayragi set edilmemis.\n");
    }

    fclose(f);
}
```


### `fflush` Fonksiyonu 

`fflush` fonksiyonunun prototipi `void fflush(FILE*);` biçimindedir, bu fonksiyon bir dosyanın hata bayraklarını sıfırlamak için kullanılır.

Dosya işlemlerinde mesela dosyaya bir byte yazmak için dosyaya yazma işlemini yapan fonksiyon çağırılsa dahi fiilen o dosyaya o byte yazılmıyor(eğer öyle olsaydı, dosyaya yazma işlemleri çok yavaş olurdu), bir dosya açıldığında o doyaya bağlı artalanda(background) bir **file buffer(bir bellek alanı)** oluşturulur, bir dosya açıldığında o dosyada okuma ve yazma işlemlerinin yapılabilmesi için ihtiyaç duyulan programın çalışma zamanında kullanılan bir bellek alanı var, o bellek alanı o dosya için kullanılacak, o bellek alanı ayrılamazsa(allacate) da `fopen` fonksiyonu başarısız olabilir. </br>
Bir dosyaya yapılan yazma işlemi doğrudan dosyaya yapılmıyor, yazma işlemi o dosyanın **file buffer(bir bellek alanı)** tarafına yapılıyor. </br>
**File buffer(bir bellek alanı)** değerinin kaç byte olduğu bilgisi `stdio.h` başlık dosyasındaki `BUFSIZE` makrosunda yer almaktadır. </br>
Dosyalar üzerinde yapılan yazma işlemlerde bazı işlemler gerçekleştiğinde **file buffer(bir bellek alanı)** alanında bulunan bütün byte'lar fiilen dosyaya yazılır, işte bu işleme **flushing** deniliyor. </br>
**Flush** işlemi dosyanın **file buffer(bir bellek alanı)** alanında yapılan değişiklerin dosyaya fiilen kaydedilmesi işlemidir.



**Flush** işlemi hangi durumlarda yapılır;
1. **File buffer(bir bellek alanı)** alanı dolduğunda **flush** işlemi yapılır.
2. Eğer program `exit` fonksiyonu ile **normal termination** işlemiyle sonlanıyorsa **flush** işlemi yapılır.
3. `fflush` fonksiyonu çağırıldığında **flush** işlemi yapılır.
4. Yazma amaçlı bir dosya okuma amaçlı bir dosyaya bağlanmış(İngilizce olarak bu durum **tie** fiiliyle belirtilir) durumda olacak ve okuma amaçlı bir dosyadan okuma işlemi yapılacak. Bu duruma **Standat input**'un **Standat output**'a bağlanmış(tie) oluşunu misal olarak verebiliriz


Sistemlerin hemen hepsinde **flush** işleminin yapılmasının sık rastlanan kullanımı da **standat output**'un , 

❗❗❗ Şu şikyet sık duyulabilir: "`printf` fonksiyonunu çağırdım ama programın akışı o çağrıya gelsiğinde yazdırılan veriler standart çıktı akımına gönderilmedi!", bunun nedeni **standat output**'un **buffer(bir bellek alanı)**'ının dolması olabilir, **standat output** ta bir dosya onun da bir **buffer(bir bellek alanı)**'ı var, demek ki henüz **standat output**'un **buffer(bir bellek alanı)**'ı **flush** edilmemiş.

❗❗❗ **Standat input** **Standat output**'a bağlanmış(İngilizce olarak bu durum **tie** fiiliyle belirtilir) durumdadır. **File buffer(bir bellek alanı)**'ın **flush** edilmesi için bir başka durum: Eğer yazma amaçlı bir dosyanın **buffer(bir bellek alanı)**'ı okuma amaçlı bir dosyaya bağlanmış(tie) ise



👇 Aşağıdaki programda 
```C
#include <stfio.h>

int main(void)
{
    // Dosyadan bir okuma işlemi yapıldığında önce onun bağlandığı çıkış akımı 'flush' edilmektedir.
    // Yani aşağıdaki kodlar çalıştığında 'bir tam sayi giriniz: ' yazısının ekranda görülmesinin kesin olmasının nedeni 'scanf' fonksiyonuyla bir giriş alınmasıdır, çünkü 'scanf' fonksiyonu 'standart input'un 'buffer(bir bellek alanı)'ını kullanıyor ve 'standart input' 'standart output'a bağlanmış durumdadır.
    printf("bir tam sayi giriniz: ");
    int x;
    scanf("%d", x);
}
```



❗❗❗ **Buffer(bir bellek alanı)** kullanımı özelleştirilebiliyor, `setvbuf` fonksiyonu kullanılarak **buffer(bir bellek alanı)** kullanımı tamamen ortadan kaldırabilir. `setvbuf` fonksiyonuyla **buffer(bir bellek alanı)** kullanımı engellenirse bir dosyaya yapılacak yazma işlemi doğrudan dosyaya yazılacak anlamına gelmektedir.



`fflush` fonksiyonuna okuma amaçlı kullanılan bir dosyanın adresi argüman olarak verilmemelidir(**ub** durumuna neden olur). `fflush` fonksiyonuna **NULL pointer** argüman olarak geçilirse bu açık olan tüm dosyaların **buffer(bir bellek alanı)**'larını **flush** edilmesini sağlar.


👇 Aşağıdaki programda `fflush(NULL)` kullanımı incelenebilir.
```C
#include <stfio.h>

int main(void)
{
    FILE* f;

    // some code here ...

    fflush(NULL); // Burada programda açık olan bütün dosyaların 'buffer(bir bellek alanı)'larını 'flush' edilecektir.
}
```


❗❗❗ Sistem tarafından **Standat output**, **Standat input** ve **Standat error** birer dosya olarak ele alınmaktadır, nasıl ki bir dosya açıldığında `FILE*` türünden bir referans dönüyor, bir C ya da C++ programı çalışmaya başladığında **Standat input**, **Standat output** ve **Standat error** için üç farklı dosya sistem tarafından oluşturulmaktadır, bu dosyaların özelliklerin müdahale edilebilir ama bu dosyalar sistem tarafından oluşturulmaktadır. </br>
**Standat output** programın varsayılan çıkış akımını temsil etmektedir, varsayılan olarak monitöre bağlıdır. </br>
**Standat input** programın varsayılan giriş akımını temsil etmektedir, varsayılan olarak klavyeye bağlıdır. </br>
**Standat error** hata iletilerinin verildiği çıkış akımıdır yani programın oluşturacağı verilrin değil de hata iletilerinin verildiği çıkış akımıdır, varsayılan olarak monitöre bağlıdır.


**Standat output**, **Standat input** ve **Standat error** birer dosya olarak kullanıldığı için bunların da `FILE*` türünden referansları(handler) vardır, `stdio.h` programa dahil edildiğinde şu üç **adın(identifier)** kullanım hakkı elde edilmiş olmaktadır;
- `stdout` **Standat output**'un handle'ı.
- `stdin` **Standat input**'un handle'ı.
- `stderr` **Standat error**'un handle'ı.


Eğer bir dosyaya yazma amaçlı işlem yapan bir fonksiyonun handle isteyen parametresine **Standat output**'un handle'ı olan `stdout`u argüman olarak geçilirse yazma işlemi dosyaya yapılır.


👇 Aşağıdaki programda `stdout` kullanımı incelenebilir.
```C
#include <stfio.h>

int main(void)
{
    fprintf(stdout, "necati ergin.\n"); // 'fprintf' foksiyonuna doğrudan bir dosya referansı yerine 'stdout' verildiği için girilen yazı 'Standat output'a yazılacaktır.
    fputc('a', stdout); // 'fputc' foksiyonuna doğrudan bir dosya referansı yerine 'stdout' verildiği için girilen karakter 'Standat output'a yazılacaktır.
    fputs("cavit kara", stdout); // 'fputs' foksiyonuna doğrudan bir dosya referansı yerine 'stdout' verildiği için girilen yazı 'Standat output'a yazılacaktır.
}
```



👇 Aşağıdaki programda `stdin` kullanımı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stfio.h>

int main(void)
{
    int x;

    printf("bir tam sayi girin: ");
    fscanf(stdin, "%d", &x); // 'fscanf' foksiyonuna doğrudan bir dosya referansı yerine 'stdin' verildiği için 'Standat input'tan okuma işlemi yapacaktır.
    
    printf("x = %d\n", x);
}
```


Ders sonu ...
