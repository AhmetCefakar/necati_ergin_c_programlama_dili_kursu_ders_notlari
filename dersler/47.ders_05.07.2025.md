# 47.Ders 05.07.2025 ğŸ•˜

Derse 9(09:01)-10(09:05)-11(09:28)-13(09:34)-13(10:01)-13(11:12)-12(12:06)-11(12:23)-11(12:54) kiÅŸi katÄ±ldÄ±.
---

## Complete Types and Incomplate Types KavramlarÄ± ğŸŒŸ

EÄŸer derleyici bir tÃ¼rÃ¼n sadece bildirimini gÃ¶rÃ¼yor ama o tÃ¼rÃ¼n tamamÄ±nÄ± gÃ¶remiyorsa bu tÃ¼rlere **incomplate type** denilmektedir. </br>
KullanÄ±cÄ± tanÄ±mlÄ± tÃ¼rler(user defined types) **tamamlanmÄ±ÅŸ tÃ¼r(complate type)** ve **tamamlanmamÄ±ÅŸ tÃ¼r(incomplate type)** olarak iki kÄ±sÄ±ma ayrÄ±lmaktadÄ±r. </br>
**Ä°lkel(primitive)** tÃ¼rlerden sadece __void*__ tÃ¼rÃ¼ **tamamlanmamÄ±ÅŸ tÃ¼r(incomplate type)** durumdadÄ±r. </br>
Derleyici bir tÃ¼rÃ¼n tanÄ±mÄ±nÄ± gÃ¶rebiliyorsa o tÃ¼re **tamamlanmÄ±ÅŸ tÃ¼r(complate type)** tÃ¼r denilmektedir, bir tÃ¼rÃ¼n tanÄ±mÄ±nÄ±n gÃ¶rÃ¼lmesi demek te o tÃ¼rÃ¼n tÃ¼m bileÅŸenlerinin derleyici tarafÄ±ndan gÃ¶rÃ¼lebilir olmasÄ±dÄ±r.


**TamamlanmamÄ±ÅŸ(incomplate)** tÃ¼r ile neler yapÄ±labilir;
1. Pointer deÄŸiÅŸken tanÄ±mlanabilir. Derleyici iÃ§in herhangi tÃ¼rden bir deÄŸiÅŸkenin gÃ¶sterici bellek bÃ¼yÃ¼klÃ¼ÄŸÃ¼ Ã¶nceden bellidir.
    
    ğŸ‘‡ AÅŸaÄŸÄ±daki program parÃ§asÄ±nda **incomplate type** durumundaki yapÄ± tÃ¼rÃ¼nÃ¼n kullanÄ±labildiÄŸi gÃ¶rÃ¼lebilir.
    ```C
    struct Data; // Buradaki 'struct Data' tÃ¼rÃ¼ Ã¼yelerinin tamanÄ± bilinmediÄŸi iÃ§in 'incomplate type' durumundadÄ±r.

    struct Nec{
        int x;
        struct Data* necptr; 
    };

    int main(void)
    {
        struct Data* ptr1;
        struct Nec* ptr2;
    }
    ```

2. TÃ¼r eÅŸ adÄ± bildirimlerinde bildirilen tÃ¼rler **incomplate type** olabilir.

    ğŸ‘‡ AÅŸaÄŸÄ±daki program parÃ§asÄ±nda **incomplate type** yapÄ± tÃ¼rÃ¼ Ã¼zerinden bildirimleri yapÄ±lan tÃ¼r eÅŸ adlarÄ± incelenebilir.
    ```C
    struct Data; // Buradaki 'struct Data' tÃ¼rÃ¼ Ã¼yelerinin tamanÄ± bilinmediÄŸi iÃ§in 'incomplate type' durumundadÄ±r.

    typedef struct Data Data; // Burada 'incomplate type' bir yapÄ± tÃ¼rÃ¼ne eÅŸ ad veriliyor.
    typedef struct Data* DataPtr; // Burada 'incomplate type' bir yapÄ± tÃ¼rÃ¼nÃ¼n gÃ¶stericisine tÃ¼r eÅŸ ad veriliyor.

    int main(void)
    {
        
    }
    ```

3. `extern` deÄŸiÅŸken bildirimlerinde **incomplate type** kullanÄ±labilir.

    ğŸ‘‡ AÅŸaÄŸÄ±daki program parÃ§asÄ±nda `extern` ile bildirilen tÃ¼rlerin **incomplate type** olabileceÄŸi gÃ¶rÃ¼lebilir.
    ```C
    struct Data; // Buradaki 'struct Data' tÃ¼rÃ¼ Ã¼yelerinin tamanÄ± bilinmediÄŸi iÃ§in 'incomplate type' durumundadÄ±r.

    extern struct Data gdata; // Burada 'extern' anahtar sÃ¶zcÃ¼ÄŸÃ¼ ile baÅŸka bir kaynak dosyada tanÄ±mlanmÄ±ÅŸ olan global bir 'gdata' adÄ±ndaki deÄŸiÅŸkenin varlÄ±ÄŸÄ± derleyiciye tanÄ±tÄ±lÄ±yor, 'extern' anahtar sÃ¶zcÃ¼ÄŸÃ¼ ile derleyiciye bu bildirim iÃ§in bellekten yer ayrÄ±lmayacaÄŸÄ± belirtilmiÅŸ oluyor.
    
    // AÅŸaÄŸÄ±daki gibi bir dizi deÄŸiÅŸkeni 'extern' ile derleyiciye tanÄ±tÄ±labilir, derleyici 'extern' bildirilen bir deÄŸiÅŸken iÃ§in bellekten yer ayÄ±rmadÄŸÄ± iÃ§in dizinin eleman sayÄ±sÄ±nÄ±n belirtilmesi gerekmemektedir.
    extern struct Data gAry1[20]; // Burada 'extern' anahtar sÃ¶zcÃ¼ÄŸÃ¼ ile baÅŸka bir kaynak dosyada tanÄ±mlanmÄ±ÅŸ olan global bir 'gAry1' adÄ±ndaki deÄŸiÅŸkenin varlÄ±ÄŸÄ± derleyiciye tanÄ±tÄ±lÄ±yor, 'extern' anahtar sÃ¶zcÃ¼ÄŸÃ¼ ile derleyiciye bu bildirim iÃ§in bellekten yer ayrÄ±lmayacaÄŸÄ± belirtilmiÅŸ oluyor.
    extern struct Data gAry2[]; // Burada 'extern' anahtar sÃ¶zcÃ¼ÄŸÃ¼ ile baÅŸka bir kaynak dosyada tanÄ±mlanmÄ±ÅŸ olan global bir 'gAry2' adÄ±ndaki deÄŸiÅŸkenin varlÄ±ÄŸÄ± derleyiciye tanÄ±tÄ±lÄ±yor, 'extern' anahtar sÃ¶zcÃ¼ÄŸÃ¼ ile derleyiciye bu bildirim iÃ§in bellekten yer ayrÄ±lmayacaÄŸÄ± belirtilmiÅŸ oluyor.
    ```

    
    **Non-defined decleration**: C standardÄ±nÄ±n kullandÄ±ÄŸÄ± bir terim olmayan ama programcÄ±lar arasÄ±nda `extern struct Data gdata;` gibi `extern` anahtar sÃ¶zcÃ¼ÄŸÃ¼yle yapÄ±lan bir bildirimi tanÄ±mlamak iÃ§in kullanÄ±lan bir terimdir. 

4. Fonksiyon bildirimlerindeki tÃ¼rler **incomplate type** olabilir.

    ğŸ‘‡ AÅŸaÄŸÄ±daki program parÃ§asÄ±nda fonksiyon bildirimlerindeki parametre ve geri dÃ¶nÃ¼ÅŸ tÃ¼rlerinin **incomplate type** olbileceÄŸi gÃ¶rÃ¼lmelidir.
    ```C
    struct Data; // Buradaki 'struct Data' tÃ¼rÃ¼ Ã¼yelerinin tamanÄ± bilinmediÄŸi iÃ§in 'incomplate type' durumundadÄ±r.

    // AÅŸaÄŸÄ±daki fonksiyon bildirimlerindeki parametre ve geri dÃ¶nÃ¼ÅŸ tÃ¼rleri 'incomplate type' durumundadÄ±r.
    struct Data foo(struct Data);
    struct Data* bar(struct Data*);
    ```


ğŸ‘‡ AÅŸaÄŸÄ±daki programdan `list.h` dosyasÄ±nda bildirilen **incomplate type** durumundaki deÄŸiÅŸkenlerin `source_file_1.c` dosyasÄ±ndan kullanÄ±labileceÄŸi ve bu biÃ§imde programÄ±n derlenebileceÄŸi gÃ¶rÃ¼lmelidir, eÄŸer **incomplate type** bildirimlerin tanÄ±mlarÄ± yoksa baÄŸlama aÅŸamsÄ±nda hata oluÅŸacaktÄ±r.
```C
// 'list.h' dosyasÄ±nÄ±n iÃ§eriÄŸi aÅŸaÄŸÄ±daki gibidir.
struct List;
typedef struct List* ListHandle; // 'ListHandle' adÄ± 'struct List*' tÃ¼rÃ¼nÃ¼n tÃ¼r eÅŸ adÄ±dÄ±r.

ListHandle create_list(void);
void add_list(ListHandle, int);
void pop_front(ListHandle);
void destroy_list(ListHandle);

// ...
// ...


// 'source_file_1.c' dosyasÄ±nÄ±n iÃ§eriÄŸi aÅŸaÄŸÄ±daki gibidir.
#include "list.h"

void foo(void)
{
    ListHandle handle = create_list(); // Burada bir pointer deÄŸiÅŸkene bir adresle ilk deÄŸer veriliyor.
    add_list(handle, 12); // Burada bir adres bir fonksiyona argÃ¼man olarak gÃ¶nderiliyor.
    add_list(handle, 23); // Burada bir adres bir fonksiyona argÃ¼man olarak gÃ¶nderiliyor.
    
    // ... 

    destroy_list(handle);
}
```



**Complate type** kullanÄ±lmasÄ± gereken durumlar;

1. **Incomplate type** ile deÄŸiÅŸken tanÄ±mlayamayÄ±z. Bir yapÄ± tÃ¼rÃ¼nden bir deÄŸiÅŸken tanÄ±mlamak iÃ§in kesinlikle **complate type** kullanmak gerekmektedir.

    ğŸ‘‡ AÅŸaÄŸÄ±daki programdan **incomplate type** durumundaki bir tÃ¼r ile deÄŸiÅŸken tanÄ±mlanamayacaÄŸÄ± gÃ¶rÃ¼lebilir.
    ```C
    struct List; // Buradaki 'struct List' tÃ¼rÃ¼ Ã¼yelerinin tamanÄ± bilinmediÄŸi iÃ§in 'incomplate type' durumundadÄ±r.

    int main()
    {
        struct List x; // Illegal, 'incomplate type' durumundaki bir tÃ¼r ile deÄŸiÅŸken bildirmeye Ã§alÄ±ÅŸmak sÃ¶zdizim(syntax) hatasÄ±dÄ±r.
    }
    ```

2. `sizeof` operatÃ¶rÃ¼nÃ¼n operandÄ± olabilen deÄŸiÅŸkenler sadece **incomplate type** durumunda olan deÄŸiÅŸkenlerdir.

    ğŸ‘‡ AÅŸaÄŸÄ±daki programdan **incomplate type** durumdaki deÄŸiÅŸkenlerin `sizeof` operatÃ¶rÃ¼nÃ¼n operandÄ± yapÄ±lmasÄ±nÄ±n **sÃ¶zdizim(syntax)** hatasÄ±na neden olacaÄŸÄ± gÃ¶rÃ¼lmelidir.
    ```C
    struct List; // Buradaki 'struct List' tÃ¼rÃ¼ Ã¼yelerinin tamanÄ± bilinmediÄŸi iÃ§in 'incomplate type' durumundadÄ±r.

    int main()
    {
        struct List* p = NULL; // Buradaki gÃ¶sterici deÄŸiÅŸken bildiriminde hata yoktur.

        size_t sz1 = sizeof(struct List*); // Legal, buradaki ilk deÄŸer verme iÅŸleminde hata yoktur.
        size_t sz2 = sizeof(p); // Legal, buradaki ilk deÄŸer verme iÅŸleminde hata yoktur.

        size_t sz3 = sizeof(struct List); // illegal, buradaki ilk deÄŸer verme iÅŸleminde sÃ¶zdizim(syntax) hatasÄ± oluÅŸur.
        size_t sz4 = sizeof(*p); // illegal, buradaki ilk deÄŸer verme iÅŸleminde sÃ¶zdizim(syntax) hatasÄ± oluÅŸur.
    }
    ```

3. YapÄ±larÄ±n elemanlarÄ±na eriÅŸim ifadelerinde **incomplate type** durumdaki tÃ¼rler kullanÄ±lamamaktadÄ±r. 

    ğŸ‘‡ AÅŸaÄŸÄ±daki programdan **incomplate type** durumundaki bir yanÄ±nÄ±n elemanlarÄ± Ã¼zerinde iÅŸlem yapÄ±lmaya Ã§alÄ±ÅŸÄ±lmasÄ±nÄ±n **sÃ¶zdizim(syntax)** hatasÄ±na neden olacaÄŸÄ± incelenebilir.
    ```C
    struct List; // Buradaki 'struct List' tÃ¼rÃ¼ Ã¼yelerinin tamanÄ± bilinmediÄŸi iÃ§in 'incomplate type' durumundadÄ±r.
    struct List* create_list(void);
    void destroy_list(struct List*);

    int main()
    {
        struct List* p1 = create_list();
        struct List* p2 = create_list();

        // some code here ...

        destroy_list(p1);

        // AÅŸaÄŸÄ±daki atama iÅŸlemleri sÃ¶zdizim(syntax) hatasÄ±dÄ±r Ã§Ã¼nkÃ¼ derleyici 'struct List' tÃ¼rÃ¼nÃ¼n tanÄ±mÄ±nÄ± bilmiyor ve yapÄ±nÄ±n Ã¼yelerini bilmiyor.
        *p1 = *p2;
        (*p1).x =23;
        p1->x = 13;
    }
    ```

4. YapÄ±larÄ±n Ã¼yelerinin tÃ¼rÃ¼ **incomplate type** olamaz. 

    ğŸ‘‡ AÅŸaÄŸÄ±daki programdan **incomplate type** durumundaki bir tÃ¼r ile deÄŸiÅŸken tanÄ±mlanamayacaÄŸÄ± gÃ¶rÃ¼lebilir.
    ```C
    struct List; // Buradaki 'struct List' tÃ¼rÃ¼ Ã¼yelerinin tamanÄ± bilinmediÄŸi iÃ§in 'incomplate type' durumundadÄ±r.

    struct Data {
        int x;
        struct List a; // Buradaki bildirim sÃ¶zdizim(syntax) hatasÄ±dÄ±r Ã§Ã¼nkÃ¼ tamamlanmamÄ±ÅŸ bir tÃ¼r yapÄ±nÄ±n bir Ã¼yesinin tÃ¼Ã¼r yapÄ±lmak isteniyor.
    };
    ```



â—â—â— C ve C++ dillerinde ÅŸu ilke kabul gÃ¶rÃ¼r: "_Bir **incomplate type** iÅŸini gÃ¶rdÃ¼ÄŸÃ¼ sÃ¼rece **complate type** kullanma._". Bir tÃ¼rÃ¼ sadece mecbur olunduÄŸunda zaman **complate type** haline getirmek tercihedilir.

â—â—â— **Incomplate type** kullanÄ±ldÄ±ÄŸÄ±nda gereksiz baÄŸÄ±mlÄ±lÄ±klarÄ±n oluÅŸmasÄ±nÄ±n Ã¶nÃ¼ne geÃ§ilmektedir, bu Ã¶nemli bir bilgidir ve ilerideki derslerde ve C programlarÄ±nÄ± yazarken Ã¶nemli olacaktÄ±r.




ğŸ‘‡ AÅŸaÄŸÄ±daki programdan C ve C++ dillerinde **incomplate type** bildirimi yapÄ±lmayan yapÄ± tÃ¼rÃ¼nden deÄŸiÅŸkenlerin yine **incomplate type** olarak yorumlandÄ±ÄŸÄ± incelenebilir.
```C
struct List foo(struct List); // Burada 'struct List' kullanÄ±lmasÄ±ndan dolayÄ± derleyici 'struct List' tÃ¼rÃ¼nÃ¼ bildirilmiÅŸ gibi yorumlar.

int main(void)
{
    struct Nec* p; // Burada 'struct Nec*' kullanÄ±lmasÄ±ndan dolayÄ± derleyici 'struct Nec' tÃ¼rÃ¼nÃ¼ bildirilmiÅŸ gibi yorumlar.

}   
```

## C++ ya da OOP TarzÄ± KÃ¼tÃ¼phene KullanÄ±mÄ± 


â—â—â— YapÄ±nÄ±n elemanlarÄ± iki farklÄ± biÃ§imde olabilir, bunlarÄ±n aÅŸaÄŸÄ±daki gibidir;
- C tarzÄ± kÃ¼tÃ¼phanelerde yapÄ±larÄ±n elemanlarÄ± **mÃ¼ÅŸteri(client)** kodlara tamamen aÃ§Ä±ktÄ±r ve yapÄ±yÄ± kullanacak yazÄ±lÄ±mcÄ±larÄ±n kullandÄ±klarÄ± yapÄ±larÄ±n Ã¼yeleriyle ilgili derin bilgiye sahip olmasÄ± gerekiyor. 
- OOP tarzÄ± kÃ¼tÃ¼phanelerde yapÄ±nÄ±n elemanlarÄ± client code tarafÄ±ndan kullanÄ±lmaz;
    1. YapÄ±nÄ±n elemanlarÄ± gÃ¶rÃ¼nÃ¼r, kullanÄ±lmasÄ± sÃ¶zdizimi(snytax) hatasÄ± oluÅŸturmaz ancak kÃ¼tÃ¼phenenin dokÃ¼manÄ±nda bildirdiÄŸi biÃ§imde sÃ¶zleÅŸme gereÄŸi(hizmet veren kodla hizmet alan kod arasÄ±ndaki bir sÃ¶zleÅŸme gereÄŸi) kullanÄ±cÄ± kodlar yapÄ±nÄ±n elemanlarÄ±na eriÅŸmez.
    2. YapÄ±nÄ±n elemanlarÄ± zaten client koda gÃ¶sterilmez, bu yolla kullanÄ±cÄ± kod ilgili yapÄ±nÄ±n dÄ±ÅŸayÄ±ya kapalÄ± olan Ã¼yelerine eriÅŸemez ya da onlarÄ± gÃ¶remez.


ğŸ‘‡ AÅŸaÄŸÄ±daki programdan C tarzÄ± kÃ¼tÃ¼phene Ã¶zelliÄŸinde `struct tm` tÃ¼rÃ¼nÃ¼n kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include <time.h>

int main(void)
{
    struct tm x;

    x.tm_mon = 1; // YapÄ±nÄ±n 'tm_mon' Ã¼yesinin deÄŸerleri '[0,11]' arasÄ±nda bir deÄŸerde olmasÄ± gerekiyor ve '1' deÄŸeri de ÅŸubat ayÄ±na karÅŸÄ±lÄ±k gelmektedir, programcÄ± bu bilgiyi bilmek zorundadÄ±r yoksa yapÄ±yÄ± doÄŸru kullanamaz.
    x.tm_year = 2025 - 1900; // YapÄ±nÄ±n 'tm_year' Ã¼yesinin deÄŸerleri '1900' yÄ±lÄ±ndan sonraki yÄ±llarÄ± ifade etmektedir, programcÄ± bunu bilmezse programÄ± doÄŸru biÃ§imde yazamaz.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda olduÄŸu gibi sadece bildirimi olan bir yapÄ± kullanÄ±cÄ± kod(client) tarafÄ±ndan kullanÄ±lamaz.
```C
struct List;

struct List* add_list(struct List*, int);
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda olduÄŸu gibi bir yapÄ± tÃ¼rÃ¼nÃ¼n bildirimi gÃ¶rÃ¼lebiliyordur ama `void*` tÃ¼rÃ¼nden Ã¼yelere sahipse bu durumda Ã¼yelere eriÅŸilebilir ama `void*` tÃ¼rÃ¼ dereferencing operatÃ¶rÃ¼nÃ¼n operandÄ± yapÄ±lamayacaÄŸÄ± iÃ§in kullanÄ±cÄ± kod(client) tarafÄ±ndan kullanÄ±lamaz.
```C
struct List{
    void* vptr;
};

int main(void)
{
    struct List myList;

    // 'myList.vptr' Ã¼yesine eriÅŸilip kullanÄ±lamaz.
}
```



ğŸ“Œ Bu derste tarih bilgilerini iÅŸleyip yÃ¶netebilmek iÃ§in kendi tarih kÃ¼tÃ¼phanemizi yazacapÄ±z.



â—â—â— OOP biÃ§iminde kÃ¼tÃ¼pheneler kullanÄ±larak aÅŸaÄŸÄ±daki faydalar elde edilmektedir;
- Ã–ÄŸrenme yÃ¼kÃ¼ azalÄ±yor.
- TutarsÄ±z deÄŸerler oluÅŸturulmasÄ± sorunu engellenebiliyor, kÃ¼tÃ¼phanedeki yapÄ± nesnelerinin Ã¼yelerinin detaylÄ± bilgisine sahip olunmasÄ± gerekmeyecektir.
- En Ã¶nemli fayda ise: Elemanlar deÄŸiÅŸirse elemanlarÄ± kullanan kodun deÄŸiÅŸmesi gerekmeyecek ve bir Ã§ok durumda kaynak kodun **yeniden derlenmesi(recompile)** gerekmeyecektir. BÃ¼yÃ¼k projelerde baÄŸÄ±mlÄ±lÄ±klar yÃ¼zÃ¼nden kaynak kodlarÄ±n tekrar tekrar derlenmesinin gerekmesi gereksiz zaman kaybÄ±na neden olmaktadÄ±r.

â—â—â— OOP biÃ§iminde kÃ¼tÃ¼pheneler kullanÄ±ldÄ±ÄŸÄ±nda yapÄ±larÄ±n elemanlarÄ±nÄ±n dÄ±ÅŸarÄ±dan gizlenmesi ya da dÄ±ÅŸarÄ±dan eriÅŸiminin dokÃ¼mantasyon ile kÄ±sÄ±tlanmasÄ± araya ayrÄ±ca bir soyutlama katmanÄ± eklenmesi anlamÄ±na geleceÄŸi iÃ§in bazÄ± durumlarda maliyeti arttÄ±rabilir. </br>
ElemanlarÄ± gÃ¶stermemenin en sÄ±radan maliyeti: BazÄ± nesnelerin daha Ã¶nce Ã¶ÄŸrenilen `malloc` fonksiyonu ile oluÅŸturulma zorunluluÄŸunu gerektirmesi ve bu biÃ§imdeki bir iÅŸlemin dinamik bellek yÃ¶netimi gerektirmesinden dolayÄ± maliyete sahip olmasÄ±dÄ±r.


## Kendi `date` KÃ¼tÃ¼phanemizi C TarzÄ± Bir KÃ¼tÃ¼phane Olarak OluÅŸturalÄ±m ğŸŒŸ 

BugÃ¼nkÃ¼ dersimizin tamamÄ± yazacaÄŸÄ±mÄ±z kendi kÃ¼tÃ¼phanemizin C tarzÄ± `date` modÃ¼lÃ¼yle ilgili olacak. </br>
BugÃ¼nkÃ¼ dersimiz kod yazma aÄŸÄ±rlÄ±klÄ± olacak. GeÃ§miÅŸte iÅŸlenen derslerde iÅŸlenilen bir Ã§ok bilgiyi kod yazarak uygulamalÄ± olarak gÃ¶receÄŸiz cw bu bilgilerin Ã¼zerine bazÄ± yeni bilgileri de ekleyeceÄŸiz. </br>
Burada bir modÃ¼l oluÅŸturacaÄŸÄ±z ama modÃ¼lÃ¼ oluÅŸtururken yazacaÄŸÄ±mÄ±z kodlar bizim daha Ã¶nce Ã¶ÄŸrendiÄŸimiz C dilinin sÃ¶zdizimine iliÅŸkin ya da genel olarak programlamaya iliÅŸkin bilgilerimizi pekiÅŸtirmemizi saÄŸlayacak. </br>
Ä°leriki derslerde bir yapÄ±nÄ±n elemanlarÄ±nÄ±n gizlenmesi konusuna geldiÄŸimizde burada yazdÄ±ÄŸÄ±mÄ±z `date` modÃ¼lÃ¼nÃ¼ kullanacaÄŸÄ±z ve gizlemenin nasÄ±l hangi yollarla yapÄ±lacaÄŸÄ±nÄ± irdeleyeceÄŸiz. </br>
Burada yazacaÄŸÄ±mÄ±z `date` modÃ¼lÃ¼nÃ¼n bir baÅŸka Ã¶nemli yanÄ± bundan sonraki konu baÅŸlÄ±klarÄ±mÄ±z, mesela buraya kadar bir yapÄ± tÃ¼rÃ¼nÃ¼n Ã¼yelerinin baÅŸka yapÄ± tÃ¼rleri olabileceÄŸi sÃ¶ylendi ama bu derin olarak incelenmedi. </br>
Burada yazÄ±lacak olan modÃ¼ldeki `struct date` tÃ¼rÃ¼nÃ¼ oluÅŸturacaÄŸÄ±mÄ±z baÅŸka modÃ¼llerdeki yapÄ± nesnelerinin Ã¼ye deÄŸiÅŸkenlerinin tÃ¼rÃ¼ yaparak bir yapÄ±nÄ±n Ã¼yesinin baÅŸka bir yapÄ± tÃ¼rÃ¼ olabileceÄŸi durum detaylÄ± olarak incelenebilecektir. </br>
YapÄ±lar konusundan sonra Ã¶nemli alt baÅŸlÄ±klarÄ±mÄ±z olacak, mesela dosya iÅŸlemleri ve dosya iÅŸlemlerinde burada oluÅŸturacaÄŸÄ±mÄ±z `struct date` yapÄ± deÄŸiÅŸkenini kullanacaÄŸÄ±z.



âš ï¸ Kursun sonuna yaklaÅŸtÄ±k ama bazÄ± konular henÃ¼z tamamlanmadÄ±, eksik kalan konularÄ± tamamlayabilmek iÃ§in bu gÃ¼nden itibaren en az altÄ± derse ihtiyacÄ±mÄ±z var, yani 50. dersten sonra en az Ã¼Ã§ ders gÃ¼nÃ¼ daha eklenmesi gerekecek. Bu kurs 50 ders deÄŸil en az 53 ders sÃ¼recektir.



â—â—â— C dilinde bir kÃ¼tÃ¼phane modÃ¼lÃ¼nÃ¼ yazarken Ã§ok Ã¶zel bir durum yoksa iki ayrÄ± dosya oluÅŸturuyoruz;
1. **KullanÄ±cÄ±(client)** kodlar iÃ§in oluÅŸturulan, **kullanÄ±cÄ±(client)** kodlarÄ±n kullanmasÄ± iÃ§in bildirimleri iÃ§eren **baÅŸlÄ±k(header)** dosyasÄ±.
2. Kodun kendisini iÃ§eren **kaynak(implementation, code, source)** dosyasÄ±.


ğŸ“Œ C programlarÄ±nda yazÄ±lan modÃ¼llerin Ã¶nemli bir yÃ¶nÃ¼ de **yeniden kullanÄ±labilirliÄŸi(reusable)** saÄŸlamasÄ±dÄ±r.



â—â—â— YazÄ±lmÄ±ÅŸ olan bir modÃ¼lÃ¼n baÅŸkalarÄ± tarafÄ±ndan kullanÄ±labilmesini saÄŸlamak iÃ§in iki farklÄ± yol izlenebilir, bunlar;
1. Mesela "date" modÃ¼lÃ¼ paylaÅŸÄ±lacaksa `date.h` dosyasÄ±nÄ±n kendisi ve `date.c` kaynak dosyanÄ±n sadece derlenmiÅŸ hali verilebilir. Bu yÃ¶ntemde modÃ¼lÃ¼ kullanacak programcÄ±ya kaynak kod dosyasÄ± verilmediÄŸi iÃ§in progrmacÄ± kaynak dosyada deÄŸiÅŸiklik yapamaz.
2. Mesela "date" modÃ¼lÃ¼ paylaÅŸÄ±lacaksa `date.h` dosyasÄ±nÄ±n kendisi ve `date.c` kaynak dosyanÄ±n kendisi verilebilir. Bu yÃ¶ntemde modÃ¼lÃ¼ kaynak kodlarÄ±yla birlikte alan programcÄ± modÃ¼lÃ¼ istediÄŸi gibi kullanÄ±p kaynak kod Ã¼zerinde istediÄŸi gibi deÄŸiÅŸiklikler yapabilir. Bu yÃ¶ntemde kaynak kod **open source** olarak paylaÅŸÄ±lmÄ±ÅŸ olur. AÃ§Ä±k kaynak olan kodlarÄ±n kullanÄ±m koÅŸullarÄ± kodun lisansÄ±na baÄŸlÄ±dÄ±r ama kod lisanslarÄ±na bu derste deÄŸinilmeyecektir.



â—â—â—Bir kÃ¼tÃ¼phane modÃ¼lÃ¼nÃ¼ yazmaya baÅŸlarken en tipik hatalardan biri modÃ¼lÃ¼n yazÄ±mÄ±na ilk Ã¶nce gerÃ§ekleÅŸtirim dosyasÄ±nÄ±n("**.c**") yazÄ±mÄ±yla iÅŸe baÅŸlanmasÄ±dÄ±r, ilk Ã¶nce yapÄ±lmasÄ± gereken bir arayÃ¼z oluÅŸturan baÅŸlÄ±k dosyasÄ±nÄ±n yazÄ±mÄ±ndan baÅŸlanmasÄ±dÄ±r.



â—â—â— Bir baÅŸlÄ±k dosyasÄ± oluÅŸturduÄŸumuzda mutlaka ve mutlaka bir baÅŸlÄ±k dosyasÄ±nÄ± bir client code tarafÄ±ndan birden fazla defa **dahil edilmesini(include)** Ã¶nlemek iÃ§in Ã¶nlem almalÄ±yÄ±z. Birden fazla defa aynÄ± "**.h**" dosyasÄ±nÄ±n eklenmesi sÃ¶zdizimi(syntax) hatasÄ±na neden olur.


â—â—â— C programlarÄ±nda yazÄ±lmÄ±ÅŸ olan bir modÃ¼l birden fazla kaynak dosyaya dahil edilmiÅŸ olabilir, bu durumda iÃ§ iÃ§e bir yapÄ±da farklÄ± dosyalar aynÄ± kaynak dosyayÄ± eklemek isteyecektir, eÄŸer kÃ¼tÃ¼phanelerin baÅŸlÄ±k dosyalarÄ±nda **Multiple Include Guards(Header Include Guards)** uygulanmadÄ±ysa bu sÃ¶zdizim(syntax) hatasÄ±na neden olacaktÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±dan **Multiple Include Guards(Header Include Guards)** durumunu incelemek iÃ§in `date`, `student` ve `employee` adÄ±ndaki modÃ¼ller Ã¼zerinden inceleme yapÄ±labilir;



**Multiple Include Guards(Header Include Guards)** uygulanÄ±rken kullanÄ±lan makronun adÄ± belirlenirken en sÄ±k kullanÄ±lan yÃ¶ntemler(convension) aÅŸaÄŸÄ±daki gibidir;
- BaÅŸlÄ±k dosyasÄ±nÄ±n adÄ±nÄ±n tÃ¼m harflerini bÃ¼yÃ¼k yazdÄ±ktan sonra `_H` karakterleriyle sonlandÄ±rÄ±labilir, mesele `DATE_H`.
- BaÅŸlÄ±k dosyasÄ±nÄ±n adÄ±nÄ±n tÃ¼m harflerini bÃ¼yÃ¼k yazdÄ±ktan sonra `INCLUDED` karakterleriyle sonlandÄ±rÄ±labilir, mesele `DATE_INCLUDED`.


```C
// 'date.h' dosyasÄ±

// #pramga once // Buradaki tek bir Ã¶n iÅŸlemci programÄ± komutuyla 'multiple inclusion guard' saÄŸlanmÄ±ÅŸ oluyor ama bu yÃ¶ntem standart olmadÄ±ÄŸÄ± iÃ§in herderleyici desteklemeyebilir, bu nedenle biz klasik yÃ¶ntemi kullanacaÄŸÄ±z.

#ifndef DATE_H // Buradaki 'multiple inclusion guard' kullanÄ±mÄ± tÃ¼m derleyicilerde desteklenmektedir.
#define DATE_H

// AÅŸaÄŸÄ±daki dÃ¶rt farklÄ± 'struct' tÃ¼rÃ¼ bildirimi de en sonunda aynÄ± iÅŸi yapmaktadÄ±r ama ilk kullanÄ±mda modÃ¼lÃ¼ kullanacak programcÄ± sadece 'Date' adÄ±yla yapÄ±yÄ± kullanmaya zorlanmaktadÄ±r.
// ! YapÄ±nÄ±n elemanlarÄ±nÄ± bilerek gizlemedik, ancak client kodlarÄ±n yapÄ±nÄ±n elemanlarÄ±nÄ± kullanmasÄ±nÄ± istemiyoruz, bunun iÃ§in de sÄ±k bir kullanÄ±m olarak(convernsion) dÄ±ÅŸarÄ±dan deÄŸiÅŸtirilmemesi istenilen yapÄ± deÄŸiÅŸkenlerinin adlarÄ±nÄ±n sonuna '_' karakteri ekleniyor. 
typedef struct{
    int d_;
    int m_;
    int y_;
} Date;


// AÅŸaÄŸÄ±daki gibi bir yapÄ± bildirimi yapÄ±ldÄ±ÄŸÄ±nda, 'client code' hem 'struct Date' hem de 'Date' identifier(ad) ile burada bildirilen yapÄ±yÄ± kullanabilir.
// typedef struct Date{
//     int d_;
//     int m_;
//     int y_;
// } Date;


// AÅŸaÄŸÄ±daki gibi bir yapÄ± bildirimi ile bu yapÄ± tÃ¼rÃ¼nÃ¼n 'typedef' adÄ± ile 'struct' adÄ± birbirinden farklÄ± yapÄ±lmÄ±ÅŸ oluyor, 'client code' hem 'struct Date_' hem de 'Date' identifier(ad) ile burada bildirilen yapÄ±yÄ± kullanabilir.
// typedef struct Date_{
//     int d_;
//     int m_;
//     int y_;
// } Date;


// AÅŸaÄŸÄ±daki gibi bir yapÄ± bildirimi ile bu yapÄ± tÃ¼rÃ¼nÃ¼n 'typedef' adÄ± ile 'struct' adÄ± birbirinden farklÄ± yapÄ±lmÄ±ÅŸ oluyor, 'client code' hem 'struct tag_Date' hem de 'Date' identifier(ad) ile burada bildirilen yapÄ±yÄ± kullanabilir.
// typedef struct tag_Date{
//     int d_;
//     int m_;
//     int y_;
// } Date;


// C dilinde bir yapÄ±nÄ±n deÄŸerlerini deÄŸiÅŸtiren fonksiyonlar 'set function', 'setter', 'mutater(daha Ã§ok C++ tarafÄ±nda)' olarak adlandÄ±rÄ±labiliyor. 
// EÄŸer fonksiyona gÃ¶nderilmesi gereken deÄŸerler doÄŸru deÄŸilse buna 'dab argument' denmektedir. Bu durumda iki yaklaÅŸÄ±m vardÄ±r; 
// 1) DoÄŸru argÃ¼manlarÄ±n geÃ§ilmesi sorumluluÄŸu fonksiyonu Ã§aÄŸÄ±ran koda yÃ¼klenir.
// 2) Fonksiyona geÃ§ilen argÃ¼manlarÄ±n doÄŸruluÄŸu fonksiyon iÃ§inde kontrol edile de bilir, bu durumda fonksiyona ek maliyet yÃ¼klenmiÅŸ olur.
void set_date(Date*, int d, int m, int y);

// Date* set_date2(Date*, int d, int m, int y);

#endif
```


`student` adÄ±nda bir modÃ¼lÃ¼n yazÄ±lmasÄ±.
```C
// 'student.h' dosyasÄ±

#ifndef STUDENT_INCLUDED 
#define STUDENT_INCLUDED

#include "date.h"

struct Student {
    char name[30];
    int id;
    struct Date bdate; // Bir yapÄ± tÃ¼rÃ¼nÃ¼n Ã¼yesi 'incomplate type' olamaz, 'struct Date' tÃ¼rÃ¼nÃ¼n bildirimini derleyicinin gÃ¶rebilmesi iÃ§in 'date.h' baÅŸlÄ±k dosyasÄ± ekleniyor.
};

#endif
```


```C
// 'student.c' dosyasÄ±


// some code here ... 
```


`employee` adÄ±nda bir modÃ¼lÃ¼n yazÄ±lmasÄ±.
```C
// employee.h dosyasÄ±

#ifndef STUDENT_INCLUDED 
#define STUDENT_INCLUDED

#include "date.h"

struct Employee {
    char name[30];
    int m_id;
    struct Date employment_date; // Bir yapÄ± tÃ¼rÃ¼nÃ¼n Ã¼yesi 'incomplate type' olamaz, 'struct Date' tÃ¼rÃ¼nÃ¼n bildirimini derleyicinin gÃ¶rebilmesi iÃ§in 'date.h' baÅŸlÄ±k dosyasÄ± ekleniyor.
};

#endif
```


```C
// 'employee.c' dosyasÄ±


// some code here ... 
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda yukarÄ±da yazÄ±lmÄ±ÅŸ olan modÃ¼llerin nasÄ±l birlikte kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
// 'main.c' dosyasÄ±

#include "date.h"

// AÅŸaÄŸÄ±daki baÅŸlÄ±k dosyalarÄ±nÄ±n ikisinde de 'date.h' baÅŸlÄ±k dosyasÄ± eklenmiÅŸtir, bu dosyalarda 
#include "student.h"
#include "employee.h"

int main(void)
{
    Date mydate;
    set_date(&mydate, 5, 6, 1995);
}
```



C dilinde yapÄ± tÃ¼rlerinin elemanlarÄ± varsayÄ±lan olarak dÄ±ÅŸaradan eriÅŸilebilir. C dilince **sÄ±k bir kullanÄ±m olarak(convension)** bir yapÄ±nÄ±n elemanlarÄ±nÄ±n adlarÄ±nÄ± sonuna `_` karakterinin eklenmesi o nesnelerin yapÄ± dÄ±ÅŸÄ±ndan deÄŸiÅŸtirilmesinin istenmediÄŸi anlamÄ±na gelmektedir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `Date` tÃ¼r eÅŸ adÄ± Ã¼zerinden tanÄ±mlanan `myDate` adÄ±ndaki deÄŸiÅŸkene doÄŸrudan yapÄ±nÄ±n Ã¼yelerine eriÅŸerek ilk deÄŸer verildiÄŸi durum incelenebilir.
```C
#include "date.h"

int main(void)
{
    Date myDate = { 3, 5, 1983 }; // Burada yapÄ±nÄ±n Ã¼yelerine doÄŸrudan eriÅŸilerek ilk deÄŸer veriliyor.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `Date` tÃ¼r eÅŸ adÄ± Ã¼zerinden tanÄ±mlanan `myDate` adÄ±ndaki deÄŸiÅŸkene dolaylÄ± yoldan `set_date` fonksiyonu kullanÄ±larak deÄŸer verildiÄŸi durum incelenebilir. </br>
Buradaki `Date` tÃ¼rÃ¼nÃ¼n sadece Ã¼Ã§ tane Ã¼yesi olmak zorunda olmadÄ±ÄŸÄ± ve dÄ±ÅŸarÄ±dan eriÅŸime kapalÄ± baÅŸka Ã¼yelerinin de olabileceÄŸi gÃ¶rÃ¼lmelidir.

```C
#include "date.h"

int main(void)
{
    Date myDate; // 'myDate' adÄ±nda 'Date' tÃ¼rÃ¼nden(esasÄ±nda tÃ¼r eÅŸ adÄ±) bir yapÄ± nesnesi tanÄ±mlanÄ±yor(tanÄ±mlanÄ±yor Ã§Ã¼nkÃ¼ derleyici bu deÄŸiÅŸken iÃ§in bellekte yer ayÄ±racaktÄ±r).

    // AÅŸaÄŸÄ±daki gibi bir kullanÄ±mda fonksiyona yapÄ±lan Ã§aÄŸrÄ± iÅŸlemi olacaÄŸÄ±ndan dolayÄ±, derleyici fonksiyona giriÅŸ kodlarÄ±yla fonksiyondan Ã§Ä±kÄ±ÅŸ kodlarÄ±nÄ± Ã¼retecektir bu da kodun iÅŸlem maliyetini yÃ¼kseltir. 
    // Buradaki kullanÄ±mÄ±n bir Ã¶nceki programdaki kullanÄ±ma kÄ±yasla daha maliyetli olacaÄŸÄ± gÃ¶rÃ¼lmelidir.
    // Derleyici 'set_date' fonksiyonunun tanÄ±mÄ±nÄ± gÃ¶rmediÄŸi iÃ§in herhangibi iyileÅŸtirme(optimizasyon) yapamaz.  
    set_date(&myDate, 3, 5, 1983); // Bu fonksiyon bildirimi ile 'myDate' deÄŸiÅŸkeninin deÄŸerleri verilmektedir.
}
```



ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ AÅŸaÄŸÄ±daki bilgileri tam olarak anlamak Ã§ok Ã¶nemlidir, burayÄ± tam anlamadan programlama konusunda daha Ã¼st bir seviyeye Ã§Ä±kÄ±lamaz, buradaki bilgiyi anlamak OOP yaklaÅŸÄ±mÄ±nÄ±n neyi getirip neyi gÃ¶tÃ¼rdÃ¼ÄŸÃ¼nÃ¼ anlamak iÃ§in bir temel oluÅŸturacaktÄ±r;
â—â—â— C dilinde yapÄ± tÃ¼rlerinden elde edilen nesnelerin Ã¼yelerinin dÄ±ÅŸarÄ±dan eriÅŸime kÄ±sÄ±tlanmasÄ± durumunda soyutlamayÄ± arttÄ±rmÄ±ÅŸ oluruz ve bÃ¶ylece sadece soyutlamayÄ± arttÄ±rmÄ±ÅŸ olmuyoruz aynÄ± zamanda Ã¼retilecek makine kodununda olacak iÅŸlem sayÄ±sÄ±nÄ± da arttÄ±rmÄ±ÅŸ oluyoruz. </br>
â—â—â— YukarÄ±daki nedenlerden dolayÄ± C dilinde soyutlamayÄ± arttÄ±rdÄ±ÄŸÄ±mÄ±z zaman sadece soyutlamayÄ± arttÄ±rmÄ±ÅŸ olmuyoruz aynÄ± zamanda maliyeti de arttÄ±rÄ±yoruz, iÅŸte bu nedenden dolayÄ±dÄ±r ki **sistem programlama**, **aÄŸ(networking) programlama**, **oyun programlama**, **yoÄŸun performanslÄ± iÅŸlem gerektiren programlamalarda** yapÄ±nÄ±n elemanlarÄ± gizlenmemektedir Ã§Ã¼nkÃ¼ soyutlamadan oluÅŸacak fazladan makine kodlarÄ±nÄ± istenmemektedir.



â—â—â— C++ dilinin bazÄ± araÃ§larÄ±(C dilinde de benzer bazÄ± araÃ§lar var) bir yapÄ±nÄ±n elemanlarÄ±na eriÅŸmeyi hem kÄ±sÄ±tlarken aynÄ± zamanda Ã§ok verilmi bir kodun oluÅŸturmasÄ±nÄ± saÄŸlayabiliyor.



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan `set_date` fonksiyonuna hatalÄ± deÄŸerler ile nasÄ±l istek yapÄ±ldÄ±ÄŸÄ± gÃ¶rÃ¼lebilir.
```C
#include "date.h"

int main(void)
{
    Date myDate; // 'myDate' adÄ±nda 'Date' tÃ¼rÃ¼nden(esasÄ±nda tÃ¼r eÅŸ adÄ±) bir yapÄ± nesnesi tanÄ±mlanÄ±yor(tanÄ±mlanÄ±yor Ã§Ã¼nkÃ¼ derleyici bu deÄŸiÅŸken iÃ§in bellekte yer ayÄ±racaktÄ±r).

    set_date(&myDate, 48, 4, 1012); // Burada 'set_date' fonksiyonuna Ã§aÄŸrÄ± yapan yerde argÃ¼man olarak geÃ§ilen deÄŸerler hatalÄ±, bu durumda izlenebilecek iki durum var, bunlarÄ±n ne olduÄŸunu aÅŸaÄŸÄ±daki aÃ§Ä±klamada gÃ¶rebilirsin.
}
```



â—â—â— Bir fonksiyona yapÄ±lan bir Ã§aÄŸrÄ±da fonksiyona geÃ§ilmek istenilen argÃ¼manlar hatalÄ± olduÄŸu durumlarda izlenecek iki yol var, bunlar;
1. HatalÄ± deÄŸ geÃ§ilen fonksiyon Ã§aÄŸrÄ±sÄ± kendi modÃ¼lÃ¼mÃ¼ze aitse o zaman hatalÄ± fonksiyon Ã§aÄŸrÄ±sÄ±nÄ±n yapÄ±ldÄ±ÄŸÄ± yerin bulunmasÄ± ardÄ±ndan da dÃ¼zeltilmesi gerekir.
2. HatalÄ± deÄŸ geÃ§ilen fonksiyon Ã§aÄŸrÄ±sÄ± **kullanÄ±cÄ±(client) kodlardan** geliyorsa bu durumda da iki farklÄ± seÃ§enekten biri tercih edilebilir;
    1. HatalÄ± fonksiyon Ã§aÄŸrÄ±larÄ±nÄ±n yapÄ±lmasÄ±nÄ±n sorumluluÄŸu **kullanÄ±cÄ±(client) koda** bÄ±rakÄ±labilir, bu durumda modÃ¼lde bir iÅŸlem yapÄ±lmasÄ± gerekmeyecektir ve kullanÄ±cÄ± hatalÄ± deÄŸerler gÃ¶nderdiÄŸinde bu **ub** durumuna da neden olabilir.
    2. HatalÄ± fonksiyon Ã§aÄŸrÄ±larÄ±nÄ±n yapÄ±lmasÄ± durumlarÄ±nÄ± modÃ¼lÃ¼n fonksiyonunda yapabiliriz, bu durumda fonksiyona geÃ§ilen argÃ¼manlar tek tek kontrol edilecek ve deÄŸerler hatalÄ± olsa bile bir dÃ¼zenleme yapÄ±labiliyorsa dÃ¼zenleme yapÄ±ldÄ±ktan sonra fonksiyon iÅŸlemine devam edip bitirecek ama iÅŸleme devam edilemezse bunun da **kullanÄ±cÄ±(client) koda** bildirilmesi gerekiyor.


â—â—â— Bir fonksiyondan geriye fonksiyonun yaptÄ±ÄŸÄ± iÅŸlemin baÅŸarÄ±lÄ± ya da baÅŸarÄ±sÄ±z olmasÄ± durumunu fonksiyon Ã§aÄŸrÄ±sÄ±nÄ± yapan koda bildirmek gerekiyor, peki bunu nasÄ±l bildirecek diye dÃ¼ÅŸÃ¼nÃ¼lÃ¼rse bu baÅŸka bir dersin konusu ve bunu yapmak iÃ§in birden fazla farklÄ± yol var. </br>
Mesela en Ã§ok kullanÄ±lan **yaklaÅŸÄ±m(convension)** olarak bÃ¶yle `Date* set_date2(Date*, int d, int m, int y);` bir **setter fonksiyon** bildiriminde fonksiyona deÄŸerleri atanmasÄ± iÃ§in geÃ§ilen nesne tekrardan geriye dÃ¶ndÃ¼rÃ¼lebilir, fonksiyondan geriye dÃ¶nen adres kendisine geÃ§ilen adres ile aynÄ± ise iÅŸlem baÅŸarÄ±lÄ± ama **NULL pointer** ise iÅŸlem baÅŸarÄ±sÄ±z anlamÄ±na gelecektir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan `set_date2` fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±ldÄ±ÄŸÄ±nda iÅŸlem baÅŸarÄ±lÄ± olmama durumunda nasÄ±l bir kod yazÄ±labileceÄŸi incelenebilir.
```C
#include "date.h"

int main(void)
{
    Date myDate; // 'myDate' adÄ±nda 'Date' tÃ¼rÃ¼nden(esasÄ±nda tÃ¼r eÅŸ adÄ±) bir yapÄ± nesnesi tanÄ±mlanÄ±yor(tanÄ±mlanÄ±yor Ã§Ã¼nkÃ¼ derleyici bu deÄŸiÅŸken iÃ§in bellekte yer ayÄ±racaktÄ±r).

    // 'set_date2' fonksiyonu iÅŸini baÅŸarÄ±lÄ± biÃ§imde yapamazsa geriye 'NULL pointer' dÃ¶necek ve bu durumda hata olduÄŸu anlaÅŸÄ±lacak ve ona gÃ¶re yapÄ±lacak bazÄ± iÅŸlemler yapÄ±labilir.
    if(!set_date2(&myDate, 48, 4, 1012)){
        // error handling code 
    }
}
```

â—â—â— ğŸ‘† YukarÄ±daki programdaki `set_date2` fonksiyon Ã§aÄŸrÄ±sÄ±nda olduÄŸu gibi her seferinde hata var mÄ± yok mu diye kontrol ettirilmesi kodu Ã§ok daha karmaÅŸÄ±k hale getirecektir, bu C'nin kÃ¼Ã§Ã¼k bir dil olmasÄ±nÄ±n sonuÃ§larÄ±ndan biri bu, C++, Java, C# gibi dillerin standardÄ±nda **exception handing** aracÄ±yla bu gibi durumlar daha kolay ele alÄ±nabilmektedir.

YazacaÄŸÄ±mÄ±z kÃ¼tÃ¼phanelerimizin hatalarÄ± nasÄ±l iÅŸleyeceÄŸine karar vermek bize dÃ¼ÅŸÃ¼yor, hatalarÄ± iÅŸleyip iÅŸlememeyi seÃ§mek bize kalÄ±yor. 


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.50-11.17 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


âœï¸ Burada `date` adÄ±ndaki kendi modÃ¼lÃ¼mÃ¼zÃ¼n baÅŸlÄ±k dosyasÄ±nÄ± aÅŸaÄŸÄ±daki gibi yazÄ±yoruz.
```C
// YazÄ±lan 'date.h' dosyasÄ±

// Ä°lerleyen derslerde bir modÃ¼lÃ¼n nasÄ±l dokÃ¼mantasyonunun yazÄ±lacaÄŸÄ± ve adlandÄ±rma yaklaÅŸÄ±mlarÄ±ndan(naming convensions) bahsedileceÄŸi belirtildi.

#ifndef DATE_H // Buradaki 'multiple inclusion guard' kullanÄ±mÄ± tÃ¼m derleyicilerde desteklenmektedir.
#define DATE_H

// ! YapÄ±nÄ±n elemanlarÄ±nÄ± bilerek gizlemedik, ancak client kodlarÄ±n yapÄ±nÄ±n elemanlarÄ±nÄ± kullanmasÄ±nÄ± istemiyoruz, bunun iÃ§in de sÄ±k bir kullanÄ±m olarak(convernsion) dÄ±ÅŸarÄ±dan deÄŸiÅŸtirilmemesi istenilen yapÄ± deÄŸiÅŸkenlerinin adlarÄ±nÄ±n sonuna '_' karakteri ekleniyor. 
typedef struct{
    int d_;
    int m_;
    int y_;
} Date;

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Set functions(mutaters)

Date* set_date(Date* p, int d, int m, int y);
Date* set_date_str(Date* p, const char* pstr);
Date* set_date_today(Date* p);
Date* set_random_date(Date* p);
Date* set_year(Date* p, int y);
Date* set_month(Date* p, int m);
Date* set_month_day(Date* p, int d);

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Get functions, getters, accessors

int get_year(const Date* p);
int get_month(const Date* p);
int get_month_day(const Date* p);
int get_week_day(const Date* p); // 0: Pazar, 1: Pazartesi ...
int get_year_day(const Date* p);

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Formatet input-output functions

void print_date(const Date* p); // '05 Temmuz 2025 Cumartesi'
Date* scan_date(Date* p); 

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/    
// Utility functions

int cmp_date(const Date* p1, const Date* p2);
int date_diff(const Date* p1, const Date* p2); 
Date* ndays_after(Date* pdest, const Date* psource, int n); 
Date* ndays_before(Date* pdest, const Date* psource, int n); 

#endif
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `date.h` dosyasÄ±ndaki mutater fonksiyonlarÄ±n nasÄ±l test edileceÄŸi gÃ¶rÃ¼lebilir.
```C
#include "date.h"

int main(void)
{
    Date date1;
    set_date(&date1, 5, 6, 1955);
    set_date_str(&date1, "02-09-2044");

    set_year(&date1, 1994);
    set_month(&date1, 11);
    set_month_day(&date1, 24);

    printf("yil = %d\n", get_year(&date1));
    printf("yilin %d. ayi\n", get_month(&date1));
    printf("ayin %d. gunu\n", get_month_day(&date1));
    printf("haftanin %d. gunu\n", get_week_day(&date1) + 1);
    printf("yilin %d. gunu\n", get_year(&date1));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `date.h` dosyasÄ±ndaki `print_date`, `cmp_date`, `set_random_date`, `print_date` fonksiyonlarÄ±nÄ± test etmek iÃ§in nasÄ±l bir program yazÄ±labileceÄŸi incelenebilir. </br> 
Bu programda Ã¶nceden Ã¶ÄŸrendiÄŸimiz dilin araÃ§larÄ±nÄ± kullanacaÄŸÄ±z. 
```C
#include "date.h"
#include <stdio.h>
#include <stdlib.h> // 'qsort' fonksiyonunu kullanmak iÃ§in eklenen baÅŸlÄ±k dosyasÄ±.
#include <time.h> // Ä°ÅŸlem sÃ¼resini Ã¶lÃ§mek iÃ§in eklenen baÅŸlÄ±k dosyasÄ±.
#include <conio.h> // Standart olmayan bir modÃ¼l


// cmp_date fonksiyonunu test etmek icin aÅŸaÄŸÄ±daki iÅŸlemleri afÄ±m adÄ±m yazalÄ±m;
// a) Dinamik bir 'Date' dizisini oluÅŸtur
// b) Dizinin elemanlarÄ±nÄ± rastgele deÄŸerler ile doldur.
// c) Diziyi standart C fonksiyonu olan 'qsort' ile kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe doÄŸru sÄ±rala.
// d) SÄ±ralanmÄ±ÅŸ diziyi standar output'a gÃ¶nder.
// e) dizinin bellek alanÄ±nÄ± serbest bÄ±rak.


// 'qsort' fonksiyonu iÃ§in kullanÄ±lan sarmalayÄ±cÄ± fonksiyon.
static int wdcmp(const void* vp1, const void* vp2)
{
    return cmp_date((const void*)vp1, (const void*)vp2);
}


// ElemanlarÄ± 'Date' tÃ¼rÃ¼nden olan bir diziyi rastgele deÄŸerlerle dolduran bir fonksiyon, bunu cliend code kendi yazÄ±yor.
// AÅŸaÄŸÄ±daki fonksiyonda 'int', 'double' vb. tÃ¼rlerden dizilerle birlikte nasÄ±l gÃ¶sterici aritmetiÄŸi kullanÄ±ldÄ±ysa burada da yapÄ± tÃ¼rÃ¼nden bir dizi iÃ§in gÃ¶sterici aritmetiÄŸi kullanÄ±lmÄ±ÅŸtÄ±r.
Date* set_date_array(Date* p, size_t size)
{
    Date* ptemp = p; // Burada fonksiyondan geriye dÃ¶ndÃ¼rÃ¼lecek olan dizinin adresinin kaybedilmemesi iÃ§in o adres deÄŸerinin 'ptemp' deÄŸiÅŸkenine ilk deÄŸer olarak veriliyor.

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ dizinin elemana sayÄ±sÄ± kadar dÃ¶necektir.
    while(size--){
        set_random_date(p++);
    }

    return ptemp;
}

// ElemanlarÄ± 'Date' tÃ¼rÃ¼nden olan bir diziyi 'print_date' fonksiyonu ile formatlÄ± olarak standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderen fonksiyon.
void print_date_array(const Date* p, size_t size)
{
    while(size--){
        print_date(p++);
    }
}


int main(void)
{
    size_t size;

    printf("kac elemanli bir dizi olsun: ");
    scanf("%zu", &size);

    Date* pd = (Date*)malloc(size * sizeof(Date));
    if(!pd){
        fprintf(stderr, "bellek yetersiz!\n"); // bu fonkisyon Ã§aÄŸrÄ±sÄ±na sonradan deÄŸinilecek. 
        return 1;
    }

    printf("siralama basladi.\n");
    clock_t start = clock();
    qsort(pd, size, sizeof(*pd), &wdcmp);
    clock_t end = clock();
    printf("siralama bitti %.2f saniye.\n", (double)(end - start) / CLOCKS_PER_SEC);
    _getch(); // ProgramÄ± burada durdurmak iÃ§in kullanÄ±lan 'conio.h' modÃ¼lÃ¼ndeki standart olmayan fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±lÄ±yor.
    print_date_array(pd, size); 

    free(pd);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan `data.h` dosyasÄ±ndaki `scan_date` fonksiyonunun nasÄ±l test edildiÄŸi gÃ¶rÃ¼lebilir.
```C
#include "date.h"
#include <stdio.h>

int main(void)
{
    Date date;

    printf("bir tarih girin: ");
    scan_date(&date);
    print_date(&date);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±da programdan `data.h` dosyasÄ±ndaki `date_diff` fonksiyonunun nasÄ±l sÄ±nandÄ±ÄŸÄ± gÃ¶rÃ¼lebilir.
```C
#include "date.h"   
#include <stdio.h>

int main(void)
{
    Date bdate;

    printf("bedenlenis tarihinizi giriniz: ");
    scan_date(&bdate);
    printf("bedenlenis tarihiniz: ");
    print_date(&bdate);

    Date today;
    set_date_today(&today);
    printf("bugunun  tarihi: ");
    print_date(&today);
    printf("bugun varolusunuzun %d. gunu, anlamini bulabildin mi?\n", date_diff(&today, &bdate));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan `data.h` dosyasÄ±ndaki `ndays_after` fonksiyonunun nasÄ±l test edildiÄŸi gÃ¶rÃ¼lebilir.
```C
#include "date.h"
#include <stdio.h>

int main(void)
{
    printf("bugunden kac gun sonrasi: ");
    int n;
    scan_date("%d", n);

    Date today;
    set_date_today(&today);
    printf("bugun: ");
    print_date(&today);

    Date future_date;

    for(int i = 0; i <= 1'000'000'000; i *= 10){ // Buradaki `'` ile bÃ¼yÃ¼k sayÄ±larÄ±n basamaklarÄ±nÄ±n okunaklÄ± olmasÄ± iÃ§in ayrÄ±lmasÄ± bir 'compiler extension' ve bu kullanÄ±ma 'digit seperator' deniliyor. 
        printf("%-15d gun sonrasi : ", i);
        ndays_after(&future_date, &today, i);
        print_date(&future_date);
    }
}
```



â—â—â— C kursunda bir kaÃ§ defa tekrarlanan bir farkÄ±ndalÄ±k olarak "**_KOD TEKRARI FELAKETTÄ°R_**" tÃ¼mcesine dikkat edilmelidir; </br>
Bir kodun kalitesinin ne olduÄŸunu kodun ne kadar az tekrarlÄ± olduÄŸuna bakarak anlayabiliriz(kod tekrarÄ± bazÄ± Ã¶zel durumlarda gerekli olabiliyor). </br>
Tekrar eden kodun sorunlarÄ±;
- Kodun tekrar ettiÄŸi her yerde ayrÄ± ayrÄ± baÄŸlamlarda her takrar eden yer iÃ§in ayrÄ± bir test kodu yazÄ±lmasÄ± gerekecektir.
- Kodda bir deÄŸiÅŸiklik(lojik) yapÄ±lmasÄ± ya da koda bir ekleme yapÄ±lmasÄ± gerekirse o kadar fazla kod yazÄ±lmasÄ± gerekecektir, bu da gereksiz iÅŸ yÃ¼kÃ¼ anlamÄ±na gelmektedir.
- Kodun tekrar etmesi aynÄ± kod bir kaÃ§ farklÄ± yerde olduÄŸu iÃ§in deÄŸiÅŸiklik yapÄ±lmasÄ± gerektiÄŸinde bazÄ± yerlerde deÄŸiÅŸiklik yapÄ±lÄ±p bazÄ± yerlerde o deÄŸiÅŸikliÄŸin yapÄ±lmasÄ± yapÄ±lmazsa hatalara neden olacaktÄ±r.
- Kod tekrar kullanÄ±labilir(reusable) yapÄ±lmamÄ±ÅŸ olur, tekrar eden kod kendisini iyi aÃ§Ä±klayamaz ve mecburen yorum satÄ±rlarÄ±yla aÃ§Ä±klamak gerekecektir, eÄŸer tekrar eden kod bir fonksiyona alÄ±nÄ±rsa fonksiyon adÄ±ndan ilgili kodun ne iÅŸ yaptÄ±ÄŸÄ± anlaÅŸÄ±labilir durumda olabilirdi.

**Self explanatory**: Bir kodun kendi kendini aÃ§Ä±klayabilir durumda olmasÄ± durumu aÃ§Ä±klamak iÃ§in kullanÄ±lan terimdir.


â—â—â— Tekrar eden kodu bir yere toplayÄ±p sÄ±klÄ±kla o kodu bir fonksiyon haline getirmek yÃ¼ksek seviyede soyutlama saÄŸlayacaktÄ±r, bu da Ä°ngilizce olarak "_**abstraction at a higher level**_" biÃ§iminde ifade edilir.



Ortak kodun bir yere toplamak iki farklÄ± biÃ§imde olabilir;
1. BaÅŸtan ortak kodun ne olacaÄŸÄ± bellidir, bu durumda 
2. BaÅŸtan ortak kodun ne olacaÄŸÄ± belli deÄŸildir, Ã¼retimde Ã§oÄŸunluklada bu biÃ§imde olmaktadÄ±r.



**Refactoring(Kodun iyileÅŸtirilmesi)**: ProgramÄ±n gÃ¶zden geÃ§irilip dÃ¼zenlenmesine verilen addÄ±r. **Refactoring** kavramÄ± Ã¶nemlidir, bu konuyla ilgili kaliteli kaynaklar okunmasÄ± Ã¶nerilir. 


**Refactoring(Kodun iyileÅŸtirilmesi)** nasÄ±l yapÄ±lÄ±r;
1. Programda kullanÄ±lan fonksiyonlarÄ±n, modÃ¼llerin, deÄŸiÅŸken adlarÄ±nÄ±n, tÃ¼r eÅŸ adlarÄ±nÄ±n vb. kendilerini daha iyi anlatacak adlara sahip olacak biÃ§imde deÄŸiÅŸtirilmesi.
2. Ortak kodlarÄ±n bir yere toplanÄ±p tekilleÅŸtirilmesi iyi bir davranÄ±ÅŸtÄ±r, bu biÃ§imde kod daha kolay yÃ¶netilebilir durumda olacaktÄ±r.
3. Kodun daha okunabilir ve anlaÅŸÄ±lÄ±r hale gelmesini saÄŸlamak iyi bir davranÄ±ÅŸtÄ±r.
4. Ã–zellikle C ve C++ programlarÄ±nÄ± daha ablaÅŸÄ±lÄ±r kÄ±lmak iÃ§in bu dillerdeki **deyimsel(idiyomatik)** yapÄ±larÄ±n kullanÄ±lmasÄ± iyi bir davranÄ±ÅŸtÄ±r.
5. YazÄ±lan programda mÃ¼mkÃ¼n mertebe standart kÃ¼tÃ¼phenenin saÄŸladÄ±ÄŸÄ± fonksiyonlarÄ± kullanÄ±lmasÄ±nÄ± saÄŸlamak 
6. ProgramÄ±n daha hÄ±zlÄ± Ã§alÄ±ÅŸmasÄ± saÄŸlamak iÃ§in(optimization) deÄŸiÅŸiklikler yapÄ±lmasÄ±.
7. ProgramÄ±n bazÄ± yerlerinde kullanÄ±lan deÄŸiÅŸken tÃ¼rlerinde ya da veri yapÄ±larÄ±nda deÄŸiÅŸiklikler yapÄ±lmasÄ±.



Kendi yazdÄ±ÄŸÄ±mÄ±z `date` modÃ¼lÃ¼ndeki tÃ¼m fonksiyonlarÄ±mÄ±z `Date` tÃ¼rÃ¼nden(esasÄ±nda tÃ¼r eÅŸ adÄ±) bir yapÄ± nesnesini kullanmaktadÄ±r ve bu nedenle bu yapÄ±nÄ±n deÄŸerlerinin doÄŸruluÄŸunu test edeceksek bu iÅŸlem Ã§oÄŸu fonksiyonda ortak bir iÅŸlem olacaktÄ±r.



C++ dilinin standardÄ± yÃ¼kseldikÃ§e dilde yapÄ±lan deÄŸiÅŸikliklerle Ã¶n iÅŸlemci program giderek devre dÄ±ÅŸÄ± yapÄ±lma eÄŸilimi vardÄ±r. C++ dilinin imkanlarÄ± neredeyse Ã¶n iÅŸlemci programa ihtiyacÄ± ortadan kaldÄ±racak noktaya gelmiÅŸtir denilebilir. 
C dili C++ dilinden farklÄ± olarak Ã¶n iÅŸlemci program kullanÄ±lmasÄ±n diye bir eÄŸilim yoktur, C dilinde gerekli olan yerlerde makrolar dikkatli bir biÃ§imde kullanÄ±lmalÄ±dÄ±r. 



âœï¸ Burada `date` adÄ±ndaki kendi modÃ¼lÃ¼mÃ¼zÃ¼n kaynak dosyasÄ±nÄ± aÅŸaÄŸÄ±daki gibi yazÄ±yoruz.
```C
// YazÄ±lan 'date.h' dosyasÄ±

#include "date.h"
#include <stdbool.h> // Kodun okunurluÄŸunu arttÄ±rmak iÃ§in 'bool' gibi makrolarÄ±n kullanÄ±labilmesi iÃ§in eklendi. 
#include <stdio.h>

#define YEARBASE    1900

#define ISLEAP(Y) (((Y) % 4 == 0) && ( ((Y) % 100 != 0) || ((Y) % 400 == 0)))
#define MONTHDAYS(Y, M) (daytabs[ISLEAP(Y)][M])

// Bir yÄ±ldaki aylarda olan gÃ¼nlerin sayÄ±sÄ± bilgisine eriÅŸmek iÃ§in kullanÄ±labilecek olan arama(lookup) tablosunun aÅŸaÄŸÄ±daki gibi olabileceÄŸini ilk defa 'The C Programing Language' kitabÄ±nda 'Dennis Ritchie' Ã¶nermiÅŸtir.
static const int daytabs[][13] = {
    { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
    { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
};


// 'is_valid_date' fonksiyonu kendisine geÃ§ilen gÃ¼n, ayi, yÄ±l deÄŸerlerinin geÃ§erli bir tarih olup olmadÄ±ÄŸÄ±nÄ± sÄ±nayan bir fonksiyondur.
static bool is_valid_date(int d, int m, int y)
{
    // Ä°lk yazÄ±lan fonksiyon gÃ¶vdesi aÅŸaÄŸÄ±daki gibidir. 
    // return y >= YEARBASE && 
    //     m > 0 && m <= 12 && daytabs[ISLEAP(y)][m];

    return y >= YEARBASE && 
        m > 0 && m <= 12 && MONTHDAYS(y, m);
} 


// 'set' adÄ±ndaki fonksiyonu sadece bu kaynak dosyada kullanacaÄŸÄ±z dÄ±ÅŸarÄ±dan eriÅŸimi olmayacak bu nedenle adÄ± genel olan bir sÃ¶zcÃ¼k olarak verildi.
// 'set' fonksiyonu kÃ¼tÃ¼phanemizdeki diÄŸer fonksiyonlarÄ±n 'Date' tÃ¼rÃ¼nÃ¼n Ã¼yelerini atama iÅŸlemini yapmak iÃ§in kullanÄ±lacak.
// 'set' fonksiyonunun adÄ± kendisini anlatmaktadÄ±r.
static Date* set(Date* p, int d, int m, int y)
{
    if(!is_valid_date(d, m, y))
        return NULL;

    p->d_ = d;
    p->m_ = m;
    p->y_ = y;

    return p;
}


// Devam edecek...
```



â—â—â— Fonksiyonlara birden fazla gÃ¶rev verilmemelidir, Ä°sviÃ§re Ã§akÄ±sÄ± gibi fonksiyonlar yazÄ±lmamalÄ±dÄ±r, verilirse aÅŸaÄŸÄ±daki gibi sorunlarla karÅŸÄ±lÄ±r;
- Fonksiyonun adÄ± yaptÄ±ÄŸÄ± iÅŸi aÃ§Ä±klayamayacak hale gelecektir.
- Fonksiyon birden fazla iÅŸi yaptÄ±ÄŸÄ± iÃ§in o fonksiyonu kullanan koda kullanmak istemeyaceÄŸi bazÄ± iÅŸlemlerin zorla kullandÄ±rÄ±lmasÄ± gibi istenmeyen bir durum oluÅŸacaktÄ±r.
- Fonksiyonu test etmek iÃ§in daha fazla test kodunun yazÄ±lmasÄ± gerekecektir.
- **Takrar kullanÄ±labilirlik(reusability)** olumsuz etkilenecektir.




âœï¸ Burada `date` adÄ±ndaki kendi modÃ¼lÃ¼mÃ¼zÃ¼n kaynak dosyasÄ±nÄ± aÅŸaÄŸÄ±daki gibi yazÄ±yoruz, burada yukarÄ±daki halinden farklÄ± olarak okunurluÄŸu arttÄ±rmak iÃ§in `PRIVATE` ve `PUBLIC` makrolarÄ± eklendi.
```C
// YazÄ±lan 'date.h' dosyasÄ±

#include "date.h"
#include <stdbool.h> // Kodun okunurluÄŸunu arttÄ±rmak iÃ§in 'bool' gibi makrolarÄ±n kullanÄ±labilmesi iÃ§in eklendi. 
#include <stdio.h>

#define YEARBASE    1900
#define PRIVATE     static
#define PUBLIC      

#define ISLEAP(Y) (((Y) % 4 == 0) && ( ((Y) % 100 != 0) || ((Y) % 400 == 0)))
#define MONTHDAYS(Y, M) (daytabs[ISLEAP(Y)][M])

// Bir yÄ±ldaki aylarda olan gÃ¼nlerin sayÄ±sÄ± bilgisine eriÅŸmek iÃ§in kullanÄ±labilecek olan arama(lookup) tablosunun aÅŸaÄŸÄ±daki gibi olabileceÄŸini ilk defa 'The C Programing Language' kitabÄ±nda 'Dennis Ritchie' Ã¶nermiÅŸtir.
PRIVATE const int daytabs[][13] = {
    { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
    { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
};


// 'is_valid_date' fonksiyonu kendisine geÃ§ilen gÃ¼n, ayi, yÄ±l deÄŸerlerinin geÃ§erli bir tarih olup olmadÄ±ÄŸÄ±nÄ± sÄ±nayan bir fonksiyondur.
PRIVATE bool is_valid_date(int d, int m, int y)
{
    // Ä°lk yazÄ±lan fonksiyon gÃ¶vdesi aÅŸaÄŸÄ±daki gibidir. 
    // return y >= YEARBASE && 
    //     m > 0 && m <= 12 && daytabs[ISLEAP(y)][m];

    return y >= YEARBASE && 
        m > 0 && m <= 12 && MONTHDAYS(y, m);
} 


// 'set' adÄ±ndaki fonksiyonu sadece bu kaynak dosyada kullanacaÄŸÄ±z dÄ±ÅŸarÄ±dan eriÅŸimi olmayacak bu nedenle adÄ± genel olan bir sÃ¶zcÃ¼k olarak verildi.
// 'set' fonksiyonu kÃ¼tÃ¼phanemizdeki diÄŸer fonksiyonlarÄ±n 'Date' tÃ¼rÃ¼nÃ¼n Ã¼yelerini atama iÅŸlemini yapmak iÃ§in kullanÄ±lacak.
// 'set' fonksiyonunun adÄ± kendisini anlatmaktadÄ±r.
PRIVATE Date* set(Date* p, int d, int m, int y)
{
    if(!is_valid_date(d, m, y))
        return NULL;

    p->d_ = d;
    p->m_ = m;
    p->y_ = y;

    return p;
}


PUBLIC Date* set_date(Date* p, int d, int m, int y)
{
    return set(p, d, m, y);
}

// Devam edecek...
```


Ders sonu ...
