# 53.Ders 19.07.2025 ğŸ•˜

---


## Command Line Arguments

**Command Line Environment(Komut satÄ±rÄ± ortamÄ±)** iÅŸletim sisteminin kullanÄ±cÄ±sÄ±yla arayÃ¼z saÄŸladÄ±ÄŸÄ± yazÄ± tabanlÄ± ortama verilen addÄ±r.

Ã‡alÄ±ÅŸtÄ±rÄ±labilir programlar Ã§oÄŸunlukla iÅŸletim sisteminin komut satÄ±rÄ±ndan uygun argÃ¼manlarla Ã§alÄ±ÅŸtÄ±rÄ±lmaktadÄ±r.

Ã‡alÄ±ÅŸtÄ±rÄ±lacak olan programÄ±n dÄ±ÅŸarÄ±dan alacaÄŸÄ± ve programÄ± Ã§alÄ±ÅŸtÄ±rÄ±rken gÃ¶nderilen deÄŸerlere **Command Line Arguments** denilmektedir. GUI ile bir programÄ±n dosyasÄ±na Ã§ift tÄ±klanarak program Ã§alÄ±ÅŸtÄ±rÄ±lsabile artalanda program yine CLI(command line interface) Ã¼zerinden uygun argÃ¼manlar programa geÃ§ilerek program Ã§alÄ±ÅŸtÄ±rÄ±lmaktadÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda geleneksel olarak en temel C programÄ±nÄ±n `main` fonksiyonunun aldÄ±ÄŸÄ± parametreler incelenebilir.
```C
#include <stdio.h>

// main fonksiyonunun parametreleri olan 'argc' ve 'argv' birer identifier'dÄ±r.
// argc: "Argument Count" sÃ¶zcÄŸklerinin kÄ±saltmasÄ±dÄ±r.
// argv: "Argument Vector" sÃ¶zcÄŸklerinin kÄ±saltmasÄ±dÄ±r.
int main(int argc, char** argv)
// int main(int argc, char* argv[]) // Buradaki 'main' fonksiyonu tanÄ±mÄ± ile yukarÄ±daki tanÄ±m birbirine denktir.
{

    /*
        Mesela bu programa geÃ§ilecen parametre 'negun 13 6 1961' olsun, bu programÄ±n parametreleri aÅŸaÄŸÄ±daki deÄŸerleri alacaktÄ±r;
        'argc' deÄŸeri 4 olacaktÄ±r Ã§Ã¼nkÃ¼ programa dÃ¶rt tane deÄŸer geÃ§ilmektedir.
        'argv[0]' 'char*' tÃ¼rÃ¼nden 'negun' string sabitinin baÅŸlangÄ±Ã§ adresinin deÄŸerini alÄ±r.
        'argv[1]' '13' deÄŸerini alÄ±r.
        'argv[2]' '6' deÄŸerini alÄ±r.
        'argv[3]' '1961 deÄŸerini alÄ±r.

    */
}
```




ğŸ‘‡ AÅŸaÄŸÄ±daki programda komut satÄ±rÄ±ndan programÄ± Ã§alÄ±ÅŸtÄ±rÄ±rken girilen deÄŸerlerin nasÄ±l standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderildiÄŸi incelenebilir, programÄ± derleyip Ã§alÄ±ÅŸtÄ±rÄ±labilir dosyasÄ±nÄ± oluÅŸturup incelemek gerekiyor.
```C
#include <stdio.h>

int main(int argc, char* argv[])
{
    for(int i = 0; i < argv; ++i){
        printf("argv[%d] = %s\n", i, argv[i]);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda komut satÄ±rÄ±ndan programÄ± Ã§alÄ±ÅŸtÄ±rÄ±rken girilecek tam sayÄ± deÄŸerlerin toplamÄ±nÄ± hesaplayÄ±p nasÄ±l standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderildiÄŸi incelenebilir, programÄ± derleyip Ã§alÄ±ÅŸtÄ±rÄ±labilir dosyasÄ±nÄ± oluÅŸturup incelemek gerekiyor.
```C
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
    int sum = 0;

    for(int i = 0; i < argv; ++i){
        sum += atoi(argv[i]);
    }

    printf("%d\n", sum);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda komut satÄ±rÄ±ndan programÄ± Ã§alÄ±ÅŸtÄ±rÄ±rken girilecek Ã¼Ã§ ata argÃ¼m ile dosya kopyalama iÅŸleminin nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir, programÄ± derleyip Ã§alÄ±ÅŸtÄ±rÄ±labilir dosyasÄ±nÄ± oluÅŸturup incelemek gerekiyor.
```C
#include <stdio.h>
#include <stdlib.h>

// ProgramÄ±n Ã¼Ã§ argÃ¼manla Ã§aÄŸÄ±rÄ±lmasÄ± gerekiyor.
int main(int argc, char* argv[])
{
    if(argc != 3)
    {
        printf("usage: <copytfile> <source file name> <dest file name>\n");
        return 1;
    }

    printf("file %s copied as file %s\n", argv[1], argv[2]);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda komut satÄ±rÄ±ndan programÄ± Ã§alÄ±ÅŸtÄ±rÄ±rken girilecek Ã¼Ã§ ata argÃ¼m ile dosya kopyalama iÅŸleminin nasÄ±l yapÄ±ldÄ±ÄŸÄ±(kullanÄ±cÄ± argÃ¼manlarÄ± doÄŸru girmediÄŸinde program iÃ§inden bu argÃ¼manlar alÄ±nmaktadÄ±r) incelenebilir, programÄ± derleyip Ã§alÄ±ÅŸtÄ±rÄ±labilir dosyasÄ±nÄ± oluÅŸturup incelemek gerekiyor.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// copyfile prg1.exe prg2.exe
int main(int argc, char* argv[])
{
    char surce_file_name[40];
    char dest_file_name[40];

    if(argc != 3)
    {
        printf("kaynak dosya adi : ");
        scanf("%s", surce_file_name);
        printf("hedef dosya adi : ");
        scanf("%s", dest_file_name);
    }
    else{
        strcpy(surce_file_name, argv[1]);
        strcpy(dest_file_name, argv[2]);
    }

    // ...

    printf("file %s copied as file %s\n", surce_file_name, dest_file_name);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda CLI Ã¼zerinden argÃ¼manlarÄ± verilecek basit bir hesap makinesinin nasÄ±l yazÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// copyfile prg1.exe prg2.exe
int main(int argc, char* argv[])
{
    if(argc != 4)
    {
        printf("kullanim: <hes> <sol operand> <operator +-*/> <sag operand>\n");
        return 1;
    }

    int op_left = atoi(argv[1]);
    int op_right = atoi(argv[3]);

    // `switch` ifadesi olan '*argv[2]' ifedesi zero-nonzero olarak mantÄ±ksal yorumlamaya tabidir.
    switch(*argv[2]){
        case '+': printf("%d\n", op_left + op_right); break;
        case '-': printf("%d\n", op_left - op_right); break;
        case '*': printf("%d\n", op_left * op_right); break;
        case '/': 
            if(op_right == 0)
                printf("sifira bolme hatasi.\n");
            else
                printf("%f\n", op_left / (double)op_right); 
        break;
        default: printf("gecersiz islem.\n"); break;
    }
}
```



`int main(int argc, char* argv[])` gibi main fonksiyonu tanÄ±mÄ±nda `argv[argc]` biÃ§imindeki bir ifadenin kullanÄ±mÄ± legaldir, C srandardÄ± `argv[argc]` ifadesinin **NULL pointer** olacaÄŸÄ± belirtilmiÅŸtir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda 
```C
#include <stdio.h>
#include <stdlib.h>

// ProgramÄ±n Ã¼Ã§ argÃ¼manla Ã§aÄŸÄ±rÄ±lmasÄ± gerekiyor.
int main(int argc, char** argv)
{
    int i = 0;

    // AÅŸaÄŸÄ±daki 
    while(argv[i] != NULL){
        printf("argc[%d] = %s", i, argv[i]);
        ++i;
    }
}
```

## Dosyalar ve Dosya Ä°ÅŸlemleri 

Kursun sonlarÄ±ndayÄ±z ama en kapsamlÄ± konu da dosya iÅŸlemleri konusu diyebiliriz, 10 saatten fazla sÃ¼recek bir konu. </br>
Åimdiye kadar yazdÄ±ÄŸÄ±mÄ±z programlar Ã§Ä±ktÄ±larÄ±nÄ± standart Ã§Ä±ktÄ± akÄ±mÄ±na yazdÄ± am aprogramlarÄ±n Ã§oÄŸu Ã§Ä±ktÄ±larÄ±nÄ± dosya ya da dosyalara yazmaktadÄ±r. </br>
AyrÄ±ca Ã§oÄŸu zaman Ã§alÄ±ÅŸtÄ±rÄ±lan programlar girdilerini bir dosya ya da dosyalardan almaktadÄ±r. </br>


### Bir dosya nedir(what is a file)

Bu bilgi seviyesinde yapÄ±labilecen en iyi soyutlama bir dosyanÄ±n byte'lardan oluÅŸan bir kÃ¼me olduÄŸudur. Dosya dendiÄŸinde akla byte'lar kÃ¼mesi gelmelidir. </br>
Dosya denildiÄŸinde program Ã§alÄ±ÅŸÄ±rken bellekte yeralan 1 ve 0 dizilerinden bahsedilmiyor ikincil saklama ortamlarÄ±ndaki(hard-disc, flash-disc vb. gibi kalÄ±cÄ± bellek alanlarÄ±) 1 ve 0 dizileri dÃ¼ÅŸÃ¼nÃ¼lmelidir. </br>
Peki bir dosyadaki 1 ve 0 dizisi ne anlama geliyor diye dÃ¼ÅŸÃ¼nÃ¼lÃ¼rse, bunu sadece dosyanÄ±n 1 ve 0 dizisine bakarak anlayamayÄ±z. </br>
Her dosyanÄ±n bir formatÄ± vardÄ±r(buna **File Format** deniliyor), bir dosyadaki 1 ve 0 dizisinin nasÄ±l yorumlanacaÄŸÄ± dosyanÄ±n formatÄ±yla ilgilidir. </br>
Verile bilecek en basit dosya formatÄ± kursun baÅŸÄ±nda gÃ¶rdÃ¼ÄŸÃ¼mÃ¼n **ASCII** karakter formatÄ±dÄ±r, bu formatta her bir byte tek bir **ASCII** karaktere karÅŸÄ±lÄ±k gelmektedir. </br>
Her dosyanÄ±n bir dosya formatÄ± olmak zorundadÄ±r yoksa o dosyayla ilgili iÅŸlemlerin nasÄ±l yapÄ±lacaÄŸÄ± bilinemez ve o dosya Ã¼zerinde Ã§alÄ±ÅŸÄ±lamaz. </br>
BazÄ± dosyalarÄ±n formatlarÄ±nÄ±n saklanma biÃ§imi herkese aÃ§Ä±k olabilir(**.jpg**, **.png**, **.mp3** dosya formatlarÄ± gibi) ya da bir ÅŸirketin mÃ¼lkiyetinde olarak gizli olabilir(bir dosya formatÄ±nÄ±n ne olduÄŸu ve bilgilerin o dosya formatÄ±nda nasÄ±l tutulduÄŸu dokÃ¼mente edilmemiÅŸ olabilir)
Dosyalar birlerden ve sÄ±fÄ±rlardan oluÅŸan bir kÃ¼medir, dosyadaki bir ve sÄ±fÄ±rlarÄ±n ne anlama geldiÄŸi bilgisine **File Format** denilmektedir.

Dosya iÅŸlemelrini kim yapÄ±yor diye dÃ¼ÅŸÃ¼nÃ¼lÃ¼rse bunun cevabÄ± iÅŸletim sistemidir. </br>
Ä°ÅŸletim sistemleri bilgisayarlarÄ±n donanÄ±mÄ±nÄ± yÃ¶netmektedir, iÅŸletim sistemlerinin farklÄ± farklÄ± modÃ¼lleri vardÄ±r, bu modÃ¼ller iÃ§indeki Ã¶nemli modÃ¼llerden biri de dosya iÅŸlemlerini yapan modÃ¼ldÃ¼r. </br>
C, C++, Java, Python vb. hangi programlama diliyle yazÄ±lmÄ±ÅŸ bir program dosyalar Ã¼zerinde Ã§alÄ±ÅŸacaÄŸÄ± zaman dosyalar Ã¼zerindeki iÅŸlemleri yapacak olan iÅŸletim sisteminin fonksiyonlarÄ±dÄ±r. </br>
Ä°ÅŸletim sistemlerinin sistem fonksiyonlarÄ± doÄŸrudan da Ã§aÄŸÄ±rÄ±labilir(bu konu sistem programlamanÄ±n konusuna giriyor). </br>
Dosya iÅŸlemlerini yapan iÅŸletim sisteminin sistem fonksiyonlarÄ± hem yazÄ±lan programlar taÅŸÄ±nabilir olsun diye(farklÄ± iÅŸletim sistemleri arasÄ±ndaki taÅŸÄ±nabilirlik) hem de iÅŸlemler daha kolay yapÄ±labilsin diye programlama dilleri kendi standart kÃ¼tÃ¼phenelerinde dosya iÅŸlemlerini yapan fonksiyonlar sunmaktadÄ±r. </br>
Programlama dillerinin standart kÃ¼tÃ¼phenelerinin sunduÄŸu dosya iÅŸlemlerini yapmak iÃ§in kullanÄ±lan fonksiyonlar iÅŸletim sistemlerinin dosya iÅŸlemlerini yapmak iÃ§in sunduÄŸu sistem fonksiyonlarÄ±nÄ± sarmalayan fonksiyonlardÄ±r(**Function wrapper**). </br>
Programlama dillerinin standart kÃ¼tÃ¼phenelerinin iÅŸletim sistemlerinin sistem fonksiyonlarÄ±nÄ± Ã§aÄŸÄ±ran fonksiyonlarÄ± iÅŸletim sistemi ile dilin saÄŸladÄ±ÄŸÄ± o fonksiyonlarÄ± kullanan programÄ± yazan programcÄ± arasÄ±ndaki bir ara tabaka gibidir, dilin standart kÃ¼tÃ¼phanesi programcÄ±yÄ± iÅŸletim sistemiyle muatab etmeyen bir aracÄ± gibidir. </br>
FarklÄ± programlama dilleirnde dosya iÅŸlemlerinin yapÄ±lmasÄ±na yÃ¶nelik farklÄ± yaklaÅŸÄ±mlar vardÄ±r. Mesela C++ dilinin standart kÃ¼tÃ¼phenessinde nesne yÃ¶nelimli denebilecek bir yapÄ± vardÄ±r. </br>
C dilinde dosya iÅŸlemlerinin yapÄ±lmasÄ± iÃ§in kullanÄ±lan sistem ise daha aÅŸaÄŸÄ± seviyeli olarak **Handle TekniÄŸini** kullanÄ±yor, dosya iÅŸlemi yapmak iÃ§in kurucu(kaynaklarÄ± ayÄ±ran fonksiyon) fonksiyona istek yapÄ±lÄ±r ardÄ±ndan iÅŸlemler bittikten sonra kaynaklarÄ± iade edecek olan yÄ±kÄ±cÄ± fonksiyona istek yapÄ±lÄ±r. </br>
C dilinde dosya iÅŸlemlerinin yapÄ±lmasÄ± iÃ§in kullanÄ±lacak tÃ¼m fonksiyonlar `stdio.h` baÅŸlÄ±k dosyasÄ±nda bulunmaktadÄ±r, sadece dosya iÅŸlemlerinde kullanÄ±lan `stdio.h` baÅŸlÄ±k dosyasÄ±nda bulunan 30 civarÄ±nda fonksiyonu bu baÅŸlÄ±k altÄ±nda inceleyeceÄŸiz.
`stdio.h` baÅŸlÄ±k dosyasÄ±ndaki dosya iÅŸlemleri iÃ§in kullanÄ±lan fonksiyonlarÄ± incelemeye `fopen` fonksiyonuyla baÅŸlayacaÄŸÄ±z.


â—â—â— Ã‡oÄŸunlukla bir dosya iÅŸleminin yapÄ±lma sÄ±rasÄ± aÅŸaÄŸÄ±daki gibidir;
1. Ä°lk Ã¶nce `fopen` fonksiyonu Ã§aÄŸÄ±rÄ±lÄ±r.
2. `fopen` fonksiyonunun geri dÃ¶nÃ¼ÅŸ tÃ¼rÃ¼ `FILE*` tÃ¼rÃ¼nden bir deÄŸiÅŸkende saklanÄ±r.
3. `FILE*` tÃ¼rÃ¼nde saklanan nesnenin adresini dosya iÅŸlemleri yapÄ±lacak fonksiyonlara geÃ§erek ilgili dosya Ã¼zerinde gerekli iÅŸlemlerin yapÄ±lmasÄ± saÄŸlanÄ±r.
4. En son `fclose` fonksiyonu Ã§aÄŸrÄ±larak **handle sisteminde** ayrÄ±lan sistem kaynaklarÄ± iade edilir.


Dosyalar Ã¼zerinde Ã§alÄ±ÅŸÄ±rken dosya yapÄ±sÄ±nÄ±n(**File Format**) ne olduÄŸu Ã¶nemli deÄŸildir yani dosya yapÄ±sÄ±nÄ±n(**File Format**) elemanlarÄ±nÄ±n ne olduÄŸu gizlenip gizlenmediÄŸi tamamen derleyiciye baÄŸlÄ±dÄ±r, Ã¼zerinde iÅŸlem yapÄ±lan dosya `FILE*` tÃ¼rÃ¼nden bir gÃ¶sterici deÄŸiÅŸkene alÄ±nÄ±r ve tÃ¼m dosya iÅŸlemleri bu pointer Ã¼zerinden yapÄ±lÄ±r(dosyanÄ±n byte'larÄ±yla iÅŸimiz olmaz, burada bir soyutlama mevcuttur).

C dilinde dosya iÅŸlemlerini Ã¶ÄŸrenmek demem C dilindeki standart dosya fonksiyonlarÄ±nÄ± Ã¶ÄŸrenmek demektir. Bu konu baÅŸlÄ±ÄŸÄ± altÄ±nda inceleyeceÄŸimiz ve Ã¶ÄŸreneceÄŸimiz iÃ§eriÄŸin %90 kadarÄ± standart kÃ¼tÃ¼phanedeki dosyalarla ilgili iÅŸlem yapan fonksiyonlardÄ±r.


AÅŸaÄŸÄ±da dosya iÅŸlemleri iÃ§in kullanÄ±lan bazÄ± fonksiyonlar gÃ¶rÃ¼lebilir;
- `fopen`
- `fclose`
- `fgetc`
- `fputc`
- `fprintf`
- `fcsanf`
- `remove`
- `rename`
- `tmpfile`
- `tmpname`
- `fseek`
- `ftell`
- `fsetpos`
- `fgetpos`
- `ungetc`
- `strerr`
- `fflush`
- `feof`
- `ferror`
- `fwrite`
- `fread`


`FILE` iÅŸletim sistemi dÃ¼zeyinde dosya iÅŸlemlerinin yapÄ±lmasÄ±nda kullanÄ±lan bir tÃ¼r aÅŸ adÄ±dÄ±r, neyin tÃ¼r eÅŸ adÄ± olduÄŸu derleyiciye bÄ±rakÄ±lmÄ±ÅŸtÄ±r.


### `fopen` Fonksiyonu 

`fopen` fonksiyonunun prototipi `FILE* fopen(const char* fname, const char* openmode);` biÃ§imindedir, `fname` iÅŸlem yapÄ±lmak istenilen dosyanÄ±n adÄ±dÄ±r. </br>
`openmode` aÃ§Ä±lmak istenilen dosyada yapÄ±lacak iÅŸlemlerin sÄ±nÄ±rÄ±nÄ± belirleyen bilgidir(dosya okumak iÃ§in mi yazmak iÃ§in mi vb. aÃ§Ä±lÄ±yor bilgisi), `openmode` bilgisi dosya varsa ve dosya yoksa ne kapÄ±lacaÄŸÄ±nÄ± belirleyen bir parametredir. </br>


Dosyalar temel olarak ya okumak iÃ§in ya da yazmak iÃ§in aÃ§Ä±lÄ±r, dosya aÃ§Ä±lÄ±ÅŸ yÃ¶ndemlerinin bileÅŸenleri aÅŸaÄŸÄ±dan incelenebilir.

Dosya aÃ§ma iÅŸlemleri aÅŸaÄŸÄ±daki durumlarda kullanÄ±lmaktadÄ±r;
1. Okuma(read) iÅŸlemi.
    1. Dosya varsa aÃ§Ä±lacak, dosya yoksa aÃ§Ä±lmayacak.
    2. Dosyadan okunabilir ama dosyaya yazÄ±lamaz.
2. Yazma(write) iÅŸlemi.
    1. Dosya varsa budanacak(truncate)(yani dosyanÄ±n Ã¼zerine yazÄ±lÄ±p), dosya yoksa oluÅŸturulacak.
    2. Dosyaya yazÄ±labilir ama dosyadan okunamaz.
3. Sona yazma(append).
    1. Dosya varsa aÃ§Ä±lacak, dosya yoksa oluÅŸturulacak.
    2. Dosyaya sadece sondan yazÄ±labilir ama dosyadan okunamaz.


ğŸ“Œ C dilinin standart kÃ¼tÃ¼phanesinde dosya oluÅŸtur anlamÄ±nda bir standart fonksiyon yoktur, yeni bir dosya oluÅŸturulmak isteniyorsa dosyayÄ± yazma ya da sona ekleme(appent) biÃ§iminde(mode) aÃ§mak gerekiyor. 



Dosya aÃ§ma iÅŸlemleri aÅŸaÄŸÄ±daki gibi Ã§oklu iÅŸlemli biÃ§imde de kullanÄ±lmaktadÄ±r;
1. **Okuma(read+)** iÅŸlemi.
    1. Dosya varsa aÃ§Ä±lacak, dosya yoksa aÃ§Ä±lmayacak.
    2. Dosyadan okunabilir ve dosyaya yazÄ±labilir.
2. **Yazma(write+)** iÅŸlemi.
    1. Dosya varsa budanacak(truncate)(yani dosyanÄ±n Ã¼zerine yazÄ±lÄ±p), dosya yoksa oluÅŸturulacak.
    2. Dosyaya yazÄ±labilir ve dosyadan okunabilir.
3. **Sona yazma(append+)**.
    1. Dosya varsa aÃ§Ä±lacak, dosya yoksa oluÅŸturulacak.
    2. Dosyaya sadece sondan yazÄ±labilir ve dosyadan okunabilir.



Dosyalardaki veriler iki farklÄ± yÃ¶ntemle iÅŸlenebilir;
1. Text mode(bu varsayÄ±landÄ±r)
2. Binary mode



ğŸ‘‡ AÅŸaÄŸÄ±daki programda programÄ±n Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ± dizinde `test_file1.txt` adÄ±ndaki bir metin dosyasÄ±nÄ±n yazma amaÃ§la nasÄ±l aÃ§Ä±ldÄ±ÄŸÄ± incelenebilir(dosya yoksa oluÅŸturulacaktÄ±r), bu yÃ¶ntemle dosyanÄ±n aÃ§Ä±lmasÄ± dosyanÄ±n tÃ¼m iÃ§eriÄŸinin silinmesi anlamÄ±na gelir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    FILE* f = fopen("test_file1.txt", "w"); // Dosya yazma yÃ¶ntemiyle aÃ§Ä±lÄ±yor.

    fclose(f); // Kaynaklar geri veriliyor.
}
```



YukarÄ±da ifade edilen **dosya aÃ§ma yÃ¶ntemlerinin(open mode)** nasÄ±l yazÄ±larla ifade edileceÄŸi aÅŸaÄŸÄ±da listelenmiÅŸtir;
1. **Text mode** ile;
    - Okuma   --> `r`. DosyayÄ± okumak iÃ§in aÃ§ar, dosya mevcut olmalÄ±dÄ±r yoksa iÅŸlem baÅŸarÄ±sÄ±z olur. 
    - Okuma+  --> `r+`. DosyayÄ± okumak ve yazmak iÃ§in aÃ§ar, dosya mevcut olmalÄ±dÄ±r yoksa iÅŸlem baÅŸarÄ±sÄ±z olur. 
    - Yazma   --> `w`. DosyayÄ± yazmak iÃ§in aÃ§ar, eÄŸer dosya mevcutsa iÃ§eriÄŸi silinecektir, dosya mevcut deÄŸilse dosya oluÅŸturulur.
    - Yazma+  --> `w+`. DosyayÄ± okumak ve yazmak iÃ§in aÃ§ar, eÄŸer dosya mevcutsa iÃ§eriÄŸi silinecektir.
    - Append  --> `a`. DosyanÄ±n sonundan itibaren dosyaya yazmak iÃ§in aÃ§ar, dosya mevcut deÄŸilse dosya oluÅŸturulur.
    - Append+ --> `a+`. DosyanÄ±n sonundan itibaren okumak ve yazmak iÃ§in aÃ§ar, dosya mevcut deÄŸilse dosya oluÅŸturulur.
2. **Binary mode** ile;
    - Okuma   --> `rb`. DosyayÄ± 
    - Okuma+  --> `rb+`. DosyayÄ± 
    - Okuma+  --> `r+b`, `rb+` ile aynÄ±. DosyayÄ± 
    - Yazma   --> `wb`. DosyayÄ± 
    - Yazma+  --> `wb+`. DosyayÄ± 
    - Yazma+  --> `w+b`, `wb+` ile aynÄ±. DosyayÄ± 
    - Append  --> `ab`. DosyayÄ±
    - Append+ --> `ab+`. DosyayÄ±
    - Append+ --> `a+b`, `ab+` ile aynÄ±. DosyayÄ± 


âš ï¸ `fopen` fonksiyonu baÅŸarÄ±sÄ±z olabilir, iÅŸletim sistemi dosyanÄ±n aÃ§Ä±lmasÄ±na bir nedenden dolayÄ± izin vermeyebilir, bu nedenden dolayÄ± dosya iÅŸlemleriyle Ã§alÄ±ÅŸÄ±rken dosyanÄ±n aÃ§Ä±lÄ±p aÃ§Ä±lmadÄ±ÄŸÄ±nÄ± sÄ±nanmasÄ± gerekiyor, `fopen` fonksiyonu dosya aÃ§ma iÅŸlemindeki baÅŸarÄ±sÄ±zlÄ±k durumunu geriye **NULL pointer** dÃ¶ndÃ¼rerek bildirmektedir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda okumuna yÃ¶ntemiyle dosya aÃ§Ä±lmak istendiÄŸinde olmayan bir dosyanÄ±n aÃ§Ä±lmasÄ± iÅŸleminin baÅŸarÄ±sÄ±z olacaÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    FILE* f = fopen("yok_dosya.txt", "r"); // Dosya okuma yÃ¶ntemiyle aÃ§Ä±lÄ±yor.

    if(!f){ // if koÅŸulu 'f == NULL' ile aynÄ±dÄ±r.
        printf("dosya acilamadi.\n");
        return 1;
    }

    printf("dosya acildi.\n");

    fclose(f); // Kaynaklar geri veriliyor.
}
```


â—â—â— Dosya iÅŸlemlerinde Ã¼zerinde iÅŸlem yapÄ±lacak dosyanÄ±n yolu belirtilmezse ilgili dosya programÄ±n kaynak dosyasÄ±nÄ±n bulunduÄŸu dizinde aranacaktÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda farklÄ± bir dizinde dosya iÅŸlemi yaparken dosya yolu(file path) ile nasÄ±l bildirildiÄŸini anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    FILE* f = fopen("c:\\neco\\test_file2.txt", "w"); // Dosya yazma yÃ¶ntemiyle aÃ§Ä±lÄ±yor.

    if(!f){ // if koÅŸulu 'f == NULL' ile aynÄ±dÄ±r.
        printf("dosya olusturulamadi.\n");
        return 1;
    }

    printf("dosya olusturuldu.\n");

    fclose(f); // Kaynaklar geri veriliyor.
}
```


ğŸ“Œ Dosya aÃ§Ä±lamazsa ne yapÄ±lacaÄŸÄ± programÄ±n yapÄ±sÄ±na baÄŸlÄ±dÄ±r, prÄ±gramÄ±n varÅŸlÄ±k nedeni dosya(lar) Ã¼zerinde bazÄ± iÅŸlemlerin yapÄ±lmasÄ±ysa program sonlandÄ±rÄ±labilir.


### `fclose` Fonksiyonu 

`fclose` fonksiyonunun prototipi `int fclose(FILE*);` biÃ§imindedir, bu fonksiyon `FILE*` tÃ¼rÃ¼nden bir deÄŸiÅŸkeni parametre olarak almaktadÄ±r. </br>
`fclose` fonksiyonu Ã§aÄŸÄ±rÄ±lmazsa ne olur, iÅŸletim sistemlerinin hepsinde program varsaylan biÃ§imde sonlanÄ±rsa(`exit()` fonksiyonuna yapÄ±lan Ã§aÄŸrÄ±yla program sonlanÄ±rsa) aÃ§Ä±k dosyalar kapatÄ±lacaktÄ±r. </br>
EÄŸer program Ã§Ã¶kme sonucunda kapatÄ±lÄ±rsa aÃ§Ä±k dosyalarÄ±n kapatÄ±lacaÄŸÄ± kesin deÄŸildir, bu nedenden dolayÄ± mutlaka aÃ§Ä±lan dosyalarÄ± kapatma fonksiyon Ã§aÄŸrÄ±larÄ± eklenmelidir. </br>
`fclose` fonksiyonundan geriye dÃ¶nen deÄŸer 0 ise dosyanÄ±n kapatÄ±lma iÅŸleminin baÅŸarÄ±lÄ± olduÄŸu anlamÄ±na gelmektedir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda okumak amaÃ§lÄ± bir dosyanÄ±n aÃ§Ä±lma kapanma iÅŸleminin nasÄ±l sÄ±nandÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    FILE* f = fopen("test_file4.txt", "r"); // Dosya okuma yÃ¶ntemiyle aÃ§Ä±lÄ±yor.

    if(!f){ // if koÅŸulu 'f == NULL' ile aynÄ±dÄ±r.
        printf("dosya acilamadi.\n");
        return 1;
    }

    printf("dosya acildi.\n");

    if(fclose(f)){
        printf("dosya kapatilamadi.\n");
    }
    else{
        printf("dosya kapatildi.\n");
    }
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.41-11.01 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


â—â—â— `fclose` fonksiyonununa Ã§aÄŸrÄ± yapÄ±lan `FILE*` tÃ¼rÃ¼nden bir gÃ¶sterici, `fclose` fonksiyonu iÅŸini bitirdikten sonra bu fonksiyona geÃ§ilen `FILE*` tÃ¼rÃ¼nden gÃ¶sterici **dangling pointer** haline geleceÄŸi iÃ§in tekrardan bu gÃ¶stericinin `fclose` fonksiyonuna argÃ¼man olarak geÃ§ilmesi **tanÄ±msÄ±z davranÄ±ÅŸtÄ±r(ub)**.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda kapatÄ±lmÄ±ÅŸ bir dosyayÄ± yeniden kapatma isteÄŸinin yapÄ±lmasÄ±nÄ±n **ub** durumuna neden olduÄŸu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    FILE* f1 = fopen("test_file3.txt", "r"); // Dosya okuma yÃ¶ntemiyle aÃ§Ä±lÄ±yor.

    if(!f1){ // if koÅŸulu 'f == NULL' ile aynÄ±dÄ±r.
        printf("dosya acilamadi.\n");
        return 1;
    }

    FILE* f2 = f1;


    fclose(f1);

    // some code here ...

    fclose(f2); // Burada tanÄ±msÄ±z davranÄ±ÅŸ vardÄ±r, 
}
```


### Standart Olmayan `fcloseall` Fonksiyonu 

`fcloseall` fonksiyonunun prototipi `int fcloseall(void);` biÃ§imindedir, geriye dosya kapatma iÅŸlemi baÅŸarÄ±lÄ± olan dosya sayÄ±sÄ±nÄ± dÃ¶ndÃ¼rÃ¼r, bu fonksiyon standart deÄŸildir ama hemen hemen tÃ¼m derleyiciler bu fonksiyonu saÄŸlar. </br>
Bu fonsiyon aynÄ± anda birden fazla fonksiyon Ã¼zerinde Ã§alÄ±ÅŸÄ±ldÄ±ÄŸÄ±nda tek tek tÃ¼m fonksiyonlar iÃ§in ayrÄ± ayrÄ± dosya kapatma iÅŸlemi yapmak yerine toplu bir biÃ§imde tÃ¼m aÃ§Ä±k dosyalarÄ±n kapatÄ±lamsÄ± iÃ§in kullanÄ±lmaktadÄ±r. </br>



ğŸ‘‡ AÅŸaÄŸÄ±daki programda tek seferde tÃ¼m aÃ§Ä±k dosyalarÄ±n nasÄ±l kapatÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    FILE* f1 = fopen("mete.txt", "w");
    FILE* f2 = fopen("alper.txt", "w");
    FILE* f3 = fopen("tuana.txt", "w");
    FILE* f4 = fopen("umay.txt", "w");

    /* some code here ... */
    
    int result = fcloseall();

    printf("result = %d\n", result);
}
```


### Dosya Ä°ÅŸlemlerinin YapÄ±lmasÄ±nÄ±n Ä°ncelenmesi 

Dosya iÅŸlemlerini yapan standart C fonksiyonlarÄ±nÄ± Ã¼Ã§ temel Ã¶beÄŸe ayÄ±rabiliriz;
1. Okuma iÅŸlemlerini yapan fonksiyonlar.
    - `fgetc` fonksiyonu
    - `fscanf` fonksiyonu
    - `fgets` fonksiyonu
    - `fread` fonksiyonu
2. Yazma iÅŸlemlerini yapan fonksiyonlar.
    - `fputc` fonksiyonu
    - `fprintf` fonksiyonu
    - `fputs` fonksiyonu
    - `fwrite` fonksiyonu
3. **Dosya konum gÃ¶stericisi(file pointer)** ile iÅŸlem yapan fonksiyonlar.
    - `fseek` fonksiyonu
    - `rewind` fonksiyonu
    - `ftell` fonksiyonu
    - `fsetpos` fonksiyonu
    - `fgetpos` fonksiyonu



â—â—â—Dosyadan okuma yapmak dosyadaki byte ya da byte'larÄ±n deÄŸerini Ã¶ÄŸrenmek demektir, dosyadan okuma(ya da yazma) iÅŸlemine dosyanÄ±n hangi byte'Ä±ndan baÅŸlayarak dosyadan okuma(ya da yazma) iÅŸlemi yapÄ±lacak bunun bilgisini tutan bizim doÄŸrudan eriÅŸemediÄŸimiz sistem tarafÄ±ndan tutulan bir tam sayÄ± deÄŸiÅŸken vardÄ±r iÅŸte bu tam sayÄ± deÄŸiÅŸkene **dosya konum gÃ¶stericisi(file pointer)** denilmektedir. </br>
**Dosya konum gÃ¶stericisinin(file pointer)** deÄŸeri hangi tam sayÄ± ise dosyadan okuma(ya da yazma) yapacak fonksiyon o byte'tan baÅŸlayarak okuma(ya da yazma) iÅŸlemini yapacaktÄ±r, buradaki indeksleme iÅŸlemi 0'dan baÅŸlamaktadÄ±r, dosyanÄ±n ilk byte'Ä± 0 indeksine sahiptir. </br>
Okuma ya da yazma iÅŸlemi yapan fonskiyonlar dosyanÄ±n hangi indeksinden itibaren iÅŸlem yapacaÄŸÄ± bilgisini fonksiyon Ã§aÄŸrÄ±sÄ± yapan koddan istememektedir, index deÄŸerini **dosya konum gÃ¶stericisinin(file pointer)** deÄŸerinden Ã¶ÄŸrenmektedirler. </br>
Okuma ya da yazma iÅŸlemi yapan fonskiyonlar hangi byte'tan itibaren iÅŸlem yapacaklarÄ± bilgisini Ã§aÄŸÄ±ran koddan istemez, **dosya konum gÃ¶stericisinin(file pointer)** deÄŸeri ne ise o indeksli byte'tan(buna **offset** deÄŸeri deniliyor) baÅŸlayarak iÅŸlem yapÄ±lacaktÄ±r. </br>
Okuma iÅŸlemi yapan fonksiyonlar okuduklarÄ± byte sayÄ±sÄ± kadar ve yazma iÅŸlemi yapan fonksiyonlarda yine yazdÄ±klarÄ± byte sayÄ±sÄ± kadar **dosya konum gÃ¶stericisinin(file pointer)** deÄŸerini arttÄ±rmaktadÄ±r. </br>
Bir dosya ilk aÃ§Ä±ldÄ±ÄŸÄ±nda **dosya konum gÃ¶stericisinin(file pointer)** deÄŸeri 0 deÄŸerinde olacaktÄ±r, dosya Ã¼zerinde iÅŸlem yapÄ±ldÄ±kÃ§a **dosya konum gÃ¶stericisinin(file pointer)** deÄŸeri artacaktÄ±r. </br>
Bir dosya Ã¼zerinde okuma ve yazma iÅŸleminin sÄ±ralÄ± biÃ§imde yapÄ±lmasÄ±na "**Sequential Access**" denilmektedir, bir dosya 2000 byte'tan oluÅŸuyorsa ve dosyanÄ±n 1986. byte'Ä±nÄ±n **sequential access** yÃ¶ntemiyle okunmasÄ± isteniyorsa bu durumda dosyanÄ±n 1985 byte'Ä±nÄ±n okunmasÄ± gerekiyor ki dosyanÄ±n 1986. byte'Ä± okunabilsin. </br>
Bir dosya Ã¼zerinde okuma ve yazma iÅŸleminin rastgele biÃ§imde yapÄ±lmasÄ±na "**Random Access**" ya da "**Direct Access**" denilmektedir, bir dosya 2000 byte'tan oluÅŸuyorsa ve dosyanÄ±n 1986. byte'Ä±nÄ±n **random access** yÃ¶ntemiyle okunmasÄ± isteniyorsa bu durumda doÄŸrudan 1986. byte'Ä± okuyabiliriz. </br>
Okuma ve yazma iÅŸlemi iÃ§in ortak tek bir gÃ¶sterici kullanÄ±lmaktadÄ±r.



**Dosya konum gÃ¶stericisi(file pointer)** iÅŸlemleri **Dosya konum gÃ¶stericisi(file pointer)** deÄŸerinin edinilmesini ve deÄŸiÅŸtirilmesini saÄŸlayan iÅŸlemleri kapsamaktadÄ±r. </br>


### `fgetc` Fonksiyonu 

`fgetc` fonksiyonunun prototipi `int fgetc(FILE*);` biÃ§imindedir, bu fonksiyondan **dosya konum gÃ¶stericisinin(file pointer)** gÃ¶sterdiÄŸi indeksteki byte deÄŸerini `int` tÃ¼rÃ¼nden bir deÄŸer olarak geriye dÃ¶ndÃ¼rmektedir. 

`fgetc` fonksiyonu neden dolayÄ± baÅŸarÄ±sÄ±z olabilir;
1. DoÄŸal baÅŸarÄ±sÄ±zlÄ±k(genel olarak kullanÄ±lan bir terim deÄŸildir): Dosyadan okunacak byte kalmadÄ±ÄŸÄ±nda `fgetc` fonksiyonu baÅŸarÄ±sÄ±z olacaktÄ±r, bu durumda `fgetc` fonksiyonundan geriye `EOF` deÄŸeri dÃ¶ner.
2. DoÄŸal olmayan baÅŸarÄ±sÄ±zlÄ±k(genel olarak kullanÄ±lan bir terim deÄŸildir): 


`EOF` deÄŸeri bir **object-like** mokrodur, bu makronun adÄ± **End of File** sÃ¶zcÃ¼klerinden gelmektedir, bu makronun deÄŸeri derleyiciler taarfÄ±ndan "-1" deÄŸerine atanmÄ±ÅŸtÄ±r yani sadece sabit deÄŸere karÅŸÄ±lÄ±k gelen bir hata kodudur.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `fgetc` fonksiyonu kullanÄ±larak `mete.txt` dosyasÄ±ndaki iÃ§eriÄŸi byte byte okunmasÄ± iÅŸlemi incelenebilir, `mete.txt` dosyasÄ±nda sadece dÃ¶rt byte'lÄ±k veri olduÄŸunda beÅŸimci `fgetc` fonksiyonu isteÄŸinde fonksiyondan geriye `EOF` deÄŸeri dÃ¶necektir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    FILE* f = fopen("mete.txt", "r");
    if(!f){
        printf("dosya acilamadi.\n");
        return 1;
    }

    int c;

    c = fgetc(f);
    printf("c = %d\n", c);
    c = fgetc(f);
    printf("c = %d\n", c);
    c = fgetc(f);
    printf("c = %d\n", c);
    c = fgetc(f);
    printf("c = %d\n", c);
    c = fgetc(f);
    printf("c = %d\n", c);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda dosya iÅŸlemlerinde karakter karakter dosyanÄ±n tÃ¼m byte'larÄ±nÄ±n okunmasÄ± iÅŸleminin nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    FILE* f = fopen("main.c", "r");
    if(!f){
        printf("dosya acilamadi.\n");
        return 1;
    }

    int c;

    while ((c = fgetc(f)) != EOF) {
        putchar(c);
    }

    fclose(f);
}
```


âš ï¸ `fgetc` fonksiyonunun kullanÄ±mÄ±nda en sÄ±k yapÄ±lan hata geri dÃ¶nÃ¼ÅŸ deÄŸerinin `char` tÃ¼rÃ¼ne atanmasÄ± iÅŸlemidir ama bu fonksiyondan geriye dÃ¶nen deÄŸer `int` tÃ¼rÃ¼ndendir, bu durumda derleyiciler tÃ¼r daralmasÄ±ndan dolayÄ± uyarÄ± iletisi verecektir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda komut satÄ±rÄ±ndan alÄ±nacak dosyalarÄ±n iÃ§eriÄŸi yazdÄ±rÄ±lacaktÄ±r(bu programÄ±n Ã§alÄ±ÅŸtÄ±rÄ±labilir dosyasÄ±nÄ±n dizinine cmd'de gittikten sonra "<Ã§alÄ±ÅŸtÄ±rÄ±labilir dosya adÄ±> <okunacak dosya adi>" biÃ§iminde Ã§alÄ±ÅŸtÄ±rabilirsin).
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(int argc, char **argv)
{
    if(argc != 2){
        printf("kullanim: <dyaz> <dosya adi>\n");
        return 1;
    }

    FILE* f = fopen(argv[1], "r");
    if(f == NULL){
        printf("%s dosyasi acilamadi\n", argv[1]);
        return 2;
    }

    int c;

    while ((c = fgetc(f)) != EOF)
        putchar(c);
    
    fclose(f);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda komut satÄ±rÄ±ndan alÄ±nacak dosyalarÄ±n iÃ§inde geÃ§en Ã¶zel bir karakterin adedinin sayÄ±sÄ±nÄ± hesaplayan program incelenebilir(bu programÄ±n Ã§alÄ±ÅŸtÄ±rÄ±labilir dosyasÄ±nÄ±n dizinine cmd'de gittikten sonra "**<Ã§alÄ±ÅŸtÄ±rÄ±labilir dosya adÄ±> <okunacak dosya adi> <sayilacak karakter>**" biÃ§iminde Ã§alÄ±ÅŸtÄ±rabilirsin).
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(int argc, char **argv)
{
    if(argc != 3){
        printf("kullanim: <ksay> <dosya adi> <sayilacak karakter>\n");
        return 1;
    }

    FILE* f = fopen(argv[1], "r");
    if(f == NULL){
        printf("%s dosyasi acilamadi\n", argv[1]);
        return 2;
    }

    int c;
    int cnt = 0;

    while ((c = fgetc(f)) != EOF)
        if(c == *argv[2])
            ++cnt;
    
    fclose(f);

    printf("%d\n", cnt);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda komut satÄ±rÄ±ndan alÄ±nacak dosyanÄ±n iÃ§inde geÃ§en karakterin hepsinin adedinin sayÄ±sÄ±nÄ± hesaplayan ve standart Ã§Ä±ktÄ± akÄ±mÄ±na alfabetik sÄ±rada gÃ¶nderen program incelenebilir(bu programÄ±n Ã§alÄ±ÅŸtÄ±rÄ±labilir dosyasÄ±nÄ±n dizinine cmd'de gittikten sonra "**<Ã§alÄ±ÅŸtÄ±rÄ±labilir dosya adÄ±> <okunacak dosya adi> <sayilacak karakter>**" biÃ§iminde Ã§alÄ±ÅŸtÄ±rabilirsin).
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h> // Added to use "character test functions".

int main(int argc, char **argv)
{
    if(argc != 2){
        printf("kullanim: <khsay> <dosya adi>\n");
        return 1;
    }

    FILE* f = fopen(argv[1], "r");
    if(f == NULL){
        printf("%s dosyasi acilamadi\n", argv[1]);
        return 2;
    }

    int cnts[26] = { 0 }; // Ä°ngiliz alfabesinde 26 harf olduÄŸu iÃ§in, her bir harfin ilgili dosyada kaÃ§ adet bulunduÄŸu bilgisi bu dizide tutulacak.
    int c;

    while ((c = fgetc(f)) != EOF){
        if(isalpha(c)){
            ++cnts[toupper(c) - 'A'];
        }
    }

    fclose(f);

    for(int i = 0; i < 26; ++i){
        if(cnts[i]){
            printf("%c  %d\n", 'A' + i, cnts[i]);
        }
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda komut satÄ±rÄ±ndan alÄ±nacak dosyanÄ±n iÃ§inde geÃ§en karakterin hepsinin adedinin sayÄ±sÄ±nÄ± hesaplayan ve standart Ã§Ä±ktÄ± akÄ±mÄ±na en Ã§ok bulunan karakterden azalarak gÃ¶nderen program incelenebilir(bu programÄ±n Ã§alÄ±ÅŸtÄ±rÄ±labilir dosyasÄ±nÄ±n dizinine cmd'de gittikten sonra "**<Ã§alÄ±ÅŸtÄ±rÄ±labilir dosya adÄ±> <okunacak dosya adi> <sayilacak karakter>**" biÃ§iminde Ã§alÄ±ÅŸtÄ±rabilirsin). </br>
Bu programÄ±n yaptÄ±ÄŸÄ± iÅŸlemi yapan programÄ±n yazÄ±lmasÄ± C mÃ¼lakatlarÄ±nda istenmektedir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h> // Added to use "character test functions".

typedef struct{
    char c;
    int cnt;
} Elem;


// 'qsort' fonksiyonuna geÃ§ilecek olan sÄ±ralama fonksiyonu.
int elemcmp(const void* vp1, const void* vp2){
    return ((const Elem*)vp2)->cnt - ((const Elem*)vp1)->cnt;
}

int main(int argc, char **argv)
{
    // 'Elem cnts[26]' dizisininilklendirme lemanlarÄ±nÄ± oluÅŸturmak iÃ§in kullanÄ±lan kod parÃ§asÄ±.
    // for(int i = 0; i < 26; ++i){
    //     printf("{'%c', 0},\n", 'A' + i);
    // }

    if(argc != 2){
        printf("kullanim: <khsay> <dosya adi>\n");
        return 1;
    }

    FILE* f = fopen(argv[1], "r");
    if(f == NULL){
        printf("%s dosyasi acilamadi\n", argv[1]);
        return 2;
    }

    // Ä°ngiliz alfabesinde 26 harf olduÄŸu iÃ§in, her bir harfin ilgili dosyada kaÃ§ adet bulunduÄŸu bilgisi bu dizide tutulacak.
    Elem cnts[26] = { 
        {'A', 0},
        {'B', 0},
        {'C', 0},
        {'D', 0},
        {'E', 0},
        {'F', 0},
        {'G', 0},
        {'H', 0},
        {'I', 0},
        {'J', 0},
        {'K', 0},
        {'L', 0},
        {'M', 0},
        {'N', 0},
        {'O', 0},
        {'P', 0},
        {'Q', 0},
        {'R', 0},
        {'S', 0},
        {'T', 0},
        {'U', 0},
        {'V', 0},
        {'W', 0},
        {'X', 0},
        {'Y', 0},
        {'Z', 0},
    };
    int c;

    while ((c = fgetc(f)) != EOF){
        if(isalpha(c)){
            ++cnts[toupper(c) - 'A'].cnt;
        }
    }

    qsort(cnts, 26, sizeof(Elem), elemcmp);

    fclose(f);

    for(int i = 0; i < 26; ++i){
        if(cnts[i].cnt){
            printf("%c  %d\n", cnts[i].c, cnts[i].cnt);
        }
    }
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.02-12.16 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


ğŸ“Œ ProgramÄ±n Ã§alÄ±ÅŸmasÄ±nda bir dosya aÃ§Ä±lÄ±p Ã¼zerinde iÅŸlemler yapÄ±ldÄ±ktan sonra o dosya kapatÄ±lÄ±r ve yeniden(program sonlanmadan) aÃ§Ä±lÄ±rsa **dosya gÃ¶stericisinin(file pointer)** deÄŸeri sÄ±fÄ±rlanÄ±r.


### **Text mode** ve **Binary mode** Ä°ÅŸlemlerinin DetaylarÄ± 

Unix/Linux sistemlerinde dosyalarÄ± **text mode** veya **binary mode** olarak aÃ§mak arasÄ±nda teknik olarak bir fark yoktur. </br>
Windows sistemlerinde dosyalarÄ± **text mode** ya da **binary mode** olarak aÃ§Ä±nca bazÄ± iÅŸlemleri farklÄ± yapÄ±lmaktadÄ±r.

DosyanÄ±n iÃ§eriÄŸi yazÄ±(text) deÄŸilse bu dosya **binary mode** olarak aÃ§Ä±lmalÄ±dÄ±r. </br>
DosyanÄ±n Ã¼zerinde yapÄ±lacak iÅŸlemler dosyanÄ±n iÃ§eriÄŸinden baÄŸÄ±msÄ±zsa(mesela dosya iÃ§eriÄŸinin kopyalanmasÄ± iÅŸlemleri) **binary mode** olarak aÃ§Ä±lmalÄ±dÄ±r.

Windows sisteminde bir dosya **text mode** olarak yazma iÅŸlemi iÃ§in aÃ§Ä±ldÄ±ÄŸÄ±nda **yeni satÄ±r(newline)** karakteri yazÄ±ldÄ±ÄŸÄ±nda bu karakter dosyaya iki byte olarak yazÄ±lmaktadÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Windows sisteminde bir dosyaya **text mode** ile yÃ¼z defa **yeni satÄ±r(newline)** karakteri yazdÄ±rÄ±ldÄ±ÄŸÄ± durumda dosyanÄ±n boyutunun ve okunma iÅŸleminin nasÄ±l olduÄŸu incelenebilir(dosya boyutu 200 byte olacaktÄ±r).
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h> // Added to use "character test functions".

int main(void)
{
    FILE* fw = fopen("abc", "w");
    if(!fw){
        printf("acilamadi.\n");
        return 1;
    }

    for(int i = 0; i < 100; ++i){
        fputc('\n', fw);
    }

    fclose(fw);


    FILE* fr = fopen("abc", "r");
    if(!fr){
        printf("acilamadi.\n");
        return 1;
    }

    int c;

    while((c = fgetc(fr)) != EOF)
        printf("%d ", c);

    fclose(fr);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Windows sisteminde bir dosyaya **binary mode** ile yÃ¼z defa **yeni satÄ±r(newline)** karakteri yazdÄ±rÄ±ldÄ±ÄŸÄ± durumda dosyanÄ±n boyutunun ve okunma iÅŸleminin nasÄ±l olduÄŸu incelenebilir(dosya boyutu 100 byte olacaktÄ±r).
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h> // Added to use "character test functions".

int main(void)
{
    FILE* fw = fopen("abc", "wb");
    if(!fw){
        printf("acilamadi.\n");
        return 1;
    }

    for(int i = 0; i < 100; ++i){
        fputc('\n', fw);
    }

    fclose(fw);


    FILE* fr = fopen("abc", "rb");
    if(!fr){
        printf("acilamadi.\n");
        return 1;
    }

    int c;

    while((c = fgetc(fr)) != EOF)
        printf("%d ", c);

    fclose(fr);
}
```



â—â—â— Eskiden dosyalarÄ±n sonunu belirtmek iÃ§in **Ctrl + Z(26 kod numaralÄ± karakter ekleniyormuÅŸ)**, Windows sisteminde bir dosya **text mode** olarak aÃ§Ä±ldÄ±ÄŸÄ±nda ve byte byte okuma yapÄ±ldÄ±ÄŸÄ±nda eÄŸer okunan byte 26 deÄŸerindeyse bu byte'a `EOF` muamelesi yapÄ±lmaktadÄ±r, ama dosya **binary mode** olarak aÃ§Ä±ldÄ±ÄŸÄ±nda ve byte byte okuma yapÄ±ldÄ±ÄŸÄ±nda eÄŸer okunan byte 26 deÄŸerindeyse bu byte'a `EOF` muamelesi yapÄ±lmamaktadÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Windows sisteminde bir dosyaya **binary mode** olarak yazma iÅŸlemi yapÄ±ldÄ±ktan sonra bu dosyanÄ±n **text mode** olarak aÃ§Ä±ldÄ±ÄŸÄ±nda bu dosyanÄ±n iÃ§eriÄŸinin byte byte okunmasÄ± sonucunda okunan bir byte'Ä±n deÄŸeri eÄŸer 26 ise o byte'Ä±n dosya sonunu belirten `EOF` muamelesi yapÄ±lacaÄŸÄ±, **binary mode** olarak aÃ§Ä±ldÄ±ÄŸÄ±nda bu dosyanÄ±n iÃ§eriÄŸinin byte byte okunmasÄ±nda okunan bir byte'Ä±n deÄŸeri eÄŸer 26 olmasÄ± durumda bir sorun oluÅŸmayacaÄŸÄ± gÃ¶zlemlenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h> // Added to use "character test functions".

int main(void)
{
    FILE* fw = fopen("abc2", "wb");
    if(!fw){
        printf("acilamadi.\n");
        return 1;
    }

    for(int i = 0; i < 100; ++i){
        fputc('a', fw);
    }

    fputc(26, fw);
    
    for(int i = 0; i < 100; ++i){
        fputc('b', fw);
    }

    fclose(fw);
    

    printf("~~~~~~~~~~~~~~~~~~~");


    FILE* fr = fopen("abc2", "r");
    if(!fr){
        printf("acilamadi.\n");
        return 1;
    }

    int c;

    while((c = fgetc(fr)) != EOF)
        printf("%d ", c);

    fclose(fr);


    printf("~~~~~~~~~~~~~~~~~~~");


    FILE* fr = fopen("abc2", "rb");
    if(!fr){
        printf("acilamadi.\n");
        return 1;
    }

    int c;

    while((c = fgetc(fr)) != EOF)
        printf("%d ", c);
    
    fclose(fr);
}
```


### `fputc` Fonksiyonu 

`fputc` fonksiyonunun prototipi `int fputc(int c, FILE*);` biÃ§imindedir, bu fonksiyon dosyaya bir karakter iÅŸlemini gerÃ§ekleÅŸtirmektedir, bu fonksiyonun ilk parametresi yazÄ±lacak byte'Ä±n deÄŸeridir, ikinci parametresi Ã¼zerinde iÅŸlem yapÄ±lacak dosyadÄ±r, fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸeri yazma iÅŸleminde bir hata olmulsa `EOF` deÄŸeridir, yazma iÅŸleminde bir hata olmamÄ±ÅŸsa dosyaya yazdÄ±rÄ±lan karakterin tam sayÄ± deÄŸeridir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir dosyaya **text mode** ile nasÄ±l Ä°ngiliz alfabesindeki bÃ¼yÃ¼k harflarin yazdÄ±rÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h> // Added to use "character test functions".


int main(void)
{
    FILE* f = fopen("timur.txt", "w");
    if(!f){
        printf("acilamadi.\n");
        return 1;
    }

    for(int i = 'A'; i <= 'Z'; ++i){
        fputc(i, f);
    }

    fclose(f);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir dosyaya **text mode** ile nasÄ±l Ä°ngiliz alfabesindeki bÃ¼yÃ¼k yazdÄ±rÄ±labilir karakterlerin standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderilebileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h> // Added to use "character test functions".


int main(void)
{
    FILE* f = fopen("timur.txt", "w");
    if(!f){
        printf("acilamadi.\n");
        return 1;
    }

    for(int i = 0; i < 128; ++i){
        if(isprint(i))
            fputc(i, f);
    }

    fclose(f);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda komut satÄ±rÄ± argÃ¼manÄ± olarak alÄ±nan deÄŸerlere gÃ¶re bir dosyaya **text mode** ile nasÄ±l birden fazla satÄ±rÄ±n yadÄ±rÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv)
{
    if(argc != 5){
        printf("usage: <crf> <filename> <no of lines> <min line length> <max line length>\n");
        return 1;
    }

    FILE *fw = fopen(argv[1], "w");
    if(fw == NULL){
        printf("cannot create file %s\n", argv[1]);
        return 2;
    }

    int no_of_lines = atoi(argv[2]);
    int min_len = atoi(argv[3]);
    int max_len = atoi(argv[4]);

    for(int i = 0; i < no_of_lines; ++i){
        int line_len = rand() % (max_len - min_len + 1) + min_len;
        while(line_len--)
            fputc(rand() % 26 + 'A', fw);
        fputc('\n', fw);
    }

    fclose(fw);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda komut satÄ±rÄ± argÃ¼manÄ± olarak alÄ±nan deÄŸerlere gÃ¶re bir dosyanÄ±n iÃ§eriÄŸinin baÅŸka bir dosyaya **binary mode** ile nasÄ±l kopyalanabileceÄŸini anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h> // Added to use "character test functions".

int main(int argc, char **argv)
{
    if(argc != 3){
        printf("usage: <filecopy> <source file name> <dest file name>\n");
        return 1;
    }

    FILE* fsource = fopen(argv[1], "rb");
    if(!fsource){
        printf("cannot open file %s\n", argv[1]);
        return 2;
    }

    FILE* fdest = fopen(argv[2], "wb");
    if(!fdest){
        printf("cannot create file %s\n", argv[2]);
        fclose(fsource);
        return 3;
    }

    int byte_count = 0;
    int c;

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile kaynak dosyanÄ±n sonu gÃ¶rÃ¼nene kadar olan tÃ¼m byte'lar hedef dosyaya byte byte yazÄ±lyor.
    while((c = fgetc(fsource) != EOF)){
        fputc(c, fdest);
        ++byte_count;
    }
    
    fclose(fsource);
    fclose(fdest);

    printf("the file %s of %d bytes copied as file %s\n", argv[1], byte_count, argv[2]);
}
```


Ders sonu ...
