# 60.Ek Ders
---


ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir Ã¶nceki derste yazÄ±ldÄ±ÄŸÄ±nda hata alÄ±nan bir programÄ±n doÄŸru Ã§alÄ±ÅŸan hali gÃ¶rÃ¼lebilir, program birebir aynÄ± olmayabilir ama bir Ã¶nceki derste yazÄ±lan program da doÄŸruydu muhtemelen.
```C
#include <stdio.h>
#include <time.h>

int main(void)
{
    struct tm tm = {
        .tm_year = 99,
        .tm_mon = 7,
        .tm_mday = 17,
        .tm_isdst = -1,
        .tm_hour = 3,
        .tm_min = 2,
        .tm_sec = 0,
    };

    const time_t now = time(NULL);
    const time_t t_quake = mktime(&tm);
    const time_t result = (time_t)difftime(now, t_quake);

    struct tm* pt = localtime(&result);

    printf("%d yil, %d ay, %d gun, %d saat, %d dakika, %d saniye\n",
           pt->tm_year - 70, pt->tm_mon + 1, pt->tm_mday, pt->tm_hour, pt->tm_min, pt->tm_sec);
}
```


## Pointer HatalarÄ± Devam


ğŸ‘‡ AÅŸaÄŸÄ±daki programda en basit pointer hatalarÄ±ndan biri incelenebilir. 
```C

int main(void)
{
    int* ptr; // Buradaki 'ptr' deÄŸiÅŸkeni Ã§Ã¶p deÄŸerdedir(indeterminant value), bu tÃ¼r gÃ¶stericilere standart olmayan biÃ§imde 'wild pointer' da denilebiliyor.

    *ptr = 10; // Buradaki atama iÅŸlemi 'ptr' deÄŸiÅŸkeni Ã§Ã¶p deÄŸerde olduÄŸu iÃ§in 'ub'dir.
}
``` 


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `p` gÃ¶stericisine deÄŸer atanmadan kullanÄ±ldÄ±ÄŸÄ± iÃ§in **ub** durumu mevcuttur.
```C
#include <stdio.h>

int main(void)
{
    char* p;

    printf("bir yazi giriniz: ");
    scanf("%s", p);
}
``` 


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `p` gÃ¶stericisine deÄŸer atanmadÄ±ÄŸÄ±ndan dolayÄ± programda bir hata yoktur.
```C
#include <stdio.h>

int main(void)
{
    char str[100];
    char* p = str;

    printf("bir yazi giriniz: ");
    scanf("%s", p);

    printf("girilen deger: %s\n", p);
}
``` 


Dizilerin taÅŸÄ±rÄ±lmasÄ± **ub** durumuna neden olur.

ğŸ‘‡ AÅŸaÄŸÄ±daki programda `p` gÃ¶stericisine deÄŸer atanmadan kullanÄ±ldÄ±ÄŸÄ± iÃ§in **ub** durumu mevcuttur.
```C
#include <stdio.h>

int main(void)
{
    int ary[10];

    for(int i = 0; i <= 10; ++i){
        ary[i] = i; // Burada dÃ¶ngÃ¼nÃ¼n son turuna 'ary[10]' ile diziye ait olmayan bir elemana eriÅŸilmiÅŸ olur bu da dizi taÅŸmasÄ±ndan dolayÄ± 'ub' durumuna neden olur.
    }
}
``` 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `p` gÃ¶stericisinin gÃ¶sterdiÄŸi adres deÄŸeri arttÄ±rÄ±ldÄ±ktan sonra oradaki deÄŸeri kullanmanÄ±n **ub** durumuna sebebiyet verdiÄŸi gÃ¶rÃ¼lmelidir.
```C
#include <stdio.h>

int main(void)
{
    int x = 11;
    int* p = &x;

    *p++ = 21; // Buradaki statement'ta bir yanÄ±ÅŸlÄ±k yoktur ama bu statement'tan sonra 'p' gÃ¶stericisinin gÃ¶sterdiÄŸi adresteki deÄŸer okunmaya Ã§alÄ±ÅŸÄ±lÄ±rsa bu 'ub' durumuna neden olur.

    *p; // Burada 'ub' durumu oluÅŸur.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `p` gÃ¶stericisine deÄŸer atanmadan kullanÄ±ldÄ±ÄŸÄ± iÃ§in **ub** durumu mevcuttur.
```C
#include <stdio.h>

int main(void)
{
    int ary[10] = { 0 };
    &ary[10]; // Burada 'ub' yoktur Ã§Ã¼nkÃ¼ sadece diziye dahil olmayan dizinin en son elemanÄ±ndan sonraki adres deÄŸerine eriÅŸiliyor, diziye dahil olmayan adresteki nesnenin deÄŸerine eriÅŸilmiyor.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `p` gÃ¶stericisinin gÃ¶sterdiÄŸi adresteki nesnenin deÄŸerine en son eriÅŸildiÄŸi yerdeki **ub** durumu iyi anlaÅŸÄ±lmalÄ±dÄ±r. 
```C
#include <stdio.h>

int main(void)
{
    int x = 5;
    int* p = &x;

    int a = *p++; // Burada hatalÄ± bir kullanÄ±m yoktur.
    int b = *p; // Burada bilinmeyen bir adrsteki deÄŸere eriÅŸildiÄŸi iÃ§in 'ub' durumu oluÅŸur.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda gÃ¶stericilerle ilgili yapÄ±labilecek hata incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int i = 45;
    int* p1, p2; // Burada 'p1'in tÃ¼rÃ¼ 'int*' ama 'p2'nin tÃ¼rÃ¼ 'int' tÃ¼rÃ¼dÃ¼r.

    p1 = &i; // Burada 'p1' gÃ¶stericisine 'i' 'int' deÄŸiÅŸkeninin adresi atanÄ±yor.
    p2 = p1; // Burada 'p2' adÄ±ndaki 'int' tÃ¼rÃ¼nden deÄŸiÅŸkene 'int*' tÃ¼rÃ¼nden bir adres atandÄ±ÄŸÄ± iÃ§in hatalara sebebiyet verebilecek bir durum oluÅŸacaktÄ±r. 
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda gÃ¶stericilerle ilgili yapÄ±labilecek hata incelenebilir, farklÄ± tÃ¼rden gÃ¶stericilerin birbirine atanmasÄ± Ã§oÄŸunlukla **ub** durumu oluÅŸmasÄ±na neden olur.
```C
#include <stdio.h>

int main(void)
{
    double dval = 123.6434;
    int* p = (int*)&dval; // Buradaki atama iÅŸleminde uyumsuz tÃ¼rden gÃ¶stericiler birbirine atandÄ±ÄŸÄ± iÃ§in 'p'nin gÃ¶sterdiÄŸi adresteki deÄŸeri kullanmak 'ub' durumuna nenden olur.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda aynÄ± tÃ¼rden tam sayÄ± tÃ¼rlerinin iÅŸaretli ve iÅŸaretsiz tÃ¼r versiyonlarÄ± arasÄ±nda pointer'lar Ã¼zerinden yapÄ±lan tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mlerinin **ub** durumuna neden olmadÄ±ÄŸÄ± ve kullanÄ±lan doÄŸru bir yÃ¶ntem olduÄŸu gÃ¶rÃ¼lebilir. </br>
- `unsigned int` --> `int`
- `unsigned short` --> `short`
- `unsigned long` --> `long`
- `unsigned long long` --> `long long`
```C
#include <stdio.h>

int main(void)
{
    unsigned int x = 213123;
    int* p = (int*)&x; // Buradaki tÃ¼r dÃ¶nÃ¼ÅŸÃ¼m iÅŸlemi legal ve doÄŸrudur, bÃ¶yle dÃ¶nÃ¼ÅŸÃ¼mler kullanÄ±labilir.

    *p; // 'p' gÃ¶stericisinin gÃ¶sterdiÄŸi adresteki nesnenin deÄŸerine eriÅŸilip nesnenin deÄŸeri kullanÄ±labilir.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda, C standardÄ±ndan Ã§Ä±karÄ±lacak ÅŸu durumun "Her nesne bir char dizisiymiÅŸ gibi kullanÄ±labilir" uygulanÄ±ÅŸÄ± incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    unsigned int x = 213124;
    unsigned char *p = (unsigned char)&x; // Burada 'unsigned int' tÃ¼rÃ¼nÃ¼n adresinin 'unsigned char*' tÃ¼rÃ¼nden bir pointer deÄŸiÅŸkene atanmaktadÄ±r.

    // AÅŸaÄŸÄ±daki gibi bir dÃ¶ngÃ¼nÃ¼n kurulmasÄ± legal ve doÄŸru bir kullanÄ±mdÄ±r.
    for(size_t i = 0; i < sizeof(x); ++i) {
        printf("%u \n", p[i]);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda yapÄ± nesnelerinin adreslerinin yapÄ±nÄ±n ilk Ã¼yesinin(elemanÄ±nÄ±n) adresi olma durumunun kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>

struct Nec {
    int a;
    double b;
    char str[16];
};

int main(void)
{
    struct Nec nec = { 123, 4.5, "metehan" };

    int* ip = (int*) &nec; // Buradaki gibi bir yapÄ± nesnesi doÄŸrudan ilk elemanÄ±nÄ±n tÃ¼rÃ¼ymÃ¼ÅŸ gibi tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapÄ±larak kullanÄ±labilir.

    printf("%d\n", *ip);

    *ip = 9999997;

    printf("nec.a = %d\n", nec.a);

    struct Nec* pn = (struct Nec*)ip;
    
    printf("%f\n", pn->d);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program adreslerin karÅŸÄ±laÅŸtÄ±rÄ±lmasÄ±yla o adreslerdeki yazÄ±larÄ±n karÅŸÄ±laÅŸtÄ±rmasÄ±nÄ±n Ã§ok baÅŸka iÅŸlem olduÄŸunu anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>
#include <string.h>

int main(void)
{
    char str1[] = "atilla";
    char str2[] = "atilla";

    // AÅŸaÄŸÄ±daki karÅŸÄ±laÅŸtÄ±rmada iki pointer'Ä±n tuttuÄŸu adresler karÅŸÄ±laÅŸtÄ±rÄ±lacaÄŸÄ± iÃ§in buradaki iÅŸlem her zaman 'false' olacaktÄ±r Ã§Ã¼nkÃ¼ iki yazÄ±nÄ±n adresi her zaman farklÄ± olacaktÄ±r.
    if(str1 == str2) {
        printf("evet esit.\n");
    }
    else {
        printf("hayir esit degil.\n");
    }

    // AÅŸaÄŸÄ±daki karÅŸÄ±laÅŸtÄ±rmada iki gÃ¶stericinin gÃ¶sterdiÄŸi adresteki yazÄ±larÄ± karÅŸÄ±laÅŸtÄ±rarak yapacaktÄ±r, 'strcmp' fonksiyonu kendisine geÃ§ilen iki yazÄ±yÄ± karÅŸÄ±laÅŸtÄ±rÄ±r.
    if(!strcmp(str1, str2)) {
        printf("evet esit.\n");
    }
    else {
        printf("hayir esit degil.\n");
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program `string literal` bir nesnenin deÄŸerinin deÄŸiÅŸtirilmek istenmesinin **ub** durumuna neden olacaÄŸÄ± gÃ¶rÃ¼lmelidir.
```C
#include <stdio.h>

int main(void)
{
    char* pname = "necati"; // Bir pinter deÄŸiÅŸkene bir 'string literal' atanÄ±yorsa o pointer Ã¼zerinden 'string literal' deÄŸiÅŸtirilmemelidir yoksa 'ub' durumu oluÅŸur.

    pname[5] = '\0'; // Burada 'string literal' bir nesnenin deÄŸeri deÄŸiÅŸtirilmek istendiÄŸi iÃ§in 'ub' durumu oluÅŸur.
}
```



ğŸ‘‡ â—â—â— AÅŸaÄŸÄ±daki program deÄŸerleri aynÄ± olan iki farklÄ± `string literal` nesnenin deÄŸerinin karÅŸÄ±laÅŸtÄ±rÄ±lmasÄ± durumunun **unspecified behavior(belirsiz davranÄ±ÅŸ)** olacaÄŸÄ± gÃ¶rÃ¼lmelidir.
```C
#include <stdio.h>

int main(void)
{
    char* p1 = "hulagu";
    char* p2 = "hulagu";

    // Dsrleyiciler standardÄ±n verdiÄŸi iÃ§inle deÄŸeri aynÄ± olan iki farklÄ± 'string literal' nesneyi tek bir bellek alanÄ±nda tutabilir ya da ayrÄ± bellek alanlarÄ±nda tutabilir ve her zaman hangini yapacaÄŸÄ± kendine kalmÄ±ÅŸtÄ±r bazen bir yolu bazen de diÄŸer yolu seÃ§ebilir!
    if(p1 = p2) {
        printf("iki gosterici ayni adresi gosteriyor.\n");
    }
    else {
        printf("iki gosterici farkli adresi gosteriyor.\n");
    }
}
```



â—â—â— Deneyimsiz programcÄ±larÄ±n en sÄ±k yaptÄ±ÄŸÄ± hatalardan biri **otomatic storage duration** Ã¶zellikteki bir nesnenin adresinin bir fonksiyondan geriye dÃ¶ndÃ¼rÃ¼len adres deÄŸeri olmasÄ± durumudur. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki program yukarÄ±daki durumla ilgili olarak yazÄ±lmÄ±ÅŸ olan fonksiyonlar incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

char* getname(void)
{
    char str[40];

    printf("ad girin: ");
    scanf("%s", str);

    return str; // Burada otomatik Ã¶mÃ¼rlÃ¼ bir nesne adresi dÃ¶ndÃ¼rÃ¼lÃ¼yor ama bu nesnenin Ã¶mrÃ¼ bu fonksiyon bloÄŸunda son buluyor.
}


char* getname01(void)
{
    static char str[40];

    printf("ad girin: ");
    scanf("%s", str);

    return str; // Burada statik Ã¶mÃ¼rlÃ¼ bir nesne adresi dÃ¶ndÃ¼rÃ¼lÃ¼yor ve bir yanlÄ±ÅŸlÄ±k yoktur.
}

// Burada geriye dÃ¶ndÃ¼rÃ¼lenek deÄŸer 'output' argÃ¼man olarak fonksiyon Ã§aÄŸrÄ±sÄ±nÄ±n yapÄ±ldÄ±ÄŸÄ± yerden alÄ±nacaktÄ±r.
char* getname02(char* p)
{
    printf("ad girin: ");
    scanf("%s", p);

    return p; // Burada client kod tarafÄ±ndan fonksiyona geÃ§ilen nesne adresi dÃ¶ndÃ¼rÃ¼lÃ¼yor ve bir yanlÄ±ÅŸlÄ±k yoktur.
}


int main(void)
{
    char str[100];

    getname02(str);

    puts(str);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program yapÄ±labilecek olan bir hata tÃ¼rÃ¼ incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x; // Burada 'x' deÄŸiÅŸkeni Ã¶mrÃ¼me Ã§Ã¶p deÄŸer ile baÅŸlar ve bu deÄŸerin kullanÄ±lmasÄ± 'ub' durumuna neden olur.
    int* ptr = &x;

    int y = *ptr;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `restrict` parametreleri olan bir fonksiyona geÃ§ilen gÃ¶stericilerin **overlapped bellek bloklarÄ±na** sahip olmamasÄ± durumunun ihlalinin **ub** durumuna neden olacaÄŸÄ± gÃ¶rÃ¼lmelidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int main(void)
{
    char str[100] = "bennur";

    strcpy(str + 3, str); // Burada 'ub' oluÅŸur Ã§Ã¼nkÃ¼ 'strcpy' fonksiyonunun parametreleri 'restrict' olduÄŸu iÃ§in bellek alanlarÄ± kesiÅŸen diziler bu fonksiyona argÃ¼man olarak geÃ§ilmemelidir.
    puts(str);
}
```



â—â—â— C mÃ¼lakatlarÄ±nda sÄ±klÄ±kla sorulan bir soru aÅŸaÄŸÄ±daki gibidir. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda **object-like makro**'lar ile deÄŸiÅŸken tÃ¼rlerinin belirlenmesindeki kritik durum incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

#define IPTR    int*

int main(void)
{
    int x = 11;
    IPTR p1, p2; // Buradaki statement 'int* p1, p2;' ile ve 'int* p1; int p2;' ile denktir ve 'p1' bir 'int*' tÃ¼rÃ¼nden pointer ama 'p2' nesnesi 'int' tÃ¼rÃ¼nden bir deÄŸiÅŸkendir.

    p1 = &x;
    p2 = p1; // Buradaki atama iÅŸlemi 'ub' durumuna neden olur.
}
```



ğŸ‘‡ â—â—â— AÅŸaÄŸÄ±daki programda bir Ã¶nceki programdan farklÄ± olarak `typedef` olarak yaptÄ±ÄŸÄ±mÄ±z durumdaki farklÄ±lÄ±k Ã¶zÃ¼msenmelidir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

typedef IPTR    int*

int main(void)
{
    int x = 11;
    IPTR p1, p2; // Buradaki statement 'int* p1; int* p2;' ile denktir ve 'p1' ve 'p2' 'int*' tÃ¼rÃ¼nden pointer nesnedir.

    p1 = &x;
    p2 = p1; // Buradaki atama iÅŸlemi doÄŸrudur.
}
```



â—â—â— C mÃ¼lakatlarÄ±nÄ±n klasik sorularÄ±ndan biri aÅŸaÄŸÄ±daki gibidir. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda `typedef` olarak bildirilen bir tÃ¼rÃ¼n `const` ile kullanÄ±mÄ±ndaki detayÄ±n iyi bilinmesi gerekiyor.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

typedef IPTR    int*

int main(void)
{
    int x = 11;
    int y = 21;
    
    const IPTR ptr = &x; // Buradaki 'ptr' deÄŸiÅŸkeni 'low lavel const' deÄŸildir yani bu statement ÅŸuna 'const int* ptr = &x;' denk deÄŸildir, bu statement ÅŸuna 'int* const ptr = &x;' denktir.

    *ptr = 746; // Buradaki atama legal ve doÄŸrudur.
    ptr = &y; // Burada sÃ¶zdÃ¼zÃ¼m hatasÄ± alÄ±nÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **ub** durumuna neden olan Ã§Ã¶y deÄŸerdeki nenselerle iliÅŸkili durum incelenebilir, bu program bir Ã¶ÄŸrencinin sorusu Ã¼zerine yazÄ±lmÄ±ÅŸtÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

typedef IPTR    int*

int main(void)
{
    int x;

    int a = x; // Burada 'ub' vardÄ±r Ã§Ã¼nkÃ¼ 'x' nesnesi 'inditormenet value' deÄŸerdedir.

    int* ptr = &x; // Buradaki atama legaldir ama 'x' nesnesi Ã§Ã¶p deÄŸerde olduÄŸu iÃ§in 'ptr' nesnesinin gÃ¶sterdiÄŸi nesne olan 'x' nesnesinin deÄŸerine eriÅŸmek iÃ§in yazÄ±labilecek bir kod 'ub' durumuna nenden olur.
    int y = *ptr; // Burada 'ub' vardÄ±r, nedeni bir Ã¼st satÄ±rda aÃ§Ä±klanmÄ±ÅŸtÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program bellekten yer ayÄ±rmak iÃ§in kullanÄ±lan fonksiyonlardan `allocate_memory01` fonksiyonunun tasarÄ±mÄ± ve kullanÄ±mÄ± hatalÄ±, `allocate_memory02` fonksiyonunun tasarÄ±mÄ± ve kullanÄ±mÄ± doÄŸrudur.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include <stdlib.h>


void allocate_memory01(char* p, size_t n)
{
    p = (char*)malloc(n);
    if(!p) {
        printf("hata!\n");
        exit(EXIT_FAILURE);
    }
}


void allocate_memory02(char** p, size_t n)
{
    *p = (char*)malloc(n);
    if(!*p) {
        printf("hata!\n");
        exit(EXIT_FAILURE);
    }
}

int main(void)
{
    // Buradaki fonksiyon kullanÄ±mlarÄ±nda 'pointer to pointer' ile 'pointer' kullanÄ±mÄ± karÄ±ÅŸtÄ±rÄ±lmaktadÄ±r, bu hata durumuna Ã§ok sÄ±k rastlanmaktadÄ±r, bu ndenden dolayÄ± dikkat edilmelidir.
    char* ptr;

    allocate_memory01(ptr, 100);

    allocate_memory02(&ptr, 100);
    free(*ptr);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan **pointer** ve **pointer to pointer** kullanÄ±mÄ±n faarklarÄ±yla ilgili bilgiler incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include <stdlib.h>


void foo(int* p)
{
    // '*p' ifadesi ile 'x' nesnesine eriÅŸilir.

}

void bar(int** p)
{
    // '*p' ifadesi ile 'ptr' nesnesine eriÅŸilir.
    // '**p' ifadesi ile 'x' nesnesine eriÅŸilir.
}


int main(void)
{
    int x = 23;
    int* ptr = &x;

    // AÅŸaÄŸÄ±daki
    foo(ptr);
    bar(&ptr); 
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **dangling pointer** durumundan kaynaklanan ve Ã¼retimde sÄ±k karÅŸÄ±laÅŸÄ±labilecek hata tÃ¼rÃ¼ incelenebilir.
```C
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

typedef struct {
    char* mp_address;
    int m_id;
} Person;

int main()
{
    const char* pa1 = "Degirmen sok. No 17 Besiktas - Istanbul";
    //const char* pa2 = "sadegul sok. No 25 Kavaklidere - Ankara";
    Person per1;

    per1.mp_address = (char*)malloc(strlen(pa1) + 1);
    strcpy(per1.mp_address, pa1);
    per1.m_id = 43254;

    Person per2 = per1; // Buradaki 'struct' nesneleri arasÄ±nda yapÄ±lan atama iÅŸlemi 'shadow copy' olarak yapÄ±ldÄ±ÄŸÄ± iÃ§in bu yapÄ± nesnelerinin pointer Ã¼yelerinin sadece pointer deÄŸerleri kopyalanÄ±r bu da bu poÅŸnter nesnelerin belleki aynÄ± nesneyi gÃ¶sterdiÄŸi anlamÄ±na gelir.
    free(per1.mp_address); // Burada 'per1' nesnesindeki 'mp_address' Ã¼yesinin Ã¶mrÃ¼ sonlandÄ±rÄ±lÄ±yor.

    puts(per2.mp_address); // Burada 'ub' vardÄ±r Ã§Ã¼nkÃ¼ ilgili gÃ¶stericinin gÃ¶sterdiÄŸi nesne zaten yukarÄ±da 'free' iÅŸlemine tabi tutuldu.
    free(per2.mp_address); // Burada 'ub' vardÄ±r Ã§Ã¼nkÃ¼ ilgili gÃ¶stericinin gÃ¶sterdiÄŸi nesne zaten yukarÄ±da 'free' iÅŸlemine tabi tutuldu.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **shallow copy** yÃ¶nteminden dolayÄ± dosyalar Ã¼zerinden yapÄ±lan iÅŸlemlerde karÅŸÄ±laÅŸÄ±labilecek **dangling pointer** hata tÃ¼rÃ¼ incelenebilir.
```C
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

typedef struct {
    FILE* fp;
    // ...
} Info;


int main()
{
    Info inf1;

    // some code here ...

    inf1.fp = fopen("somefile.txt", "r");

    // some code here ...
    
    Info inf2 = inf1;

    // some code here ...
    
    fclose(inf1.fp);

    inf2.fp; // Burada 'inf2' gÃ¶stericisinin 'fp' Ã¼ye deÄŸiÅŸkeni 'dangling pointer' durumundadÄ±r Ã§Ã¼nkÃ¼ 'inf1.fp' nesnesi dosya kapatma iÅŸlemine tabi tutuldu ve 'inf1.fp' ve 'inf2.fp' aynÄ± dosya nesnesini gÃ¶steriyordu.
}
```

â—â—â— EÄŸer bir yapÄ± nesnesine baÅŸka bir yapÄ± nesnesi atanÄ±yorsa bu atama iÅŸleminde yapÄ±larÄ±n Ã¼yeleri birbirine kopyalanÄ±r ama gÃ¶sterici tÃ¼rÃ¼nden nesnelerde sadece adres deÄŸerleri kopyalanÄ±r, buradaki kopyalama **shallow copy** biÃ§imindeki kopyalamadÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki hata incelenebilir.
```C
//dynamic memory mistakes

#include <stdlib.h>
#include <stdio.h>

int main(void)
{
    char str[] = "necati ergin";
    char* p = str;
    //...
    puts(p);
    free(p); // 'free' fonksiyonu sadece dinamik olarak elde edilen bellek bloklarÄ±nÄ± geri vermek iÃ§in kullanÄ±lailir ama burada 'free' fonksiyonuna otomatik Ã¶mÃ¼rlÃ¼ bir nesne veriliyor.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program `free` fonksiyonuna argÃ¼man olarak **NULL pointer** geÃ§ilmesinin Ã¶zel bir durum olduÄŸunun ve bu iÅŸlemin yapÄ±labileceÄŸinin anlaÅŸÄ±lmasÄ± iÃ§in incelenebilir.
```C
//dynamic memory mistakes

#include <stdlib.h>
#include <stdio.h>

int main(void)
{
    char str[] = "necati ergin";
    char* p = str;
    //...
    puts(p);
    p = NULL;
    free(p); // Buradaki kullanÄ±mda bir hata ya da yanlÄ±ÅŸlÄ±k yoktur.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `malloc` fonksiyonuyla bellekten bir yazÄ±yÄ± kopyalamak iÃ§in yer ayrÄ±lÄ±rken yazÄ±nÄ±n dizi sonu karakteri hesaba kayÄ±lmadÄ±ÄŸÄ± iÃ§in oluÅŸacak **ub** durumu incelenebilir.
```C
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
    char str[] = "man plans and god laughs";

    char* pd = (char*)malloc(strlen(str)); // Burada yazÄ±nÄ±n sonu '\0' karakteri hesaba katÄ±lmÄ±yor.

    // some code here ...

    strcpy(pd, str); // Burada 'ub' vardÄ±r Ã§Ã¼nkÃ¼ kaynak yazÄ± kopyalamanÄ±n yapÄ±ldÄ±ÄŸÄ± hedef yazÄ±dan daha bÃ¼yÃ¼k. 

    puts(pd);
    free(pd);
}
```



C mÃ¼lakatlarÄ±nda sorulmuÅŸ bir soru aÅŸaÄŸÄ±daki gibidir. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki dinamik bellek alanlarÄ±nÄ± gÃ¶steren gÃ¶stericilerden hangileri  `a` dizisinin kopyalanabileceÄŸi kadar geniÅŸ bir bellek alanÄ±na sahiptir?
```C
#include <stdlib.h>

int main(void)
{
    int a[10] = { 1, 2, 5, 7, 9, 3, 9, 12, 4, 6 };
    int* p = a;
    int(*pa)[10] = &a;

    // AÅŸaÄŸÄ±daki bellek ayÄ±rmalarÄ±ndan elde edilen bellek alanlarÄ±ndan hangilerine 'a' dizisi kopyalanabilir ve hangilerine kopyalanamaz.
    int* p1 = (int*)malloc(sizeof(p)); // 'sizeof(p)' ifadesinde 'p' bir gÃ¶sterici nesne olduÄŸundan dolayÄ± bellek boyutu 32 bit mimaride '4', 64 bit mimaride '8' olur ama bize en az '10 * sizeof(int)' kadarlÄ±k bellek alanÄ± gerekiyor!
    int* p2 = (int*)malloc(sizeof(*p)); // 'sizeof(*p)' ifadesinde '*p' ifadesinin tÃ¼rÃ¼ 'int' tÃ¼rÃ¼ olduÄŸu iÃ§in gerekli olan en az '10 * sizeof(int)' kadarlÄ±k bellek alanÄ±nÄ± karÅŸÄ±layamaz.
    int* p3 = (int*)malloc(sizeof(a)); // 'sizeof(a)' ifadesinde 'array to pointer conversion' uygulanmaz ve 'p3' gÃ¶stericisinin gÃ¶sterdiÄŸi bellek alanÄ± tam olarak '10 * sizeof(int)' kadardÄ±r.
    int* p4 = (int*)malloc(sizeof(pa)); // 'sizeof(pa)' ifadesinde 'pa' bir pointer olduÄŸu iÃ§in sadece programÄ±n Ã§alÄ±ÅŸacaÄŸÄ± sistemdeki tek bir pointer'Ä±n 'sizeof' deÄŸeri kadarlÄ±k bir yer kaplayacaÄŸÄ± iÃ§in gerekli olan en az '10 * sizeof(int)' kadarlÄ±k bellek alanÄ±nÄ± karÅŸÄ±layamaz. 
    int* p5 = (int*)malloc(sizeof(*pa)); // 'sizeof(*pa)' ifadesinde '*pa' bir 10 elemanlÄ± 'int' dizisini gÃ¶stermektedir bu nedenden dolayÄ± 'array to pointer conversion' uygulanmaz ve gerekli olan en az '10 * sizeof(int)' kadarlÄ±k bellek alanÄ±nÄ± karÅŸÄ±lar.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki **memory leak** hatasÄ± durumu incelenebilir ama burada **ub** yoktur.
```C
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
    //...
    size_t n = (rand() % 100 + 5) * 16;
    int* p = (int*)malloc(sizeof(int));
    //...
    if (!p) {
        printf("cannot allocate memory!");
        return 1;
    }
    //...
    int x = 20;
    p = &x;
    //...

    // 'p' gÃ¶stericisiyle iÅŸlem bittikten sonra 'p' nesnesinin gÃ¶sterdiÄŸi dinamik bellek alanÄ±nÄ±n geri iade edilmesi gerekiyor.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki **dangling pointer** hatasÄ± durumu incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    size_t n;
    printf("enter the size of the array: ");
    (void)scanf("%zu", &n);

    int* pd = (int*)malloc(n * sizeof(int)); // Burada dinamik bir bellek alanÄ± ayrÄ±lÄ±yor.
    if (!pd) {
        printf(stdern, "cannot allocate memory: ");
        return 1;
    }

    int* p = pd; // dinamik bellek alanÄ±nÄ± gÃ¶steren pointer adresi 'p' gÃ¶stericisine de kopyalanÄ±yor, iki gÃ¶sterici d eaynÄ± bellek alanÄ±nÄ± gÃ¶steriyor ÅŸu anda.
    memset(pd, 0, n * sizeof(int));
    //...
    free(pd); // Buradan sonra aynÄ± bellek bloklarÄ±nÄ± gÃ¶sterdikleri iÃ§in 'p' gÃ¶stericisi 'dangling pointer' durumuna dÃ¼ÅŸer.
    //...
    free(p);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki **dangling pointer** hatasÄ± durumu incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    size_t n;
    printf("enter the size of the array: ");
    (void)scanf("%zu", &n);

    int* pd = (int*)malloc(n * sizeof(int));
    if (!pd) {
        printf(stderr, "cannot allocate memory: ");
        return 1;
    }

    memset(pd, Î¸, n * sizeof(int));
    //...
    free(pd);

    int x = *pd; // Burada 'dangling pointer' hatasÄ± vardÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki **memory leak** hatasÄ± durumu incelenebilir, buradaki gibi hatalarla sÄ±klÄ±kla karÅŸÄ±laÅŸÄ±lmaktadÄ±r.
```C
#include <stdio.h>
#include <string.h>

int icmp(const void* vp1, const void* vp2)
{
    int i1 = *(const int*)vp1;
    int i2 = *(const int*)vp2;

    return i1 > i2 ? 1 :
        i1 < i2 ? -1 : 0;
}

int get_median(const int* p, size_t size)
{
    int* pd = (int*)malloc(size * sizeof(int)); // Burada dinamik olarak bellek bloÄŸu ediniliyor.
    //...
    memcpy(pd, p, size * sizeof(int));
    qsort(pd, size, sizeof(*pd), &icmp);

    // Burada 'pd' iÃ§in 'free' fonksiyonu Ã§aÄŸrÄ±sÄ± yapÄ±lmasÄ± gerekiyor, yoksa 'memory leak' oluÅŸur.

    return pd[size / 2];
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 20.43-21.04 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


## Dinamik Dizi Veri YapÄ±sÄ± GerÃ§ekleÅŸtirimi(Daynamic Array Data Structure Implementation) ğŸŒŸ

Daha Ã¶nce **dinamik dizi** veri yapÄ±sÄ±ndan bahsedilmiÅŸti ve en Ã§ok kullanÄ±lan veri yapÄ±sÄ± olduÄŸu belirtilmiÅŸti. </br>
Bu veri yapÄ±sÄ±nÄ±n bellek geniÅŸli tamamen dolduktan sonra yeni bir eleman ekleneceÄŸi zaman bellekten yeni bir blok ayrÄ±lÄ±p(**reallocation**) tÃ¼m veri o yeni bellek bloÄŸuna taÅŸÄ±nÄ±r. </br>
Bu veri yapÄ±sÄ±nda sondan yapÄ±lan ekleme ve silme iÅŸlemleri "**Amortised constand time**" zaman almaktadÄ±r, sondan olmayan noktalardan yapÄ±lan ekleme ve silme iÅŸlemleri doÄŸrusal karmaÅŸÄ±klÄ±ktadÄ±r($O(n)$).

C dilindeki yapÄ±lacak **dinamik dizi** gerÃ§ekleÅŸtiriminde dizide ne tutulacaÄŸÄ±na baÄŸlÄ± olarak kodun bazÄ± yerlerinin deÄŸiÅŸmesi gerekmesinden kaynaklanan bir sorun vardÄ±, bu deÄŸiÅŸikliÄŸin nasÄ±l yapÄ±lacaÄŸÄ±na sonradan deÄŸinilecektir.


```Text

Bir dinamik diziyi modelleyebilmek iÃ§in, en az Ã¼Ã§ tane bilginin tutulmasÄ± gerekiyor;
1. Dinamik dizinin baÅŸlangÄ±Ã§ adresi.
2. Dizinin son elemanÄ±nÄ±n adres bilgisi ya da dizinin eleman sayÄ±sÄ±nÄ± tutan bir tam sayÄ± deÄŸeri. (Sondan ekleme yapÄ±lacaÄŸÄ± iÃ§in bu bilgi gerekli oluyor)
3. Dizinin en fazla alabileceÄŸi eleman sayÄ±sÄ± deÄŸeri(dizinin eriÅŸebileceÄŸi o anki en yÃ¼ksek eleman sayÄ±sÄ± deÄŸeri)

Temsili Bellek GÃ¶rÃ¼nÃ¼mÃ¼
+--------------------+ 
| Dinamik dizi adresi|  >>>>>>----------------> Dinamik dizinin baÅŸlangÄ±Ã§ adresi.
+--------------------+ 
+--------------------+ 
| Veriyle dolu       |
+--------------------+ 
+--------------------+ 
| Veriyle dolu       |
+--------------------+ 
+--------------------+ 
| Veriyle dolu       |
+--------------------+ 
+--------------------+ 
| Veriyle dolu       |
+--------------------+
+--------------------+ 
| Veriyle dolu       |  >>>>>>----------------> Dinamik dizinin en son elemanÄ±nÄ±n adresi.
+--------------------+ 
+--------------------+ 
|                    |
+--------------------+ 
+--------------------+ 
|                    |
+--------------------+ 
+--------------------+ 
|                    |  >>>>>>----------------> Dinamik dizinin o anki eleman yerleÅŸtirilebilecen en son adres deÄŸeri, dinamik dizinin azami bÃ¼yÃ¼ye bileceÄŸi konum.
+--------------------+ 
+--------------------+ 
|                    |
+--------------------+  

```


âœï¸ Burada `nvector.h` kÃ¼tÃ¼phanesini aÅŸaÄŸÄ±daki gibi ekliyoruz, C++ kÃ¼tÃ¼phanesindeki vector sÄ±nÄ±fÄ±na benzer bir gerÃ§ekleÅŸtirim yapÄ±lmÄ±ÅŸtÄ±r.
```C
// YazÄ±lan 'nvector.h' dosyasÄ±na eklenenler.

#pragma once
// #ifndef NVECTOR_H
// #define NVECTOR_H

#include <stddef.h> // Ä°lk baÅŸta 'size_t' tÃ¼rÃ¼nÃ¼ kullanabilmek iÃ§in eklendi.
#include <stdbool.h> // 'bool', 'true', 'false' gibi object-like makrolarÄ± kullanabilmek iÃ§in eklenmiÅŸtir.

#define NOT_FOUND           ((size_t)(-1))
#define DEFAULT_CAPACITY    16 // Dinamik dizinin baÅŸlangÄ±Ã§ azami eleman sayÄ±sÄ± deÄŸeri.


/* FUNCTUONAL MACROS START*/

#define get_element(hvec, idx)      (hvec->mp[idx])

/* FUNCTUONAL MACROS END */


typedef int DATATYPE;
typedef int(*VALUECOMPARE)(const DATATYPE*, const DATATYPE*);


typedef struct  {
    DATATYPE* mp; // AyrÄ±lacak(allocate) bellek alanÄ± adresi.
    size_t msize; // Dinamik dizide bulunan o anki eleman sayÄ±sÄ±. 
    size_t mcap; // Dinamik dizinin o anki eriÅŸebileceÄŸi en yÃ¼ksek eleman sayÄ±sÄ±.
} Vector, *HVector;


// Dinamik dizinin eleman sayÄ±sÄ±nÄ± geriye dÃ¶ndÃ¼ren static fonksiyon.
static inline size_t get_size(HVector h)
{
    return h->msize;
}

// Dinamik dizinin eriÅŸebileceÄŸi en yÃ¼ksek eleman sayÄ±sÄ±nÄ± geriye dÃ¶ndÃ¼ren static fonksiyon.
static inline size_t get_capacity(HVector h)
{
    return h->mcap;
}

static bool is_empty(HVector h)
{
    // return h->mp == NULL;
    return h->msize ==0;
}


// Dinamik diziyi kullanmak iÃ§in faydalanÄ±lacak olan .
HVector create_vector(void);
HVector create_vector_with_capacity(size_t cap);
HVector create_vector_from_array(const DATATYPE* pa, size_t size);
HVector create_vector_filled(size_t size, DATATYPE value);

void destroy_vector(HVector);

bool reserve(HVector h, size_t newcap);
bool push_back(HVector h, DATATYPE value);
bool pop_back(HVector);
bool insert(HVector h, size_t idx, DATATYPE value); // Dinamik diziye aradan eleman eklemek iÃ§in kullanÄ±lan fonksiyon.
bool erase(HVector h, size_t idx); // Dinamik dizinin herhangi bir elemanÄ±nÄ± silmek iÃ§in kullanÄ±lacak olan fonksiyon.
bool erase_first(HVector h, DATATYPE value, VALUECOMPARE fp); // Beliri bir deÄŸere sahip ilk Ã¶ÄŸeyi silen fonksiyon.
size_t erase_all(HVector h, DATATYPE value); // Beliri bir deÄŸere sahip tÃ¼m Ã¶ÄŸeleri silen fonksiyon, geriye silinen Ã¶ÄŸe sayÄ±sÄ±nÄ± dÃ¶ndÃ¼rÃ¼r.
size_t find(HVector h, DATATYPE value, VALUECOMPARE); // Beliri bir deÄŸere sahip olan elemanÄ± dizide aramak iÃ§in kullanÄ±lan fonksiyon, aranan deÄŸer bulunursa indeks deÄŸeri dÃ¶ndÃ¼rÃ¼lÃ¼r bulunamazsa iÅŸaretsiz bir tam sayÄ± tÃ¼rÃ¼nÃ¼n en bÃ¼yÃ¼k deÄŸeri dÃ¶ndÃ¼rÃ¼lÃ¼r.
// size_t find(HVector h, DATATYPE value, int(*fp)(const DATATYPE*, const DATATYPE*)); // Beliri bir deÄŸere sahip olan elemanÄ± dizide aramak iÃ§in kullanÄ±lan fonksiyon, aranan deÄŸer bulunursa indeks deÄŸeri dÃ¶ndÃ¼rÃ¼lÃ¼r bulunamazsa iÅŸaretsiz bir tam sayÄ± tÃ¼rÃ¼nÃ¼n en bÃ¼yÃ¼k deÄŸeri dÃ¶ndÃ¼rÃ¼lÃ¼r.
void shring_to_fit(HVector); // Dinamik dizinin eriÅŸebileceÄŸi en yÃ¼ksek eleman sayÄ±sÄ±nÄ± dÃ¼ÅŸÃ¼rmek iÃ§in kullanÄ±lan fonksiyon.
void clear(HVector); // Dinamik dizinin tÃ¼m elemanlarÄ±nÄ± silmek ve diziyi boÅŸaltmak iÃ§in kullanÄ±lan fonksiyon.

// #endif
```



âœï¸ Burada `nvector.c` kÃ¼tÃ¼phanesini aÅŸaÄŸÄ±daki gibi ekliyoruz, C++ kÃ¼tÃ¼phanesindeki vector sÄ±nÄ±fÄ±na benzer bir gerÃ§ekleÅŸtirim yapÄ±lmÄ±ÅŸtÄ±r.
```C
#include "nvector.h"
#include <stdlib.h> // Ä°lk Ã¶nce 'malloc' fonksiyonunu kullanabilmek iÃ§in eklenmiÅŸtir.
#include <stdio.h> 
#include <string.h> // Ä°lk Ã¶nce 'memmove' fonksiyonunu kullanabilmek iÃ§in eklenmiÅŸtir.

HVector create_vector_with_capacity(size_t cap)
{
    HVector h = (HVector)malloc(sizeof(Vector));
    if(!h) {
        fprintf(stderr, "cannot allocate memory!\n"); // DEBUG

        return h;
        // return NULL; // YukarÄ±daki statement ile aynÄ±dÄ±r.
    }

    h->msize = 0;
    h->mcap = cap;

    h->mp = (DATATYPE*)molloc(cap * sizeof(DATATYPE));
    if(!h->mcap) {
        fprintf(stderr, "cannot allocate memory!\n"); // DEBUG
        free(h);
        return NULL;
    }

    return h;
}



HVector create_vector(void)
{
    return create_vector_with_capacity(DEFAULT_CAPACITY);
}



HVector create_vector_from_array(const DATATYPE* pa, size_t size)
{
    HVector h = create_vector_with_capacity(size);
    if(!h) {
        return NULL;
    }

    memmove(h->mp, pa, size * sizeof(DATATYPE));

    h->msize = size;

    return h;
}



HVector create_vector_filled(size_t size, DATATYPE value)
{
    HVector h = create_vector_with_capacity(size);
    if(!h) {
        return NULL;
    }

    h->msize = size;

    for(size_t i = 0; i < size; ++i) {
        h->mp[i] = value;
    }

    return h;
}


bool reserve(HVector h, size_t newcap)
{
    if(newcap < h->mcap)
        return false;

    if(newcap == h->mcap)
        return true;

    DATATYPE* pd = (DATATYPE*)realloc(h->mp, newsize * sizeof(DATATYPE));
    if(!pd) {
        fprintf(stderr, "cannot reserve capacity\n"); // DEBUG
        return false;
    }

    h->mp = pd;
    h->mcap = newcap;

    return true;
}


// Sona ekleme iÅŸlemini yapan fonksiyon. 
bool push_back(HVector h, DATATYPE value)
{
    if(k->cap == h->msize && !reserve(h, h->mcap * 2)) {
        fprintf(stderr, "cannot allocate capacity\n"); // DEBUG
        return false;
    }

    h->mp[h->msize] = value;
    ++(h->msize); // '++h->msize;' ile aynÄ±dÄ±r ama okunmayÄ± kolaylaÅŸtÄ±rmak iÃ§in Ã¶ncelik parantezi kullanÄ±labiliyor bu gibi durumlarda.

    return true;
}

// Sondan silme iÅŸlemini yapan fonksiyon. 
bool pop_back(HVector)
{
    // GerÃ§ekten bir silme iÅŸlemi yapÄ±lmÄ±yor, sadece dizideki eleman sayÄ±sÄ± bir azaltÄ±lÄ±yor.
    if(h->msize > 0) {
        --h->msize;
        return true;
    }

    return false;
}


// Dinamik diziye aradan eleman eklemek iÃ§in kullanÄ±lan fonksiyon. 
bool insert(HVector h, size_t idx, DATATYPE value)
{
    // Araya Ã¶ÄŸe ekleme iÅŸleminde dizinin Ã¶ÄŸerelerinin bir Ã¶telenmesi gerekecek.

    if(idx > h->msize)
        return false;

    if(k->cap == h->msize && !reserve(h, h->mcap * 2)) {
        fprintf(stderr, "cannot allocate capacity\n"); // DEBUG
        return false;
    }

    memmove(h->mp + idx + 1, h->mp + idx, (h->msize - idx) * sieof(DATATYPE)); // Burada dinamik dizinin Ã¶ÄŸeleri bir ileri Ã¶teleniyor.
    h->mp[idx] = value;
    ++h->msize; // Araya Ã¶ÄŸe ekleme iÅŸlemi sonrasÄ±nda dizinin sahip olduÄŸu eleman sayÄ±sÄ± bir arttÄ±rÄ±lÄ±yor.

    return true;
}


// Dinamik dizinin herhangi bir elemanÄ±nÄ± silmek iÃ§in kullanÄ±lacak olan fonksiyon. 
bool erase(HVector h, size_t idx)
{
    if(idx >= h->msize) {
        return false;
    }

    memmove(h->mp + idx, h->mp  + idx + 1, (h->msize - idx - 1) * sizeof(DATATYPE)); // Burada dinamik dizinin Ã¶ÄŸeleri bir geri Ã¶teleniyor.

    --h->msize;
}

// Beliri bir deÄŸere sahip olan elemanÄ± dizide aramak iÃ§in kullanÄ±lan fonksiyon, aranan deÄŸer bulunursa indeks deÄŸeri dÃ¶ndÃ¼rÃ¼lÃ¼r bulunamazsa iÅŸaretsiz bir tam sayÄ± tÃ¼rÃ¼nÃ¼n en bÃ¼yÃ¼k deÄŸeri dÃ¶ndÃ¼rÃ¼lÃ¼r. 
size_t find(HVector h, DATATYPE value, VALUECOMPARE fp)
{
    for(size_t i = 0; i < h->msize; ++i) {
        // Buradaki karÅŸÄ±laÅŸtÄ±rma sadece primitive tÃ¼rler iÃ§in geÃ§erlidir, 'complex type' deÄŸiÅŸkenler iÃ§in uygun bir karÅŸÄ±laÅŸtÄ±rma yÃ¶ntemi deÄŸildir.
        // if(h->mp[i] == value) {
        // }

        if(fp(h->mp[i], &value) == 0) {
            return i;
        }
    }

    return NOT_FOUND;
} 

// Beliri bir deÄŸere sahip ilk Ã¶ÄŸeyi silen fonksiyon. 
bool erase_first(HVector h, DATATYPE value, VALUECOMPARE fp)
{
    size_t idx = find(h, value, fp);
    if(idx != NOT_FOUND) {
        erase(h, idx);
        return true;
    }

    return false;
}

// Dinamik dizinin eriÅŸebileceÄŸi en yÃ¼ksek eleman sayÄ±sÄ±nÄ± dÃ¼ÅŸÃ¼rmek iÃ§in kullanÄ±lan fonksiyon. 
void shring_to_fit(HVector h)
{
    h->mp = (DATATYPE*)realloc(h->mp, h->msize * sizeof(DATATYPE)); // Dinemik dizinin bellketeki boyutu gÃ¼ncellendi ve ilk adresi yapÄ±nÄ±n 'mp' Ã¼yesine atandÄ±.
    h->mcap = msize; // Dinamik dizinin eriÅŸebileceÄŸi en bÃ¼yÃ¼k eleman sayÄ±sÄ± o andaki elemen sayÄ±sÄ± olarak belirleniyor.
}

// Ä°lgili dinamik diziyi bellekten silen fonksiyon. 
void destroy_vector(HVector)
{
    free(h->mp);
    free(h);
}

// Dinamik dizinin tÃ¼m elemanlarÄ±nÄ± silmek ve diziyi boÅŸaltmak iÃ§in kullanÄ±lan fonksiyon. 
void clear(HVector h)
{
    h->msize = 0;
}


size_t erase_all(HVector h, DATATYPE value); // Beliri bir deÄŸere sahip tÃ¼m Ã¶ÄŸeleri silen fonksiyon, geriye silinen Ã¶ÄŸe sayÄ±sÄ±nÄ± dÃ¶ndÃ¼rÃ¼r.
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda yazdÄ±ÄŸÄ±mÄ±z dinamik dizinin ilk sÄ±nama programÄ± incelenebilir. 
```C
#include <nvector.h>
#include <nutikity.h>
#include <stdio.h>

void print_test(HVector h)
{
    printf("size     = %zu\n", get_size(h));
    printf("capacity = %zu\n", get_capacity(h));

    if(is_empty(h)) {
        printf("[]");
        return;
    }

    printf("[");
    for(size_t i = 0; i < get_size(h) - 1; ++i) {
        printf("%d, ", get_element(h, i))
    }
    printf("%d]\n", get_element(h, get_size(h) - 1));
}

int main(void)
{
    HVector handle = create_vector();

    print_test(handle);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda yazdÄ±ÄŸÄ±mÄ±z dinamik dizinin ikinci sÄ±nama programÄ± incelenebilir. 
```C
#include <nvector.h>
#include <nutikity.h>
#include <stdio.h>

void print_test(HVector h)
{
    printf("size     = %zu\n", get_size(h));
    printf("capacity = %zu\n", get_capacity(h));

    if(is_empty(h)) {
        printf("[]");
        return;
    }

    printf("[");
    for(size_t i = 0; i < get_size(h) - 1; ++i) {
        printf("%d, ", get_element(h, i))
    }
    printf("%d]\n", get_element(h, get_size(h) - 1));
}

int main(void)
{
    HVector h = create_vector();


    for(int i = 0; i < h->mcap; ++i) {
        push_back(h, i);
    }

    print_test(h);
    push_back(h, 737);

    printf("\n~~~~~~~~~~~~~\n");

    print_test(h);
}
```


Ders sonu ...
