# 50.Ders 13.07.2025 🕘

Derse 6(09:01)-7(09:04)-8(09:21)-10(10:02)-11(10:55)-11(11:35)-10(12:41) kişi katıldı.
---

📌 Kursun tamamlanması için en az 16 saat ilave ders eklenmesi gerektiği belirtildi.

📌 Microsoft derleyicisinde `#pragma pack(1)` makrosu **pedding bytes** kullanılmaması için kullanılıyor.


## `offsetof` Function Like Makro 

Bu fonksiyonel makro `stddef.h` başlık dosyasında bulunmaktadır ve C99 standardı ile dile eklenmiştir. </br>
`offsetof` makrosunun ürettiği değer `size_t` türündendir. </br>
`offsetof` makrosunun bir türün öyelerinin bellek adreslerinin türün başlangıç adresini referans alarak türün başlangıç adresinden kaç byte sonra bulunduğu bilgisini `size_t` türünden geriye dönmektedir.


`offsetof` makrosunu iyi bilmek hem dile hakimiyet açısından önemli hem de profesyonel C mülakatlarında bu makronun **gerçekleştiriminin(implementation)** yapılması isteniyor, mülakatlarda bunun istenmesinin nedeni C diline hakimiyeti ölçmektir.


👇 Aşağıdaki programda `offsetof` fonkisyonel makrosunun nasıl kullanıldığı incelenebilir.
```C
#include <stddef.h> // Standart kütüphenedeki en sade başlık dosyasıdır.
#include <stdio.h>

typedef struct Data {
    char c1;
    int i;
    char c2;
    char c3;
} Data;

int main(void)
{
    printf("offsetof c1 = %zu\n", offsetof(struct Data, c1));
    printf("offsetof i = %zu\n", offsetof(struct Data, i));
    printf("offsetof c2 = %zu\n", offsetof(struct Data, c2));
    printf("offsetof c3 = %zu\n", offsetof(struct Data, c3));

    Data data1 = { 19, 4423423, 54, 76};
    char* p = (char*)&data1;

    // 'offsetof' makrosunun doğru çalıştığını görmek için aşağıdaki sınama kodlarını yazdık.
    printf("c1 = %d", *(p + offsetof(struct Data, c1)));
    printf("i = %d", *(int*)(p + offsetof(struct Data, i)));
    printf("c2 = %d", *(p + offsetof(struct Data, c2)));
    printf("c3 = %d", *(p + offsetof(struct Data, c3)));
}
```



👇 Aşağıdaki programda standart olan `offsetof` maktosunun gerçekleştiriminin `OFFSETOF` adında yapıldığı incelenebilir, `OFFSETOF` gerçekleştirimini anlamak zor olabilir bu nedenden dolayı ayrıca inceleme yapmak gerekebilir. 
```C
#include <stddef.h> // Standart kütüphenedeki en sade başlık dosyasıdır.
#include <stdio.h>

#define OFFSETOF(S, M)      (size_t)(&((S *)0)->m) // Mülakatlarda buradaki gibi 'offsetof' makrosunun yaptığı işi yapan 'OFFSETOF' makrosu gibi bir tanımlamanın yapılması istenebilir ve burada neden 'ub' olmadığı sorulacaktır.

typedef struct Data {
    char c1;
    int i;
    char c2;
    char c3;
} Data;

int main(void)
{
    printf("OFFSETOF c1 = %zu\n", OFFSETOF(struct Data, c1));
    printf("OFFSETOF i = %zu\n", OFFSETOF(struct Data, i));
    printf("OFFSETOF c2 = %zu\n", OFFSETOF(struct Data, c2));
    printf("OFFSETOF c3 = %zu\n", OFFSETOF(struct Data, c3));

    Data data1 = { 19, 4423423, 54, 76};
    char* p = (char*)&data1;

    // 'OFFSETOF' makrosunun doğru çalıştığını görmek için aşağıdaki sınama kodlarını yazdık.
    printf("c1 = %d", *(p + OFFSETOF(struct Data, c1)));
    printf("i = %d", *(int*)(p + OFFSETOF(struct Data, i)));
    printf("c2 = %d", *(p + OFFSETOF(struct Data, c2)));
    printf("c3 = %d", *(p + OFFSETOF(struct Data, c3)));
}
```


## Unions(Birlikler) 

Yapı bildirimleriyle bir kaç farklılık dışında aynıdır. Yapılar ve birlikler aradaki tek fark **memory layout** kısmındadır, yapı nesneleri bellekte elemanlarının toplan bellek alanı kadar(**paddin bytes** dahil) yer kaplarken bir birlik nesnesi bellekte sadece en büyük bellek alanına sahip olan üyesi kadar yer kaplar.


👇 Aşağıdaki programda yapı türü ve birlik türlerinin bildirimi incelenebilir.
```C
#include <stddef.h>
#include <stdio.h>

struct SData {
    char c1;
    int i;
    char c2;
    char c3;
};

union UData {
    char c1;
    int i;
    char c2;
    char c3;
};
```



👇 Aşağıdaki programda yapı türü ve birlik türlerinin bildirimi ve birlik kullanımı incelenebilir.
```C
#include <stddef.h>
#include <stdio.h>

typedef struct SData {
    double d;
    int i;
    char c2;
    char c3;
}SData;

typedef union UData {
    double d;
    int i;
    char c2;
    char c3;
}UData;


int main(void)
{
    UData data1;

    // Birlik türünden bir nesnesin 
    data1.d = 3.2423;
    data1.c1 = 23;
    UData* p = &data1;

    p.c2 = 4;
}
```



👇 Aşağıdaki programda yapı nesnelerinin ve birlik nesnelerinin bellekte ne kadar yer kapladıkları incelenebilir.
```C
#include <stddef.h>
#include <stdio.h>


typedef struct SData1 {
    int i;
}SData1;

typedef union UData1 {
    int i;
}UData1;


typedef struct SData2 {
    int x, y;
}SData2;

typedef union UData2 {
    int x, y;
}UData2;


typedef struct SData3 {
    int x, y, z;
}SData3;

typedef union UData3 {
    int x, y, z;
}UData3;


typedef struct SData4 {
    int x, y, z;
    double dval;
}SData4;

typedef union UData4 {
    int x, y, z;
    double dval;
}UData4;


typedef struct SData5 {
    int x, y, z;
    double d1, d2;
}SData5;

typedef union UData5 {
    int x, y, z;
    double d1, d2;
}UData5;


typedef struct SData6 {
    int x, y, z;
    double d1, d2;
    char str[12];
}SData6;

typedef union UData6 {
    int x, y, z;
    double d1, d2;
    char str[12];
}UData6;


int main(void)
{
    printf("sizeof(SData1) = %zu\n", sizeof(SData1)); // 'int' türü 4 byte olan sistemde standart çıktı akımına 'sizeof(SData1) = 4\n' değeri gönderilir.
    printf("sizeof(UData1) = %zu\n", sizeof(UData1)); // 'int' türü 4 byte olan sistemde standart çıktı akımına 'sizeof(UData1) = 4\n' değeri gönderilir.

    printf("sizeof(SData2) = %zu\n", sizeof(SData2)); // 'int' türü 4 byte olan sistemde standart çıktı akımına 'sizeof(SData2) = 8\n' değeri gönderilir.
    printf("sizeof(UData2) = %zu\n", sizeof(UData2)); // 'int' türü 4 byte olan sistemde standart çıktı akımına 'sizeof(UData2) = 4\n' değeri gönderilir.

    printf("sizeof(SData3) = %zu\n", sizeof(SData3)); // 'int' türü 4 byte olan sistemde standart çıktı akımına 'sizeof(SData3) = 12\n' değeri gönderilir.
    printf("sizeof(UData3) = %zu\n", sizeof(UData3)); // 'int' türü 4 byte olan sistemde standart çıktı akımına 'sizeof(UData3) = 4\n' değeri gönderilir.

    printf("sizeof(SData4) = %zu\n", sizeof(SData4)); // 'int' türü 4 byte ve 'double' türü 8 byte olan sistemde standart çıktı akımına 'sizeof(SData4) = 24\n' değeri gönderilir. Burada yapının bellek boyutunun '20' yerine '24' olmasının nedeni geçen derste incelenen 'alignment requirement' değerinin '8' olmasıdır. 
    printf("sizeof(UData4) = %zu\n", sizeof(UData4)); // 'int' türü 4 byte ve 'double' türü 8 byte olan sistemde standart çıktı akımına 'sizeof(UData4) = 8\n' değeri gönderilir.

    printf("sizeof(SData5) = %zu\n", sizeof(SData5)); // 'int' türü 4 byte ve 'double' türü 8 byte olan sistemde standart çıktı akımına 'sizeof(SData5) = 32\n' değeri gönderilir. Burada yapının bellek boyutunun '28' yerine '32' olmasının nedeni geçen derste incelenen 'alignment requirement' değerinin '8' olmasıdır. 
    printf("sizeof(UData5) = %zu\n", sizeof(UData5)); // 'int' türü 4 byte ve 'double' türü 8 byte olan sistemde standart çıktı akımına 'sizeof(UData5) = 8\n' değeri gönderilir.

    printf("sizeof(SData6) = %zu\n", sizeof(SData6)); // 'int' türü 4 byte ve 'double' türü 8 byte olan sistemde standart çıktı akımına 'sizeof(SData6) = 48\n' değeri gönderilir. Burada yapının bellek boyutunun '40' yerine '48' olmasının nedeni geçen derste incelenen 'alignment requirement' değerinin '8' olmasıdır. 
    printf("sizeof(UData6) = %zu\n", sizeof(UData6)); // 'int' türü 4 byte ve 'double' türü 8 byte olan sistemde standart çıktı akımına 'sizeof(UData6) = 16\n' değeri gönderilir çünkü birliğin bellekte en hazla yer kaplayan 'str[12]' üyesinin bellek büyüklüğü '12'dir ama birliğin 'alignment requirement' değerinin '8' olduğu için varsayılan durumda bellekten yer 8 byte'lık dilimler halinde ayrılmaktadır.
}
```


❗❗❗ 👆 Yukarıdaki programdan da görülebileceği gibi yapılarda her üye bellekte farklı yerde tutulur ama birliklerde tüm üyeler aynı bellek bloğunda tutulurlar.



👇 Aşağıdaki programda `union UData` türünden olan bir birlik türünün nesnelerinin bellekte kaplayacakları alanın kendi üyelerinden en büyük bellek boyutuna sahip üyenin bellek boyutu olduğu ve birliğin her üyesinin bellek boyutunun aynı olduğu incelenebilir.
```C
#include <stddef.h>
#include <stdio.h>

typedef union UData{
    int x, y, z;
    double d1, d2;
    char str[12];
} UData;

int main(void)
{
    UData data1 = { 0 };

    // Aşağıdaki kodlarda sıtandart çıktı akımına gönderilecek bilgilerdeki adres değerinin aynı olduğu görülecektir, bunun nedeni 'union' nesnelerin kendi adresi ile tüm üyelerinin adresinin aynı olarak tutulmasından kaynaklanmaktadır.
    printf("&data1      = %p\n", &data1);
    printf("&data1      = %p\n", &data1.x);
    printf("&data1      = %p\n", &data1.y);
    printf("&data1      = %p\n", &data1.z);
    printf("&data1      = %p\n", &data1.d1);
    printf("&data1      = %p\n", &data1.d2);
    printf("&data1      = %p\n", &data1.str);


}
```

❗❗❗ 👆 Yukarıdaki programdan da görülebileceği gibi birliklerin nesnelerinin tüm üyeleri aynı bellek bloğunu kullanırlar, bunun gerekli olduğu senaryolar vardır, ilerleyen kısımlarda göreceğiz.



❗❗❗ 👇 Aşağıdaki programdan birlik türlerine ilk değer verme sözdizimi incenebilir.
```C
#include <stddef.h>
#include <stdio.h>

typedef union {
    int x, y, z;
    double d1, d2;
    char str[12];
} Data;

int main(void)
{
    Data data1 = { 12, 23 }; // Bir birlik türünün tüm öğeleri bellekte aynı yerde tutulduğu için ilk değer verirken sadece tek bir üyeye ilk değer verilmesine izin verilmektedir, bu nedenlerden ötürü burada sözdizimi hatası vardır.

    Data data2 = { 67 }; // Buradaki ilk değer verme işleminde verilen ilk değer birlik nesnesinin ilk üyesine verilecektir.

    Data data2 = { .d2 = 4.75 }; // Burada C99 standardı ile dile eklenen 'designated initializer' sözdizim'i ile birlik nesnesinin 'd2' adlı üyesine ilk değer veriliyor.
}
```


### Unions(Birlikler) Kullanın Nedenleri 

Bu başlık altında **unions(birlikler)** aracının kullanılma nedenlerini inceleyeceğiz.


#### Bellekten Tasarruf İçin Kullanılır

Bellekten tasarruf için aynı anda bir arada olma ihtimali olmayan iki değişken olduğunda bu iki değişken `union` ile aynı bellek alanında tutulabilir, böylece hem bellekten tasarruf edilmiş olur hem de kafa karışıklı önlenebilir. Bu **mikro controlor** üzerinde çalışacak programları yazarken önemli olacaktır.



👇 Aşağıdaki programda `Employee` türünde(esasında tür eş adı) cinsiyete özel bazı bilgilerin cinsiyet fark etmeksizin tutulduğu durum incelenebilir, bu kullanımda yapı nesnelerinin bellek boyutları olabileceğinden daha büyüktür.
```C
#include <stddef.h>
#include <stdio.h>

typedef struct {
    int category; 
    char dept[12]; // Ne olduğu önemli olmayan bir bilgi
} Milinfo; // Değişken alarına zaman ayrılmadı ama üretimde düzgün adlar verilmelidir.

// 'Employee' yapısında tutulacak olan kişi bilgisi erkek ya da kadın olabilir, 
typedef struct {
    int id;
    char name[24];
    char maiden_name[16]; // Evlenmeden önceki soyad bilgisi.
    char gender;
    Milinfo minfo; // Askerlik bilgisi.
} Employee;


int main(void)
{
    printf("sizeof(Employee) = %zu\n", sizeof(Employee)); // 'int' türünün 4 byte oldğu sistemde standart çıktı akımına 'sizeof(Employee) = 64\n' gönderilir, bu değerin neden böyle olduğunu 'alignment requirement' değerinin 4 olduğunu anlayınca hesaplayıp anlayabilirsin.
}
```

👇 Aşağıdaki programda `Employee` türünde(esasında tür eş adı) cinsiyete özel bazı bilgilerin cinsiyet fark etmeksizin tutulduğu durum incelenebilir, bu kullanımda yapı nesnelerinin bellek boyutları olabileceğinden daha büyüktür.
```C
#include <stddef.h>
#include <stdio.h>

typedef struct {
    double category; 
    char dept[12]; // Ne olduğu önemli olmayan bir bilgi
} Milinfo; // Değişken alarına zaman ayrılmadı ama üretimde düzgün adlar verilmelidir.

// 'Employee' yapısında tutulacak olan kişi bilgisi erkek ya da kadın olabilir, 
typedef struct {
    int id;
    char name[24];
    char maiden_name[16]; // Evlenmeden önceki soyad bilgisi.
    char gender;
    Milinfo minfo; // Askerlik bilgisi.
} Employee;


int main(void)
{
    printf("sizeof(Employee) = %zu\n", sizeof(Employee)); // 'int' türünün 4 byte oldğu sistemde standart çıktı akımına 'sizeof(Employee) = 72\n' gönderilir, bu değerin neden böyle olduğunu 'alignment requirement' değerinin 8 olduğunu anlayınca hesaplayıp anlayabilirsin. 
}
```



👇 Aşağıdaki programda **anonymous struct** ve **anonymous union** aracını kullanarak `Employee` türünün(esasında tür eş adı) bellekte kapladığı alanın nasıl azaltılabileceği incelenebilir.
```C
#include <stddef.h>
#include <stdio.h>

typedef struct {
    int id;
    char name[24];
    
    // Aşağıdaki kullanım 'anonymous struct' ve 'anonymous union' aracı kullanılıyor.
    union {
        char maiden_name[16];
        struct {
            int category; 
            char dept[12]; // Ne olduğu önemli olmayan bir bilgi
        };
    };

    char gender;
} Employee;


int main(void)
{
    printf("sizeof(Employee) = %zu\n", sizeof(Employee));// 'int' türünün 4 byte oldğu sistemde standart çıktı akımına 'sizeof(Employee) = 48\n' gönderilir, bu değerin neden böyle olduğunu 'alignment requirement' değerinin 4 olduğunu anlayınca ve 'union' varlığın çalışma biçimini bildiğinde hesaplayıp görebilirsin. 
}
```


#### Bir Veri Türünün Farklı iki Biçimde Temsil Edilmesi 


👇 Aşağıdaki programda `FLOAT_t` türünün(esasında tür eş adı) aynı anda hem tam sayı hem de `float` türünden ondalıklı sayı tutabileceği(bu tür ile bir ondalıklı sayının virgülden önceki ve sonraki kısımları ayrı ayrı bu tür ile tutulabilir) bir kullanım incelenebilir.
```C
#include <stddef.h>
#include <stdio.h>
#include <stdint.h>

typedef union {
    int32_t i;
    float f;
} FLOAT_t;


int main(void)
{
    printf("sizeof(FLOAT_t) = %zu\n", sizeof(FLOAT_t)); // 'float' türü 4 byte olan sistemde standart çıktı akımına 'sizeof(SData1) = 4\n' değeri gönderilir.
}
```



👇 Aşağıdaki program `myint_t` türünün(esasında tür eş adı) aynı anda farklı türleri tutuyormuş gibi nasıl kullanıldığını anlamak için incelenebilir.
```C
#include <stddef.h>
#include <stdio.h>
#include <stdint.h>

typedef union {
    int32_t uval;
    struct {
        uint16_t lowbytes;
        uint16_t highbytes;
    };
    uint8_t bytes[4]
} myint_t;


int main(void)
{
    printf("sizeof(myint_t) = %zu\n", sizeof(myint_t)); // Burada standart çıktı akımına 'sizeof(myint_t) = 4\n' değeri gönderilir.

    myint_t = { .uval = 123231321u };

    printf("%zu\n", x.lowbytes);
    printf("%zu\n", x.highbytes);

    for(int i = 0; i < 4; ++i){
        printf("%zu\n", x.bytes[i]);
    }
}
```



❗❗❗ Özellikle sistem programlama tarafında bir **yazmaça(register)** erişimde buradakine benzer biçimde `union` kullanılmaktadır, mesela 32 bitlik bir **yazmaça(register)** tek bir 32 bit değişken gibi, iki tane 16 bitlik değişken gibi ya da dört tane 8 bitlik bir değişken gibi kullanılabilir.



Bu başlık altında özellikle de sistem programlama tarafında kullanım biçimleriyle ilgili olarak kullanımını incelemek için bitsel işlemler konusun öğrenmiş olmak gerekiyor, o konuyu işledikten sonra bu konuya geri döneceğiz.


#### Discriminated union(tagged union) Kullanım Biçimi 

Programlamada ihtiyaç duyulan işlemlerden biri de şudur: Bazen bir değişkenin önceden belirlenmiş farklı türden değerler alabilmesini isteriz, bunun için kullanılan yapıya **discriminated union** ya da **tagged union** deniliyor.



👇 Aşağıdaki programda bir tür ile aynı anda nasıl hem bir işaretli tam sayı, hem bir double ondalıklı sayı, hem bir yazı(ad), hem bir tarih türünü tutucak bir değişkenin nasıl bildirilip kullanılacağını anlamak için incelenebilir.
```C
#include <date.h>
#include <stdio.h>

// Aşağıdaki gibi birlik tanımında farklı türler aynı nesne üzerinden kullanılabiliyor ama bu kullanımda hangi verinin nesnede tutulduğu bilgisi bulunmadığı için kullanılmasından sıkıntılar çıkacaktır.
typedef union {
    char str[16]; // Ad
    Date dt;
    double dval;
    int ival;
} Data1;


// Aşağıdaki gibi bir 'struct' türüyle sarmalanmış olan birlik tanımını ilk hale göre daha kullanılabilirdir. 
typedef struct{
    union {
        char str[16]; // Ad
        Date dt;
        double dval;
        int ival;
    };
    int type; // Hangi türden değer tutulacağı bilgisini taşıyacak olan değişken.
} Data2;


int main(void)
{
    Data1 data1;

    data1.ival = 7; // Burada tam sayı türüne değer atanıyor.

    printf("data1.dval = %f", data1.dval); // Bu kulanım hatalıdır çünkü, birlik nesnesinin 'dval' üyesine değer atanmadan kullanılmaya çalışılıyor.
}
```



⚠️ C ve C++ dilindeki `union` türünün kullanımında sözdizim farklılıkları vardır, bu rada anlatılan her şey C dili için geçerlidir, C++ dili için geçerli olmayabilir.



👇 Aşağıdaki programda **discriminated union(tagged union)** olarak adlandırılan bir veri yapısının nasıl olabileceği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "date.h"
#include "nutility.h"


#define NAME_T     1
#define DATE_T     2
#define INT_T      3
#define DOUBLE_T   4

typedef struct {
    union {
        char name[16]; // Ad
        Date dt;
        double dval;
        int ival;
    };
    int type;
} Data;


void set_data_random(Data* p)
{
    switch(rand() % 4){
        case NAME_T : 
            strcpy(p->name, random_name()); 
            p->type = NAME_T;
        break;
        case DATE_T : 
            set_random_date(&p->dt);
            p->type = DATE_T;
        break;
        case INT_T : 
            p->ival = rand();
            p->type = INT_T;
        break;
        case DOUBLE_T : 
            p->dval = drand();
            p->type = DOUBLE_T;
        break;
    }
}

void print_data(const Data* p)
{
    switch(p->type){
        case NAME_T : 
            printf("%s\n", p->name); 
        break;
        case DATE_T : 
            printf_date(&p->dt);
        break;
        case INT_T : 
            printf("%d\n", p->ival);
        break;
        case DOUBLE_T : 
            printf("%f\n", p->dval);
        break;
    }
}


int main(void)
{
    randomize();
    Data data1;

    for(int i = 0; i < 100; ++i){
        set_data_random(&data1);
        print_data(&data1);
        (void)getchar(); // Burada kullanıcıdan bir karakter girişi bekleniyor, böylece program her döngü adımında durduruluyor.
    }
}
```



✍️ Burada `nutility` modülümüzün başlık dosyasına aşağıdaki gibi fonkisyon bildirimini ekliyoruz.
```C

// Rastgele bir ondalıklı değer dönen fonksiyon.
double dran(void);

```

✍️ Burada `nutility` modülümüzün kaynak dosyasına aşağıdaki gibi fonkisyon tanımını ekliyoruz.
```C

double dran(void)
{
    return 1.735434 * rand();
}

```


> ❔ 
> 
> Sorulan soru;
> 
> union nesnesinin boyutu icindeki  en büyük elemanin boyutu kadar midir?
> 
> Cevap
> 
> Evet, ama aligmnet olabilir.



***
==================================================

✦✦✦✦✦ 10.35-10.56 birinci ara verildi. ✦✦✦✦✦

==================================================
***


❗❗❗ **Discriminated union(tagged union)** olarak adlandırılan veri yapıları **Xml parser**, **Json parser** gibi işlemlerde kullanılan bir veri yapısıdır.



👇 Aşağıdaki programda **discriminated union(tagged union)** olarak adlandırılan bir veri yapısının dizisinin kullanımı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "date.h"
#include "nutility.h"


#define NAME_T     1
#define DATE_T     2
#define INT_T      3
#define DOUBLE_T   4

typedef struct {
    union {
        char name[16]; // Ad
        Date dt;
        double dval;
        int ival;
    };
    int type;
} Data;


void set_data_random(Data* p)
{
    switch(rand() % 4){
        case NAME_T : 
            strcpy(p->name, random_name()); 
            p->type = NAME_T;
        break;
        case DATE_T : 
            set_random_date(&p->dt);
            p->type = DATE_T;
        break;
        case INT_T : 
            p->ival = rand();
            p->type = INT_T;
        break;
        case DOUBLE_T : 
            p->dval = drand();
            p->type = DOUBLE_T;
        break;
    }
}

void print_data(const Data* p)
{
    switch(p->type){
        case NAME_T : 
            printf("%s\n", p->name); 
        break;
        case DATE_T : 
            printf_date(&p->dt);
        break;
        case INT_T : 
            printf("%d\n", p->ival);
        break;
        case DOUBLE_T : 
            printf("%f\n", p->dval);
        break;
    }
}


int main(void)
{
    Data ar[100];

    randomize();

    for(int i = 0; i < 100; ++i){
        set_data_random(ar + i);
    }

    for(int i = 0; i < 100; ++i){
        print_data(ar + i);
    }
}
```


C++ dilinin standart kütüphanesinde bu amaçla kullanılan adı `variant` olan bir `class` vardır ama C dilinin kendimiz yazmamız gerekiyor.


## Enumarations(Numaralandırmalar) 

**Enumaration(Numaralandırma)** aracı sabit olan belirli bir türe ait değerleri tutabilmek için kullanılan bir varlıktır, mesela haftanın günleri, yazıda kullanılan fonst ailesi, **state machine** için belirlenmiş olan durum değerleri bilgileri **enumaration(numaralandırma)** bünyesinde tutulabilir. </br>
Bu araç hem C hem de C++ dilinde yoğun olarak kullanılmaktadır.


Mülakatlarda **Enumaration(Numaralandırma)** aracıyla ilgili olarak kullanılan 



❗❗❗ Enum türleri hem bir **user difined type** hem de aynı zamanda **integer type** özelliğe sahiptir.



👇 Aşağıdaki programda bir `enum` türünün nasıl oluşturulduğu ve bu türün kullanımı incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>

// Aşağıdaki 'enum' bildiriminde adlandırma kurallarına dikkat edilmemiştir.
enum Color { // Buradaki 'Color'a 'Enumaration tag' deniliyor.
    // Aşağıdaki tam sayı sabitlerine 'Enumaration constands' ya da 'Enumarator' deniliyor.
    // 'Enumarator' değerleri verilmediğinde 0 değerinden başlayıp artarak devam eder.
    White, // 0 değerine karşılık geliyor.
    Red, // 1 değerine karşılık geliyor.
    Yellow, // 2 değerine karşılık geliyor.
    Green, // 3 değerine karşılık geliyor.
    Black // 4 değerine karşılık geliyor.
};

// Aşağıdaki gibi 'enum' türleri fonksiyonlarda kullanılabilir.
void set_color(enum Color);
enum Color get_color(void);


// Bir yapı üyesi aşağıdaki gibi 'enum' türünden olabilir.
struct Window{
    // ...
    enum Color base_color;
};


enum Color cgc = Yellow; // Burada olduğu gibi global alanda enum türü tanımı(defination) yapılabilir.


int main(void)
{
    enum Color c = Red;



}
```


❗❗❗ `enum` türleri üretimde çok sık kullanılmaktadır ve makrolardan farklı olarak **kapsamları(scope)** vardır, derleyici program tarafından tanındıkları için debug edilebilirler. 


👇 Aşağıdaki programda bir `enum` türünün değerlerinin sabit bir tam sayı olduğu görülebilir.
```C

enum Color {
    White,
    Red,
    Yellow,
    Green,
    Black
};

int main(void)
{
    int ar[Green]; // Bu kullanım 'Green' ifadesinin sabit bir tam sayı değeri olduğu için geçerli(legal)'dir.

}
```





👇 Aşağıdaki programda bir `enum` **bildiriminde(decleration)** üyelerinin değerlerine farklı değerler verileceği incelenebilir.
```C

enum Color {
    White = 17,
    Red, // Burada 'Red' sabiti '18' değerini alacaktır.
    Yellow = 90,
    Green, // Burada 'Green' sabiti '91' değerini alacaktır.
    Black = 27
};


int main(void)
{


}
```



👇 Aşağıdaki programda bir `enum` **bildiriminde(decleration)** varlığın üyelerinin değerlerine eksi değerler verileceği incelenebilir.
```C

enum Color {
    White = -5,
    Red, // Burada 'Red' sabiti '-4' değerini alacaktır.
    Yellow = -76,
    Green, // Burada 'Green' sabiti '-75' değerini alacaktır.
    Black = -3
};


int main(void)
{


}
```



👇 Aşağıdaki programda bir `enum` **bildiriminde(decleration)** varlığın farklı üyelerinin değerlerinin aynı olabileceği incelenebilir.
```C

enum Color {
    White = 1,
    Gray = 2,
    Grey = 2,
    Red, // Burada 'Red' sabiti '3' değerini alacaktır.
    Yellow,
    Green,
    Black
};


int main(void)
{


}
```



👇 Aşağıdaki programda oyun kartlarının `enum` türleriyle temsil edilebileceği incelenebilir.
```C

// İskambil kağıtlarının renk bilgisi 'enum Suit' adındaki bir türle temsil ediliyor.
enum Suit {
    Club,
    Diamond,
    Heart,
    Spade
};

// İskambil kağıtlarının değeri 'enum Face' adındaki bir türle temsil ediliyor.
enum Face {
    Two,
    Three,
    Four,
    Five,
    Six,
    Seven,
    Eight,
    Nine,
    Ten,
    Jack,
    Queen,
    King,
    Ace
};


/*

// Aşağıda 'enum' türleriyle birlikte 'typedef' kullanılabildiği görülebilir.

typedef enum Suit {
    Club,
    Diamond,
    Heart,
    Spade
} Suit;

typedef enum Face {
    Two,
    Three,
    Four,
    Five,
    Six,
    Seven,
    Eight,
    Nine,
    Ten,
    Jack,
    Queen,
    King,
    Ace
}Face;

*/

// Bir iskambil kağıdı da 'struct Card' adındaki bir tür ile temsil ediliyor.
struct Card{
    enum Suit s;
    enum Face f;
};


int main(void)
{
    struct Card mycard = { Spade, Queen };

}
```


> ❔ 
> 
> Sorulan soru;
> 
> Bütün C ögrendiklerimizi kapsayacak bir proje yapmak istesek, hobi amacli ya da open source olarak, bir tavsiyeniz olur mu?
> 
> Cevap;
> 
> Olucak, bu tavsiyeler ayrı bir kayıt ile ya da topluluk sayfasıdan paylaşılacakmış, her domain için inceleme yapılabilecek açık kaynak projeler paylaşılacağı belirtildi.



👇 Aşağıdaki programda `enum` türlerinde sıranın önemli olduğu durumlardan biri olarak kart oyununun türüne göre kartların renk açısından önem sırasının farklı olduğu durum incelenebilir. </br>
Kart oyununun türüne `enum Suit` türünün bildirimindeki kartların sıralanışı değişmektedir.
```C

#ifdef POKER

typedef enum Suit {
    Club, Diamond, Spade, Heart
} Suit;

#else

typedef enum Suit {
    Club, Diamond, Heart, Spade
} Suit;

#endif 

int main(void)
{
    

}
```



👇 Aşağıdaki programda `enum` türlerinin `switch` ile kullanımı görülebilir, bu program çalıştırılmak için yazılmamıştır.
```C
typedef enum Suit {
    Club,
    Diamond,
    Heart,
    Spade
} Suit;

typedef enum Face {
    Two,
    Three,
    Four,
    Five,
    Six,
    Seven,
    Eight,
    Nine,
    Ten,
    Jack,
    Queen,
    King,
    Ace
} Face;


struct Card{
    enum Suit s;
    enum Face f;
};


void card_game_(Card c)
{
    swtich(c.s) {
        case Club:
            ;
        break;
        case Diamond:
            ;
        break;
        case Heart:
            ;
        break;
        case Spade:
            ;
        break;
    }
}


int main(void)
{


}
```



👇 Aşağıdaki programda `enum` türlerinin **sabitlerin(Symbolinh Constant)** yerine kullanılabildiği incelenebilir.
```C
#include <stdio.h>

// 'Enumaration tag' olmadan 'enum' türü tanımlanıyor, bu kullanım 'Sabitlerin(Symbolinh Constant)' bir muadilidir.
enum {
    LOW = 100,
    MEDIUM = 200,
    HIGH = 500
};


void foo(void)
{
    enum { SIZE = 100 }; // Burada 'enum' türü bir sabit olarak kullanılmıştır, bu kullanım 'object like makro' kullanımının yerine tercih edilebilir.

    printf("SIZE value: %d", SIZE);
}

int main(void)
{
    foo();
}
```



👇 Aşağıdaki programda `enum` türleriyle birlikte sık kullanılan iki durum incelenebilir.
```C

enum Color {
    White,
    Red,
    Yellow,
    Green,
    Black,
    NoOfColors // Bu bir renk bilgisi tutmamaktadır.
};

int main(void)
{
    // 'enum Color' türünün tüm elemanları aşağıdaki gibi gezilebilir.
    for(enum Color c = White; c < NoOfColors; ++c){

    }

    enum Color ar[NoOfColors]; // Buradaki gibi bir dizi bildirimi yapılabiliyor.
}
```


***
==================================================

✦✦✦✦✦ 12.00-12.06 ikinci ara verildi. ✦✦✦✦✦

==================================================
***


⚠️ C dilinde numaralandırma türleriyle ilgili hoş karşılanmayan bir durum var, bu durum C dilinde farklı `enum` türleri ya da tam sayı türleri arasında örtülü tür dönüşümü yapılabiliyor olmasıdır ve bu bazı hatalara neden olabiliyor.


👇 Aşağıdaki programda C dilindeki örtülü olarak `enum` türlerine farklı türlerin atabildiği incelenebilir, bu özellik esasen istenilen bir durum değil çünkü hatalara neden olabilmektedir.
```C
#include <stdio.h>

enum Color { Red, Black, White };
enum State { On, Off, Hold };


int main(void)
{
    enum Color color1;
    enum State state1;
    int ival = 4;

    color1 = ival; // 'int' türünden 'enum Color' türüne örtülü tür dönüşümü yapılıyor, bu C dilinde legal bir durumdur.
    color1 = Off; // 'enum State' türünden 'enum Color' türüne örtülü tür dönüşümü yapılıyor.
    state1 = Black; // 'enum Color' türünden 'enum State' türüne örtülü tür dönüşümü yapılıyor.
    state1 = 48  ; // 'int' türünden 'enum State' türüne örtülü tür dönüşümü yapılıyor.
}
```



👇 Aşağıdaki programda `enum` türünden bir değişkenin nasıl yazdırılabildiği incelenebilir.
```C
#include <stdio.h>

enum Color { Red, Black, White };
enum State { On, Off, Hold };

int main(void)
{
    enum Color color1 = Black;

    printf("%d\n", color1);
}
```



👇 Aşağıdaki programda C dilinde `enum` türünün adlarını yazdırmak için kullanılabilecek bir araç olmasada bunu yapmak için **lookup table** kullanılabileceği incelenebilir.
```C
#include <stdio.h>

enum Color { Red, Gree, Blue, Magente, Black, White };
const char* const pcolors[] = { "Red", "Gree", "Blue", "Magente", "Black", "White" }; // Bu lookup tablosu 'enum Color' türünün öğelerini temsil etmek için kullanılmaktadır.

int main(void)
{
    enum Color color1 = Black;

    printf("%d\n", color1); 
    printf("%s\n", pcolors[color1]);
}
```



C mülakatlarında karşılabilecek sorulardan biri de iki farklı başlık dosyasından gelen farklı `enum` türünden değişkenlerin üyeleri aynı ada sahip olması durumlarına karşı ne yapılabileceğidir. </br>
👇 Aşağıdaki programda aynı ada sahip olan varlıklar olduğu için sözdizim hatası oluşacaktır.
```C
// #include <screen.h> // Bu başlık dosyasından 'enum ScreenColor' tanımı geliyor.
enum ScreenColor { Red, Gree, Blue, Magente, Black, White };

// #include <traffic.h> // Bu başlık dosyasından 'enum TrafficLiht' tanımı geliyor.
enum TrafficLiht { Red, Gree, Yellow };

// Yukaradaki iki farklı başlık dosyasından gelen 'enum' türlerinin sabitleri aynı olduğu için sözdüzüm hatası oluşacaktır.

int main(void)
{
}
```


👇 Aşağıdaki programda aynı ada sahip olan varlıklar olduğu için sözdizim hatası oluşacaktır.
```C
// #include <screen.h> // Bu başlık dosyasından 'enum ScreenColor' tanımı geliyor.
enum ScreenColor { ScreenColorRed, ScreenColorGree, ScreenColorBlue, ScreenColorMagente, ScreenColorBlack, ScreenColorWhite };

// #include <traffic.h> // Bu başlık dosyasından 'enum TrafficLiht' tanımı geliyor.
enum TrafficLiht { TrafficLihtRed, TrafficLihtGree, TrafficLihtYellow };

// Yukaradaki iki farklı başlık dosyasından gelen 'enum' türlerinin sabitlerinin aynı olmasından dolayı oluşabilecek sözdizimi hatasını önlemek için yukarıdaki gibi 'enum' türlerinin bulunduğu kütüphene modüllerini belirtecek biçimde adlar güncellenerek ad çakışması önlenmeye çalışılmıştır.

int main(void)
{
}
```


## Endianness Kavramı 🌟 

Tam sayı değişkenlerin bellekteki yerleşimiyle ilgili bir kavramdır. </br>
Bellekte her şey byte olarak tutulmaktadır bu nedenden dolayı da birden fazla byte yer kaplayan tam sayı türünden nesnelerin byte'larının bellekte nasıl dizileneceği önemlidir. </br>

`int x = 1;` değişken bildiriminde `x` değişkeninin değeri bir yazarken `00000000 00000000 00000000 00000001` biçiminde yazarız ama bu değeri bellekte iki farklı biçimde tutulabiliriz, bunlar;
1. Düşük sayısal adreste yüksek anlamlı byte, yüksek sayısal adreste düşük anlamlı byte bulunması durumuna "**Big endian**" deniliyor.

    | Address       | Byte     |
    | ------------- | -------- |
    | 0xBFFFF000    | 00000000 |
    | 0xBFFFF001    | 00000000 |
    | 0xBFFFF002    | 00000000 |
    | 0xBFFFF003    | 00000001 |

2. Düşük sayısal adreste düşük anlamlı byte, yüksek sayısal adreste yüksek anlamlı byte bulunması durumuna "**Little endian**" deniliyor.
   
    | Address       | Byte     |
    | ------------- | -------- |
    | 0xBFFFF000    | 00000001 |
    | 0xBFFFF001    | 00000000 |
    | 0xBFFFF002    | 00000000 |
    | 0xBFFFF003    | 00000000 |


📌 **Endianness** davranışının ne olacağı işlemciye bağlıdır, Intel mimariler "**Little endian**", Motorola tarzı mimari "**Big endian**", Arm mimaride her iki yaklaşım da kullanılabiliyor.


Bir sistemin "**Little endian**" ya da "**Big endian**" olması bizi ne zaman ilgilendirir;
- İki farklı mimarideki veri alışverişi sırasında **endianness** durumu iki sistemde farklı ise haberleşme sırasında dönüşüm yapılması gerekiyor, bu dönüşüm işlemi bit işlemleri konusunda incelenecektir.
- Dosya işlemlerinde kaynaktaki dosyanın **endianness** durumu ile dosyayı açık okuyacak sistemin **endianness** durumu birbirinden farklı ise bu durumun anlaşılıp gerekli dönüşümün yapılması gerekecektir.



Mülakatlarda sistemin **big endian** ya da **little endian** olma durumunu tespit edip standart çıktı akımına gönderen(yazdıran) bir C programı yazılması istenebilir. </br>
👇 Aşağıdaki programda yukarıdaki mülakat sorusunda istenilen program yazılmıştır.
```C
#include <stdio.h>

int main(void)
{
    int x = 1;
    
    // '*(char*)&x' ifadesinde '&x' ile 'x' değişkeninin adres değeri elde ediliyor(bu değer R-value) ardından '(char*)&x' ifadesindeki '(char*)' tür dönüşümü ile adres değerinin sadece ilk byte'ı 'char' türünün adres türüne dönüştürülüyor, ardından da '*(dereferencing)' işlemi ile tek byte'ın değerine erişiliyor.
    // Burada şuna dikkat etmek gerekiyor, ilk byte demek ilgili tam sayı türünün tüm byte'ları içinde adres değeri en küçün olan byte demektir.
    // '*(char*)&x' ifadesinin zero-nonzero durumuna göre 'endianness' durumu tespit ediliyor.
    if(*(char*)&x){
        printf("little endian.\n");
    }
    else{
        printf("big endian.\n");
    }
}
```

⚠️ Bir sistemin **endianness** durumunu anlamak için C dilinde tek yol bunu çalışma zamanında(run-time) sınamaktır ama C++ dilinde derleme zamanında da tespit edebiliyoruz(C++20 standardından eklenen `byte` adında bir modül eklendi oradaki öğelerle öğrenilebiliyor).



👇 Aşağıdaki programda işaretsiz bir tam sayı değişkenin tüm byte'ları düşük adresten büyük adrese doğru yazdırılmıştır, bu yöntemle sistemin **endianness** durumu tespit edilebilir.
```C
#include <stdio.h>

int main(void)
{
    unsigned int x = 0x1234ABCD;

    printf("%X\n", x);
    unsigned char* p = (unsigned char*)&x;

    int n = sizeof(int);
    while(n--){
        printf("%X\n", *p++);
    }
}
```


## Bitsel Operatörler(Bitwise Operations) 

Bu konu 5, 6 saat kadar sürecektir. </br>
Bit manipülasyonları **bitsel operatörler(bitwise operators)** kullanılarak yapılıyor.

C dilindeki **bitsel operatörler(bitwise operators)** aşağıdaki gibidir;
- `~` **bitwise not operator(bitsel değil operatörü)**
- `>>` **bitwise right shift operator(bitsel sağa kaydırma operatörü)**
- `<<` **bitwise left shift operator(bitsel sola kaydırma operatörü)**
- `&` **bitwise and operator(bitsel ve operatörü)**
- `^` **bitwise xor operator(bitsel özel veya operatörü)**
- `|` **bitwise or operator(bitsel veya operatörü)**
- `>>=`, `<<=`, `&=`, `^=`, `|=` **bitwise assignment operators(bitsel atama operatörleri)**


⚠️ Yukarıda dizilenen **işleçler(operators)** öğrenildikten sonra C11 ile dile eklenen `_Alignof` ve `_Alignas` operatörleri dışında C dilindeki tüm operatörleri görmüş olacağız.


📌 Bu operatörler ne işe yarıyor sorusuna cevap vermeden önce tek tek tüm bitsel operatörlerini inceleyeceğiz.


❗❗❗ **Bitsel operatörlerle(bitwise operators)** ilgili olarak aşağıdaki durumlara dikkat edilmesi gerekiyor;
1. Bitsel operatörlerin operantları tam sayı türlerinden olmak zorundadır, yani ondalıklı sayı ya da başka bir tür olamaz.
2. Bu operatorler aşağı seviyeli olarak bit bit işlem yapmak için kullanılmaktadır.
3. Bitsel işlemler çok büyük çoğunlukla **işeretsiz(unsigned)** tam sayı türleri üzerinde yapılırlar.


❗❗❗ `0101'0101'0101'0101` biçiminde olan iki byte'lık bir verinin en sağındaki en düşün anlamlı bitin indeks değeri "0." bit olarak tanımlanır, bitlerin konumlarının ne olduğunu bilmek bitler üzerinde işlem yaparken önemlidir ve iyi bilinmelidir.

❗❗❗ Bitsel operatörlerin operantları çok büyük çoğunlukla işaretsiz tam sayılar oluyor, çok az oranda da işaretli tam sayılar da operand olabilir, bunun temel nedeni işaretsiz tam sayılarda daha kolay işlem yapılabilmesidir.


✍️ Burada `nutility` adındaki kendi modülümüze rastgele ad ve soyad soyad üretecek ayrı ayrı iki fonksiyon ekliyoruz.
```C
// Yazılan 'nutility.h' dosyasına eklenenler.

void bprint(unsigned);
```

```C
// Yazılan 'nutility.c' dosyasına eklenenler.

void bprint(unsigned x)
{
    while(x){
        putchar(x & 1 ? '1' : '0'); // Burada sayının sıfırıncı bitinin ne olduğu standart çıktı akımına gönderiliyor.
        x >>= 1; // Burada sayı bir sağa kaydırılıyor ve böylece sayıyı 0 yapana kadar tüm bitlerini gezmiş olacağız.
    }
    putchar('\n');
}
```


👇 Aşağıdaki programda kendi `nutility.h` başlık dosyamıza eklediğimiz `bprint` fonksiyonu ile ilgili tam sayının 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = 8795;

    bprint(x);
}
```


Ders sonu ...
