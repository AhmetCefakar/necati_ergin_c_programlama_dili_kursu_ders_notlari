# 13.Ders 22.02.2025 ğŸ•˜

Derse 22(09:01)-27(09:05)-29(09:10)-31(09:40)-30(10:50)-33(11:20)-34(11:45)-35(12:05) kiÅŸi katÄ±ldÄ±.

## Ã–ncelik Parantezi

ğŸ§­ **(...)** parantez kullanÄ±lan Ã¼Ã§ farklÄ± baÄŸlam var;
1. **SÃ¶zdiziminin(syntax)** bileÅŸeni olarak kullanÄ±lan parantez, mesela **fonksiyon bildirim(declaration)** ya da **tanÄ±mlama(definition)** **SÃ¶zdizimdeki(syntax)** parantez.
2. Fonksiyon Ã§aÄŸrÄ±larÄ±nda kullanÄ±lan operatÃ¶r olan parantez.
3. **Ã–ncelik parantezi** olarak Ã¼Ã§ farklÄ± nedenden dolayÄ± kullanÄ±lmaktadÄ±r;
    1. Matematiksel ve mantÄ±ksal iÅŸlemlerin Ã¶nceliÄŸini belirlemek iÃ§in kullanÄ±lÄ±r.
        - "-b/2a" yazmak iÃ§in `-b / 2 * a` ya da `-b / 2 / a` ya da  `(-b / 2) / a` yazÄ±labilir
    2. Matematiksel ve mantÄ±ksal iÅŸlemlerde kodun okunurluÄŸunu kolaylaÅŸtÄ±rmak iÃ§in kullanÄ±lÄ±r.
        - KarmaÅŸÄ±k matematiksel ifadeleri okunaklÄ± yazmak iÃ§in: `a * a * a + b * b * b` ifadesi okunur olmasÄ± iÃ§in `(a * a * a) + (b * b * b)` ÅŸeklinde kullanÄ±labilir.
    3. BÃ¼nyesinde bir Ã§ok farklÄ± operatÃ¶r bulunan ifadelerde(expression) operatÃ¶r Ã¶ncelikleri bilinmediÄŸinde kullanÄ±lÄ±r.
        - `(a & (b >> x)) ^ (y & z)` gibi bir ifade operatÃ¶r Ã¶nceliÄŸi bilinmediÄŸinde Ã¶ncelik parantezi kullanÄ±labilir.


ğŸ‘‡ AÅŸaÄŸÄ±daki program **Ã¶ncelik parantezi** kullanÄ±lmasÄ±nÄ±n bir ifadenin(expression) value kategorisine etkisini anlamak iÃ§in Ã¶nemlidir.
```C
#include <stdio.h>

int main(void)
{
    int x = 7;

    x; // Buradaki ifade(expression) l-value kategorisindedir.

    (((((x))))) = 98; // Buradaki ifade(expression) l-value kategorisindedir, parantez kullanÄ±mÄ± ifadenin value kategorisini deÄŸiÅŸtirmez.
    (((((x)))))++; // Buradaki ifade(expression) l-value kategorisindedir, parantez kullanÄ±mÄ± ifadenin value kategorisini deÄŸiÅŸtirmez. 

    return 0;
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki program **yan etkiye(side-effect)** maruz kalmÄ±ÅŸ bir nesnenin bir **sequence point** olmadan aynÄ± ifade(expression) iÃ§inde tekrar kullanÄ±lmasÄ± durumlarÄ±nda oluÅŸan **ub** durumlarÄ± incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 7, y = 5;
    
    y = x++ + x; // Burada 'ub' var.
    x = x++; // Burada 'ub' var.
    int z = (x = y) * x; // Burada 'ub' var.
    
    return 0;
}
```


## Control Statements(Kontrol Deyimleri) 

ProgramÄ±n akÄ±ÅŸ yÃ¶nÃ¼nÃ¼ deÄŸiÅŸtiren **deyimlerdir(statements)**.

ğŸ§­ AÅŸaÄŸÄ±daki kontrol **deyimlerinin(statements)** hepsinin nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±yla ilgili detaylarÄ±n Ã§ok iyi bilinmesi gerekiyor;
- if statement
- Loop Statements
    - for statement
    - while statement
    - do while statement
- Switch statements
- goto statement
- return statement
- break statement(loop statements ve switch deyimiyle birlikte kullanÄ±labilir)
- continue statement


ğŸ§­ **Control statements** konusundaki anlatÄ±mda ÅŸunlara odaklanÄ±lacak; 
- Syntax in C.
- Typical mistakes. 
- Idioms in C.


ğŸ§­ C ve C++ dillerinde **control statements** kullanÄ±mlarÄ±nda bazÄ± **SÃ¶zdizim(syntax)** farklÄ±lÄ±klarÄ± olabilir, mesela;
- `for(int i : ar)` bu **deyim(statements)** sadece C++ dilinde mevcut. Buradaki dÃ¶ngÃ¼ yapÄ±sÄ±na **range-base for loop** denilmektedir.
- `if(int x = foo(); x > 10)` bu **deyim(statements)** sadece C++ dilinde mevcut. Buradaki if yapÄ±sÄ±na **if with initializer** denilmektedir.
- `if(int x = foo())` bu **deyim(statements)** sadece C++ dilinde mevcut.


### if Statement(if Deyimi)

ğŸ§­ **if statement** aÅŸaÄŸÄ±daki maddelerde belirtildiÄŸi durumlarda kullanÄ±lÄ±r;
1. Bir koÅŸul doÄŸru ise bir iÅŸ yapÄ±lacak koÅŸul yanlÄ±ÅŸ ise yapÄ±lmayacak, durumlarÄ±nda kullanÄ±lÄ±r. 
2. Bir koÅŸul doÄŸru ise bir iÅŸ yapÄ±lacak koÅŸul yanlÄ±ÅŸ ise baÅŸka bir iÅŸ yapÄ±lacak, durumlarÄ±nda kullanÄ±lÄ±r.
3. Birden fazla koÅŸulun sÄ±rayla kontrol edildiÄŸi durumlarda kullanÄ±lÄ±r, bu kullanÄ±ma **else if ladder/cascaded if(else if merdiveni)** ÅŸeklinde adlandÄ±rÄ±lÄ±r.


â— **if Statement** koÅŸul olarak sadece ifade(expression) alabilir, if parantezleri arasÄ±ndaki ifade(expression) **zero/non-zero** olarak iÅŸlenir, ifadenin(expression) deÄŸeri "0" ise sonuÃ§ "false" ve "non-zero" ise "true" olarak kabul edilir.

ğŸ§  C dilinde lojik ifade beklenen yerde kullanÄ±lan ifadenin tÃ¼rÃ¼ **void** olamaz bunun dÄ±ÅŸÄ±nda bir kÄ±sÄ±tlama yoktur.

ğŸ§  **if Statement** koÅŸul olarak alacaÄŸÄ± ifadeye(expression) **conditional expression** denilmektedir.


ğŸ‘‡ AÅŸaÄŸÄ±daki sÃ¶zde kodlar C dilinde **if Statement** kullanÄ±mÄ±yla ilgili olan bazÄ± durumlarÄ± gÃ¶stermektedir;
```C
// AÅŸaÄŸÄ±daki gÃ¶sterim C'de if deyiminin en temel kullanÄ±mÄ±dÄ±r.
if(expr)
    one statement;

// AÅŸaÄŸÄ±daki kullanÄ±m C de geÃ§erli deÄŸildir, C++ dilinde geÃ§erlidir ama buna bu kursta deÄŸinilmeyecek
if(int x = 5)
    one statement;

// AÅŸaÄŸÄ±daki gibi bir kullanÄ±m C ve C++ dilerinde geÃ§erli(legal) deÄŸildir.
if()
    one statement;
```


ğŸ§­ Nerelerde lojik yorumlama yapÄ±lÄ±r;
- `!exp`
- `exp1 && exp2`
- `exp1 || exp2`
- `ex1 ? exp2 : exp3`
- `if(exp)`
- `while(exp)`
- `do...while(exp)`
- `for(;exp;)`



ğŸ‘‡ AÅŸaÄŸÄ±daki sÃ¶zde kodlarda C dilinde **if Statement** kullanÄ±mÄ±nda birden fazla **ifadenin(expression)** nasÄ±l kullanÄ±labileceÄŸi gÃ¶rÃ¼lebilir;
```C
if(exp){
    a++;
    b++;
    c++;
}

// AÅŸaÄŸÄ±da 'compont statement' kullanÄ±mÄ± ile Ã¼Ã§ ifadenin nasÄ±l tek bir statement iÃ§inde birleÅŸtirilerek kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
if(exp)
    a++, b++, c++;
```


âš ï¸ **if statement** kullanÄ±rken **KÄ±sa Devre DavranÄ±ÅŸÄ±na(Short Circuit behavior)** dikkat edilmesi gerekiyor.



ğŸš€ DiÄŸer programlama dillerinde olmayan idiomatic yapÄ±lar C de Ã§ok kullanÄ±lmaktadÄ±r. 
- Åu iki kullanÄ±m C dilinde aynÄ±dÄ±r: `if(exp != 0)` ve `if(exp)` aynÄ±dÄ±r ve ikinci kullanÄ±m C dilinde daha yaygÄ±ndÄ±r.
- Åu iki kullanÄ±m C dilinde aynÄ±dÄ±r: `if(exp == 0)` ve `if(!exp)` aynÄ±dÄ±r ve ikinci kullanÄ±m C dilinde daha yaygÄ±ndÄ±r.


ğŸš€ Ã–zellikle `if` parantezi iÃ§inde fonksiyon Ã§aÄŸrÄ± ifadelerinin bulunmasÄ± Ã§ok sÄ±k karÅŸÄ±mÄ±za Ã§Ä±kar.
- `if(isprima(x) != 0)` ile `if(isprima(x))` aynÄ± anlamdadÄ±r.
- `if(isprima(x) == 0)` ile `if(!isprima(x))` aynÄ± anlamdadÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki sÃ¶zde kod C dilinde **if Statement**'a ÅŸart olarak verilebilecek bir **ifadenin(expression)** nasÄ±l Ã§alÄ±ÅŸacaÄŸÄ±nÄ± anlamak iÃ§in Ã¶nemlidir;
```C
int x = 0;

if(++x) // Burada bir 'sequance point' vardÄ±r
    foo(++x); // Burada 'foo' fonksiyonuna '2' deÄŸeri argÃ¼man olarak gÃ¶nderilir
```


#### if Statement ile YapÄ±lan Tipik Hatalar 

**if Statement** kullanÄ±mÄ±nda yapÄ±labilecek hatalar aÅŸaÄŸÄ±daki gibidir;

1. ProgramcÄ±nÄ±n `||` yerine yanlÄ±ÅŸlÄ±kla `&&` kullandÄ±ÄŸÄ± durumlar yanlÄ±ÅŸlÄ±kla yapÄ±lan hatalardandÄ±r.

    
    ğŸ‘‡ AÅŸaÄŸÄ±daki programda `||` operatÃ¶rÃ¼ yerine yanlÄ±ÅŸlÄ±kla `&&` operatÃ¶rÃ¼ kullanÄ±ldÄ±ÄŸÄ± durum incelenebilir.
    ```C
    #define _CRT_SECURE_NO_WARNINGS
    
    #include <stdio.h>
    
    int main(void)
    {
        int x;
    
        printf("bir sayi giriniz: ");
        scanf("%d", &x);
        
        if(x != 5 || x != 3) // Buradaki ifadenin deÄŸeri 'always true' olacaktÄ±r. AslÄ±nda 'x != 5 && x != 3' yazÄ±lmalÄ±ydÄ±. 
            printf("doÄŸru\n");
    
        return 0;
    }
    ```

    > â” 
    > 
    > Sorulan soru;
    > 
    > Always true ifadeleri tespit etmenin yÃ¶ntemi var mi?
    > 
    > Cevap;
    > 
    > static olarak(runtime sÃ¶z konusu deÄŸil, koda bakarak, compile-time) kodu inceleyip koddaki logic hatalarÄ±() inceleyen programlar var, bu programlara **static code analyzer** deniliyor.
    > 
    > **static code analyzer** programlarÄ± kodu inceleyip sorunlu durumlarÄ± bildiren programlardÄ±r.
    > 
    > **static code analyzer** programlarÄ±na bu iÅŸi ilk yapan program **lint** olduÄŸu iÃ§in eskiden **linter** deniyormuÅŸ, "**lint**, **cppcheck**, **clang tidy**" bu programlardan bazÄ±larÄ±dÄ±r. 

2. ProgramcÄ±nÄ±n `&&` operatÃ¶rÃ¼nÃ¼ kullanacaÄŸÄ± yerde `&` operatÃ¶rÃ¼nÃ¼ kullanmasÄ± ya da programcÄ±nÄ±n `||` operatÃ¶rÃ¼nÃ¼ kullanacaÄŸÄ± yerde `|` operatÃ¶rÃ¼nÃ¼ kullanmasÄ± yanlÄ±ÅŸlÄ±kla yapÄ±lan hatalardandÄ±r.

3. Matematiksel notasyonlarÄ± olduÄŸu gibi kodlamada kullanÄ±ldÄ±ÄŸÄ± durumlar yanlÄ±ÅŸlÄ±kla yapÄ±lan hatalardandÄ±r, mesela `if(10 < x < 20)` ÅŸeklindeki bir kullanÄ±m bu durumlardan biridir.

4. ProgramcÄ±nÄ±n if deyiminde `==` operatÃ¶rÃ¼ yerine `=` operatÃ¶rÃ¼ kullandÄ±ÄŸÄ± durumlar yanlÄ±ÅŸlÄ±kla yapÄ±lan hatalardandÄ±r. `if(x == y)` yerine `if(x = y)` yazÄ±ldÄ±ÄŸÄ± durumlar yanlÄ±ÅŸlÄ±kla yapÄ±lan hatalardandÄ±r.

    
    ğŸ‘‡ AÅŸaÄŸÄ±daki programda `==` operatÃ¶rÃ¼ yerine `=` operatÃ¶rÃ¼nÃ¼n kullanÄ±ldÄ±ÄŸÄ± durum incelenebilir.
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>

    int main(void)
    {
        int x = 10;

        if(x == 10)
            printf("doÄŸru\n");
        else
            printf("yanlis\n");

        if(x = 15)
            printf("doÄŸru\n");
        else
            printf("yanlis\n");


        // Bir 'l-value' ile 'r-value' deÄŸerlerin aÅŸaÄŸÄ±daki gibi karÅŸÄ±laÅŸtÄ±rÄ±lmasÄ± C'de idiomatic yapÄ±dÄ±r.
        if(10 == x)
            printf("doÄŸru\n");
        else
            printf("yanlis\n");

        // AÅŸaÄŸÄ±daki koÅŸul **sÃ¶zdizim hatasÄ±(syntax error)** verecektir.
        if(10 = x)
            printf("doÄŸru\n");
        else
            printf("yanlis\n");

        printf("x = %d\n", x);

        return 0;
    }
    ```

5. Kayan noktalÄ± sayÄ±larda karÅŸÄ±laÅŸtÄ±rma yaparken `.` yerine `,` yazÄ±ldÄ±ÄŸÄ± durumlar yanlÄ±ÅŸlÄ±kla yapÄ±lan hatalardandÄ±r. 

    ğŸ‘‡ AÅŸaÄŸÄ±daki programda `.` yerine `,` yazÄ±ldÄ±ÄŸÄ± durum incelenebilir.
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>

    int main(void)
    {
        double dval = 4.5;

        if(dval > 5.2)
            printf("doÄŸru\n");
        else
            printf("yanlis\n");

        // AÅŸaÄŸÄ±daki ÅŸekilde 'dval > 5,2' kullanÄ±mÄ± 'always-true' durumundadÄ±r ve burada '.' yerine ',' kullanÄ±m hatasÄ± mevcuttur.
        if(dval > 5,2)
            printf("doÄŸru\n");
        else
            printf("yanlis\n");

        return 0;
    }
    ```

6. Fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±ldÄ±ÄŸÄ± yerlerde fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±lmasÄ± yerine sadece fonksiyon adÄ±nÄ±n yazÄ±ldÄ±ÄŸÄ± durumlar yanlÄ±ÅŸlÄ±kla yapÄ±lan hatalardandÄ±r. 
   
    â— Lojik ifade beklenen yerlerde herhangi bir fonksiyonun adÄ±nÄ±n yazmak **sÃ¶zdizim hatasÄ±(syntax error)** oluÅŸturmaz.
   
    ğŸ§  C dilinde **nesnelerin(object)** adreslerini tutmak iÃ§in **pointer**'lar kullanÄ±lÄ±r.

    **Pointer**'lar iki ana gruba ayrÄ±lmaktadÄ±r, bunlar;
    1. **Object pointer**
    2. **Function pointer**

    ğŸ§  **Function To Pointer Conversion**: Bir fonksiyon adÄ± bir ifade(expression) oluÅŸturduÄŸunda derleyici bu ifadeyi Ã¶rtÃ¼lÃ¼ olarak ilgili fonksiyonun adresine dÃ¶nÃ¼ÅŸtÃ¼rmektedir, bu kurala verilen addÄ±r.
    
    ğŸ§  **NULL pointer** olmayan adres deÄŸerleri **logic expression** iÃ§inde kullanÄ±ldÄ±ÄŸÄ±nda "true(non-zero)" olarak yorumlanmaktadÄ±r.

    
    ğŸ‘‡ AÅŸaÄŸÄ±daki program, fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±lacaÄŸÄ± yerde sadece fonksiyonun adÄ±nÄ±nÄ±n kullanÄ±lmasÄ±ndan kaynaklÄ± olarak nasÄ±l yanlÄ±ÅŸlÄ±kla hata yapÄ±labileceÄŸini anlamak iÃ§in incelenebilir. 
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>

    int foo()
    {
        // some code here
        
        return 0;
    }
   
    int main(void)
    {
        // AÅŸaÄŸÄ±daki sorgu Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda konsola 'yanlis' yazar
        if(foo())
            printf("dogru\n");
        else
            printf("yanlis\n");


        // AÅŸaÄŸÄ±daki sorguda yanlÄ±ÅŸlÄ±kla yapÄ±lan hatalardan biri vardÄ±r. 'foo' eÄŸer 'NULL' deÄŸilse 'always-true' olacaktÄ±r.
        // AÅŸaÄŸÄ±daki 'if(foo)' statement kullanÄ±mÄ± **sÃ¶zdizim hatasÄ±(syntax error)** deÄŸildir bu kullanÄ±m legal durumundadÄ±r.
        if(foo)
            printf("dogru\n");
        else
            printf("yanlis\n");

        return 0;
    }
    ```

7. Kayan noktalÄ± sayÄ±lar `==` operatÃ¶rÃ¼ ile karÅŸÄ±laÅŸtÄ±rÄ±lmamalÄ±dÄ±r, bu yapÄ±ldÄ±ÄŸÄ±nda deÄŸiÅŸken deÄŸerlerinde tek bir bit bile farklÄ± olunca kod beklenmeyen ÅŸekilde Ã§alÄ±ÅŸacaktÄ±r. 

    Kayan noktalÄ± sayÄ±larda karÅŸÄ±laÅŸtÄ±rma iÅŸlemlerinin nasÄ±l yapÄ±lmasÄ± gerekir: EÄŸer mantÄ±ksal olarak kayan noktalÄ± sayÄ±larda karÅŸÄ±laÅŸtÄ±rma iÅŸlemi yapma ihtiyacÄ± varsa bu karÅŸÄ±laÅŸtÄ±rmanÄ±n aradaki farkÄ±n belirli bir deÄŸerden kÃ¼Ã§Ã¼k olup olmadÄ±ÄŸÄ±na bakÄ±lmalÄ±dÄ±r.

    
    ğŸ‘‡ AÅŸaÄŸÄ±daki programda kayan noktalÄ± sayÄ±lardaki karÅŸÄ±laÅŸtÄ±rma iÅŸlemlerinin nasÄ±l yapÄ±lmasÄ± gerektiÄŸi gÃ¶rÃ¼lebilir. 
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include <math.h>

    int foo()
    {
        // some code here
        
        return 0.6786;
    }

    int main(void)
    {
        double dval = foo();

        // AÅŸaÄŸÄ±daki gibi bir karÅŸÄ±laÅŸtÄ±rma yapÄ±lmamalÄ±.
        if(dval == 0.333333) 
            printf("doÄŸru\n");
        else
            printf("yanlis\n");


        // Kayan noktaÄ± sayÄ±larda aÅŸaÄŸÄ±daki gibi bir karÅŸÄ±laÅŸtÄ±rma yapÄ±lmalÄ±dÄ±r.
        double epsilon = 1e-6;  // tolerance level
        
        if(fabs(dval - 0.333333) < epsilon)
            printf("doÄŸru\n");
        else
            printf("yanlis\n");

        return 0;
    }
    ```

8. **Control statement** kullanÄ±mlarÄ±nda en Ã§ok yapÄ±lan hatalardan biri **sonlandÄ±rÄ±cÄ± atomunun(terminator token(`;`))** yanlÄ±ÅŸ yerde kullanÄ±lmasÄ±dÄ±r.

    
    ğŸ‘‡ AÅŸaÄŸÄ±daki programda **terminator token(`;`)** yanlÄ±ÅŸ yerde kullanÄ±lmasÄ±ndan kaynaklanan hata incelenebilir.
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include <stdlib.h>

    double foo(void);

    int main(void)
    {
        int x;

        printf("bir sayi giriniz: ");
        scanf(%d, x);
        // YazÄ±lan tÃ¼m programlar iÃ§in geÃ§erli olarak: YukarÄ±daki kod parÃ§asÄ±nÄ±n kullanÄ±lmasÄ±nÄ±n amacÄ± deÄŸiÅŸkenin deÄŸerinin run-time'da beli olmasÄ±nÄ± kurgulamak iÃ§indir.


        if(x > 10)
            printf("doÄŸru\n");

        // AÅŸaÄŸÄ±daki kullanÄ±m hatalÄ±dÄ±r Ã§Ã¼nkÃ¼ ';' token'Ä± 'if' sonrasÄ±na eklenmiÅŸ
        if(x > 10);
            printf("doÄŸru\n");
        
        return 0;
    }
    ```

9. **Control statement** kapsam bloÄŸunun yanlÄ±ÅŸ yorumlanmasÄ±ndan dolayÄ± `{...}` bloklarÄ±nÄ±n kullanÄ±lmadÄ±ÄŸÄ± durumlar yanlÄ±ÅŸlÄ±kla yapÄ±lan hatalardandÄ±r.

    
    ğŸ‘‡ AÅŸaÄŸÄ±daki programda if deyimlerinde kapsamÄ±n(block) yanlÄ±ÅŸ yorumlanmasÄ±ndan kaynaklÄ± durumlar incelenebilir.
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include <stdlib.h>

    double foo(void);

    int main(void)
    {
        int x;
        int a = 5, b = 9;

        printf("bir sayi giriniz: ");
        scanf(%d, x);
        // YazÄ±lan tÃ¼m programlar iÃ§in geÃ§erli olarak: YukarÄ±daki kod parÃ§asÄ±nÄ±n kullanÄ±lmasÄ±nÄ±n amacÄ± deÄŸiÅŸkenin deÄŸerinin runtime'da beli olmasÄ±nÄ± kurgulamak iÃ§indir.

        // AÅŸaÄŸÄ±daki 'if' deyimi sadece 'a = 20;' deyimini kapsar, 'b = 30;' bu statement'Ä± kapsamaz.
        if(x > 10)
            a = 20;
            b = 30;

        // AÅŸaÄŸÄ±daki if deyimi ve gÃ¶vdesi 'compone statement' olarak adlandÄ±rÄ±lmaktadÄ±r.
        if(x > 5){
            ++a;
            b--;
            foo();
        }

        return 0;
    }
    ```
   
    âš¡ "Kontrol deyimlerinin Ã¶zellikle de if deyiminin doÄŸru kÄ±smÄ±nÄ±n tek bir deyim varsa blok kullanÄ±lmalÄ± mÄ±?" diye sorulursa, Ã¼retimde kullanan da var kullanmayan da ama bu durumda sÄ±klÄ±kla blok kullanÄ±lmamasÄ± tercih ediyor.

10. Bir **if**'e baÄŸlÄ± olmayan **else** kullanÄ±mlarÄ± yanlÄ±ÅŸlÄ±kla yapÄ±labilecek **sÃ¶zdizim(syntax)** hatalarÄ±ndandÄ±r ama bu hata derleme aÅŸamasÄ±nda belli olacaktÄ±r, bu hatalar Ã§ok Ã¶nemli deÄŸildir. 

    
    ğŸ‘‡ AÅŸaÄŸÄ±daki program **if**'e ait olmayan **else** durumlarÄ±nda oluÅŸan hatalarÄ± anlamak iÃ§in incelenebilir.
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>

    double foo(void);

    int main(void)
    {
        int x;

        printf("bir sayi giriniz: ");
        scanf(%d, &x);

        // AÅŸaÄŸÄ±daki kodda 'if'i olmayan 'else' olduÄŸu iÃ§in derleme hatasÄ± oluÅŸacaktÄ±r.
        if(x % 2 == 0);
            printf("%d cift sayi\n", x);
        else
            printf("%d tek sayi\n", x);
        
        return 0;
    }
    ```

    
    ğŸš€ Error and Mistake; 
    - **Error**: Bu kavram **sÃ¶zdizimde(syntax)** oluÅŸan derleme zamanÄ± hatalarÄ±nÄ± belirtmek iÃ§in kullanÄ±lÄ±r.
    - **Mistake**: Bu kavram kodlamadaki mantÄ±k hatalarÄ±nÄ± belirtmek iÃ§in kullanÄ±lÄ±r.

    **Bad-code**: DeÄŸiÅŸken adlarÄ±nÄ±n anlaÅŸÄ±lmaz olarak verilmesi, kodun gereksiz yere tekrarlÄ± olarak yazÄ±lmÄ±ÅŸ olmasÄ± gibi kodun bakÄ±mÄ±nÄ± zorlaÅŸtÄ±ran durumlarÄ± ifade etmek iÃ§in kullanÄ±lÄ±r. **SÃ¶zdizim(syntax)** hatalarÄ± ve mantÄ±ksal hatalar **Bad-code** kavramÄ±yla ilgili deÄŸildir.
    **Good-code**: BakÄ±mÄ±, okunurluÄŸu ve Ã¼zerinde deÄŸiÅŸiklik yapÄ±labilmesi kolay kodlamalarÄ±(programlarÄ±) nitelemek iÃ§in kullanÄ±lÄ±r.

11. ProgramcÄ±lar bazen bir ÅŸartÄ±n sadece yanlÄ±ÅŸ durumu iÃ§in bir iÅŸlem yapacak kodlarÄ± yazmalarÄ± **bad-code** olarak nitelenir. DoÄŸru kÄ±smÄ±nda bir iÅŸlem yapÄ±lmayan sadece yanlÄ±ÅŸ kÄ±smÄ±nda iÅŸlem yapÄ±lan "if" deyimlerinin yazÄ±lmasÄ± doÄŸru olmayan bir yaklaÄ±ÅŸÄ±mdÄ±r.

    
    ğŸ‘‡ AÅŸaÄŸÄ±daki program "if" deyiminde **bad-code/good-code** yazÄ±mÄ±nÄ±n nasÄ±l olduÄŸunu anlamak iÃ§in incelenebilir.
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>

    double foo(void);

    int main(void)
    {
        int x;
        
        printf("bir sayi giriniz: ");
        scanf(%d, &x);

        // AÅŸaÄŸÄ±daki kodlama 'bad-code' olarak adlandÄ±rÄ±lacaktÄ±r.
        if(x < 0){

        }  
        else
            printf("sadece 'else' bloguna girecektir\n x degeri pozitif bir sayidir.", x);


        // AÅŸaÄŸÄ±daki kodlama 'bad-code' olarak adlandÄ±rÄ±lacaktÄ±r. 
        // AyrÄ±ca statement'a sahip olmayan 'if' deyimleri 'boÅŸ deyim(null-statement)' olarak kullanÄ±labilir.
        if(x < 0);  
        else
            printf("sadece 'else' bloguna girecektir\n x degeri pozitif bir sayidir.", x);

        
        // YukarÄ±daki ÅŸekilde yazmaktansa aÅŸaÄŸÄ±daki gibi yazmak daha okunaklÄ± ve anlaÅŸÄ±lmasÄ± kolay olacaktÄ±r.
        if(x >= 0)
            printf("x deÄŸeri %d olarak girildi ve pozitif bir sayidir.\n", x);
        
        return 0;
    }
    ```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.49-11.10 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


#### if Statement(if Deyimi) ile kullanÄ±lan Idiomatic YapÄ±lar

1. En sÄ±k kullanÄ±lan deyim(idiomatic) yapÄ±sÄ± `if` parantezi iÃ§inde atama operatÃ¶rÃ¼ ile oluÅŸturulan bir **ifadeyi(expression)** kullanmaktÄ±r. 
    Ã–zellikle fonksiyonlarÄ±n geri dÃ¶nÃ¼ÅŸ deÄŸerinin hata kodu olup olmadÄ±ÄŸÄ±nÄ± test etmek iÃ§in `if` deyimlerinde bu deyim(idiomatic) yapÄ±sÄ± Ã§ok kullanÄ±lmaktadÄ±r.

    
    ğŸ‘‡ AÅŸaÄŸÄ±daki programda "2. kullanÄ±m" kÄ±smÄ±ndaki kullanÄ±m C dilindeki en Ã§ok kullanÄ±lan deyim(idiomatic) yapÄ±yÄ±sÄ± anlamak iÃ§in incelenebilir.
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>

    double foo(void);

    int main(void)
    {
        int x;
        
        // 1. kullanÄ±m
        x = foo();
        if(x < 0){
            // statements
        }

        // 2. kullanÄ±m
        // Buradaki idiom en Ã§ok kullanÄ±lan C idiyom'dÄ±r. Bu kullanÄ±m Ã¶zellikle Unix/Linux sistemlerinde sÄ±k kullanÄ±lÄ±yormuÅŸ.
        if((x = foo()) < 0){
            // statements
        }

        return 0;
    }
    ```


2. C dilinde `malloc` fonksiyonuyla birlikte kullanÄ±lan aÅŸaÄŸÄ±daki programda gÃ¶rÃ¼lebilecek kodlama yaklaÅŸÄ±mÄ± C dilinde idyomatik yapÄ±dÄ±r.

    ğŸ‘‡ 
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include <stdlib.h>

    double foo(void);

    int main(void)
    {
        char *p;

        // ...


        // AÅŸaÄŸÄ±daki 'if' deyimindeki kullanÄ±m idiomatik bir yapÄ±dÄ±r.
        if((p == malloc(1024)) == NULL){
            printf("cannot allocate memory!");
            return 1;
        }
        
        return 0;
    }
    ```


3. **ctype.h** baÅŸlÄ±k dosyasÄ±nda yer alan test fonksiyonlarÄ±nÄ±n kullanÄ±lmasÄ±.

    ğŸ‘‡ AÅŸaÄŸÄ±daki programda **stype.h** kÃ¼tÃ¼phanesinin fonksiyonlarÄ±nÄ±n nasÄ±l deyim(idiomatic) olarak kullanÄ±ldÄ±ÄŸÄ± gÃ¶rÃ¼lebilir, bu kullanÄ±mlar kolay anlaÅŸÄ±labilirdir. [11:16]
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include <stdlib.h>
    #include <stype.h>

    int main(void)
    {
        int c;
        
        // AÅŸaÄŸÄ±daki gibi 'stype.h' kÃ¼tÃ¼phanesinin fonksiyonlarÄ±nÄ±n kullanÄ±lmasÄ± bir deyim(idiomatic) yapÄ±sÄ±dÄ±r.
        if(!isupper(c)){
            // do something
        }

        return 0;
    }
    ```


4. VirgÃ¼l operatÃ¶rÃ¼ ile oluÅŸturulan C deyim(idiomatic) ifadeleri.

    
    ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir **if deyimi(if statement)** dÄ±ÅŸÄ±nda kalan bir statement'Ä±n nasÄ±l if parantezi iÃ§inde `,` operatÃ¶r ile birlikte kullanÄ±ldÄ±ÄŸÄ± deyim(idiomatic) yapÄ±sÄ± gÃ¶rÃ¼lebilir.
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>

    int main(void)
    {
        int x;
        
        // ...

        // 1. kullanÄ±m
        scanf("%d", &x);
        if(x > 0){
            // ...
        }
        
        // 2. kullanÄ±m, bu kullanÄ±m bir deyim(idiomatic) yapÄ±sÄ±dÄ±r
        if(scanf("%d", &x), x > 0){
            // ...
        }

        return 0;
    }


5. C dilinde Ã§ok kullanÄ±lan deyim(idiomatic) yapÄ±larÄ±ndan biri **if deyiminin(statement)** birden fazla **statement(deyim)** aldÄ±ÄŸÄ± durumlarda **curly-break** kullanmamak iÃ§in `if`e ait olan deyimleri tek bir **deyim(statement)** haline getirip **curly-break** kÄ±smÄ±nÄ± silmektir.

    â”
    MÃ¼lakatlarda sÄ±k sorulan sorularÄ±ndan biri, bu soru Ã§ok Ã¶nemli deÄŸilmiÅŸ ama bazen soruluyormuÅŸ:
    Ä°ki tam sayÄ±nÄ±n deÄŸerini 3. deÄŸiÅŸken kullanmadan takas(swap) ediniz(buna **xor swap** deniyor).

    
    ğŸ‘‡ AÅŸaÄŸÄ±daki program ile iki sayÄ±nÄ±n Ã¼Ã§Ã¼ncÃ¼ bir deÄŸiÅŸken kullanmadan nasÄ±l birbiriyle deÄŸiÅŸtirilebileceÄŸi incelenebilir.
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include <stdlib.h>

    int main(void)
    {
        int x = 10, y = 20;
        
        printf("x = %d, y = %d", x, y);
        
        x ^= y;
        y ^= x;
        x ^= y;

        // YukarÄ±daki Ã¼Ã§ statement aÅŸaÄŸÄ±daki gibi tek bir statement olarak yazÄ±labilir.
        // x ^= y, y ^= x, x ^= y;
        
        printf("x = %d, y = %d", x, y);

        return 0;
    }
    ```

6. **Dangling else**, blok kullanmadan yapÄ±lan kodlamalarda "else" kÄ±smÄ±nÄ±n kendisine en yakÄ±n olan `if`e ait olmasÄ± durumuna ifade eden terimdir.

    
    ğŸ‘‡ AÅŸaÄŸÄ±daki sÃ¶zde kod **dangling else** durumunu anlamak iÃ§in incelenebilir.
    ```C
    if(a > b)
        if(b > 10)
            foo();
        else // Buradaki 'else'e 'dangling else' deniliyor
            bar();

    if(a > b){
        if(b > 10)
            foo();
        }
    else
        bar();

    ```


7. **else-if merdiveni(else-if ladder)**, programlamaya yeni baÅŸlayanlar **else-if merdiveni(else-if ladder)** kullanÄ±mÄ±nda Ã§oÄŸunlukla hata yapÄ±yormuÅŸ. 

    
    ğŸ‘‡ AÅŸaÄŸÄ±daki programda **else-if merdiveni(else-if ladder)** kullanÄ±mÄ± incelenebilir.
    ```C
    // AyrÄ±k if kullanÄ±mÄ±
    if(exp1)
        statement1;

    if(exp2)
        statement2;

    if(exp3)
        statement3;


    // 'else-if merdiveni' kullanÄ±mÄ± aÅŸaÄŸÄ±daki gibidir;
    if(exp1)
        statement1;
    else if(exp2)
        statement2;
    else if(exp3)
        statement3;

    if(x == 1)
        ++a;
    else if(x == 3)
        ++b;
    else if(x == 17) // Buradaki koÅŸul tÃ¼m if-else bloÄŸuna bakÄ±ldÄ±ÄŸÄ±nda 'x != 1 && x != 3 && x == 17' ÅŸeklindedir.
        ++c;
    else if(x == 17)
        foo();
    else
        bar();
    ```


â—**else-if merdiveni** yapÄ±sÄ±yla ilgili birkaÃ§ tane saptama aÅŸaÄŸÄ±daki gibidir;
1. En son **if**'in **else**'i yoksa iÅŸlem yapÄ±lmadan Ã§Ä±kÄ±labilir.
2. Derleyici Ã¶zel bir optimizasyon yapmÄ±yorsa **else-if merdiveni** kullanÄ±lmasÄ± gereken yerlerde birden fazla koÅŸulun sÃ¼rekli gereksiz yere kontrol edilmesi verimli bir kodlama deÄŸildir.


ğŸ§  EÄŸer **else-if merdiveni(else-if ladder)** basamaklardan birinde doÄŸru olma olasÄ±lÄ±ÄŸÄ± ya da sÄ±klÄ±ÄŸÄ± diÄŸerlerine gÃ¶re daha yÃ¼ksek bir koÅŸul varsa bu koÅŸulun if-else bloÄŸunun Ã¼st sÄ±ralarÄ±nda olmasÄ± daha doÄŸrudur.

ğŸŒŸ BazÄ± else-if merdivenleri yerine **switch deyimini(statement)** kullanmak kodun daha kolay okunmasÄ±nÄ± saÄŸladÄ±ÄŸÄ± gibi derleyicinin daha iyi kod Ã¼retmesini saÄŸlayabilir, derleyiciler **switch deyimini(statement)** kullanÄ±mlarÄ±nda **jump table** oluÅŸturup daha performanslÄ± makine kodu oluÅŸturabilir.

âš ï¸ Her **else-if merdiveni(else-if ladder)** **switch deyimini(statement)** ile oluÅŸturulamayabilir, Ã¶zellikle iÃ§ iÃ§e kullanÄ±mlarda.


#### Hidden else(Gizli else)   

Kodda fiilen yazÄ±lan **else** yok ama baÄŸlamda else anlamÄ± varsa bu durumu belirtmek iÃ§in **hidden else** terimi kullanÄ±lÄ±r.

**Hidden else** daha Ã§ok **return**, **break**, **continue**, **goto** deyimlerinde(statement) karÅŸÄ±mÄ±za Ã§Ä±kacaktÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki program **hidden else** terimini daha iyi anlayabilmek iÃ§in incelenebilir. 
```C
double foo(int x)
{
    if(x > 10)
        return x;
    else
        return x * x * x -1;
}

double foo(int x)
{
    if(x > 10)
        return x;
    
    return x * x * x -1; // Buradaki kullanÄ±m 'hidden-else'tir
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki iki kullanÄ±m da aynÄ±dÄ±r ve 2. kullanÄ±mda **hidden else** vardÄ±r. 
```C

// 1. kullanÄ±m
while(expr)
{
    if(x > 10)
        break;
    else{
        statement1;
        statement2;
        statement3;
        statement4;
    } 
}

// 2. kullanÄ±m
while(expr)
{
    if(x > 10)
        goto out; // 'out' etiketi dÃ¶gÃ¼ dÄ±ÅŸÄ±nda bir yerde olacaktÄ±r, burada Ã¶nemli deÄŸil.
    
    statement1;
    statement2;
    statement3;
    statement4;
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.06-12.15 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


## C Dilinin SÄ±k KullanÄ±lan Standart Fonksiyonu Olan **getchar** Fonksiyonu

"**getchar**" standart C fonksiyonu geri dÃ¶nÃ¼ÅŸ deÄŸeri **int** olan ve parametre almayan bir fonksiyondur, "getchar" fonksiyonunun adÄ± "Get Character" sÃ¶zcÃ¼klerinden gelmektedir. `int getchar(void);` ÅŸeklinde **bildirimi(declaration)** vardÄ±r.

**getchar** Fonksiyonu Standart input fonksiyonlarÄ±ndandÄ±r ve aÅŸaÄŸÄ±daki Ã¶zelliklere sahiptir;
1. Standart input buffer'Ä±ndan sadece tek bir **karakter(byte)** alÄ±r.
2. **getchar** line-buffered(newline isteyer) bir fonksiyondur yani Ã§alÄ±ÅŸmasÄ± iÃ§in enter tuÅŸuna basÄ±lmasÄ± gerekiyor, bundan sonra Ã§alÄ±ÅŸÄ±r.
3. **getchar** echo veren bir fonksiyondur. **echo** vermek demek ÅŸu demektir: GiriÅŸ iÅŸlemi yapÄ±lÄ±rken **standard output**'a Ã§Ä±ktÄ±ÅŸ yapÄ±lmasÄ± demektir, konsoldan giriÅŸ iÅŸlemi yapÄ±lÄ±yorsa konsola giriÅŸ yapÄ±lan karakterlerin yazÄ±lmasÄ± echo verme durumunu ifade eder.
4. C dilinin standart **getchar** ve **scanf** fonksiyonlarÄ± **standard input buffer**'Ä±nÄ± kullanÄ±rlar, bu aynÄ± yerden deÄŸer Ã§ektikleri(okuduklarÄ±) anlamÄ±na gelir.
5. **getchar** standart input'un buffer'Ä± boÅŸ olduÄŸunda geriye **-1** deÄŸer dÃ¶ndÃ¼rÃ¼r.



ğŸ‘‡ AÅŸaÄŸÄ±daki program **getchar** fonksiyonunun nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± anlamak iÃ§in incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    printf("bir karakter girin: ");
    int c = getchar(); // standart input'un buffer deÄŸeri: !23423mete

    printf("%d -> %c\n", c, c);
    
    return 0;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program **getchar** ve **scanf** fonksiyonlarÄ±nÄ±n **standard input buffer**'Ä±nÄ± kullandÄ±ÄŸÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    printf("bir karakter girin: ");
    int c = getchar(); // '!23434memo' ÅŸeklinde giriÅŸ yapÄ±ldÄ±ÄŸÄ±nda 
    
    printf("%d -> %c\n", c, c);

    int x;
    char str[100];

    scanf("%d%s", &x, &str);
    printf("x = %d\n ad:", x, str);
    
    return 0;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program **getchar** fonksiyonunun **standard input buffer** boÅŸ iken "-1" deÄŸer dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ incelenebilir.
Windows ortamÄ±nda giriÅŸ beklenen yerlerde "Ctrl + Z" tuÅŸuna basÄ±lmasÄ± **standard input buffer**'Ä±nÄ±n boÅŸ bÄ±rakÄ±lmasÄ±nÄ± saÄŸlar.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    printf("bir karakter girin: ");
    int c = getchar();  

    printf("%d -> %c\n", c, c);

    return 0;
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki program **standard input buffer**'Ä±ndan tÃ¼m karakterleri okuyup **standard input**'a gÃ¶nderecektir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int c;  

    while((c = getchar()) != '\n'){
        printf("%d  %c\n", c, c);
    }

    return 0;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programÄ±n amacÄ± **scanf** benzeri bir fonksiyon nasÄ±l oluÅŸturulabileceÄŸinin incelenebilmesidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

// AÅŸaÄŸÄ±daki fonksiyon **scanf** fonksiyonun yaptÄ±ÄŸÄ± iÅŸi sadece int tÃ¼rÃ¼ iÃ§in 'standard input buffer'dan okuma iÅŸlemini yapan bir fonksiyondur.
// Fonksiyon giriÅŸ yapÄ±lan deÄŸerin sadece int tÃ¼rÃ¼nden olacaÄŸÄ± varsayÄ±larak yazÄ±lmÄ±ÅŸtÄ±r.
void scanint(int* p)
{
    int c;
    int temp = 0;

    while((c = getchar()) != '\n'){
        temp = temp * 10 + c - '0'; 
    }

    *p = temp;
}

int main(void)
{
    int x;
    printf("pozitif bir tam sayi girin: ");  
    scanint(&x);
    
    printf("x = %d\n", x);
    
    return 0;
}
```


â” 
C mÃ¼lakatlarÄ±nda Ã§ok sorulan bir soru aÅŸaÄŸÄ±daki gibidir;
- Girilen bir tam sayÄ±nÄ±n Ã¼Ã§e tam bÃ¶lÃ¼nÃ¼p bÃ¶lÃ¼nmediÄŸini tespit eden bir program yazÄ±nÄ±z ?
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x;

    printf("bir karakter girin: ");
    
    while((ch = getchar()) != '\n'){
        // Buradaki kullanÄ±mÄ±n nedenini anlamak Ã¶nemlidir.
        sum += ch - '0'; // 'ch' deÄŸiÅŸkeni bir rakam karakteri ve biz bu rakam karakterinin karÅŸÄ±lÄ±k geldiÄŸi sayÄ±sal deÄŸerini bulmak iÃ§in '0' karakterinden Ã§Ä±kartÄ±yoruz, tÃ¼m karakter kodlamalarÄ±nda on tabanÄ±ndaki rakam karakterlerinin kodlarÄ±nÄ±n 0'dan 9'a kadar sÄ±ralÄ± olduÄŸu kesin olduÄŸu iÃ§in bu iÅŸlem ile rakam karakterinin sayÄ±sal kaÅŸÄ±lÄ±ÄŸÄ±nÄ± buluyoruz.
    }

    if(sum % 3 == 0)
        printf("evet bolunur.\n");
    else
        printf("hayir bolunur.\n");
    
    return 0;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program klavyeden girilen bir karaktere gÃ¶re bir iÅŸlem yapÄ±lÄ±p yapÄ±lmamasÄ±nÄ± saÄŸlamak iÃ§in nasÄ±l kodlama yapÄ±labileceÄŸini gÃ¶rmek iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    printf("evet mi(e), hayir mi(h)?: ");
    int c = getchar();

    if(c == 'e')
        printf("evet dediniz.\n");
    else if(c == 'h')
        printf("hayir dediniz.\n");
    else
        printf("cevabiniz geÃ§ersiz.\n");
    
    return 0;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program **getchar** fonksiyonunun onar onar sayÄ±larÄ±n yazdÄ±rÄ±lmasÄ± ÅŸeklinde nasÄ±l kullanÄ±ldÄ±ÄŸÄ±nÄ± anlamak iÃ§in incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    for(int i = 0; i < 5000; ++i){
        if(i && i % 10 == 0)
            (void)getchar(); // Burada kullanÄ±lan 'getchar' fonksiyonu klavyeden 'enter' giriÅŸi beklemek iÃ§in kullanÄ±lmÄ±ÅŸtÄ±r, dÃ¶nÃ¼ÅŸ deÄŸeri kullanÄ±lmayacaÄŸÄ± iÃ§in '(void)' ile geri dÃ¶nÃ¼ÅŸ deÄŸeri 'discarde' edilmiÅŸtir.
        printf("%d", i);
    }

    return 0;
}
```



âš ï¸ **getchar**'Ä±n geri dÃ¶nÃ¼ÅŸ deÄŸeri fonksiyonun varlÄ±k nedeni olduÄŸu iÃ§in **getchar** fonksiyonunun geri dÃ¶nÃ¼ÅŸ deÄŸerini kullanmamak **logic error** olarak deÄŸerlendirilir.

âš ï¸ EÄŸer bir fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸeri varlÄ±k nedeni ise ya da geri dÃ¶nÃ¼ÅŸ deÄŸerini kullanmak lojik aÃ§Ä±dan bir zorunluluk ise ama buna karÅŸÄ±lÄ±k bilerek isteyerek geri dÃ¶nÃ¼ÅŸ deÄŸerini kullanmÄ±yorsanÄ±z bunu belirtmek iÃ§in `(void)` **casting** kullanÄ±lmalÄ±dÄ±r.


> â”	
> 
> Sorulan Soru; 
> 
> O zaman encoding'e gÃ¶re algoritmamÄ±z da deÄŸiÅŸebilir mi, 'c' - 0 ifadesi icin soruyorum? 
> 
> Cevap;
> 
> DeÄŸiÅŸmez Ã§Ã¼nkÃ¼ rakam karakterlerinin hangi encoding olursa olsun ardÄ±ÅŸÄ±k olma kesinliÄŸi vardÄ±r ama harf karakterleri iÃ§in bu kesinlik yoktur.



ğŸ‘‡ AÅŸaÄŸÄ±daki program **getchar** fonksiyonu ile girilen bir hex sayÄ±nÄ±n decimal olarak nasÄ±l yazdÄ±rÄ±ldÄ±ÄŸÄ±nÄ± anlamak iÃ§in incelenebilir. ASCII karakter kodlamasÄ± dÄ±ÅŸÄ±ndaki kodlamalarda doÄŸru Ã§alÄ±ÅŸmayabilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    printf("bir hex sayi girin: ");
    
    int c;
    int result = 0;
    
    while((c == getchar()) != '\n'){
        if(c >= '0' && c <= '9')
            result = result * 16 + c - '0'; // Burada '16' ile Ã§arpÄ±p on tabanÄ±ndaki basamak deÄŸeri elde ediliyor.
        else if(c >= 'A' && c <= 'F')
            result = result * 16 + c - 'A' + 10;
        else if(c >= 'a' && c <= 'f')
            result = result * 16 + c - 'a' + 10;
    }
    
    printf("girilen sayi: %d\n", );
}
```



âš ï¸ C programlarÄ±nda her ÅŸeyin standart C fonksiyonlarÄ±yla yapÄ±lmasÄ± mÃ¼mkÃ¼n deÄŸildir, mesela C standart kÃ¼tÃ¼phenelerinde echo vermeyen bir fonksiyon yoktur.

âš¡ Standart olmaya ".h" uzantÄ±lÄ± baÅŸlÄ±k dosyalarÄ±nda sÃ¼rekli derlenme yapÄ±lmasÄ± gerekmemesi iÃ§in derleyicide derlenmiÅŸ halleri tutulmaktadÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki program ile **getchar** ve **_getch** fonksiyonlarÄ±nÄ±n Ã§alÄ±ÅŸmasÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // Standart kÃ¼tÃ¼phane('head' dosyasÄ±) deÄŸildir.

int main(void)
{
    printf("bir karakter giriniz: ");
    int c2 = getchar();
    printf("\ngirdiÄŸiniz karakter: %c\n", c2); // echo verir ve 'new-line' ister.


    printf("bir karakter giriniz: ");
    int c2 = _getch(); // '_getch' fonksiyonu standart deÄŸildir ve Windos derleyicisinde bulunmaktadÄ±r. 'new-line' istemeyen ve 'echo' vermeyen bir fonksiyondur.
    printf("\ngirdiÄŸiniz karakter: %c\n", c2);
}
```


Ders sonu ...
