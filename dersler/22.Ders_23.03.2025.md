# 22.Ders 23.03.2025 ğŸ•˜

Derse 9(09:01)-16(09:31)-18(10:01)-18(11:00)-17(12:04)-xx(12:45) kiÅŸi katÄ±ldÄ±.
---

ğŸš€ KÃ¼Ã§Ã¼k tam sayÄ± tÃ¼rlerinden bÃ¼yÃ¼k tam sayÄ± tÃ¼rlerine dÃ¶nÃ¼ÅŸÃ¼mde iÅŸaretli iÅŸaretsiz farkÄ± olmadÄ±ÄŸÄ± sÃ¼rece bir karmaÅŸÄ±klÄ±k yoktur.

ğŸš€ BÃ¼yÃ¼k tam sayÄ± tÃ¼rÃ¼nden kÃ¼Ã§Ã¼k tam sayÄ± tÃ¼rÃ¼ne yapÄ±lan tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mlerinde veri kaybÄ± oluÅŸabilir.

ğŸš€ Ä°ÅŸaretli bÃ¼yÃ¼k tam sayÄ±dan kÃ¼Ã§Ã¼k tam sayÄ± tÃ¼rÃ¼ne yapÄ±lan dÃ¶nÃ¼ÅŸÃ¼mler derleyiciye baÄŸlÄ±dÄ±r ama **tanÄ±msÄ±z davranÄ±ÅŸ(ub)** deÄŸildir ve derleyicilerin hemen hepsi bu iÅŸlemi yÃ¼ksek anlamlÄ± byte'larÄ± silecek ÅŸekilde yapmaktadÄ±r. Mesela 4 byte bÃ¼yÃ¼klÃ¼kteki iÅŸaretli bir tam sayÄ± deÄŸeri 2 byte bÃ¼yÃ¼klÃ¼kteki iÅŸaretli bir tam sayÄ± deÄŸiÅŸkene atarsak yÃ¼ksek anlamlÄ± byte'lar atÄ±ldÄ±ktan sonra geriye kalan byte'lar atanacaktÄ±r.

ğŸš€ Ä°ÅŸaretsiz sayÄ±lar olunca modÃ¼ler aritmetik devreye girmektedir ve **wrap around** olarak adlandÄ±rÄ±lan bir iÅŸlem uygulanmaktadÄ±r. Ä°ÅŸaretsiz tam sayÄ± tÃ¼rlerine yapÄ±lan atamalarda derleyiciye baÄŸlÄ± bir durum yok bu durum C standardÄ± tarafÄ±ndan belirlenmiÅŸtir.

ğŸš€ TÃ¼r dÃ¶nÃ¼ÅŸÃ¼mleri **Implicity Type Conversions(Ã–rtÃ¼lÃ¼ TÃ¼r DÃ¶nÃ¼ÅŸÃ¼mleri)** ve **Explicit Type Conversions(AÃ§Ä±k TÃ¼r DÃ¶nÃ¼ÅŸÃ¼mleri)** olarak ikiye ayrÄ±lmaktadÄ±r ve aÃ§Ä±klamalarÄ± bir Ã¶nceki ders notunda vardÄ±r.

ğŸš€ **Explicit Type Conversions(AÃ§Ä±k TÃ¼r DÃ¶nÃ¼ÅŸÃ¼mleri)** ile veri kaybÄ± olabilecek tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mlerinde derleyiciye ve kodu sonradan okuyacak kiÅŸiye yapÄ±lan iÅŸlemin bilinÃ§li olarak yapÄ±ldÄ±ÄŸÄ±nÄ± ifade etmek iÃ§in kullanÄ±lÄ±yor. Bunun dÄ±ÅŸÄ±nda yapÄ±lan bir iÅŸlemin sonucunun istenilen tÃ¼re Ã§evirmek iÃ§in kullanÄ±lÄ±yor, mesela iki int tÃ¼rÃ¼nden deÄŸiÅŸken `/` operatÃ¶rÃ¼ ile iÅŸleme tabi tutuluyorsa sonucun ondalÄ±klÄ± olabilmesi iÃ§in tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ `(double)first_int/ second_int` gibi uygulanÄ±r.

ğŸš€ Bir **ifadede(expression)** constand(sabit) varsa kodun daha ÅŸÄ±k durmasÄ± iÃ§in tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ sabitler Ã¼zerinden yapÄ±lmalÄ±dÄ±r, mesela `int x = 4; double d = (double)x / 3` yerine `int x = 4; double d = x / 3.` ÅŸeklinde yapÄ±lmalÄ±dÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda kullanÄ±cÄ±dan alÄ±nan bir ondalÄ±k sayÄ±nÄ±n herhangi bir kÃ¼tÃ¼phane kullanÄ±lmadan kÃ¼sÃ¼rrata gÃ¶re nasÄ±l aÅŸaÄŸÄ± ya da yukarÄ±ya yuvarlandÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    double dval;

    printf("bir ondalikli sayi giriniz: ");
    scanf("%lf", &dval);

    printf("%d\n", (int)(dval + (dval > 0. ? .5 : -.5)));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda girilen sÃ¼renin kaÃ§ saat yaptÄ±ÄŸÄ± hesaplanmaktadÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int hour, min, sec;

    printf("saat dakika saniye olarak sureyi giriniz: ");
    scanf("%d%d%d", &hour, &min, &sec);

    printf("%f saat \n", hour + min / 60. + sec / 3600.);
}
```


>â”
> 
> SorduÄŸum soru; 
> 
> Merhaba, tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ iÅŸlemlerindeki kurallarda C ve C++ dilleri arasÄ±nda farklÄ±lÄ±k var mÄ± yoksa C dilindeki kurallar C++ dili iÃ§in de tamamen geÃ§erli mi?
> 
> Cevap;
> 
> Kurallar aynÄ± ama tÃ¼rsel aÃ§Ä±dan ufak bir farklÄ±lÄ±k var, C dilinde **_Bool** tÃ¼rÃ¼ varken C++ dilinde **bool** tÃ¼rÃ¼ vardÄ±r.
> 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda C dilindeki **_Bool** tÃ¼rÃ¼ iÃ§in uygulanan tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ kurallarÄ± gÃ¶rÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    _Bool x;
    int ival = 3268;

    x = ival;
    printf("x = %d\n", x);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda C dilindeki `stdbool.h` baÅŸlÄ±k dosyasÄ±nda(C99 standardÄ±yla dile eklenmiÅŸtir) bulunun makrolarÄ±n kullanÄ±mÄ± incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdbool.h> // Bu baÅŸlÄ±k dosyasÄ±nda 'bool', 'true', 'false' vb. makrolar vardÄ±r.

int main(void)
{
    bool flag = false; // Ã–niÅŸlemci program Ã§alÄ±ÅŸtÄ±ktan sonra bu satÄ±r '_Bool flag = 0;' olarak deÄŸiÅŸtirilir.

    flag = true; // Ã–niÅŸlemci program Ã§alÄ±ÅŸtÄ±ktan sonra bu satÄ±r 'flag = 1;' olarak deÄŸiÅŸtirilir.
}
```


## Arrays(Diziler) [Bu konu 8-10 saat sÃ¼recek]  

Hangi dilde program yazÄ±yor olursak olalÄ±m Ã§oÄŸunlukla veriler Ã¼zerinde iÅŸlemler gerÃ§ekleÅŸtiriyoruz, mesela bir resimdeki pixel'ler Ã¼zerinde iÅŸlem yapacaÄŸÄ±z ya da bir tarih aralÄ±ÄŸÄ±ndaki sipariÅŸler gezilip hazÄ±r olanlarÄ±n kargo aktarÄ±mÄ± iÅŸlemleri gerÃ§ekleÅŸtirilecekse bu iÅŸlemleri verileri iÅŸleyere yaparÄ±z. </br>
MantÄ±ksal iliÅŸki iÃ§indeki veriler Ã¼stÃ¼nde bazÄ± iÅŸlemler yapma ihtiyacÄ± her programlama dilinde karÅŸÄ±mÄ±za Ã§Ä±kacaktÄ±r. </br>
Hemen her zaman Ã¼stÃ¼nde iÅŸlem yapÄ±lacak verilerin bellekte tutulmasÄ± gerekiyor, peki bu verileri bellekte nasÄ±l tutacaÄŸÄ±z? Bu sorunun cevabÄ± **data structure(Veri yapÄ±sÄ±)** kullanmaktÄ±r, bir Ã§ok farklÄ± veri yapÄ±sÄ± vardÄ±r(Lincket list, Binary-Tree, Hash table vb.). </br>
Veri yapÄ±sÄ± demek mantÄ±ksal iliÅŸki iÃ§indeki verilerin onlara ulaÅŸabileceÄŸimiz ÅŸekilde bellekte bir dÃ¼zende tutulmasÄ± demektir, bunu saÄŸlayan dÃ¼zeneÄŸe **data structure(Veri yapÄ±sÄ±)** denilmektedir. </br>

**Data structure(Veri yapÄ±sÄ±)**: Bu tanÄ±mdan bahsederken aslÄ±nda bir implemantation(gerÃ§ekleÅŸtirmesi yapÄ±lmÄ±ÅŸ, yazÄ±lmÄ±ÅŸ birkoddan bahsediliyor) iÅŸlemi belirtilmektedir.

**Absract data type(Soyut veri yapÄ±sÄ±)**: Bu tanÄ±m kullanÄ±ldÄ±ÄŸÄ± Ã§oÄŸu yerde **ADT** olarak kÄ±saltÄ±larak kullanÄ±lmaktadÄ±r. Bu tanÄ±mda **Veri yapÄ±sÄ±nÄ±n(Data structure)** soyut olarak nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ± tanÄ±mlarÄ±(aÃ§Ä±klamalarÄ±) belirtilmektedir. **Queue** kuyruk yapÄ±sÄ±, **Stack** son giren ilk Ã§Ä±kar(LIFO) ÅŸeklinde farklÄ± veri yapÄ±larÄ±nÄ±n Ã§alÄ±ÅŸma ÅŸeklini ifade eder. Bu terim gerÃ§ekleÅŸtirimden baÄŸÄ±msÄ±z olarak veri yapÄ±larÄ±nÄ±n soyut olarak akÄ±lda canlanan halini ifade etmek iÃ§in kullanÄ±lÄ±r.

**Algorithm**: Bu terim yazÄ±lÄ±mda Ã§oÄŸunlukla bir veri yapÄ±sÄ± Ã¼zerinden yapÄ±lacak iÅŸlemin hangi adÄ±mlarla ne ÅŸeklide yapÄ±lacaÄŸÄ±nÄ±n aÃ§Ä±k ÅŸekilde belirtiliÅŸine verilen addÄ±r.

**Dynamic array(deÄŸiÅŸken dizi)**: Bu veri yapÄ±sÄ±nda dizinin elemanlarÄ± bellekte peÅŸi sÄ±ra tutulmaktadÄ±r ve yeni dÃ¼ÄŸÃ¼m ekleyip Ã§Ä±karma iÅŸlemleri yapÄ±labiliyor.  

ğŸ§  En Ã§ok kullanÄ±lan **Absract data type(Soyut veri yapÄ±sÄ±)** ÅŸunlardÄ±r: **Dynamic array**, **Link list** tÃ¼revleri olan **Singly linked lists.** **Doubly linked lists.** **Circular linked lists.** **Circular doubly linked lists.**, **Tree** tÃ¼revleri olan **Binary Tree** **Binary Search Tree** vb., **Hash table**, **Graphs** tÃ¼revleri.

Eldeki verilerin ne ÅŸekilde iÅŸleneceÄŸine baÄŸlÄ± olarak hangi **data structure(Veri yapÄ±sÄ±)** kullanÄ±ldÄ±ÄŸÄ± Ã§alÄ±ÅŸan algoritmanÄ±n maliyetini etkileyecektir.

ğŸ§  **Absract data type(Soyut veri yapÄ±sÄ±)** terimi soyut olarak veri yapÄ±larÄ±nÄ±n ne olduÄŸunun aÃ§Ä±klanmasÄ± ve zihinde canlanmasÄ±nÄ± ifade eder, **Data structure(Veri yapÄ±sÄ±)** terimi veri yapÄ±larÄ±nÄ±n gerÃ§ekleÅŸtirimlerini(implementation) ifade eder.



â— C dilinin standardÄ±nda sadece **fixed array(static array)** veri yapÄ±sÄ± desteÄŸi vardÄ±r. </br>
â— Programlarda Ã§ok uzak ara en Ã§ok kullanlan **veri yapÄ±sÄ±(Data structure)** **Dynamic array**'dir ama C dilinin standardÄ±nda yoktur. </br>
â— **fixed array(static array)** veri yapÄ±sÄ± dÄ±ÅŸÄ±ndaki baÅŸka bir veri yapÄ±sÄ±nÄ± kullanabilmek iÃ§in ya kendimizin yazmasÄ± gerekir ya da Ã¼Ã§Ã¼ncÃ¼ tarafa kÃ¼tÃ¼phanelerin kullanÄ±lmasÄ± gerekiyor.


Veri yapÄ±larÄ±nÄ±n hepsinde en Ã§ok kullanÄ±lan iÅŸlemler **ekleme(insert - insertion)**, **deÄŸer silme(erasure)**, **dÃ¼ÄŸÃ¼m silme(remove)** iÅŸlemleridir. </br>
C dilinde olan tek veri yapÄ±sÄ± olan **fixed array(static array)** ekleme(insert - insrtion) ve silme(remove) iÅŸlemlerine sahip deÄŸildir.


C dilinde en Ã§ok kullanÄ±lan **string literal(yazÄ± sabitleri)** aslÄ±nda **fixed array(static array)** veri yapÄ±sÄ±dÄ±r.

**Algorithm**: Bu terim genel bir terimdir sÄ±ralÄ± olarak bir iÅŸin/iÅŸlemin adÄ±m adÄ±m nasÄ±l yapÄ±ldÄ±ÄŸÄ±nÄ± tarif eden aÃ§Ä±klamalara verilen addÄ±r. Bu terim ilk bakÄ±ÅŸta sadece yazÄ±lÄ±mda kullanÄ±lan bir terimmiÅŸ gibi zannedilse de bir yemek tarifinde, bir matematik denkleminin Ã§Ã¶zÃ¼mÃ¼nde, tÄ±pta bir hastalÄ±ÄŸÄ±n hangi adÄ±mlarla tedavi edildiÄŸi de bir algoritmadÄ±r.

ğŸ§  Veri yapÄ±sÄ± verilerin bellekte nasÄ±l tutulacaÄŸÄ±nÄ± belirtirken, algoritma hangi iÅŸlemlerin hangi sÄ±rayla yapÄ±lacaÄŸÄ±nÄ± belirtir. Veri yapÄ±larÄ±yla algoritma kavramÄ± iÃ§i iÃ§ie geÃ§miÅŸtir.


## Complexity of an Algorithm(AlgoritmanÄ±n karmaÅŸÄ±klÄ±ÄŸÄ±) 

En Ã¶nemli kavramlardan biri **AlgoritmanÄ±n karmaÅŸÄ±klÄ±ÄŸÄ±(Complexity of an algorithm)** terimidir.

**AlgoritmanÄ±n karmaÅŸÄ±klÄ±ÄŸÄ±(Complexity of an algorithm)** saniyeyle, milisaniyeyle, nanosaniyeyle ilgili bir birim deÄŸildir, bir algoritmanÄ±n yapacaÄŸÄ± iÅŸlem adÄ±mlarÄ±nÄ±n maliyetiyle ilgili bilgi vermektedir.

**Computational complexity(Hesaplama karmaÅŸÄ±klÄ±ÄŸÄ±)**: Veri yapÄ±sÄ±ndaki Ã¶ÄŸe sayÄ±sÄ±nÄ±n artmasÄ± ile yapÄ±lan iÅŸlem sayÄ±sÄ±nÄ±n artmasÄ± arasÄ±ndaki iliÅŸkidir.

**Complexity of an algorithm(AlgoritmanÄ±n karmaÅŸÄ±klÄ±ÄŸÄ±)** konusundan bahsederken **Big O Notation** adÄ± kullanÄ±lmaktadÄ±r.

ğŸ§­ AÅŸaÄŸÄ±da bazÄ± temel **algoritmanÄ±n karmaÅŸÄ±klÄ±ÄŸÄ±(Complexity of an algorithm)** tÃ¼rleri gÃ¶rÃ¼lebilir;
- **Constant Time Complexity**: $O(1)$ olarak gÃ¶sterilir. Bir **fixed array(static array)** veri yapÄ±sÄ±nda index numarasÄ± bilinen bir elemana tek bir aritmetik hesaplamayla eriÅŸilebilir.
- **Linear Time Complexity**: $O(n)$ olarak gÃ¶sterilir. Bir **fixed array(static array)** veri yapÄ±sÄ±nda bir deÄŸerin aranmasÄ± iÅŸleminde dizinin eleman sayÄ±sÄ±na baÄŸlÄ± olarak yapÄ±lan iÅŸlem sayÄ±sÄ± doÄŸrusal olacaktÄ±r.
- **Logaritmic Time Complexity**: $O(Log n)$ olarak gÃ¶sterilir. Bir **ikili arama aÄŸacÄ±(binary search tree)** veri yapÄ±sÄ±nda yapÄ±lan arama iÅŸlemleri bu karmaÅŸÄ±klÄ±ktadÄ±r.
- **Quadratic Time Complexity**: $O(n^2)$ olarak gÃ¶sterilir. Ä°Ã§ iÃ§e kullanÄ±lan dÃ¶ngÃ¼ler Ã§oÄŸu zaman bu karmaÅŸÄ±klÄ±k seviyesindedir.


â—YazÄ±lÄ±m mÃ¼lakatlarÄ±nda sorulan en temel sorulardan biri verilen bir programÄ±n algoritma karmaÅŸÄ±klÄ±ÄŸÄ±nÄ±n hesaplanmasÄ±dÄ±r ya da bir algoritmanÄ±n belirli bir zaman karmaÅŸÄ±klÄ±ÄŸÄ± ya da daha performans ÅŸartÄ±nÄ± saÄŸlayacak ÅŸekilde programÄ±nÄ±n yazÄ±lmasÄ±nÄ±n istenmesidir.


Bir algoritmanÄ±n karmaÅŸÄ±klÄ±ÄŸÄ± aÅŸaÄŸÄ±daki gibi olabilir;
- $O(1)$                    1 iÅŸlem
- $O(Log n)$                5 iÅŸlem
- $O(n)$                    32 iÅŸlem
- $O(n Logn)$               160 iÅŸlem
- $O(n Log2n)$              25 * 32 iÅŸlem
- $O(n^2)$                  32 * 32 iÅŸlem
- $O(n^2 Logn)$             32 * 32 * 5 iÅŸlem
- $O(n^3)$                  
- $O(n^4)$
- $O(2^n)$                   
- $O(n^n)$
- $O(n!)$


ğŸ” **Merge Algoritm**: Bu algoritma iki farklÄ± diziyi birleÅŸtirmek iÃ§in kullanÄ±lan algoritmadÄ±r, bunu ayrÄ±ca araÅŸtÄ±rabilirsin.


â— YazÄ±lan bir algoritmanÄ±n **algoritmanÄ±n karmaÅŸÄ±klÄ±ÄŸÄ±(Complexity of an algorithm)** bÃ¼nyesinde kullanÄ±lan karmaÅŸÄ±klÄ±ÄŸÄ± oluÅŸturan iÅŸlem bÃ¶lÃ¼mlerinden en yÃ¼ksek karmaÅŸÄ±klÄ±ÄŸa sahip olan karmaÅŸÄ±klÄ±k olarak gÃ¶sterilir. 


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.31-10.52 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


## C Dilinde Diziler [10.53:00]


C dilindeki diziler **fixed array(static array)** Ã¶zelliÄŸindedir, bir dizinin dÃ¼ÄŸÃ¼mlerinin tÃ¼rleri herhangi bir tÃ¼rden olabilir.

â— Bir dizide aynÄ± tÃ¼rden olan deÄŸiÅŸkenler tutulur ve **sÃ¶zdizimi(syntax)**  `<array-type> array-name[constand-variable]` ÅŸeklindedir, `int[10] ary;`ÅŸeklinde `int` tÃ¼rÃ¼nden on elemanlÄ± bir dizi tanÄ±mlanabilir.

[10.55:30]
â— Dizinin eleman sayÄ±sÄ±nÄ± belirten ifade **constand expression** olmalÄ±, bu kÄ±smÄ±n anlaÅŸÄ±lmasÄ± biraz zor olabilir. 

â— Bir diziyi bildiirrken o dizinin eleman sayÄ±sÄ± belli olmalÄ±dÄ±r yoksa **sÃ¶zdizim hatasÄ±(syntax error)** oluÅŸur, mesela `int[] ary;`ÅŸeklinde bir dizi bildirimi hatlÄ±dÄ±r ve C dilinde illegal'dir.

ğŸ§  C99 standardÄ±yla dile eklenen **VLA(variable length array)** deÄŸiÅŸken sayÄ±da elemana sahip olan dizilerin tanÄ±mlanmasÄ± Ã¶zelliÄŸi C11 standardÄ±yla **optional(destek verilmesi derleyiciye bÄ±rakÄ±lmÄ±ÅŸ Ã¶zellikler)** hale getirilmiÅŸtir ve her derleyici desteklemediÄŸi iÃ§in bu kursta iÅŸlenmeyecektir.


[10:57:40-10:59:40]
ğŸ‘‡ AÅŸaÄŸÄ±daki programda C99 ve Ã¼zeri standartlara gÃ¶re C dilinde dizi tanÄ±mlaasÄ±yla ilgili bazÄ± duurmlar Ã¶ÄŸrenilebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

int main(void)
{
    int x = 20;
    int ar[x]; // Burada sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur Ã§Ã¼nkÃ¼ bir dizinin eleman sayÄ±sÄ±nÄ± belirten ifade(expression) sabit(constant) olmak zorundadÄ±r.

    const int size3 = 100;

    int arr1[10]; // DoÄŸru tanÄ±mlanÄ±m.
    int arr2[10 + 8]; // DoÄŸru tanÄ±mlanÄ±m.
    int arr3[size3]; // Bu satÄ±r C dilinde sÃ¶zdizim hatasÄ±dÄ±r(syntax error) ama C++ dilinde legal'dir.
    int arr1['c']; // DoÄŸru tanÄ±mlanÄ±m.
}
```



â— C dilinde fonksiyonlarÄ±n parametre deÄŸiÅŸkenleri dizi tÃ¼rÃ¼ olamaz bunun yerine pointer olabilir. </br>
â— C dilinde fonksiyonlarÄ±n geri dÃ¶nÃ¼ÅŸ deÄŸeri tÃ¼rÃ¼ dizi tÃ¼rÃ¼ olamaz bunun yerine pointer olabilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda dizilerle ilgili bazÄ± bilgiler gÃ¶rÃ¼lebilir.
```C
int arrg[30]; // Buradaki 'arrg' dizisi global bir deÄŸiÅŸkendir ve 'storage duration' Ã¶zelliÄŸi 'static'tir, ayrÄ±ca dizinin elemanlarÄ± '0' deÄŸeriyle baÅŸlatÄ±lacaktÄ±r.

int main(void)
{
    int arr1[10]; // 'arr1' deÄŸiÅŸkeninin tÃ¼rÃ¼ 'int[10]' ama dizinin her bir elemanÄ±nÄ±n tÃ¼rÃ¼ 'int' tÃ¼rÃ¼ndendir. Buradaki dizinin elemenlarÄ± Ã§Ã¶p deÄŸer ile baÅŸlatÄ±lacaktÄ±r Ã§Ã¼nkÃ¼ 'otomatic' Ã¶mÃ¼rlÃ¼ bir deÄŸiÅŸkendir.

    static int arr2[10]; // 'arr1' dizi deÄŸiÅŸkeninin deÄŸerleri "0" deÄŸeri ile baÅŸlatÄ±lacaktÄ±r, bunun nedeni deÄŸiÅŸkenin 'static' olarak bildirilmesidir.

    int x, a[5], y, z[25]; // Buradaki gibi bir tanÄ±mlama legal'dir ama kodun okunaklÄ± olabilmesi iÃ§in kullanmasÄ± tavsiye edilmemektedir.
}
```

â— `int ary[100];` bu **deyimdeki(statement)** bildirimi yapÄ±lan `ary` deÄŸiÅŸkeninin tÃ¼rÃ¼ `int[100]` ÅŸeklindedir. </br>
â— Ä°smi `arr` olan ve tÃ¼rÃ¼ `int[8]` olan bir deÄŸiÅŸken tanÄ±mlayÄ±n denilince bu tanÄ±mlama `int arr[8];` ÅŸeklinde yazÄ±lacaktÄ±r.


â—â—â— Adres operatÃ¶rÃ¼ ile oluÅŸturulan ifadeler **R-value expression** Ã¶zelliÄŸindedir.



â— Burada C ve C++ dilerinde dizilerle ilgili en Ã¶nemli kuralÄ±ndan ilk defa bahsediliyor. </br>
â— C ve C++ dilerinde dizi deÄŸiÅŸkenleri atama operatÃ¶rÃ¼nÃ¼n sol operandÄ± olamaz, bunun nedeni **array decay(array to pointer conversion)** kuralÄ±dÄ±r. </br>
â— BirkaÃ§ istisna dÄ±ÅŸÄ±nda bir dizinin adÄ± bir ifade iÃ§inde kullanÄ±rsak derleyici o dizi adÄ±nÄ±n dizinin ilk elemanÄ±nÄ±n adresine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda yukarÄ±da aÃ§Ä±klanan durum iÃ§in inceleme yapÄ±labilir.
```C
#define _CRT_SECURE_NO_WARNINGS

int main(void)
{
    int arr1[10];
    int arr2[10];

    arr1 = arr2; // Burada 'array decay' kuralÄ±ndan dolayÄ± sÃ¶zdizim hatasÄ±(syntax error) oluÅŸacaktÄ±r. Bu kullanÄ±m     
}
```


Dizi kullanÄ±mÄ±nÄ±n en Ã¶nemli kÄ±sÄ±m aÅŸaÄŸÄ±daki aÃ§Ä±klamada belirtilmiÅŸtir.
â—Bir dizinin kendisini kullanmak baÅŸka dizinin elemanlarÄ±nÄ± kullanmak baÅŸkadÄ±r. Bir dizinin en Ã¶nemli Ã¶zelliÄŸi her elemanÄ±nÄ±n bellekte sÄ±ralÄ± olarak bulunuyor olmasÄ±dÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

int main(void)
{
    int x, y, z; // Bu tanÄ±mlamadaki deÄŸiÅŸkenler bellekte farklÄ± farklÄ± yerlerde olma durumu vardÄ±r, bu tanÄ±mlamada deÄŸiÅŸkenlerin bellekte peÅŸi sÄ±ra konumlanacaÄŸÄ± kesin deÄŸildir.
    int arr1[3]; // Bu dizi tanÄ±mlamasÄ±nda dizinin elemanlarÄ± bellekte peÅŸi sÄ±ra bellek bloÄŸunda bulunacaktÄ±r.
}
```


### Dizinin ElemanlarÄ±na EriÅŸim Ä°ÅŸlemi 

`[]` operatÃ¶rÃ¼nÃ¼n adÄ± **subscript(index, kÃ¶ÅŸeli parantes) operatÃ¶rÃ¼dÃ¼r** ve dizilerle birlikte kullanÄ±ldÄ±ÄŸÄ±nda dizinin elemanlarÄ±na eriÅŸmek iÃ§in kullanÄ±lan bir operatÃ¶rdÃ¼r.

Pointer'lar ve diziler C ve C++ dillerinde iÃ§ iÃ§e geÃ§miÅŸtir. </br>
Dizinin ilk elemanÄ± dizinin 0 indisli elamanÄ±dÄ±r. </br>
Dizinin son elemanÄ± dizinin eleman sayÄ±sÄ±ndan bir dÃ¼ÅŸÃ¼k sayÄ± aÄŸÄ±rlÄ±ÄŸÄ±ndaki indisli elamanÄ±dÄ±r. </br>
â—Bir dizinin dizi uzunluÄŸu(range) dÄ±ÅŸÄ±ndaki bir dizi elemanÄ±na eriÅŸmek istenmesi **ub** durumuna neden olacaktÄ±r ve bu durum **run-time**'da oluÅŸan bir sorundur. </br>
Bir dizinin uzunluÄŸu(range) birden fazla yerde kullanÄ±lÄ±yorsa genel yaklaÅŸÄ±m olarak dizi uzunluÄŸunu(range) tutan deÄŸer bir makroda tutulur ve bu ÅŸekilde deÄŸeri yÃ¶netmek daha kolay olmaktadÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **VLA(variable length array)** desteÄŸi olan bir derleyicinin hata vermeyeceÄŸi ama **VLA(variable length array)** desteÄŸi olmayan bir derleyicinin hata vereceÄŸi durum incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

int main(void)
{
    int d = 6;
    int arr1[d]; // EÄŸer derleyici bu satÄ±rda hata vermezse bu derleyicinin 'VLA' desteÄŸi verdiÄŸi anlamÄ±na gelir. 
}
```



ğŸš€ **Traversa(Traversal Operation)**: Bir veri yapÄ±sÄ±nÄ±n tÃ¼m elemanlarÄ±nÄ±n gezildiÄŸi iÅŸleme verilen addÄ±r. 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda en temel haliyle bir dizinin deÄŸerlerinin yazdÄ±rÄ±lmasÄ± iÅŸlemleri incelenebilir, programda **traversa** iÅŸlemi yapÄ±lmaktadÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

#define SIZE 100

int main(void)
{
    int arr1[SIZE];

    for(int i = 0; i < SIZE; ++i){
        arr1[i] = i;
    }

    for(int i = 0; i < SIZE; ++i){
        printf("%d. dizi elemani: %d\n", i, arr1[i]);
    }
}
```



ğŸ‰ C bilenlerin yeni Ã¶ÄŸrenenelere yaptÄ±ÄŸÄ± bir ÅŸaka aÅŸaÄŸÄ±daki programdan incelenebilir. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda pointer'lar ile ilgili olan `i[arr1]` ve `arr1[i]` ifadelerinin aynÄ± anlama gelmesiyle ilgili durum incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

#define SIZE 10

int main(void)
{
    int arr1[SIZE];

    for(int i = 0; i < SIZE; ++i){
        arr1[i] = i;
    }

    for(int i = 0; i < SIZE; ++i){
        printf("1. kullanim. %d. dizi elemani: %d\n", i, i[arr1]);
        printf("2. kullanim. %d. dizi elemani: %d\n", i, arr1[i]);
    }

    int z = ++arr1[46]; // Buradaki 'arr1[46]' ifadesi 'L-value' Ã¶zelliktedir.
}
```


### C Dilinde Dizilere Ä°lk DeÄŸer Verilmesi(Initialization of Array) 

C dilinin standardÄ±nda bir dizinin elemanlarÄ±na ilk deÄŸer verme iÅŸleminde `int arry[8] = { 1 };` ÅŸeklinde bir tanÄ±mlama yapÄ±lÄ±rsa deÄŸerleri belirtilmemiÅŸ olsa da dizinin **otomatic** ya da **static** Ã¶mÃ¼rlÃ¼ olmasÄ±ndan baÄŸÄ±msÄ±z olarak "0" deÄŸerini alacaktÄ±r. 


ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir diziye ilk deÄŸer atamasÄ±nÄ± yaparken `type array_name[SIZE] = { values ... }` ÅŸeklindeki notasyonun nasÄ±l kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

#define SIZE 10

int main(void)
{
    int arr1[SIZE] = { 1, 3, 5, 7 }; // Buradaki ilk deÄŸer verme iÅŸleminden dolayÄ± dizinin ilk dÃ¶rt elemanÄ± dÄ±ÅŸÄ±ndaki elemalarÄ± '0' deÄŸerini alacaktÄ±r.

    for(int i = 0; i < SIZE; ++i){
        printf("arr1[%d] = %d\n", i, arr1[i]);
    }

    int arr2[SIZE] = { 0 }; // Burada dizinin tÃ¼m elemanlarÄ±nÄ±n '0' deÄŸeriyle baÅŸlatÄ±lacaktÄ±r.

    for(int i = 0; i < SIZE; ++i){
        printf("arr2[%d] = %d\n", i, arr2[i]);
    }
}
```



ğŸ§  **Aggregate Type**: Ã–yle bir tÃ¼r ki bu tÃ¼rden bir deÄŸiÅŸken kendi iÃ§inde birden fazla deÄŸiÅŸkene sahip olabiliyor, bu tanÄ±ma **array**, **struck** tÃ¼rleri girmektedir. </br>
ğŸ§  **Trailing Comma**: Dizi ilklendirme yÃ¶nteminde en son elamandan sonra `,` eklenmesi durumuna verilen addÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda **trailing comma** kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

#define SIZE 10

int main(void)
{
    int arr1[] = { 1, 3, 5, 7, }; // Buradaki ÅŸekilde dizi ilklendirme iÅŸlemi yapÄ±labiliyor, buna 'trailing comma' deniliyor
}
```



âš ï¸ Bir dizinin eleman sayÄ±sÄ± "0" olamaz, **sÃ¶zdizim hatasÄ±(syntax error)** oluÅŸur. 


Dizilerle ilgili ilk deÄŸer verme **sÃ¶zdizimi(syntax)** C99 standardÄ±na kadar sadece yukarÄ±dakilerden ibaretti ama C99 standartÄ±ndan sonra aÅŸaÄŸÄ±daki kullanÄ±mlar da dile eklenmiÅŸtir.

C99'dan sonra **designated initializer** **sÃ¶zdizimi(syntax)** ile birlikte dizilere ilk deÄŸer verme iÅŸlevi dile eklenmiÅŸtir.

ğŸ‘‡ AÅŸaÄŸÄ±daki programda C99 standardÄ± sonrasÄ± iÃ§in **designated initializer** **sÃ¶zdizimi(syntax)** ile nasÄ±l ilk deÄŸer atandÄ±ÄŸÄ± gÃ¶rÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

#define SIZE 10

int main(void)
{
    // AÅŸaÄŸÄ±daki dizi tanÄ±mÄ±nda dizinin 8 ve 2 indisli elemanlarÄ±na ilk deÄŸer verilmiÅŸtir ama diÄŸer elemanlarÄ±na 0 deÄŸeri verilecektir.
    int arr1[SIZE] = {
        [8] = 123,
        [2] = 4
    };  

    for(int i = 0; i < SIZE; ++i){
        printf("arr1[%d] = %d\n", i, arr1[i]);
    }

    // AÅŸaÄŸÄ±daki dizi tanÄ±mÄ±nda dizinin 8. 2. ve 56. indisli elemanlarÄ±na ilk deÄŸer verilmiÅŸtir ama diÄŸer elemanlarÄ±na 0 deÄŸeri verilecektir. Bu dizi 57 elemana sahip olacaktÄ±r.
    int arr2[] = {
        [8] = 123,
        [2] = 4,
        [56] = 24342
    };  

    for(int i = 0; i < 57; ++i){
        printf("arr1[%d] = %d\n", i, arr2[i]);
    }

    // AÅŸaÄŸÄ±daki dizi tanÄ±mÄ±nda dizinin eleman sayÄ±sÄ± 59'dur ve bu ÅŸekilde kullanÄ±m legal'dir.
    int arr3[] = {
        [8] = 123,
        [2] = 4,
        23, // Burada dizinin 3 indisli elemanÄ±nÄ±n deÄŸeri bildiriliyor.
        [56] = 24342,
        123, // Burada dizinin 57 indisli elemanÄ±nÄ±n deÄŸeri bildiriliyor.
        4324,  // Burada dizinin 58 indisli elemanÄ±nÄ±n deÄŸeri bildiriliyor.
        [20] = 41,
    };

    for(int i = 0; i < 59; ++i){
        if(i && i % 10 == 0)
            printf("\n");
        printf("arr3[%d] = %d\n", i, arr3[i]);
    }
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.05-12.16 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


## `sizeof` OperatÃ¶rÃ¼

Bu operatÃ¶r operandÄ±nÄ±n bellekte kapladÄ±ÄŸÄ± alanÄ± byte olarak tam sayÄ± deÄŸeri olarak geri dÃ¶ner.

`sizeof` hem bir keyword hem de bir operatÃ¶rdÃ¼r. </br>
`sizeof` operatÃ¶rÃ¼ diÄŸer operatÃ¶rlerden farklÄ± olarak **compile time** Ã¶zelliÄŸiyle Ã§alÄ±ÅŸmaktadÄ±r. </br>
`sizeof` operatÃ¶rÃ¼ ile oluÅŸturulan ifadeler **constant expression** niteliÄŸindedir ve sabit deÄŸer kullanÄ±lmasÄ± gereken her yerde kullanÄ±labilir. </br>
`sizeof` operatÃ¶rÃ¼ bir veri tÃ¼rÃ¼nÃ¼n bellek alanÄ± ihtiyacÄ±nÄ±n(storage) kaÃ§ byte olduÄŸu bilgisinin **compile time** anÄ±nda elde edilmesini saÄŸlar. </br>
`sizeof` operatÃ¶rÃ¼ ile birlikte yan etkisi olan varlÄ±klar kullanÄ±lÄ±rsa bu varlÄ±klarÄ±n yan etkileri oluÅŸmayacaktÄ±r. </br>


â—â—â— `sizeof` operatÃ¶rÃ¼nÃ¼n Ã¼rettiÄŸi deÄŸer iÅŸaretsiz bir tam sayÄ± tÃ¼rÃ¼ndendir(**size_t** adÄ±ndaki type-alias(tÃ¼r-eÅŸ adÄ±)), bu bir makrodur ama bu makronun hangi iÅŸaretsiz tam sayÄ±ya karÅŸÄ±lÄ±k geldiÄŸi derleyiciye bÄ±rakÄ±lmÄ±ÅŸtÄ±r.


`sizeof(int), sizeof(double), sizeof 35, sizeof 5.` ÅŸeklinde kullanÄ±lÄ±r ve kendisine verilen tÃ¼rÃ¼n bellekte byte olarak ne kadar alan kapladÄ±ÄŸÄ± bilgisini geriye dÃ¶ner.

â—â—â— `sizeof(type)` bu ifade de kullanÄ±lan parantez "type" deÄŸeri verildiÄŸi iÃ§in zorunludur yani Ã¶ncelik parantesi deÄŸildir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `sizeof` operatÃ¶rÃ¼nÃ¼n birinci kullanÄ±mÄ± olan parantez iÃ§inde tÃ¼r adÄ± aldÄ±ÄŸÄ± kullanÄ±mÄ±n Ã§alÄ±ÅŸmasÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    printf("sizeof(int) = %zu\n", sizeof(int)); // C99 standardÄ±yla birlikte '%zu' ile formatlama yÃ¶ntemi dile eklenmiÅŸtir.
    printf("sizeof(double) = %zu\n", sizeof(double));
    printf("sizeof(long long) = %zu\n", sizeof(long long));
    printf("sizeof(float) = %zu\n", sizeof(float));
    printf("sizeof(int[5]) = %zu\n", sizeof(int[5]));
    printf("sizeof(double[5]) = %zu\n", sizeof(double[5]));
}
```


â—â—â— `sizeof` operatÃ¶rÃ¼nÃ¼n ikinci kullanÄ±mÄ±nda parantez kullanÄ±lmasÄ± zorunluluÄŸu yoktur ve `sizeof expr` ÅŸeklinde kullanÄ±lmaktadÄ±r, `sizeof ival;` ya da `sizeof 20;` ÅŸeklinde kullanÄ±labiliyor.

ğŸ‘‡ AÅŸaÄŸÄ±daki programda `sizeof` operatÃ¶rÃ¼nÃ¼n ikinci kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 10;

    printf("sizeof(x) = %zu\n", sizeof(x));
    printf("sizeof x = %zu\n", sizeof x);


    printf("sizeof(78) = %zu\n", sizeof(78));
    printf("sizeof 78 = %zu\n", sizeof 78);


    char c1 = 'a';
    char c2 = 4;
    char c3 = 5;

    printf("sizeof c1 = %zu\n", sizeof c1);
    printf("sizeof +c1 = %zu\n", sizeof +c1);


    printf("sizeof(c2 + c3) = %zu\n", sizeof(c2 + c3));
    printf("sizeof c2 + c3 = %zu\n", sizeof c2 + c3);


    printf("sizeof c1 = %zu\n", sizeof c1);
}
```



â—`sizeof` operatÃ¶rÃ¼nÃ¼n operandÄ± olan ifade iÃ§in iÅŸlem kodu oluÅŸturulmaz, bu C dilinin kuralÄ±dÄ±r ve C mÃ¼lakatlarÄ±nda sÄ±klÄ±kla sorulmaktadÄ±r. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda yukarÄ±da beliritlen Ã¶nemli duurm incelnebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 7;

    int sz = sizeof(x++); // Derleyici buradaki 'x++' ifadesine sadece tÃ¼r bilgisi olarak bakmaktadÄ±r ve 'x++' iÃ§in makine kodu Ã¼retilmediÄŸi iÃ§in x deÄŸiÅŸkeni deÄŸeri deÄŸiÅŸmeyecektir.
    
    printf("sz = %d\n", sz);
    printf("x = %d\n", x);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `sizeof` kullanÄ±mÄ±na dair dilin Ã¶nemli kurallarÄ±ndan birinin nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ± incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int foo()
{
    printf("foo called!\n");   

    return 1;
}

int main(void)
{
    int x = foo();
    printf("x = %d\n", x);


    int y = sizeof(foo()); // Burada 'foo' fonksiyonuna Ã§aÄŸrÄ± yapÄ±lmayacaktÄ±r.
    printf("x = %d\n", x);
}
```



ğŸ”¥ğŸ”¥ğŸ”¥ `sizeof` operatÃ¶rÃ¼yle ilgili birkaÃ§ tane Ã¶nemli kural listelenmiÅŸtir, bunlar unutulmamalÄ± ve iyi bilinmelidir;
- `sizeof` operatÃ¶rÃ¼ bir **compile time** operatÃ¶rÃ¼dÃ¼r.
- `sizeof` operatÃ¶rÃ¼ bir anahtar sÃ¶zcÃ¼ktÃ¼r.
- `sizeof` operatÃ¶rÃ¼nÃ¼n Ã¼rettiÄŸi deÄŸerin tÃ¼rÃ¼ bir tÃ¼r-eÅŸ adÄ± olan **size_t** tÃ¼rÃ¼dÃ¼r, **size_t** standart kÃ¼tÃ¼phanenin kullandÄ±ÄŸÄ± bir tÃ¼r-eÅŸ adÄ±dÄ±r ve hangi iÅŸaretsiz tam sayÄ±ya karÅŸÄ±lÄ±k geldiÄŸi derleyiciye bÄ±rakÄ±lmÄ±ÅŸtÄ±r.
- `sizeof` operatÃ¶rÃ¼ operandÄ± olan ifade iÃ§in derleyici iÅŸlem kodu(makine kodu) Ã¼retmez, bu dilin kuralÄ±dÄ±r.



â—**Unveriabilty Context(Ä°ÅŸlem kodu Ã¼retilmeyen baÄŸlam)**: C++ standardÄ±nda derleyicinin **iÅŸlem kodu(makine kodu)** Ã¼retmediÄŸi kod parÃ§alarÄ± iÃ§in kullanÄ±lan terimdir(C dilinde bunun iÃ§in standardÄ±n Ã¶nerdiÄŸi bir terim yoktur). Bu Ã¶zellik C dilinde sadece `sizeof` operatÃ¶rÃ¼nÃ¼n kullanÄ±mÄ±nda mevcuttur ama C++ dilinde birden fazla farklÄ± iÅŸlemde mevcuttur.

â—**Array Decay(Array to pointer conversion)**: Dizi deÄŸiÅŸkenlerinin programda gÃ¶nderilmek istendiÄŸi yerlerde dizinin pointer'a dÃ¶nÃ¼ÅŸÃ¼m yapÄ±larak kullanÄ±ldÄ±ÄŸÄ± yere gÃ¶nderilmesi durumu iÃ§in kullanÄ±lan terimdir.

â—â—â— **Array Decay(Array to pointer conversion)** kuralÄ±nÄ±n uygulanmadÄ±ÄŸÄ± bazÄ± istisnai durumlar vardÄ±r, bunlardan biri dizi deÄŸiÅŸkenlerinin `sizeof` operatÃ¶rÃ¼ ile birlikte kullanÄ±ldÄ±ÄŸÄ± durumdur. 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `sizeof` operatÃ¶rÃ¼nÃ¼n operandÄ± olarak bir dizi deÄŸiÅŸkeni kullanÄ±ldÄ±ÄŸÄ±nda **array decay(array to pointer conversion)** kuralÄ±nÄ±n uygulanmadÄ±ÄŸÄ± istisnai durum incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int ary[10];

    printf("sizeof ary           = %zu\n", sizeof ary);
    printf("sizeof(ary)          = %zu\n", sizeof(ary));
    printf("sizeof(int[10])      = %zu\n", sizeof(int[10]));
    printf("sizeof(ary[0])       = %zu\n", sizeof(ary[0]));
    printf("sizeof(&ary[0])      = %zu\n", sizeof(&ary[0]));
}
```



â—â—â— `sizeof` operatÃ¶rÃ¼nÃ¼n operandÄ± bir dizi adÄ± olduÄŸunda **array decay** uygulanmaz. Bu durumda sizeof operatÃ¶rÃ¼nÃ¼n Ã¼rettiÄŸi deÄŸer dizi tÃ¼rÃ¼nÃ¼n deÄŸeridir.


ğŸ‘‡ AÅŸaÄŸÄ±daki program `sizeof` operatÃ¶rÃ¼nÃ¼n farklÄ± tÃ¼rlerden dizi deÄŸiÅŸkenlerinde nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± anlayabilmek iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int aryi[100];
    printf("sizeof aryi = %zu", sizeof aryi);
    printf("sizeof(aryi) = %zu", sizeof(aryi));

    double aryd[100];
    printf("sizeof aryd = %zu", sizeof aryd);
    printf("sizeof(aryd) = %zu", sizeof(aryd));

    float aryf[100];
    printf("sizeof aryf = %zu", sizeof aryf);
    printf("sizeof(aryf) = %zu", sizeof(aryf));

    long long int arylli[100];
    printf("sizeof arylli = %zu", sizeof arylli);
    printf("sizeof(arylli) = %zu", sizeof(arylli));

    long long aryll[100];
    printf("sizeof aryll = %zu", sizeof aryll);
    printf("sizeof(aryll) = %zu", sizeof(aryll));

    int arry[300];

    printf("arry dizisinin eleman sayisi= ", sizeof(arry) / sizeof(arry[0]));

}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `sizeof` operatÃ¶rÃ¼ ile bir dizinin eleman sayÄ±sÄ±nÄ± Ã¶ÄŸrenmek iÃ§in nasÄ±l bir kod yazÄ±lmasÄ± gerektiÄŸi gÃ¶rÃ¼lebilir. Programda kullanÄ±lan `sizeof(arry) / sizeof(arry[0])` ifadesi(expression) `sizeof` operatÃ¶rÃ¼ kullanÄ±ldÄ±ÄŸÄ± iÃ§in bir sabit(constand) ifadesidir ve bu bize bir Ã§ok yerde kullanabileceÄŸimiz bir yapÄ± saÄŸlar.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int arry[300];

    printf("arry dizisinin eleman sayisi= ", sizeof(arry) / sizeof(arry[0]));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda C programcÄ±larÄ±nÄ±n bir dizinin eleman sayÄ±sÄ±nÄ± **compile time**'da elde edebilmek iÃ§in Ã§ok sÄ±k kullandÄ±ÄŸÄ± **asize** makro'sunun kullanÄ±mÄ± gÃ¶rÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

#define asize(ar) (sizeof(ar) / sizeof(ar[0])) 

int main(void)
{
    int arry[] = { 3, 34, 45, 6, 78, 87, 98, 2, 9 };

    // 'arry' dizisinin elemanlarÄ±nÄ±n 'sizeof' operatÃ¶rÃ¼ ile dizi eleman sayÄ±sÄ±nÄ±n derleme anÄ±nda elde edildiÄŸi kullanÄ±m aÅŸaÄŸÄ±daki gibidir.
    for(size_t i = 0; i < sizeof(arry) / sizeof(arry[0]); ++i){
        printf("%d\n", arry[i]);
    }

    printf("-------------------\n++++++++++++++++++++++\n-----------------------");
    
    // AÅŸaÄŸÄ±daki dÃ¶mgÃ¼nÃ¼n dÃ¶neceÄŸi adÄ±m sayÄ±sÄ± 'asize' makrÄ±su Ã¼zerindne dizinin eleman sayÄ±sÄ± Ã¶ÄŸrenilerek yapÄ±lÄ±yor.
    for(size_t i = 0; i < asize(arry); ++i){
        printf("%d", arry[i]);
    }
}
```


âœï¸ `nutility.h` baÅŸlÄ±k dosyasÄ±na `asize(x)` function like makro'sunun eklenmesi.
```C
// YazÄ±lan 'nutility.h' dosyasÄ±

#ifndef NUTILITY_H
#define NUTILITY_H

// ...

#define asize(ar) (sizeof(ar) / sizeof(ar[0])) 

// ...

#endif
```


â” 
ğŸš€ MÃ¼lakatlarda sorulan gÃ¼zel bir soru mevcuttur. </br>
ğŸš€ Soru: Program Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda ekrana dizinin hangi elemanlarÄ±nÄ± yazdÄ±rÄ±r? </br>
ğŸ‘‡ AÅŸaÄŸÄ±da bu soru iÃ§in verilen program yer almaktadÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

#define asize(ary) (sizeof(ary) / sizeof(ary[0])) 

int main(void)
{
    int arry[] = { 1, 2, 3, 4, 5 };

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ye girilmeyecektir, 'i < asize(arry) - 3' buradaki ifadeye tÃ¼rler aÃ§Ä±sÄ±ndan bakarsak 'int < unsigned int' iÅŸlemi yapÄ±lacaktÄ±r ama 
    // bu karÅŸÄ±laÅŸtÄ±rmada 'int' tÃ¼rÃ¼ 'unsigned int' tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rÃ¼ldÃ¼kten sonra karÅŸÄ±laÅŸtÄ±rma yapÄ±lacaktÄ±r, 
    // '-3' int tÃ¼rÃ¼nden 'unsigned int' tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rÃ¼ldÃ¼ÄŸÃ¼nde Ã§ok bÃ¼yÃ¼k bir sayÄ±ya dÃ¶nÃ¼ÅŸtÃ¼ÄŸÃ¼ iÃ§in dÃ¶ngÃ¼ye girilmemektedir.
    for(int i = -3; i < asize(arry) - 3; ++i){
        printf("%d ", arry[i + 3]);
    }

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ye girilecektir.
    for(int i = -3; i < (int)(asize(arry) - 3); ++i){
        printf("%d ", arry[i + 3]);
    }
}
```

Cevap;
ğŸ§  ProgramÄ±n for dÃ¶ngÃ¼sÃ¼ incelendiÄŸinde tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mlerinden dolayÄ± hiÃ§ bir zaman dÃ¶ngÃ¼ye girilmeyeceÄŸi anlaÅŸÄ±lacaktÄ±r, **asize** adÄ±ndaki **function-like makro** bÃ¼nyesinde `sizeof` operatÃ¶rÃ¼nÃ¼ barÄ±ndÄ±rÄ±yor ve bu operatÃ¶rÃ¼n Ã¼reteceÄŸi deÄŸer iÅŸaretsiz tam sayÄ± deÄŸeri, dÃ¶ngÃ¼ ÅŸartÄ±nda `int` ve **iÅŸeretsiz int** tÃ¼rÃ¼ mantÄ±ksal(logic) iÅŸleme sokulduÄŸunda iÅŸlem tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ kurallarÄ± gereÄŸi iÅŸaretsiz tam sayÄ± tÃ¼rÃ¼nde yapÄ±lacaktÄ±r, bu iÅŸlemde `i < asize(arry) - 3` ifadesindeki `<` operantÄ±nÄ±n sol operantÄ± olan "-3" bitlerinde deÄŸiÅŸiklik yapÄ±lmadan tÃ¼rÃ¼ iÅŸaretsiz tam sayÄ± tÃ¼rÃ¼ olarak deÄŸerlendirildiÄŸi iÃ§in Ã§ok bÃ¼yÃ¼k bir sayÄ± olacaktÄ±r ve bu nedenle de dÃ¶ngÃ¼ ÅŸartÄ± her zaman zero(false) deÄŸerde olur ve dÃ¶ngÃ¼ye hiÃ§ bir zaman girilmez. </br>
ğŸ‰ Fakat C mÃ¼lakatlarÄ±na giren kiÅŸiler bu soruya "Dizinin tÃ¼m elemanlarÄ± yazdÄ±rÄ±lacaktÄ±r." ÅŸeklinde cevap verip tongaya dÃ¼ÅŸÃ¼yorlarmÄ±ÅŸ.


Ders sonu ...
