# 53.Ders 19.07.2025 🕘

---


## Command Line Arguments

**Command Line Environment(Komut satırı ortamı)** işletim sisteminin kullanıcısıyla arayüz sağladığı yazı tabanlı ortama verilen addır.

Çalıştırılabilir programlar çoğunlukla işletim sisteminin komut satırından uygun argümanlarla çalıştırılmaktadır.

Çalıştırılacak olan programın dışarıdan alacağı ve programı çalıştırırken gönderilen değerlere **Command Line Arguments** denilmektedir. GUI ile bir programın dosyasına çift tıklanarak program çalıştırılsabile artalanda program yine CLI(command line interface) üzerinden uygun argümanlar programa geçilerek program çalıştırılmaktadır.


👇 Aşağıdaki programda geleneksel olarak en temel C programının `main` fonksiyonunun aldığı parametreler incelenebilir.
```C
#include <stdio.h>

// main fonksiyonunun parametreleri olan 'argc' ve 'argv' birer identifier'dır.
// argc: "Argument Count" sözcğklerinin kısaltmasıdır.
// argv: "Argument Vector" sözcğklerinin kısaltmasıdır.
int main(int argc, char** argv)
// int main(int argc, char* argv[]) // Buradaki 'main' fonksiyonu tanımı ile yukarıdaki tanım birbirine denktir.
{

    /*
        Mesela bu programa geçilecen parametre 'negun 13 6 1961' olsun, bu programın parametreleri aşağıdaki değerleri alacaktır;
        'argc' değeri 4 olacaktır çünkü programa dört tane değer geçilmektedir.
        'argv[0]' 'char*' türünden 'negun' string sabitinin başlangıç adresinin değerini alır.
        'argv[1]' '13' değerini alır.
        'argv[2]' '6' değerini alır.
        'argv[3]' '1961 değerini alır.

    */
}
```




👇 Aşağıdaki programda komut satırından programı çalıştırırken girilen değerlerin nasıl standart çıktı akımına gönderildiği incelenebilir, programı derleyip çalıştırılabilir dosyasını oluşturup incelemek gerekiyor.
```C
#include <stdio.h>

int main(int argc, char* argv[])
{
    for(int i = 0; i < argv; ++i){
        printf("argv[%d] = %s\n", i, argv[i]);
    }
}
```



👇 Aşağıdaki programda komut satırından programı çalıştırırken girilecek tam sayı değerlerin toplamını hesaplayıp nasıl standart çıktı akımına gönderildiği incelenebilir, programı derleyip çalıştırılabilir dosyasını oluşturup incelemek gerekiyor.
```C
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
    int sum = 0;

    for(int i = 0; i < argv; ++i){
        sum += atoi(argv[i]);
    }

    printf("%d\n", sum);
}
```



👇 Aşağıdaki programda komut satırından programı çalıştırırken girilecek üç ata argüm ile dosya kopyalama işleminin nasıl yapıldığı incelenebilir, programı derleyip çalıştırılabilir dosyasını oluşturup incelemek gerekiyor.
```C
#include <stdio.h>
#include <stdlib.h>

// Programın üç argümanla çağırılması gerekiyor.
int main(int argc, char* argv[])
{
    if(argc != 3)
    {
        printf("usage: <copytfile> <source file name> <dest file name>\n");
        return 1;
    }

    printf("file %s copied as file %s\n", argv[1], argv[2]);
}
```



👇 Aşağıdaki programda komut satırından programı çalıştırırken girilecek üç ata argüm ile dosya kopyalama işleminin nasıl yapıldığı(kullanıcı argümanları doğru girmediğinde program içinden bu argümanlar alınmaktadır) incelenebilir, programı derleyip çalıştırılabilir dosyasını oluşturup incelemek gerekiyor.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// copyfile prg1.exe prg2.exe
int main(int argc, char* argv[])
{
    char surce_file_name[40];
    char dest_file_name[40];

    if(argc != 3)
    {
        printf("kaynak dosya adi : ");
        scanf("%s", surce_file_name);
        printf("hedef dosya adi : ");
        scanf("%s", dest_file_name);
    }
    else{
        strcpy(surce_file_name, argv[1]);
        strcpy(dest_file_name, argv[2]);
    }

    // ...

    printf("file %s copied as file %s\n", surce_file_name, dest_file_name);
}
```



👇 Aşağıdaki programda CLI üzerinden argümanları verilecek basit bir hesap makinesinin nasıl yazılabileceği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// copyfile prg1.exe prg2.exe
int main(int argc, char* argv[])
{
    if(argc != 4)
    {
        printf("kullanim: <hes> <sol operand> <operator +-*/> <sag operand>\n");
        return 1;
    }

    int op_left = atoi(argv[1]);
    int op_right = atoi(argv[3]);

    // `switch` ifadesi olan '*argv[2]' ifedesi zero-nonzero olarak mantıksal yorumlamaya tabidir.
    switch(*argv[2]){
        case '+': printf("%d\n", op_left + op_right); break;
        case '-': printf("%d\n", op_left - op_right); break;
        case '*': printf("%d\n", op_left * op_right); break;
        case '/': 
            if(op_right == 0)
                printf("sifira bolme hatasi.\n");
            else
                printf("%f\n", op_left / (double)op_right); 
        break;
        default: printf("gecersiz islem.\n"); break;
    }
}
```



`int main(int argc, char* argv[])` gibi main fonksiyonu tanımında `argv[argc]` biçimindeki bir ifadenin kullanımı legaldir, C srandardı `argv[argc]` ifadesinin **NULL pointer** olacağı belirtilmiştir.



👇 Aşağıdaki programda 
```C
#include <stdio.h>
#include <stdlib.h>

// Programın üç argümanla çağırılması gerekiyor.
int main(int argc, char** argv)
{
    int i = 0;

    // Aşağıdaki 
    while(argv[i] != NULL){
        printf("argc[%d] = %s", i, argv[i]);
        ++i;
    }
}
```

## Dosyalar ve Dosya İşlemleri 

Kursun sonlarındayız ama en kapsamlı konu da dosya işlemleri konusu diyebiliriz, 10 saatten fazla sürecek bir konu. </br>
Şimdiye kadar yazdığımız programlar çıktılarını standart çıktı akımına yazdı am aprogramların çoğu çıktılarını dosya ya da dosyalara yazmaktadır. </br>
Ayrıca çoğu zaman çalıştırılan programlar girdilerini bir dosya ya da dosyalardan almaktadır. </br>


### Bir dosya nedir(what is a file)

Bu bilgi seviyesinde yapılabilecen en iyi soyutlama bir dosyanın byte'lardan oluşan bir küme olduğudur. Dosya dendiğinde akla byte'lar kümesi gelmelidir. </br>
Dosya denildiğinde program çalışırken bellekte yeralan 1 ve 0 dizilerinden bahsedilmiyor ikincil saklama ortamlarındaki(hard-disc, flash-disc vb. gibi kalıcı bellek alanları) 1 ve 0 dizileri düşünülmelidir. </br>
Peki bir dosyadaki 1 ve 0 dizisi ne anlama geliyor diye düşünülürse, bunu sadece dosyanın 1 ve 0 dizisine bakarak anlayamayız. </br>
Her dosyanın bir formatı vardır(buna **File Format** deniliyor), bir dosyadaki 1 ve 0 dizisinin nasıl yorumlanacağı dosyanın formatıyla ilgilidir. </br>
Verile bilecek en basit dosya formatı kursun başında gördüğümün **ASCII** karakter formatıdır, bu formatta her bir byte tek bir **ASCII** karaktere karşılık gelmektedir. </br>
Her dosyanın bir dosya formatı olmak zorundadır yoksa o dosyayla ilgili işlemlerin nasıl yapılacağı bilinemez ve o dosya üzerinde çalışılamaz. </br>
Bazı dosyaların formatlarının saklanma biçimi herkese açık olabilir(**.jpg**, **.png**, **.mp3** dosya formatları gibi) ya da bir şirketin mülkiyetinde olarak gizli olabilir(bir dosya formatının ne olduğu ve bilgilerin o dosya formatında nasıl tutulduğu dokümente edilmemiş olabilir)
Dosyalar birlerden ve sıfırlardan oluşan bir kümedir, dosyadaki bir ve sıfırların ne anlama geldiği bilgisine **File Format** denilmektedir.

Dosya işlemelrini kim yapıyor diye düşünülürse bunun cevabı işletim sistemidir. </br>
İşletim sistemleri bilgisayarların donanımını yönetmektedir, işletim sistemlerinin farklı farklı modülleri vardır, bu modüller içindeki önemli modüllerden biri de dosya işlemlerini yapan modüldür. </br>
C, C++, Java, Python vb. hangi programlama diliyle yazılmış bir program dosyalar üzerinde çalışacağı zaman dosyalar üzerindeki işlemleri yapacak olan işletim sisteminin fonksiyonlarıdır. </br>
İşletim sistemlerinin sistem fonksiyonları doğrudan da çağırılabilir(bu konu sistem programlamanın konusuna giriyor). </br>
Dosya işlemlerini yapan işletim sisteminin sistem fonksiyonları hem yazılan programlar taşınabilir olsun diye(farklı işletim sistemleri arasındaki taşınabilirlik) hem de işlemler daha kolay yapılabilsin diye programlama dilleri kendi standart kütüphenelerinde dosya işlemlerini yapan fonksiyonlar sunmaktadır. </br>
Programlama dillerinin standart kütüphenelerinin sunduğu dosya işlemlerini yapmak için kullanılan fonksiyonlar işletim sistemlerinin dosya işlemlerini yapmak için sunduğu sistem fonksiyonlarını sarmalayan fonksiyonlardır(**Function wrapper**). </br>
Programlama dillerinin standart kütüphenelerinin işletim sistemlerinin sistem fonksiyonlarını çağıran fonksiyonları işletim sistemi ile dilin sağladığı o fonksiyonları kullanan programı yazan programcı arasındaki bir ara tabaka gibidir, dilin standart kütüphanesi programcıyı işletim sistemiyle muatab etmeyen bir aracı gibidir. </br>
Farklı programlama dilleirnde dosya işlemlerinin yapılmasına yönelik farklı yaklaşımlar vardır. Mesela C++ dilinin standart kütüphenessinde nesne yönelimli denebilecek bir yapı vardır. </br>
C dilinde dosya işlemlerinin yapılması için kullanılan sistem ise daha aşağı seviyeli olarak **Handle Tekniğini** kullanıyor, dosya işlemi yapmak için kurucu(kaynakları ayıran fonksiyon) fonksiyona istek yapılır ardından işlemler bittikten sonra kaynakları iade edecek olan yıkıcı fonksiyona istek yapılır. </br>
C dilinde dosya işlemlerinin yapılması için kullanılacak tüm fonksiyonlar `stdio.h` başlık dosyasında bulunmaktadır, sadece dosya işlemlerinde kullanılan `stdio.h` başlık dosyasında bulunan 30 civarında fonksiyonu bu başlık altında inceleyeceğiz.
`stdio.h` başlık dosyasındaki dosya işlemleri için kullanılan fonksiyonları incelemeye `fopen` fonksiyonuyla başlayacağız.


❗❗❗ Çoğunlukla bir dosya işleminin yapılma sırası aşağıdaki gibidir;
1. İlk önce `fopen` fonksiyonu çağırılır.
2. `fopen` fonksiyonunun geri dönüş türü `FILE*` türünden bir değişkende saklanır.
3. `FILE*` türünde saklanan nesnenin adresini dosya işlemleri yapılacak fonksiyonlara geçerek ilgili dosya üzerinde gerekli işlemlerin yapılması sağlanır.
4. En son `fclose` fonksiyonu çağrılarak **handle sisteminde** ayrılan sistem kaynakları iade edilir.


Dosyalar üzerinde çalışırken dosya yapısının(**File Format**) ne olduğu önemli değildir yani dosya yapısının(**File Format**) elemanlarının ne olduğu gizlenip gizlenmediği tamamen derleyiciye bağlıdır, üzerinde işlem yapılan dosya `FILE*` türünden bir gösterici değişkene alınır ve tüm dosya işlemleri bu pointer üzerinden yapılır(dosyanın byte'larıyla işimiz olmaz, burada bir soyutlama mevcuttur).

C dilinde dosya işlemlerini öğrenmek demem C dilindeki standart dosya fonksiyonlarını öğrenmek demektir. Bu konu başlığı altında inceleyeceğimiz ve öğreneceğimiz içeriğin %90 kadarı standart kütüphanedeki dosyalarla ilgili işlem yapan fonksiyonlardır.


Aşağıda dosya işlemleri için kullanılan bazı fonksiyonlar görülebilir;
- `fopen`
- `fclose`
- `fgetc`
- `fputc`
- `fprintf`
- `fcsanf`
- `remove`
- `rename`
- `tmpfile`
- `tmpname`
- `fseek`
- `ftell`
- `fsetpos`
- `fgetpos`
- `ungetc`
- `strerr`
- `fflush`
- `feof`
- `ferror`
- `fwrite`
- `fread`


`FILE` işletim sistemi düzeyinde dosya işlemlerinin yapılmasında kullanılan bir tür aş adıdır, neyin tür eş adı olduğu derleyiciye bırakılmıştır.


### `fopen` Fonksiyonu 

`fopen` fonksiyonunun prototipi `FILE* fopen(const char* fname, const char* openmode);` biçimindedir, `fname` işlem yapılmak istenilen dosyanın adıdır. </br>
`openmode` açılmak istenilen dosyada yapılacak işlemlerin sınırını belirleyen bilgidir(dosya okumak için mi yazmak için mi vb. açılıyor bilgisi), `openmode` bilgisi dosya varsa ve dosya yoksa ne kapılacağını belirleyen bir parametredir. </br>


Dosyalar temel olarak ya okumak için ya da yazmak için açılır, dosya açılış yöndemlerinin bileşenleri aşağıdan incelenebilir.

Dosya açma işlemleri aşağıdaki durumlarda kullanılmaktadır;
1. Okuma(read) işlemi.
    1. Dosya varsa açılacak, dosya yoksa açılmayacak.
    2. Dosyadan okunabilir ama dosyaya yazılamaz.
2. Yazma(write) işlemi.
    1. Dosya varsa budanacak(truncate)(yani dosyanın üzerine yazılıp), dosya yoksa oluşturulacak.
    2. Dosyaya yazılabilir ama dosyadan okunamaz.
3. Sona yazma(append).
    1. Dosya varsa açılacak, dosya yoksa oluşturulacak.
    2. Dosyaya sadece sondan yazılabilir ama dosyadan okunamaz.


📌 C dilinin standart kütüphanesinde dosya oluştur anlamında bir standart fonksiyon yoktur, yeni bir dosya oluşturulmak isteniyorsa dosyayı yazma ya da sona ekleme(appent) biçiminde(mode) açmak gerekiyor. 



Dosya açma işlemleri aşağıdaki gibi çoklu işlemli biçimde de kullanılmaktadır;
1. **Okuma(read+)** işlemi.
    1. Dosya varsa açılacak, dosya yoksa açılmayacak.
    2. Dosyadan okunabilir ve dosyaya yazılabilir.
2. **Yazma(write+)** işlemi.
    1. Dosya varsa budanacak(truncate)(yani dosyanın üzerine yazılıp), dosya yoksa oluşturulacak.
    2. Dosyaya yazılabilir ve dosyadan okunabilir.
3. **Sona yazma(append+)**.
    1. Dosya varsa açılacak, dosya yoksa oluşturulacak.
    2. Dosyaya sadece sondan yazılabilir ve dosyadan okunabilir.



Dosyalardaki veriler iki farklı yöntemle işlenebilir;
1. Text mode(bu varsayılandır)
2. Binary mode



👇 Aşağıdaki programda programın çalıştırıldığı dizinde `test_file1.txt` adındaki bir metin dosyasının yazma amaçla nasıl açıldığı incelenebilir(dosya yoksa oluşturulacaktır), bu yöntemle dosyanın açılması dosyanın tüm içeriğinin silinmesi anlamına gelir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    FILE* f = fopen("test_file1.txt", "w"); // Dosya yazma yöntemiyle açılıyor.

    fclose(f); // Kaynaklar geri veriliyor.
}
```



Yukarıda ifade edilen **dosya açma yöntemlerinin(open mode)** nasıl yazılarla ifade edileceği aşağıda listelenmiştir;
1. **Text mode** ile;
    - Okuma   --> `r`. Dosyayı okumak için açar, dosya mevcut olmalıdır yoksa işlem başarısız olur. 
    - Okuma+  --> `r+`. Dosyayı okumak ve yazmak için açar, dosya mevcut olmalıdır yoksa işlem başarısız olur. 
    - Yazma   --> `w`. Dosyayı yazmak için açar, eğer dosya mevcutsa içeriği silinecektir, dosya mevcut değilse dosya oluşturulur.
    - Yazma+  --> `w+`. Dosyayı okumak ve yazmak için açar, eğer dosya mevcutsa içeriği silinecektir.
    - Append  --> `a`. Dosyanın sonundan itibaren dosyaya yazmak için açar, dosya mevcut değilse dosya oluşturulur.
    - Append+ --> `a+`. Dosyanın sonundan itibaren okumak ve yazmak için açar, dosya mevcut değilse dosya oluşturulur.
2. **Binary mode** ile;
    - Okuma   --> `rb`. Dosyayı 
    - Okuma+  --> `rb+`. Dosyayı 
    - Okuma+  --> `r+b`, `rb+` ile aynı. Dosyayı 
    - Yazma   --> `wb`. Dosyayı 
    - Yazma+  --> `wb+`. Dosyayı 
    - Yazma+  --> `w+b`, `wb+` ile aynı. Dosyayı 
    - Append  --> `ab`. Dosyayı
    - Append+ --> `ab+`. Dosyayı
    - Append+ --> `a+b`, `ab+` ile aynı. Dosyayı 


⚠️ `fopen` fonksiyonu başarısız olabilir, işletim sistemi dosyanın açılmasına bir nedenden dolayı izin vermeyebilir, bu nedenden dolayı dosya işlemleriyle çalışırken dosyanın açılıp açılmadığını sınanması gerekiyor, `fopen` fonksiyonu dosya açma işlemindeki başarısızlık durumunu geriye **NULL pointer** döndürerek bildirmektedir.



👇 Aşağıdaki programda okumuna yöntemiyle dosya açılmak istendiğinde olmayan bir dosyanın açılması işleminin başarısız olacağı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    FILE* f = fopen("yok_dosya.txt", "r"); // Dosya okuma yöntemiyle açılıyor.

    if(!f){ // if koşulu 'f == NULL' ile aynıdır.
        printf("dosya acilamadi.\n");
        return 1;
    }

    printf("dosya acildi.\n");

    fclose(f); // Kaynaklar geri veriliyor.
}
```


❗❗❗ Dosya işlemlerinde üzerinde işlem yapılacak dosyanın yolu belirtilmezse ilgili dosya programın kaynak dosyasının bulunduğu dizinde aranacaktır.



👇 Aşağıdaki programda farklı bir dizinde dosya işlemi yaparken dosya yolu(file path) ile nasıl bildirildiğini anlamak için incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    FILE* f = fopen("c:\\neco\\test_file2.txt", "w"); // Dosya yazma yöntemiyle açılıyor.

    if(!f){ // if koşulu 'f == NULL' ile aynıdır.
        printf("dosya olusturulamadi.\n");
        return 1;
    }

    printf("dosya olusturuldu.\n");

    fclose(f); // Kaynaklar geri veriliyor.
}
```


📌 Dosya açılamazsa ne yapılacağı programın yapısına bağlıdır, prıgramın varşlık nedeni dosya(lar) üzerinde bazı işlemlerin yapılmasıysa program sonlandırılabilir.


### `fclose` Fonksiyonu 

`fclose` fonksiyonunun prototipi `int fclose(FILE*);` biçimindedir, bu fonksiyon `FILE*` türünden bir değişkeni parametre olarak almaktadır. </br>
`fclose` fonksiyonu çağırılmazsa ne olur, işletim sistemlerinin hepsinde program varsaylan biçimde sonlanırsa(`exit()` fonksiyonuna yapılan çağrıyla program sonlanırsa) açık dosyalar kapatılacaktır. </br>
Eğer program çökme sonucunda kapatılırsa açık dosyaların kapatılacağı kesin değildir, bu nedenden dolayı mutlaka açılan dosyaları kapatma fonksiyon çağrıları eklenmelidir. </br>
`fclose` fonksiyonundan geriye dönen değer 0 ise dosyanın kapatılma işleminin başarılı olduğu anlamına gelmektedir.



👇 Aşağıdaki programda okumak amaçlı bir dosyanın açılma kapanma işleminin nasıl sınandığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    FILE* f = fopen("test_file4.txt", "r"); // Dosya okuma yöntemiyle açılıyor.

    if(!f){ // if koşulu 'f == NULL' ile aynıdır.
        printf("dosya acilamadi.\n");
        return 1;
    }

    printf("dosya acildi.\n");

    if(fclose(f)){
        printf("dosya kapatilamadi.\n");
    }
    else{
        printf("dosya kapatildi.\n");
    }
}
```


***
==================================================

✦✦✦✦✦ 10.41-11.01 birinci ara verildi. ✦✦✦✦✦

==================================================
***


❗❗❗ `fclose` fonksiyonununa çağrı yapılan `FILE*` türünden bir gösterici, `fclose` fonksiyonu işini bitirdikten sonra bu fonksiyona geçilen `FILE*` türünden gösterici **dangling pointer** haline geleceği için tekrardan bu göstericinin `fclose` fonksiyonuna argüman olarak geçilmesi **tanımsız davranıştır(ub)**.



👇 Aşağıdaki programda kapatılmış bir dosyayı yeniden kapatma isteğinin yapılmasının **ub** durumuna neden olduğu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    FILE* f1 = fopen("test_file3.txt", "r"); // Dosya okuma yöntemiyle açılıyor.

    if(!f1){ // if koşulu 'f == NULL' ile aynıdır.
        printf("dosya acilamadi.\n");
        return 1;
    }

    FILE* f2 = f1;


    fclose(f1);

    // some code here ...

    fclose(f2); // Burada tanımsız davranış vardır, 
}
```


### Standart Olmayan `fcloseall` Fonksiyonu 

`fcloseall` fonksiyonunun prototipi `int fcloseall(void);` biçimindedir, geriye dosya kapatma işlemi başarılı olan dosya sayısını döndürür, bu fonksiyon standart değildir ama hemen hemen tüm derleyiciler bu fonksiyonu sağlar. </br>
Bu fonsiyon aynı anda birden fazla fonksiyon üzerinde çalışıldığında tek tek tüm fonksiyonlar için ayrı ayrı dosya kapatma işlemi yapmak yerine toplu bir biçimde tüm açık dosyaların kapatılamsı için kullanılmaktadır. </br>



👇 Aşağıdaki programda tek seferde tüm açık dosyaların nasıl kapatıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    FILE* f1 = fopen("mete.txt", "w");
    FILE* f2 = fopen("alper.txt", "w");
    FILE* f3 = fopen("tuana.txt", "w");
    FILE* f4 = fopen("umay.txt", "w");

    /* some code here ... */
    
    int result = fcloseall();

    printf("result = %d\n", result);
}
```


### Dosya İşlemlerinin Yapılmasının İncelenmesi 

Dosya işlemlerini yapan standart C fonksiyonlarını üç temel öbeğe ayırabiliriz;
1. Okuma işlemlerini yapan fonksiyonlar.
    - `fgetc` fonksiyonu
    - `fscanf` fonksiyonu
    - `fgets` fonksiyonu
    - `fread` fonksiyonu
2. Yazma işlemlerini yapan fonksiyonlar.
    - `fputc` fonksiyonu
    - `fprintf` fonksiyonu
    - `fputs` fonksiyonu
    - `fwrite` fonksiyonu
3. **Dosya konum göstericisi(file pointer)** ile işlem yapan fonksiyonlar.
    - `fseek` fonksiyonu
    - `rewind` fonksiyonu
    - `ftell` fonksiyonu
    - `fsetpos` fonksiyonu
    - `fgetpos` fonksiyonu



❗❗❗Dosyadan okuma yapmak dosyadaki byte ya da byte'ların değerini öğrenmek demektir, dosyadan okuma(ya da yazma) işlemine dosyanın hangi byte'ından başlayarak dosyadan okuma(ya da yazma) işlemi yapılacak bunun bilgisini tutan bizim doğrudan erişemediğimiz sistem tarafından tutulan bir tam sayı değişken vardır işte bu tam sayı değişkene **dosya konum göstericisi(file pointer)** denilmektedir. </br>
**Dosya konum göstericisinin(file pointer)** değeri hangi tam sayı ise dosyadan okuma(ya da yazma) yapacak fonksiyon o byte'tan başlayarak okuma(ya da yazma) işlemini yapacaktır, buradaki indeksleme işlemi 0'dan başlamaktadır, dosyanın ilk byte'ı 0 indeksine sahiptir. </br>
Okuma ya da yazma işlemi yapan fonskiyonlar dosyanın hangi indeksinden itibaren işlem yapacağı bilgisini fonksiyon çağrısı yapan koddan istememektedir, index değerini **dosya konum göstericisinin(file pointer)** değerinden öğrenmektedirler. </br>
Okuma ya da yazma işlemi yapan fonskiyonlar hangi byte'tan itibaren işlem yapacakları bilgisini çağıran koddan istemez, **dosya konum göstericisinin(file pointer)** değeri ne ise o indeksli byte'tan(buna **offset** değeri deniliyor) başlayarak işlem yapılacaktır. </br>
Okuma işlemi yapan fonksiyonlar okudukları byte sayısı kadar ve yazma işlemi yapan fonksiyonlarda yine yazdıkları byte sayısı kadar **dosya konum göstericisinin(file pointer)** değerini arttırmaktadır. </br>
Bir dosya ilk açıldığında **dosya konum göstericisinin(file pointer)** değeri 0 değerinde olacaktır, dosya üzerinde işlem yapıldıkça **dosya konum göstericisinin(file pointer)** değeri artacaktır. </br>
Bir dosya üzerinde okuma ve yazma işleminin sıralı biçimde yapılmasına "**Sequential Access**" denilmektedir, bir dosya 2000 byte'tan oluşuyorsa ve dosyanın 1986. byte'ının **sequential access** yöntemiyle okunması isteniyorsa bu durumda dosyanın 1985 byte'ının okunması gerekiyor ki dosyanın 1986. byte'ı okunabilsin. </br>
Bir dosya üzerinde okuma ve yazma işleminin rastgele biçimde yapılmasına "**Random Access**" ya da "**Direct Access**" denilmektedir, bir dosya 2000 byte'tan oluşuyorsa ve dosyanın 1986. byte'ının **random access** yöntemiyle okunması isteniyorsa bu durumda doğrudan 1986. byte'ı okuyabiliriz. </br>
Okuma ve yazma işlemi için ortak tek bir gösterici kullanılmaktadır.



**Dosya konum göstericisi(file pointer)** işlemleri **Dosya konum göstericisi(file pointer)** değerinin edinilmesini ve değiştirilmesini sağlayan işlemleri kapsamaktadır. </br>


### `fgetc` Fonksiyonu 

`fgetc` fonksiyonunun prototipi `int fgetc(FILE*);` biçimindedir, bu fonksiyondan **dosya konum göstericisinin(file pointer)** gösterdiği indeksteki byte değerini `int` türünden bir değer olarak geriye döndürmektedir. 

`fgetc` fonksiyonu neden dolayı başarısız olabilir;
1. Doğal başarısızlık(genel olarak kullanılan bir terim değildir): Dosyadan okunacak byte kalmadığında `fgetc` fonksiyonu başarısız olacaktır, bu durumda `fgetc` fonksiyonundan geriye `EOF` değeri döner.
2. Doğal olmayan başarısızlık(genel olarak kullanılan bir terim değildir): 


`EOF` değeri bir **object-like** mokrodur, bu makronun adı **End of File** sözcüklerinden gelmektedir, bu makronun değeri derleyiciler taarfından "-1" değerine atanmıştır yani sadece sabit değere karşılık gelen bir hata kodudur.



👇 Aşağıdaki programda `fgetc` fonksiyonu kullanılarak `mete.txt` dosyasındaki içeriği byte byte okunması işlemi incelenebilir, `mete.txt` dosyasında sadece dört byte'lık veri olduğunda beşimci `fgetc` fonksiyonu isteğinde fonksiyondan geriye `EOF` değeri dönecektir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    FILE* f = fopen("mete.txt", "r");
    if(!f){
        printf("dosya acilamadi.\n");
        return 1;
    }

    int c;

    c = fgetc(f);
    printf("c = %d\n", c);
    c = fgetc(f);
    printf("c = %d\n", c);
    c = fgetc(f);
    printf("c = %d\n", c);
    c = fgetc(f);
    printf("c = %d\n", c);
    c = fgetc(f);
    printf("c = %d\n", c);
}
```



👇 Aşağıdaki programda dosya işlemlerinde karakter karakter dosyanın tüm byte'larının okunması işleminin nasıl yapıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    FILE* f = fopen("main.c", "r");
    if(!f){
        printf("dosya acilamadi.\n");
        return 1;
    }

    int c;

    while ((c = fgetc(f)) != EOF) {
        putchar(c);
    }

    fclose(f);
}
```


⚠️ `fgetc` fonksiyonunun kullanımında en sık yapılan hata geri dönüş değerinin `char` türüne atanması işlemidir ama bu fonksiyondan geriye dönen değer `int` türündendir, bu durumda derleyiciler tür daralmasından dolayı uyarı iletisi verecektir.



👇 Aşağıdaki programda komut satırından alınacak dosyaların içeriği yazdırılacaktır(bu programın çalıştırılabilir dosyasının dizinine cmd'de gittikten sonra "<çalıştırılabilir dosya adı> <okunacak dosya adi>" biçiminde çalıştırabilirsin).
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(int argc, char **argv)
{
    if(argc != 2){
        printf("kullanim: <dyaz> <dosya adi>\n");
        return 1;
    }

    FILE* f = fopen(argv[1], "r");
    if(f == NULL){
        printf("%s dosyasi acilamadi\n", argv[1]);
        return 2;
    }

    int c;

    while ((c = fgetc(f)) != EOF)
        putchar(c);
    
    fclose(f);
}
```



👇 Aşağıdaki programda komut satırından alınacak dosyaların içinde geçen özel bir karakterin adedinin sayısını hesaplayan program incelenebilir(bu programın çalıştırılabilir dosyasının dizinine cmd'de gittikten sonra "**<çalıştırılabilir dosya adı> <okunacak dosya adi> <sayilacak karakter>**" biçiminde çalıştırabilirsin).
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(int argc, char **argv)
{
    if(argc != 3){
        printf("kullanim: <ksay> <dosya adi> <sayilacak karakter>\n");
        return 1;
    }

    FILE* f = fopen(argv[1], "r");
    if(f == NULL){
        printf("%s dosyasi acilamadi\n", argv[1]);
        return 2;
    }

    int c;
    int cnt = 0;

    while ((c = fgetc(f)) != EOF)
        if(c == *argv[2])
            ++cnt;
    
    fclose(f);

    printf("%d\n", cnt);
}
```



👇 Aşağıdaki programda komut satırından alınacak dosyanın içinde geçen karakterin hepsinin adedinin sayısını hesaplayan ve standart çıktı akımına alfabetik sırada gönderen program incelenebilir(bu programın çalıştırılabilir dosyasının dizinine cmd'de gittikten sonra "**<çalıştırılabilir dosya adı> <okunacak dosya adi> <sayilacak karakter>**" biçiminde çalıştırabilirsin).
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h> // Added to use "character test functions".

int main(int argc, char **argv)
{
    if(argc != 2){
        printf("kullanim: <khsay> <dosya adi>\n");
        return 1;
    }

    FILE* f = fopen(argv[1], "r");
    if(f == NULL){
        printf("%s dosyasi acilamadi\n", argv[1]);
        return 2;
    }

    int cnts[26] = { 0 }; // İngiliz alfabesinde 26 harf olduğu için, her bir harfin ilgili dosyada kaç adet bulunduğu bilgisi bu dizide tutulacak.
    int c;

    while ((c = fgetc(f)) != EOF){
        if(isalpha(c)){
            ++cnts[toupper(c) - 'A'];
        }
    }

    fclose(f);

    for(int i = 0; i < 26; ++i){
        if(cnts[i]){
            printf("%c  %d\n", 'A' + i, cnts[i]);
        }
    }
}
```



👇 Aşağıdaki programda komut satırından alınacak dosyanın içinde geçen karakterin hepsinin adedinin sayısını hesaplayan ve standart çıktı akımına en çok bulunan karakterden azalarak gönderen program incelenebilir(bu programın çalıştırılabilir dosyasının dizinine cmd'de gittikten sonra "**<çalıştırılabilir dosya adı> <okunacak dosya adi> <sayilacak karakter>**" biçiminde çalıştırabilirsin). </br>
Bu programın yaptığı işlemi yapan programın yazılması C mülakatlarında istenmektedir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h> // Added to use "character test functions".

typedef struct{
    char c;
    int cnt;
} Elem;


// 'qsort' fonksiyonuna geçilecek olan sıralama fonksiyonu.
int elemcmp(const void* vp1, const void* vp2){
    return ((const Elem*)vp2)->cnt - ((const Elem*)vp1)->cnt;
}

int main(int argc, char **argv)
{
    // 'Elem cnts[26]' dizisininilklendirme lemanlarını oluşturmak için kullanılan kod parçası.
    // for(int i = 0; i < 26; ++i){
    //     printf("{'%c', 0},\n", 'A' + i);
    // }

    if(argc != 2){
        printf("kullanim: <khsay> <dosya adi>\n");
        return 1;
    }

    FILE* f = fopen(argv[1], "r");
    if(f == NULL){
        printf("%s dosyasi acilamadi\n", argv[1]);
        return 2;
    }

    // İngiliz alfabesinde 26 harf olduğu için, her bir harfin ilgili dosyada kaç adet bulunduğu bilgisi bu dizide tutulacak.
    Elem cnts[26] = { 
        {'A', 0},
        {'B', 0},
        {'C', 0},
        {'D', 0},
        {'E', 0},
        {'F', 0},
        {'G', 0},
        {'H', 0},
        {'I', 0},
        {'J', 0},
        {'K', 0},
        {'L', 0},
        {'M', 0},
        {'N', 0},
        {'O', 0},
        {'P', 0},
        {'Q', 0},
        {'R', 0},
        {'S', 0},
        {'T', 0},
        {'U', 0},
        {'V', 0},
        {'W', 0},
        {'X', 0},
        {'Y', 0},
        {'Z', 0},
    };
    int c;

    while ((c = fgetc(f)) != EOF){
        if(isalpha(c)){
            ++cnts[toupper(c) - 'A'].cnt;
        }
    }

    qsort(cnts, 26, sizeof(Elem), elemcmp);

    fclose(f);

    for(int i = 0; i < 26; ++i){
        if(cnts[i].cnt){
            printf("%c  %d\n", cnts[i].c, cnts[i].cnt);
        }
    }
}
```


***
==================================================

✦✦✦✦✦ 12.02-12.16 ikinci ara verildi. ✦✦✦✦✦

==================================================
***


📌 Programın çalışmasında bir dosya açılıp üzerinde işlemler yapıldıktan sonra o dosya kapatılır ve yeniden(program sonlanmadan) açılırsa **dosya göstericisinin(file pointer)** değeri sıfırlanır.


### **Text mode** ve **Binary mode** İşlemlerinin Detayları 

Unix/Linux sistemlerinde dosyaları **text mode** veya **binary mode** olarak açmak arasında teknik olarak bir fark yoktur. </br>
Windows sistemlerinde dosyaları **text mode** ya da **binary mode** olarak açınca bazı işlemleri farklı yapılmaktadır.

Dosyanın içeriği yazı(text) değilse bu dosya **binary mode** olarak açılmalıdır. </br>
Dosyanın üzerinde yapılacak işlemler dosyanın içeriğinden bağımsızsa(mesela dosya içeriğinin kopyalanması işlemleri) **binary mode** olarak açılmalıdır.

Windows sisteminde bir dosya **text mode** olarak yazma işlemi için açıldığında **yeni satır(newline)** karakteri yazıldığında bu karakter dosyaya iki byte olarak yazılmaktadır.



👇 Aşağıdaki programda Windows sisteminde bir dosyaya **text mode** ile yüz defa **yeni satır(newline)** karakteri yazdırıldığı durumda dosyanın boyutunun ve okunma işleminin nasıl olduğu incelenebilir(dosya boyutu 200 byte olacaktır).
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h> // Added to use "character test functions".

int main(void)
{
    FILE* fw = fopen("abc", "w");
    if(!fw){
        printf("acilamadi.\n");
        return 1;
    }

    for(int i = 0; i < 100; ++i){
        fputc('\n', fw);
    }

    fclose(fw);


    FILE* fr = fopen("abc", "r");
    if(!fr){
        printf("acilamadi.\n");
        return 1;
    }

    int c;

    while((c = fgetc(fr)) != EOF)
        printf("%d ", c);

    fclose(fr);
}
```



👇 Aşağıdaki programda Windows sisteminde bir dosyaya **binary mode** ile yüz defa **yeni satır(newline)** karakteri yazdırıldığı durumda dosyanın boyutunun ve okunma işleminin nasıl olduğu incelenebilir(dosya boyutu 100 byte olacaktır).
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h> // Added to use "character test functions".

int main(void)
{
    FILE* fw = fopen("abc", "wb");
    if(!fw){
        printf("acilamadi.\n");
        return 1;
    }

    for(int i = 0; i < 100; ++i){
        fputc('\n', fw);
    }

    fclose(fw);


    FILE* fr = fopen("abc", "rb");
    if(!fr){
        printf("acilamadi.\n");
        return 1;
    }

    int c;

    while((c = fgetc(fr)) != EOF)
        printf("%d ", c);

    fclose(fr);
}
```



❗❗❗ Eskiden dosyaların sonunu belirtmek için **Ctrl + Z(26 kod numaralı karakter ekleniyormuş)**, Windows sisteminde bir dosya **text mode** olarak açıldığında ve byte byte okuma yapıldığında eğer okunan byte 26 değerindeyse bu byte'a `EOF` muamelesi yapılmaktadır, ama dosya **binary mode** olarak açıldığında ve byte byte okuma yapıldığında eğer okunan byte 26 değerindeyse bu byte'a `EOF` muamelesi yapılmamaktadır.



👇 Aşağıdaki programda Windows sisteminde bir dosyaya **binary mode** olarak yazma işlemi yapıldıktan sonra bu dosyanın **text mode** olarak açıldığında bu dosyanın içeriğinin byte byte okunması sonucunda okunan bir byte'ın değeri eğer 26 ise o byte'ın dosya sonunu belirten `EOF` muamelesi yapılacağı, **binary mode** olarak açıldığında bu dosyanın içeriğinin byte byte okunmasında okunan bir byte'ın değeri eğer 26 olması durumda bir sorun oluşmayacağı gözlemlenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h> // Added to use "character test functions".

int main(void)
{
    FILE* fw = fopen("abc2", "wb");
    if(!fw){
        printf("acilamadi.\n");
        return 1;
    }

    for(int i = 0; i < 100; ++i){
        fputc('a', fw);
    }

    fputc(26, fw);
    
    for(int i = 0; i < 100; ++i){
        fputc('b', fw);
    }

    fclose(fw);
    

    printf("~~~~~~~~~~~~~~~~~~~");


    FILE* fr = fopen("abc2", "r");
    if(!fr){
        printf("acilamadi.\n");
        return 1;
    }

    int c;

    while((c = fgetc(fr)) != EOF)
        printf("%d ", c);

    fclose(fr);


    printf("~~~~~~~~~~~~~~~~~~~");


    FILE* fr = fopen("abc2", "rb");
    if(!fr){
        printf("acilamadi.\n");
        return 1;
    }

    int c;

    while((c = fgetc(fr)) != EOF)
        printf("%d ", c);
    
    fclose(fr);
}
```


### `fputc` Fonksiyonu 

`fputc` fonksiyonunun prototipi `int fputc(int c, FILE*);` biçimindedir, bu fonksiyon dosyaya bir karakter işlemini gerçekleştirmektedir, bu fonksiyonun ilk parametresi yazılacak byte'ın değeridir, ikinci parametresi üzerinde işlem yapılacak dosyadır, fonksiyonun geri dönüş değeri yazma işleminde bir hata olmulsa `EOF` değeridir, yazma işleminde bir hata olmamışsa dosyaya yazdırılan karakterin tam sayı değeridir.



👇 Aşağıdaki programda bir dosyaya **text mode** ile nasıl İngiliz alfabesindeki büyük harflarin yazdırılabileceği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h> // Added to use "character test functions".


int main(void)
{
    FILE* f = fopen("timur.txt", "w");
    if(!f){
        printf("acilamadi.\n");
        return 1;
    }

    for(int i = 'A'; i <= 'Z'; ++i){
        fputc(i, f);
    }

    fclose(f);
}
```



👇 Aşağıdaki programda bir dosyaya **text mode** ile nasıl İngiliz alfabesindeki büyük yazdırılabilir karakterlerin standart çıktı akımına gönderilebileceği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h> // Added to use "character test functions".


int main(void)
{
    FILE* f = fopen("timur.txt", "w");
    if(!f){
        printf("acilamadi.\n");
        return 1;
    }

    for(int i = 0; i < 128; ++i){
        if(isprint(i))
            fputc(i, f);
    }

    fclose(f);
}
```



👇 Aşağıdaki programda komut satırı argümanı olarak alınan değerlere göre bir dosyaya **text mode** ile nasıl birden fazla satırın yadırılabileceği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv)
{
    if(argc != 5){
        printf("usage: <crf> <filename> <no of lines> <min line length> <max line length>\n");
        return 1;
    }

    FILE *fw = fopen(argv[1], "w");
    if(fw == NULL){
        printf("cannot create file %s\n", argv[1]);
        return 2;
    }

    int no_of_lines = atoi(argv[2]);
    int min_len = atoi(argv[3]);
    int max_len = atoi(argv[4]);

    for(int i = 0; i < no_of_lines; ++i){
        int line_len = rand() % (max_len - min_len + 1) + min_len;
        while(line_len--)
            fputc(rand() % 26 + 'A', fw);
        fputc('\n', fw);
    }

    fclose(fw);
}
```



👇 Aşağıdaki programda komut satırı argümanı olarak alınan değerlere göre bir dosyanın içeriğinin başka bir dosyaya **binary mode** ile nasıl kopyalanabileceğini anlamak için incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h> // Added to use "character test functions".

int main(int argc, char **argv)
{
    if(argc != 3){
        printf("usage: <filecopy> <source file name> <dest file name>\n");
        return 1;
    }

    FILE* fsource = fopen(argv[1], "rb");
    if(!fsource){
        printf("cannot open file %s\n", argv[1]);
        return 2;
    }

    FILE* fdest = fopen(argv[2], "wb");
    if(!fdest){
        printf("cannot create file %s\n", argv[2]);
        fclose(fsource);
        return 3;
    }

    int byte_count = 0;
    int c;

    // Aşağıdaki döngü ile kaynak dosyanın sonu görünene kadar olan tüm byte'lar hedef dosyaya byte byte yazılyor.
    while((c = fgetc(fsource) != EOF)){
        fputc(c, fdest);
        ++byte_count;
    }
    
    fclose(fsource);
    fclose(fdest);

    printf("the file %s of %d bytes copied as file %s\n", argv[1], byte_count, argv[2]);
}
```


Ders sonu ...
