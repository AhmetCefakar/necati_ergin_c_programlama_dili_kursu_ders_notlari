# 2. Ders 12.01.2025 ğŸ•˜

Derse 29-38 kiÅŸi katÄ±ldÄ±.
---

## C Dilinin Tarihi

Ä°lk baÅŸta dÃ¼n yapÄ±lan dersin kÄ±sa bir aÃ§Ä±klamasÄ±nÄ± yapÄ±ldÄ±.

C dili yÃ¼ksek seviyeli dillerin alt kÄ±smÄ±nda olduÄŸu iÃ§in orta seviyeli bir dil olduÄŸu sÃ¶ylenebilir.

Java, C# vb. diller Ã§oÄŸunlukla static tÃ¼r desteÄŸi olan diller ama yapÄ±larÄ±nda belirli seviyede dynamic tÃ¼r desteÄŸi de mevcuttur.

C dili standarda sahip olduÄŸu iÃ§in farklÄ± derleyicilerin C kodunu aynÄ± yorumladÄ±ÄŸÄ±nÄ± ve C dilinde yazÄ±lmÄ±ÅŸ programlarÄ±n kaynak kod olarak taÅŸÄ±nabilir bir dildir, bu taÅŸÄ±nabilirlik kaynak kodun farklÄ± mikro iÅŸlemciler arasÄ±ndaki taÅŸÄ±nabilirliÄŸidir.

C ve C++ arasÄ±ndaki farklara/benzerliÄŸe daha fazla deÄŸinilecek, piyasada C dilini bilenlerden C++ dilini de bilmeleri beklenmektedir. C++'Ä±n Ã§ekirdeÄŸinde bir miktar C dili bulunmaktadÄ±r. C ve C++ dillerinin her ikisi de topluluk yÃ¶netiminde mÃ¼lkiyetsiz bir dildir. C dili kÃ¼Ã§Ã¼k ve genel bir dildir. C ve C++ dilleri static tÃ¼r kullanan dillerdir. TÃ¼r kontrolÃ¼nÃ¼n **weak type checking** ve **strong type checking** olarak iki farklÄ± yaklaÅŸÄ±mÄ± vardÄ±r. KÃ¼Ã§Ã¼k bir dilde daha az araÃ§ vardÄ±r ve dilin araÃ§larÄ± daha az ve derlendiÄŸinde az yer kaplamaktadÄ±r. C++ dili Ã§oklu paradigmaya sahiptir, procedural, nesne yÃ¶nelimli, generic programlama ve en son versiyonu fonksiyonel programlama yaklaÅŸÄ±mlarÄ±na destek vermektedir. Her iki dil de yaygÄ±n kullanÄ±ma sahiptir, her zaman ilk Ã¼Ã§ sÄ±rada yer almaktadÄ±rlar. Yeni dilleri bu dillere rakip olacaÄŸÄ± ve yerlerini alacaklarÄ± belirtilse bile C ve C++ dillerinin kullanÄ±mÄ± zaman iÃ§inde artmaktadÄ±r.

Programlama dilleri sÃ¶z konusu olduÄŸunda bir ekosistem vardÄ±r, yazÄ±lÄ±mda ekosistem birbiriyle baÄŸlantÄ±lÄ± birbirlerini kullanan yapÄ±lardan oluÅŸur, programcÄ±larÄ±n dilleri Ã¶ÄŸrenmesi gerekir(dÃ¼nya Ã§aÄŸÄ±nda 8-9 milyon civarÄ± C++ programcÄ± varmÄ±ÅŸ ve C dilini kullanan programcÄ± sayÄ±sÄ± 9 milyondan fazlaymÄ±ÅŸ), yazÄ±lÄ±m platformlarÄ±nda bir Ã§ok kÃ¼tÃ¼phane yazÄ±lmÄ±ÅŸ olduÄŸu iÃ§in her yeni projeye baÅŸlanÄ±rken tÃ¼m kodlar yeniden yazÄ±lmaz baÅŸkalarÄ±nÄ±n yazdÄ±ÄŸÄ± kodlar(kÃ¼tÃ¼phaneler vb.) kullanÄ±lÄ±r, bu gibi nedenlerden dolayÄ± bir dilin bÄ±rakÄ±lmasÄ± zor olabilir. C ve C++ dillerinde bir Ã§ok kÃ¼tÃ¼phane, tool, derleyici vb. ÅŸeyler mevcut. Yeni bir dilde de bu yapÄ±larÄ±n oluÅŸturulmasÄ± gerekecektir ve bu zaman alacaktÄ±r. Rust dilini C++'Ä±n yerini alacaÄŸÄ±nÄ±n sÃ¶ylenmesinin cahilce olduÄŸu belirtildi. 

C dilinin ortaya Ã§Ä±kÄ±ÅŸÄ± 1970'e kadar gidiyor ama programlarÄ±n tarihÃ§esi daha eskiye gitmektedir. 1, 2, 3, 4.kuÅŸak diller vardÄ±r. Makine dilleri 1. kuÅŸak diller olarak ifade ediliyor, 2. kuÅŸak diler assembly dilleridir, 3. kuÅŸak diller makine ve assembly dillerinden sonra ortaya Ã§Ä±kan insan konuÅŸma dillerine biraz daha yakÄ±n dillerdir, bu diller ilk baÅŸta ÅŸu dillerdi: **Fortran**, **Cobol**, **Algol**(IBM'in geliÅŸtirdiÄŸi ve C'nin atasÄ± kabul edilen bir dil) ve bu diller diÄŸer programlama dillerinin atasÄ± olarak kabuledilmektedir. **Fortran** Nasa'da yoÄŸun kullanÄ±lmaktadÄ±r. Necati Ergin Ã¼niversitedeyken **Fortran** ile delikli kartlar ile program yazmaya baÅŸlamÄ±ÅŸ. **Fortran** yÃ¼ksek performanslÄ± uygulamalarda kullanÄ±lÄ±yor gÃ¼nÃ¼mÃ¼zde. **Cobol(Common Business Oriented language)** dili insanÄ±n konuÅŸtuÄŸu dile Ã¶ykÃ¼nen bir dildir. **Algol** dili aÃ§Ä±lÄ±mÄ± "**Algorithmic Language**" ve C dilinin atasÄ± bir dildir. **Algol** dilinden sonra **BCPL** dili **Algol** dilini temel alÄ±narak ortaya Ã§Ä±kÄ±yor. C dili **BCPL** dilini temel alarak geliÅŸtiriliyor. 

Bell laboratuvarlarÄ± bir zamanlar Amerika da telekominikasyon sektÃ¶rÃ¼nde tekeldi ve bir Ã§ok baÅŸarÄ±lÄ± insanÄ± bÃ¼nyesinde barÄ±ndÄ±rÄ±yordu. **BCPL** dilinde **B** dili, **B** dilinden **New B** ve bu dilden de **C** dili oluÅŸturuluyor. C dili 1972-1973 tarihinde doÄŸdu denilebilir, C dili Unux iÅŸletim sisteminin yazÄ±m sÃ¼recinde bir yan Ã¼rÃ¼n olarak ortaya Ã§Ä±kÄ±yor, C dilinin tasarÄ±mcÄ±larÄ± **Ken Thompson** ve **Dennis Ritchie** dÄ±r. C diliyle ilgili ilk kitap 1978 yÄ±lÄ±nda yazÄ±lan "**The C Programming Language**" kitabÄ±dÄ±r(bu kitap Unix iÅŸletim sistemindende bahsetmektedir). C dilinin standartlaÅŸtÄ±rÄ±lmasÄ±ndan Ã¶nceki dÃ¶neme farklÄ± adlar veriliyor, bu adlar: **Clacick C**, **Traditional C**. C dilinin standardÄ± olmadÄ±ÄŸÄ± dÃ¶nemde yazÄ±lan C programlarÄ± **The C Programming Language** kitabÄ±nÄ± dilin standardÄ± gibi kullanÄ±lÄ±yordu ve bu nedenle bu programlar **K & R** standardÄ± ile yazÄ±lmÄ±ÅŸ olarak niteleniyordu. 1983 yÄ±lÄ±nda C dilinin standartlarÄ±nÄ±n belirlenmesi iÃ§in bir kominite oluÅŸturuluyor. C dilinin ilk standardÄ± 1989 yÄ±lÄ±nda AmerikanÄ±n standart ensitÃ¼tesinin "**ANSI-ISO C89**" belgesiyle yayÄ±nlanmÄ±ÅŸtÄ±r. C dilinin ikinci standardÄ± C99 standardÄ±dÄ±r.

â— B ve C dillerinin geliÅŸtirilme amacÄ± bir iÅŸletim sistemi yazabilmek iÃ§indi.

â— C dilinin hangi ata dillerden geliÅŸtiÄŸini ÅŸu ÅŸekilde Ã¶zetleyebiliriz: "**Algol --> BCPL --> B Language --> New B Language(Ara bir dil denilebilir) --> C Language**"

C dili **Ken Thompson** ve **Dennis Ritchie**(The C Programming Language kitabÄ±nÄ±n yazarlarÄ±)" tarafÄ±ndan Unix iÅŸletim sistemini yazarken ortaya mecburiyetten Ã§Ä±kan bir yan Ã¼rÃ¼n gibidir, UNIX iÅŸletim sistemi ilk baÅŸta ÅŸu "**PDP-7 and PDP-11**" bilgisayarlarla birlikte Ã§alÄ±ÅŸabilmesi iÃ§in geliÅŸtirilmiÅŸtir.

- **Not almanÄ±za gerek yok, hem Ã¶ÄŸrencilerin aldÄ±ÄŸÄ± notlar hem de kendi notu varmÄ±ÅŸ onu paylaÅŸacaÄŸÄ±nÄ± belirtildi**.
- "**O zaman Ã§ok Ã¶nemli olmadÄ±kÃ§a bir ÅŸey yazmayacaÄŸÄ±m.**" demiÅŸtim ama sonradan dersleri tekrarederken yazmaya kara verdim Ã§Ã¼nkÃ¼ paylaÅŸÄ±lan ders notlarÄ± bana gÃ¶re Ã§ok kaliteli deÄŸildi!

â—2020-2025'li senelerde daha Ã§ok C99 standardÄ±na gÃ¶re C projeleri kodlanmaktadÄ±r.

C99 standardÄ±yla gelen yeniliklerle birlikte C++ dilinin iÃ§inde yer alan C dilinde C99 ve sonraki standartlarÄ±n kullanÄ±lmasÄ±nÄ±n "**Legal**" olmasÄ± daha zor hale gelmiÅŸtir.

Åu ana kadarki C standartlarÄ± ÅŸunlardÄ±r => C89(Major), C99(Major), C11(Major, multi treading gibi yeni eklemeler yapÄ±ldÄ±), C17(ilk oluÅŸturulduÄŸu sene)-C18(resmi olarak yayÄ±nlanÄ±m zamanÄ±)[Minor], C23(Minor) 


Kursun sonuna doÄŸru 8 saat boyunca C99 standardÄ± ile gelen yenilikler anlatÄ±lacakmÄ±ÅŸ.


Bu kursta C99 standardÄ±yla eklenen tÃ¼m araÃ§larÄ± ve C11 standardÄ± ile eklenen Ã¶nemli araÃ§larÄ± gÃ¶receÄŸiz. Kust boyunca standartlardan daha Ã§ok **ana akÄ±m derleyiciler(main stream compiler)[GCC, Clang, Microsolf C ve C++ compiler, IBM compiler, ARM temelli derleyiciler]** C dili iÃ§in verdikleri destekler dikkate alÄ±narak anlatÄ±m yapÄ±lacak, bu ana akÄ±m derleyiciler C99 standardÄ±nÄ±n tamamÄ±na ve C11 standardÄ±na kÄ±smÄ± olarak destek vermektedir. Kurs esas olarak C99 standardÄ± baz alÄ±nacak ilerleyecek denilebilir. 

Go dili(**Ken Thompson** bu dilin oluÅŸturulmasÄ±nda yer almÄ±ÅŸtÄ±r) sistem programlama tarafÄ±nda da kullanÄ±lan yaygÄ±n bir dildir, **Ken Thompson** Unix iÅŸletim sistemi ve C dili geliÅŸtirmesinde Ã¶nemli katkÄ±sÄ± olan biridir ve Go dilinin oluÅŸturulmasÄ±nda da yer almÄ±ÅŸtÄ±r.

Pascal dili C'nin ortaya Ã§Ä±ktÄ±ÄŸÄ± dÃ¶nemde ortaya Ã§Ä±ktÄ± ama C kadar gÃ¶zde olamadÄ±, Pascal 

Smalltalk(dilin adÄ± "havadan sudan konuÅŸmak" anlamÄ±na geliyor) dilinden C++ dili de faydalanmÄ±ÅŸtÄ±r.

C dilinde herkesin bilmesi gereken bir terminolojinin olduÄŸunu belirtildi, bundan sonra o terminoloji terimlerinin aÃ§Ä±klamasÄ± yapÄ±lacak. C dilini Ã¶ÄŸrenmeye baÅŸlamadan Ã¶nce 4 saatte boyunca kurs boyunca kullanÄ±lacak olan genel terminolojiden bahsedilecek. AnlatÄ±lan her ÅŸeyin ilk baÅŸta anlaÅŸÄ±lmasÄ±nÄ±n beklenmemesini gerektiÄŸi belirtildi, baÅŸlangÄ±Ã§ derslerinde anlaÅŸÄ±lamayan bazÄ± terimlerin, kavramlarÄ±n, sÃ¼reÃ§lerin zaman iÃ§inde Ã¶ÄŸrenileceÄŸini belirtildi. 


C dilini anlatÄ±rken Visual-Studio IDE sinin code-snippet vb. Ã¶zellikler ile daha hÄ±zlÄ± kod yazmasÄ±nÄ± saÄŸladÄ±ÄŸÄ± iÃ§in tercihedildiÄŸi belirtildi, bu IDE ile kursun en az 30-40 saat daha kÄ±sa sÃ¼rdÃ¼ÄŸÃ¼ belirtildi. 

Bu dersin ilk baÅŸÄ±nda C dilinin tarihinden bahsedildi ve sonraki kÄ±smÄ± IDE ve Text Editor kavramlarÄ±nÄ±n aÃ§Ä±klanmasÄ±na yÃ¶nelik olacak.


## Temeller

â— Bu derslerin(iÅŸin) kalbinde olan ÅŸeyin Compiler(Compilation process) olduÄŸu ve her derste bundan behsedileceÄŸi belirtildi.

Bilgisayar Ã¼zerindeki her ÅŸey dosya olarak tutulur ve tÃ¼m dosyalar bilgisayarÄ±n depolama biriminde(hard-disc) saklanÄ±r ve her bir dosyanÄ±n dosya formatÄ± mevcuttur ve bir dosya okunurken dosyanÄ±n formatÄ±na gÃ¶re okuma iÅŸlemi yapÄ±lÄ±r.

Bir dosya dendiÄŸinde anlaÅŸÄ±lmasÄ± gereken kalÄ±cÄ± olarak bir ortamda tutulan sÄ±fÄ±r-bir dizileri olmalÄ±dÄ±r. KalÄ±cÄ± saklama alanÄ±nda turulan sÄ±fÄ±r-bir dizilerinin ne olduÄŸunu dosyanÄ±n formatÄ±(**file format**) belirler, her dosyanÄ±n bir formatÄ± vardÄ±r ve biz bir dosyanÄ±n formatÄ±na sahipsek o dosyayla uygun olarak iÅŸlem yapabiliriz.

- **file_name.c** => UzantÄ± olan "c" dilin adÄ±ndan gelmektedir.
- **file_name.h** => UzantÄ± olan "h" "header" sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n kÄ±saltmasÄ±dÄ±r.

ASCI(1 byte, 0-255 deÄŸerlerini alabilir) ve UTF-8(4 byte) gibi karakter kodlama standartlarÄ± vardÄ±r.


Kod yazarken Ã¼Ã§ temel ÅŸeye ihtiyaÃ§ vardÄ±r;
1. Text IDE(Metin EditÃ¶rÃ¼) 
2. Compiler(Derleyici program)
3. Linker(BaÄŸlayÄ±cÄ±): Bu aÅŸamada projedeki tÃ¼m derlenmiÅŸ(object file) dosyalar birleÅŸtiriliyor ve Ã§alÄ±ÅŸtÄ±rÄ±labilir dosya ortaya Ã§Ä±kÄ±yor.

C dilinin kaynak kodunu iÃ§eren dosyalara **source file**, **.c file**, **implementetion file**, **code file** adlarÄ± verilebiliyor ama sonuÃ§ olarak bu dosya C diliyle yazÄ±lmÄ±ÅŸolan kodlarÄ± taÅŸÄ±maktadÄ±r.

Derlemeyle ilgili kavramlar;
- Compile      (Derlemek)
- Compiler     (Derleyici)
- Complication (Derleme iÅŸlemi)

BaÄŸlamayla ilgili kavramlar;
- Linking      (BaÄŸlama iÅŸlemi)
- Linker       (BaÄŸlayÄ±cÄ±)


**Translator**: Bir dilde yazÄ±lan kodlarÄ± baÅŸka bir dile Ã§eviren programlara verilen genel bir addÄ±r. Buradaki Ã§eviri iÅŸlemi kaynak dilden(source language) hedef dile(target language) dÃ¶nÃ¼ÅŸtÃ¼rme iÅŸlemi yapÄ±lÄ±r. Fakat kaynak dil yÃ¼ksek seviyeli ve hedef dil de dÃ¼ÅŸÃ¼k seviyeli ise bu iÅŸlemi yapan programlara yaygÄ±n olarak "Compiler" denilmektedir. 

**Compiler** yazÄ±lÄ±mÄ±nÄ±n girdisi olan dosyaya "Source File" ve Ã§Ä±ktÄ±sÄ± olan dosyaya "Object File" adlandÄ±rmasÄ± yapÄ±lmaktadÄ±r.

Bir programÄ± yazarken en Ã¶nemli Ã¼Ã§ araÃ§(yazÄ±lÄ±m) var, bunlar sÄ±rasÄ±yla;
- IDE(Kodun yazÄ±ldÄ±ÄŸÄ± ortamÄ±n programÄ±)
- Compiler(tek tek her bir C dosyasÄ±nÄ± ayrÄ± ayrÄ± hedef donanÄ±m mimarisinin makine/Assembly koduna Ã§evirir)
- Linker(tÃ¼m "Object File" larÄ±n arasÄ±nda olan kullanma iliÅŸkisini kuran programlardÄ±r)


**C makefile** kullanÄ±mÄ±nÄ±n **linker** ile herhangi bir baÄŸlantÄ±sÄ± yoktur.

Kurs boyunca ".c" ve ".h" uzantÄ±lÄ± dosyalarla Ã§alÄ±ÅŸÄ±lacak.
Bundan sonra ilk derste verilecek ara 20 dk. ve ikinci ders iÃ§in verilecek ara 10-15 dk. arasÄ±nda olacakmÄ±ÅŸ.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.38-10.58 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


Aradan sonra bir kiÅŸi "C Programing Language" kitabÄ±nÄ±n resmini paylaÅŸtÄ± dedi ve bu kitabÄ± C kursunu bitirdikten sonra okumanÄ±n doÄŸru olacaÄŸÄ± belirtildi, kitap okuyarak dil Ã¶ÄŸrenilmez gibi bir fikri olduÄŸu izlenimi oluÅŸturdu bende!

**Preprocessing-time**, **compile-time**, **link-time**, **run-time** kavramlarÄ± Ã¶nemlidir ve bu aÅŸamalarÄ±n herhangi birinde alÄ±nan hatalar ayrÄ± hatalardÄ±r(**compile-time error**, **link-time error**, **run-time error**).

Preprocessing iÅŸlemi(Ã¶n iÅŸlemci modÃ¼lÃ¼): C ve C++ dillerinde yazÄ±lmÄ±ÅŸ dosyalarÄ±n ilk Ã¶nce iÅŸlendiÄŸi derleyicinin iÃ§indeki alt programdÄ±r. Bu alt program toplamda 13 adet komuta sahipmiÅŸ ve bunlarÄ±n da Ã¶ÄŸrenilmesi gerektiÄŸini belirtildi. Kursun yaklaÅŸÄ±k 16 saatlik kÄ±smÄ± "Preprocessing" ile ilgili olacakmÄ±ÅŸ.

ğŸš€ **C Ã¶ÄŸrenmek demek Ã–n Ä°ÅŸlemci komutlarÄ±nÄ± da Ã¶ÄŸrenmeyi gerektiriyor**.

**#** karakteri **number sign**, **hash**, **diyez** olarak adlandÄ±rÄ±labiliyor.

IDE'lerde genellikle birkaÃ§ adet alt program iÃ§erir, bunlar: Compiler, Intellicense(YazÄ±lÄ±m yaparken yardÄ±mcÄ± olan programlar), Debugger(Rune-time'Ä±n kontrollÃ¼ olarak Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±nÄ± saÄŸlayan ve hatalarÄ±n bulunmasÄ±nÄ± saÄŸlayan programlar), Styler(Kodun editÃ¶rdeki yerleÅŸimini ayarlayan programlar), Profiler(rune-time'da performansÄ±n Ã¶lÃ§Ã¼lmesine ya da deÄŸiÅŸiklikler yapÄ±lmasÄ±nÄ± saÄŸlayan programlar), Static Code Analizer() vb. IDE burada belirtilen programlarÄ±n hepsini, bir kÄ±smÄ±nÄ± ya da daha fazlasÄ±nÄ± da bÃ¼nyesinde iÃ§eren yazÄ±lÄ±m yaparken kullanÄ±lan programlardÄ±r.

C ve C++ iÃ§in kullanÄ±labilecek IDE'ler => **Visual Studio**, **Qt creator**, **Eclipse**, **Xcode**, **C lion(Jetbrains)**, **Dev-C++**, **Code::Blocks** gibi. EÄŸitimci Visual Studio IDE kullanÄ±yor.


Compiler programlarÄ±nÄ± yazmak zordur, Interpreter yazmak daha kolaydÄ±r. 

Bir Compiler farklÄ± alt parÃ§alardan oluÅŸuyor, Compiler'Ä±n ayrÄ± ayrÄ± modÃ¼lleri "Compilation" sÃ¼recindeki ayrÄ± ayrÄ± iÅŸlemleri gerÃ§ekleÅŸtirir, Bir Compiler'Ä±n giriÅŸ modÃ¼lÃ¼ kaynak dosyayÄ± en kÃ¼Ã§Ã¼k anlamlÄ± parÃ§alar olan **token**'lara ayÄ±rÄ±r(bu sÃ¼rece "**Lexical Analysis**" deniliyor) eÄŸer bu adÄ±mda dilin kurallarÄ±na aykÄ±rÄ± durum(lar) oluÅŸmuÅŸsa Derleyici bu durumu(larÄ±) "**Diagnostic(Bulgu iletisi)**" olarak adlandÄ±rÄ±lan iletilerle bildirecektir.


- **Well-Formd** : YazÄ±lan program(kod dosyalarÄ±) ilgili dilin kurallarÄ±na aykÄ±rÄ± bir durum iÃ§ermiyorsa ve derlenebilir olmasÄ±nÄ± ifade eder. 
- **Ill-Formd**  : YazÄ±lan program(kod dosyalarÄ±) ilgili dilin kurallarÄ±na aykÄ±rÄ± bazÄ± durumlar iÃ§eriyorsa ve program(kod dosyalarÄ±) derlenebilir olmamasÄ±nÄ± ifade eder.

- **Invalid(code)**, **Illegal(code)**: Dilin kurallarÄ±na aykÄ±rÄ± olan kodlarÄ± belirtmek iÃ§in kullanÄ±lan terimler.
- **Valid(code)**, **Legal(code)**    : Dilin kurallarÄ±na uygun olan kodlarÄ± belirtmek iÃ§in kullanÄ±lan terimler.

- **Syntax Error**: Dilin kurallarÄ±na aykÄ±rÄ± olan bir durum olduÄŸunda alÄ±nan hatalara verilen addÄ±r.

- **Ill-Formd** tanÄ±mlamasÄ± **Syntax Error** tanÄ±mlamasÄ±ndan daha Ã¼st seviye hata durumlarÄ±nÄ± belirtmek iÃ§in kullanÄ±lÄ±yor. BazÄ± hatalar dilin kurallarÄ±na uygun olsa bile birden fazla dosya birleÅŸtirildiÄŸi zaman ortaya Ã§Ä±kabilir fakat derleyici dosyalarÄ± tek tek derlediÄŸi iÃ§in birleÅŸtirme sonucunda oluÅŸacak hatalarÄ± bilemez, bu durumda da "Syntax Error" oluÅŸmasa bile yazÄ±lmÄ±ÅŸ program sorunludur ve **Ill-Formd** olarak nitelendirilebilir.

**Diagnostic(bulgu iletisi)** diye bir kavram var %95 programcÄ± bunu yanlÄ±ÅŸ anlÄ±yormuÅŸ;
- **Error**  : Dilin kurallarÄ±na aykÄ±rÄ± kodlarÄ± tespit edip hata verildiÄŸi durumdur.
- **Warning**: Dilin kurallarÄ±na aykÄ±rÄ± olmayan ama semantik olarak hatalÄ± olabilecek kodlar iÃ§in uyarÄ± verildiÄŸi durumdur.

Dilin kurallarÄ±na aykÄ±rÄ± olan bazÄ± Ã¶zel durumlarda compiler hata vermeyebilir sadece **Warning Diagnostic** verebilir ama yine de programÄ± derleyebilir.

ğŸ‘‡ AÅŸaÄŸÄ±daki sÃ¶zde kodda **warning diagnostic** verilecek olan durumlar gÃ¶rÃ¼lebilir, bu hatalar locig(mantÄ±ksal) hata kapsamÄ±na girmektedir.
```C
// Alttaki kod parÃ§asÄ± C dilinin kurallarÄ±na uygundur fakat burada mantÄ±k hatasÄ± var, kaliteli derleyiciler burada 'diagnostic(bulgu iletisi)' verecektir.
if(x = 4)
{

}

// Alttaki kod parÃ§asÄ± C dilinin geÃ§erlidir fakat "++x;" yerine "+x;" ÅŸeklinde yazÄ±lan kod parÃ§asÄ± iÃ§in Derleyici uyarÄ± iletisi verebilir.
int x = 3;
+x;
```

- Derleyici program yazÄ±lmÄ±ÅŸ kodu iÅŸlerken bir aÅŸamada **Optimizer** modÃ¼lÃ¼ ile yazÄ±lmÄ±ÅŸ kodun anlamÄ±nÄ± deÄŸiÅŸtirmeden yazÄ±lmÄ±ÅŸ olan kodu olduÄŸu gibi Ã§evirmez, bu aÅŸamada gereksiz gÃ¶rÃ¼len kodlar silinip sadeleÅŸtirilebilir ve bu sadeleÅŸtirilen kod makine kodlarÄ±na Ã§evrilir. 

- **Compiler** programlarÄ±nda Ã§oÄŸunlukla **static Code Analysis(Linter)** denilen kodlarÄ±n analizini yapan programlar bulunmaktadÄ±r, bu programlar tespit ettiÄŸi sorunlu durumlarÄ± uyarÄ± iletisi olarak verecektir. 
- **Compiler** programlarÄ±nÄ±n birinci amacÄ± syntax hatalarÄ±nÄ± tespit etmek ve yazÄ±lmÄ±ÅŸ kodlarÄ± derleyip makine koduna Ã§evirmektir fakat asÄ±l gÃ¶revi olmasa bile Diagnostic kontrollerini de yapabilir.
- **Compiler** programlarÄ±nÄ±n en Ã¶nemli Ã¶zelliÄŸi kodu alÄ±p kodun Ã¼zerinde Ã§alÄ±ÅŸacaÄŸÄ± iÅŸlemciye uygun en optimize edilmiÅŸ makine kodunu Ã¼retmektir, bu iÅŸlemi yapan **Compiler** yazÄ±lÄ±mÄ±nÄ±n alt parÃ§asÄ±na **Optimizer** denilmektedir.
- **Compiler** programlarÄ±nda **As-if rule(sanki)[C standardÄ± bu terimi kullanmamaktadÄ±r]** diye adlandÄ±rÄ±lan bir ifade mevcut, bu ifade bir derleyicinin yazÄ±lmÄ±ÅŸ bir dosyanÄ±n ilgili dilin standardÄ±nÄ±n verdiÄŸi yetki ile farklÄ± ÅŸekilde yorumlayÄ±p derleme iÅŸlemini yapabilir, fakat bu iÅŸlem ilgili kodun Ã§Ä±ktÄ±sÄ±nÄ± etkilemeyecek ÅŸekilde yapÄ±lmaktadÄ±r.
- **Observable Behavior(GÃ¶zlenebilir DavranÄ±ÅŸ)** terimi de yazÄ±lmÄ±ÅŸ bir kodun gereksiz parÃ§alarÄ±nÄ±n derleme aÅŸamasÄ±nda sadeleÅŸtirilmesi iÅŸlemini ifade eder, programÄ±n Ã§alÄ±ÅŸma anÄ±ndaki davranÄ±ÅŸÄ±nÄ± ifade eden bir terimdir.
- Derleyicilerin **Optimizer** modÃ¼lÃ¼ olmasaydÄ± C ve C++ dillerinde yazÄ±lan kodlar daha verimsiz Ã§alÄ±ÅŸÄ±rdÄ±, bir derleyicinin en Ã¶nemli Ã¶zelliklerinden birini **Optimizer** modÃ¼lÃ¼ gerÃ§ekleÅŸtirmektedir.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.01-12.15 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


Derleyici programlar ilk Ã¶nce **Lexical Analysis** iÅŸlemi yapÄ±yor yani kaynak kodu en kÃ¼Ã§Ã¼k parÃ§alarÄ±na ayÄ±rÄ±yorlar sonrasÄ±nda **sÃ¶zdizim kontrolÃ¼(sÃ¶zdizim aÄŸacÄ± oluÅŸturuluyor)** yapÄ±lÄ±yor, derleyicinin ayrÄ± bir modÃ¼lÃ¼ olan **Optimizer Module** yazÄ±lmÄ±ÅŸ kod dosyalarÄ±nÄ±n anlamlarÄ±nÄ± deÄŸiÅŸtirmeden deÄŸiÅŸiklik yapar.

â—â—â— **AkÄ±lda kalmasÄ± gereken en Ã¶nemli bilgi, derleyicilerin yazÄ±lmÄ±ÅŸ kaynak kodu bire bir derlemeyip, bazÄ± iyileÅŸtirmeler yapmasÄ±dÄ±r**.

## Terminoloji Terimleri 

- **Token(Atom)**: Derleyicinin iÅŸlem yaparken ele aldÄ±ÄŸÄ± en ufak kod parÃ§alarÄ±na verilen ad.
- **Tokenizing(AtomlarÄ±na ayrÄ±ÅŸtÄ±rma)** ya da **Lexical Analyzer**: Herhangi bir derleyici ile Ã§alÄ±ÅŸan programlama dilinde derleyicinin ilk yaptÄ±ÄŸÄ± iÅŸlem kod dosyalarÄ±nÄ±n iÃ§eriÄŸini **Token**lara ayÄ±rmaktÄ±r, bu iÅŸleme **Tokenizing** denir.

### Token tÃ¼rleri

**Token** tÃ¼rleri aÅŸaÄŸÄ±daki gibi kategorilere ayrÄ±lÄ±r;

1. **Keyword(Reserved Word)(Anahtar SÃ¶zcÃ¼k)**: Dilde Ã¶zel anlam yÃ¼klenen ve programda diÄŸer varlÄ±klara verilmesi kÄ±sÄ±tlanan sÃ¶zcÃ¼klerdir(if, while, goto, union, signed vb.).
   C89'da 32 adet anahtar sÃ¶zcÃ¼k mevcuttur.
   C99'da 37 adet anahtar sÃ¶zcÃ¼k mevcuttur.

2. **Identifier(Ä°sim)**: "Name" demenin formal ÅŸeklidir ve yazÄ±lÄ±mda tanÄ±mlanan varlÄ±klarÄ±n(variable, function, data type, label, enum, struck vb. adlarÄ±dÄ±r) adlarÄ±nÄ± ifade eder. Bir programlama dilinde "Identifier" tanÄ±mlarken belirli kurallar olur, C iÃ§in bu kurallar aÅŸaÄŸÄ±daki gibidir.
   1. Bir "Identifier" "Keyword" olamaz.
   2. Bir "Identifier" tanÄ±mlarken sadece ÅŸu karakterler kullanÄ±labilir; 
      - "a..z(Latin-Roman)" 
      - "A..Z(Latin-Roman)"
      - "0..9(Arabic numerals)" 
      - "_"
   3. Bir "Identifier" ilk karakteri rakam olamaz.
   4. C dilinde ÅŸu durumdaki adlar rezerve edildiÄŸi iÃ§in bir "identifier"a verilmemelidir.
      1. Bir "Identifier" tanÄ±mÄ± "__" ÅŸeklinde iki alt Ã§izgi ile baÅŸlamamalÄ±dÄ±r.
      2. Bir "Identifier" tanÄ±mÄ± "_U" ÅŸeklinde ilk karakteri alt Ã§izgi ve bundan sonraki karakteri bÃ¼yÃ¼k harf olacak ÅŸekilde verilmemelidir.
      3. Bir "Identifier" tanÄ±mÄ± global alanda "_" ÅŸeklinde alt Ã§izgi karakteri ile baÅŸlamamalÄ±dÄ±r.

   - Bir programlama dili **case-sensitive** ya da **case-insensitive** adlandÄ±rma yaklaÅŸÄ±mÄ±nÄ± kabul eder. Bir programlama dili eÄŸer "case-sensitive" ise "for", "For", "fOr", "FOR" tanÄ±mlarÄ±nÄ±n her biri ayrÄ± bir **identifier** olarak ele alÄ±nacaktÄ±r fakat **case-insensitive** bir dilde bu adlarÄ±n her biri aynÄ± kabul edilecekti.

3. **Constant(Sabit)**: Dilde adÄ± Ã¼stÃ¼nde sabit olarak gÃ¶sterilebilen varlÄ±klarÄ±n basit olanlarÄ±dÄ±r ve sayÄ± sisteminin elemanÄ±dÄ±r. Sabitler C dilinde Ã¼Ã§ farklÄ± sayÄ± sisteminde ifade edilmektedir, C++ dilinde bunlara ikilik sayÄ± sistemi de dahil olmaktadÄ±r ve bunlar aÅŸaÄŸÄ±daki gibidir. Bir Ã§ok programla dili "**Constant(Sabit)**" ifadelerin yazÄ±m kurallarÄ±nÄ± C dilinden almÄ±ÅŸtÄ±r.
   1. **Decimal**(10 tabanÄ±)
   2. **Octal**(8 tabanÄ±)
   3. **Hexadecimal**(16 tabanÄ±)

   - 75    (10 tabanÄ±)
   - 075   (8  tabanÄ±)
   - 0x75  (16 tabanÄ±)
   - 0b1010010101110100 (2 tabanÄ±) => Bu yazÄ±m kuralÄ± C89 standardÄ±nda yoktur fakat derleyiciler bu kullanÄ±ma "**extension**" ile destek verebilir.

   Tam sayÄ±yÄ± sabitlerini hangi sayÄ± tabanÄ±nda kullanÄ±ldÄ±ÄŸÄ± bu sabitlerle yapÄ±lan iÅŸlemlerde bir farklÄ±lÄ±k oluÅŸturmamaktadÄ±r.

4. **Operator(Ä°ÅŸleÃ§)**: Dilde kullanÄ±lan "`+`, `-`, `/`, `sizeof` vb." gibi belirli iÅŸlemleri yapmak iÃ§in kullanÄ±lan ifadelerdir.

5. **String literal(String sabit)**: 

6. **Others, Delimiter(AyÄ±raÃ§)**: 

   â—â—â— AÅŸaÄŸÄ±daki Maddeler Ã–nemlidir;
   ğŸš€ C dilinin **sÃ¶zdizimini(syntax)** C StandardÄ± belirlemektedir fakat Derleyiciler C StandardÄ±nÄ±n kendilerine verdiÄŸi yetkiyle standard olmayan(yani dilin standardÄ±nda yer almayan) bazÄ± eklemeleri programcÄ±lara kullanma olanaÄŸÄ± saÄŸlayabiliyor, bu eklemelere "**compiler extension(derleyici eklentisi)**" denilmektedir. </br>
   ğŸš€ Mesela **C99** standardÄ±nda sadece decimal(10 sayÄ± tabanÄ±), octal(8 sayÄ± tabanÄ±) ve hexadecimal(16 sayÄ± tabanÄ±) ama **GCC** derleyicisi ayrÄ±ca binary(2 sayÄ± tabanÄ±) gÃ¶sterimi desteklemek iÃ§in bir **extension**'a sahip fakat bu **C** standardÄ±nda yoktur, ilave olarak derleyici tarafÄ±ndan eklenmiÅŸ ama aynÄ± Ã¶zelliÄŸi destekleyen bir **extension**'a sahip olmayan baÅŸka bir derleyicide binary tabanda yazÄ±lmÄ±ÅŸ sayÄ± kullanÄ±mlarÄ± olduÄŸunda kodu derlerken hata alÄ±nacaktÄ±r. </br> 
   ğŸš€ **GCC** derleyicisi bÃ¼nyesinde bir Ã§ok **compiler extension** mevcuttur ve bir Ã§ok **compiler extension** kullanÄ±larak yazÄ±lmÄ±ÅŸ bir **C** programÄ± baÅŸka bir derleyicide derlenmek istendiÄŸinde eÄŸer diÄŸer derleyici **GCC** derleyicisinde mevcut olan **compiler extension**'lardan tek birine bile sahip deÄŸilse ilgili program derlenirken hata oluÅŸacaktÄ±r, bu da programÄ±n farklÄ± derleyiciler arasÄ±nda taÅŸÄ±nabilirliÄŸini olumuz olarak etkileyecektir. </br>
   ğŸš€ **Digit Separator** kullanÄ±mÄ± **C++** dilinde bir standart iken **C** dilinde standart deÄŸildir(sadece derleyiciler **extension** olarak bu kullanÄ±mÄ± sunabilirler), `int value = 123'453'434;` kullanÄ±mÄ± **digit separator** kullanÄ±mÄ±dÄ±r ve bu derleyicinin saÄŸladÄ±ÄŸÄ± **extension**'dÄ±r. 


Ders sonu ...
