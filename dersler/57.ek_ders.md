# 57.Ek Ders
---

## C Dilinde Hatalar Tekrar

Hatalar **programming error** ve **run-time error** olarak ikiye ayrÄ±lÄ±r. Programlama hatalarÄ±yla baÅŸa Ã§Ä±kmak iÃ§in kullanÄ±lan temel araÃ§ seti **Assertion**'lardÄ±r. </br>
**Assertion**'lar **Static Assertions**(**Compile Time Assertions**) ve **Dynamic Assertions**(**Run Time Assertions**) olarak iki Ã¶beÄŸe ayrÄ±lmaktadÄ±r, **Static Assertions** C diline dilin C11 standardÄ±yla birlikte eklenmiÅŸtir. </br>
**Dynamic Assertions**(**Run Time Assertions**) programÄ±n Ã§alÄ±ÅŸma zamanÄ±nda alÄ±nan hatalarÄ±n tespiti iÃ§in kullanÄ±lmaktadÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `foo` fonksiyonunda kullanÄ±lan hata tespit kodunun yanlÄ±ÅŸ bir kullanÄ±m olduÄŸu gÃ¶rÃ¼lmelidir. 
```C
#include <stdio.h>
#include <stdlib.h>

void foo(int* p, int size)
{
    // AÅŸaÄŸÄ±daki if deyimi hata tespiti iÃ§in eklenmiÅŸtir ama bÃ¶yle bir hata tespit kodu yazmak iyi bir kullanÄ±m deÄŸildir.
    // Ä°lk olarak bu kodun hata tespit kodu olduÄŸu ilk bakÄ±ÅŸta anlaÅŸÄ±lmamaktadÄ±r.
    // Ä°kinci olarak da bu kod 'Static error detection' hata tespit kodlarÄ± olduÄŸu iÃ§in, programÄ± derlemeden Ã¶nce bu kodlarÄ± programdan kaldÄ±rmak gerekecektir, bÃ¶yle yazarsak bÃ¶yle bir Ã§ok kod olduÄŸunda bunu kolayca yapamayÄ±z.
    if(p == NULL){
        fprintf(stderr, "p != NULL ifadesi dogrulanmadi.\n");
        fprintf(stderr, "%s dosyasinin %d. satiri\n", __FILE__, __LINE__);
    }

    for(int i = 0; i < size; ++i){
        printf("%d ", p[i]);
    }
}

int main(void)
{
    int a[10] = { 0 };
    int* p;

    p = NULL;

    // some code here ...

    foo(p, 10);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±da `assert` makrosunun gerÃ§ekleÅŸtirimini derleyiciler yapmaktadÄ±r, her derleyici kendine gÃ¶re bir tane gerleÅŸtirim yapar, olabilecek en basit `assert` makrosu aÅŸaÄŸÄ±daki gibi olabilir;
```C
//sample assert macro implementation

#include <stdio.h>

#ifndef NDEBUG
#define ASSERT (EXPR) (                           \
    (EXPR)? (void)0: (                            \
        printf("%s:%d: failed assertion '%s' \n", \
        __FILE__, __LINE__, #EXPR                 \
        ),                                        \
        abort()                                   \
    ))                                            \
#else                                             \
#define ASSERT(EXPR) ((void)0)                    \
#endif /* NDEBUG */                               \
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda basit bir `ASSERT` makrosunun kullanÄ±mÄ± incelenebilir.
```C
#include <stdlib.h>

#define NDEBUG // Buradaki 'NDEBUG' 'No Debug' sÃ¶zcÃ¼klerinden gelmektedir.

#ifndef NDEBUG
#define ASSERT (EXPR) (                           \
    (EXPR)? (void)0: (                            \
        printf("%s:%d: failed assertion '%s' \n", \
        __FILE__, __LINE__, #EXPR                 \
        ),                                        \
        abort()                                   \
    ))                                            \
#else                                             \
    #define ASSERT(EXPR) ((void)0)                \
#endif /* NDEBUG */                               \

int main(void)
{
    int x = 5;

    ASSERT(x != 0); // 'NDEBUG' bildirildiÄŸi iÃ§in buradaki kod '((void)0)' ile yerdeÄŸiÅŸtirilir.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki kod parÃ§asÄ±nda `assert` makrosunun nasÄ±l devredÄ±ÅŸÄ± bÄ±rakÄ±labileceÄŸi incelenebilir.
```C
#define NDEBUG // Buradaki 'NDEBUG' 'No Debug' sÃ¶zcÃ¼klerinden gelmektedir. Bu kullanÄ±m tÃ¼m 'assert' makrolarÄ±nÄ± devredÄ±ÅŸÄ± bÄ±rakÄ±r ve bÃ¶ylece programdaki tÃ¼m hata tespit kodlarÄ± programdan Ã§Ä±kartÄ±lmÄ±ÅŸ olur.

#include <assert.h>

#ifndef NDEBUG
#define ASSERT (EXPR) (                           \
    (EXPR)? (void)0: (                            \
        printf("%s:%d: failed assertion '%s' \n", \
        __FILE__, __LINE__, #EXPR                 \
        ),                                        \
        abort()                                   \
    ))                                            \
#else                                             \
    #define ASSERT(EXPR) ((void)0)                \
#endif /* NDEBUG */                               \
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `assert` makrosunun nasÄ±l devredÄ±ÅŸÄ± bÄ±rakÄ±labileceÄŸi incelenebilir.
```C
#include <stdlib.h>
#include <math.h>
#include <stdio.h>

#ifndef NDEBUG
#define ASSERT (EXPR) (                           \
    (EXPR)? (void)0: (                            \
        printf("%s:%d: failed assertion '%s' \n", \
        __FILE__, __LINE__, #EXPR                 \
        ),                                        \
        abort()                                   \
    ))                                            \
#else                                             \
    #define ASSERT(EXPR) ((void)0)                \
#endif /* NDEBUG */                               \


double foo(double d)
{
    ASSERT(d >= 0.);

    // some code here ...

    return sqrt(d * 1.2);
}

int main(void)
{
    double dx = foo(4.7);
    printf("dx = %f\n", dx);
}
```



`ASSERT` makrosu C++ dilindede kullanÄ±lmaktadÄ±r. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda standart `assert` makrosunun kullanÄ±mÄ± incelenebilir.
```C
#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <assert.h>

double foo(double d)
{
    ASSERT(d >= 0.);

    // some code here ...

    return sqrt(d * 1.2);
}

int main(void)
{
    double dx = foo(-4.7); // 'ASSERT' makrosu Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda bufonksiyon Ã§aÄŸrÄ±sÄ±nda hata alÄ±nacaktÄ±r.
    printf("dx = %f\n", dx);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `assert` makrosunun nasÄ±l devredÄ±ÅŸÄ± bÄ±rakÄ±labileceÄŸi incelenebilir.
```C
#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#define NDEBUG // Bu kullanÄ±mla 'assert' makrolarÄ±nÄ±n kullanÄ±mÄ± devredÄ±ÅŸÄ± bÄ±rakÄ±lmÄ±ÅŸ olur.
#include <assert.h>

double foo(double d)
{
    ASSERT(d >= 0.);

    // some code here ...

    return sqrt(d * 1.2);
}

int main(void)
{
    double dx = foo(-4.7); // 'ASSERT' makrosu Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda bu fonksiyon Ã§aÄŸrÄ±sÄ±nda hata alÄ±nacaktÄ±r.
    printf("dx = %f\n", dx);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki `assert` makrolarÄ±nÄ±n kullanÄ±mÄ±nda nasÄ±l ilave aÃ§Ä±klama eklenebileceÄŸi incelenebilir. `ASSERT_MSG` makrosunun kullanÄ±mÄ±nda yan etkisi olmayan ifadelerin kullanÄ±lmasÄ±na dikkat edilmesi gerekiyor.
```C
#include <stdlib.h>
#include <math.h>
#include <stdio.h>
//#define NDEBUG // Bu kullanÄ±mla 'assert' makrolarÄ±nÄ±n kullanÄ±mÄ± devredÄ±ÅŸÄ± bÄ±rakÄ±lmÄ±ÅŸ olur.
#include <assert.h>

#define ASSERT_MSG(MSG, EXP)    assert((MSG, (EXP))) // Buradaki 'ASSERT_MSG' makrosu 'assert' makrosunu sarmalÄ±yor, burada iki tane yazÄ±nÄ±n yan yana gelmesi sonucu Ã¼retilecek yeni yazÄ±nÄ±n bu iki yazÄ±nÄ±n birleÅŸi olmasÄ±ndan faydalanÄ±lÄ±yor.

int main(void)
{
    int x = 0;
    ASSERT_MSG("value out of range", x != 0);

    int count = 5;
    assert(-count > 0);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `assert` kullanÄ±mÄ±nÄ±n doÄŸru ve yanlÄ±ÅŸ yaklaÅŸÄ±mÄ± 
```C
#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <assert.h>

void foo(int x, double d)
{
    // assert(x > 0 && d < 4.5); // Ä°ki farklÄ± koÅŸul aynÄ± anda sÄ±nanmamalÄ±dÄ±r.

    // YukarÄ±daki 'assert' kullanÄ±mÄ± yerine aÅŸaÄŸÄ±daki gibi kullanmak daha doÄŸrudur.
    assert(x > 0);
    assert(d < 4.5);
}


int main(void)
{
    foo(3, 7.1);
}
```


### Hata DurumlarÄ±nÄ±n Bildirilmesi 

EÄŸer bir fonksiyon Ã¼stlendiÄŸi vazifeyi yerine getiremeyeceÄŸini anlarsa(anladÄ±ÄŸÄ±nda) kendisini Ã§aÄŸÄ±ran koda bu durumu bildirmelidir, ama nasÄ±l bildirebilir. </br>
HatalarÄ±n yÃ¶netimi konusuna **error handling** denilmektedir ve **error handling** iÃ§in tek bir ortak yol ya da konvension yoktur. </br>

**Error handling** iÃ§in aÅŸaÄŸÄ±daki yollar kullanÄ±labilir;
1. Fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸerinin fonksiyonun baÅŸarÄ±lÄ± ya da baÅŸarÄ±sÄ±z olma durumunun dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ durum.
2. Fonksiyona geÃ§ilen bir nesnenin deÄŸerine bakÄ±larak hata durumunun tespit edilmesi.

    ğŸ‘‡ AÅŸaÄŸÄ±daki gibi bazen bir fonksiyonun geri dÃ¶nÃ¼ÅŸ tÃ¼rÃ¼ yapÄ± tÃ¼rÃ¼nden oluyor ve bir hata olmasÄ± durumunda hata durumunu tutan yapÄ± Ã¼yesinin deÄŸeri gÃ¼ncellenecektir.
    ```C
    struct Result{
        int mx; // Hesaplanan deÄŸer.
        int error_code;
    }
    ```
3. `errno.h` baÅŸlÄ±k dosyasÄ±nda tanÄ±mlÄ± olan `errno` nesnesinin deÄŸeri Ã¼zerinden hata olup olmadÄ±ÄŸÄ± sÄ±nanabiliyor. `errno` nesnesini derleyiciler global bir deÄŸiÅŸken ya da global bir object-like makro olarak tanÄ±mlayabiliyor. 


#### `errno.h` BaÅŸlÄ±k DosyasÄ±ndaki AraÃ§larÄ± Kullanarak Hata KontrolÃ¼

`errno` nesnesinin deÄŸeri hata olmadÄ±ÄŸÄ±nda "0" hata olduÄŸunda sÄ±fÄ±rdan baÅŸka bir tam sayÄ± deÄŸeridir.

ğŸ‘‡ AÅŸaÄŸÄ±daki programda `errno` kullanÄ±mÄ± incelenebilir.
```C
#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <assert.h>
#include <errno.h>

int main(void)
{
    printf("errno = %d\n", errno); // Standart Ã§Ä±ktÄ± akÄ±mÄ±na 'errno = 0' gÃ¶nderilir.

    FILE* f = fopen("uygarpinar.dat", "rb");

    printf("errno = %d\n", errno); // Standart Ã§Ä±ktÄ± akÄ±mÄ±na 'errno = 2' gÃ¶nderilir, bunun nedeni bir Ã¶nceki statement'ta aÃ§Ä±lmak istenilen dosyanÄ±n aÃ§Ä±lamamÄ±ÅŸ olmasÄ±dÄ±r.

    if(!f){
        perror("file not opened "); // Standart Ã§Ä±ktÄ± akÄ±mÄ±na 'file not opened : No such file or directory' gÃ¶nderilir.
    }
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strerror` fonksiyonu kullanÄ±larak `errno` hata kodunun ne anlama geldiÄŸi Ã¶ÄŸrenilebilmektedir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <assert.h>
#include <errno.h>
#include <string.h>

int main(void)
{
    printf("errno = %d\n", errno); // Standart Ã§Ä±ktÄ± akÄ±mÄ±na 'errno = 0' gÃ¶nderilir.

    FILE* f = fopen("uygarpinar.dat", "rb");

    if(!f){
        perror("hata olustu : %s\n", strerror(errno); // Standart Ã§Ä±ktÄ± akÄ±mÄ±na 'file not opened : No such file or directory' gÃ¶nderilir.
    }
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strerror` fonksiyonu kullanÄ±larak [0, 19] arasÄ±ndaki hata kodlarÄ±nÄ±n aÃ§Ä±klamalarÄ±nÄ±n ne olduÄŸu standart Ã§Ä±ktÄ± akÄ±mÄ±na yazdÄ±rÄ±lmaktadÄ±r.
```C
#include <errno.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    for(int i = 0; i < 20; ++i){
        printf("error value %d : %s \n", i, strerror(i);
    }
}
```


C dilinin standardÄ±nda belirtilen `EDOM`, `ERANGE`, `` object-like makrolarÄ± sabit bir deÄŸere 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `EDOM` kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <assert.h>
#include <errno.h>
#include <string.h>


int main(void)
{
    double d = sqrt(-4.5);

    if(errno == EDOM){
        printf("errno deÄŸeri == EDOM");
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `ERANGE` hatasÄ±nÄ±n oluÅŸmasÄ± durumu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <assert.h>
#include <errno.h>
#include <string.h>


int main(void)
{
    long lval1 = strtol("0x1ac4", NULL, 0);
    printf("lval1 = %ld\n", lval1);

    long lval2 = strtol("0xFFFFFFF", NULL, 0);
    
    if(errno == ERANGE){
        printf("Evet 'errno' degeri 'ERANGE'e esit.\n");
    }
    
    printf("lval2 = %ld\n", lval2);

    perror("'lval2' degiskeni icin donusum hatasi: ");
}
```


### `setjmp.h` BaÅŸlÄ±k DosyasÄ±ndaki `setjmp` ve `longjmp` FonksiyonlarÄ±

C++, Java, C# gibi dillerde hatalarÄ±n yÃ¶netimi iÃ§in **Exception Handing** aracÄ± bulunmaktadÄ±r, C++ kursunda bu kunu 8-10 saatte anlatÄ±lmaktaymÄ±ÅŸ.

`errno` deÄŸeri kullanÄ±lmadan Ã¶nce bu deÄŸer sÄ±fÄ±rlanmalÄ±dÄ±r ardÄ±ndan iÅŸlem yapÄ±lmalÄ±dÄ±r, **function call chain** yapÄ±sÄ±nda iÃ§ iÃ§e fonksiyon Ã§aÄŸÄ±rÄ±lma zincirinde iÃ§ fonksiyonlarda hata oluÅŸtuÄŸunda ilk Ã§aÄŸÄ±rÄ±lan fonksiyona hata bilgisinin geri dÃ¶nÃ¼lmesi kullanÄ±lan bir yaklaÅŸÄ±mdÄ±r(bÃ¶yle bir durumda **non-local jump** bir goto deyimi kullanÄ±lÄ±r). </br>
`setjmp.h` baÅŸlÄ±k dosyasÄ±nda yukarÄ±da belirtilen durumda iÃ§ fonksiyonda hata oluÅŸtuÄŸunda ilk Ã§aÄŸÄ±ran fonksiyona geri dÃ¶nÃ¼lmesini saÄŸlayan araÃ§lar mevcuttur.

C dilinde `setjmp.h` baÅŸlÄ±k dosyasÄ±nda bulunan `setjmp` ve `longjmp` fonksiyonlarÄ±nÄ±n kullanÄ±mÄ± ile diÄŸer dillerde olan **Exception Handing** mekanizmasÄ±nÄ±n basit bir benzeri oluÅŸturulabilir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `setjmp` ve `longjmp` fonksiyonlarÄ±nÄ±n kullanÄ±mÄ± incelenebilir.
```C
#include <setjmp.h>

jmp_buf buf;


void bom(void)
{
    printf("bom cagirildi.\n");
    longjmp(buf, 4);
}

void baz(void)
{
    printf("baz cagirildi.\n");
    bom();
}

void bar(void)
{
    printf("bar cagirildi.\n");
    baz();
}

void foo(void)
{
    printf("foo cagirildi.\n");
    bar();
}

int main(void)
{
    if(setjmp(buf)){
        printf("longjmp jump'i sonucunda akis buraya geldi.\n");
    }
    else{
        foo();
    }   
}
```



> Sorulan soru;
> 
> `setjmp` fonksiyonu illaki bir if statement iÃ§inde mi kullanÄ±lmasÄ± gerekiyor?
> 
> Cevap;
> 
> Evet Ã§Ã¼nkÃ¼, programÄ±n akÄ±ÅŸÄ±nÄ±n 


## Variadic Fonksiyonlar ğŸŒŸ 

Bir fonksiyonun **variadic** olmasÄ± durumunda bu fonksiyonu Ã§aÄŸÄ±ran kod tarafÄ±nda istenildiÄŸi kadar argÃ¼manla fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±labilir. </br>
FarklÄ± farklÄ± programlama dillerinde farklÄ± farklÄ± kullanÄ±m yapÄ±sÄ±yla **variadic function** yapÄ±sÄ± mevcuttur. </br>
**Variadic function** programlama dÃ¼nyasÄ±nda kullanÄ±lan genel bir terimdir, farklÄ± farklÄ± argÃ¼man sayÄ±sÄ±yla Ã§aÄŸÄ±rÄ±labilen fonksiyonlar iÃ§in kullanÄ±lmaktadÄ±r. </br>
Neden deÄŸiÅŸken sayÄ±da parametre alan fonksiyonlara ihtiyaÃ§ duyuluyor diye dÃ¼ÅŸÃ¼nÃ¼ldÃ¼ÄŸÃ¼nde, `printf`, `scanf` fonksiyonlarÄ±nda olduÄŸu gibi Ã¶nceden kaÃ§ tane deÄŸer iÃ§in iÅŸlem yapÄ±lacaÄŸÄ± Ã¶nceden belirsizdir olduÄŸu iÃ§in **variadic** Ã¶zellikte belirsi sayÄ±da argÃ¼man geÃ§ilebilir olmasÄ± kullanÄ±ÅŸlÄ±dÄ±r. </br>
Mesela kendisine geÃ§ilen belirsiz adetteki tam sayÄ±larÄ±n toplamÄ±nÄ± hesaplayan ya da ortalamasÄ±nÄ± hesaplayan ya da sayÄ±larÄ±n en bÃ¼yÃ¼ÄŸÃ¼nÃ¼ tespiteden vb. fonksiyonlar yazÄ±lacaÄŸÄ±nda bu fonksiyonlarÄ±n **variadic** tanÄ±mlanmasÄ± tercihedilir.

**Variadic function** sÃ¶zdizimi ÅŸÃ¶yledir: En az bir parametre alan bir fonksiyonun en son parametresinin elipsis(`...`) token'Ä± yapÄ±lmasÄ± sonucunda **variadic** bir fonksiyon bildirimi ya da tanÄ±mÄ± yapÄ±lmaktadÄ±r. </br>
Mesela `void func(int x, ...);`, `void func(int x, int y, ...);` biÃ§iminde **variadic function** bildirilebilir. </br>
Mesela `void func(int x, ..., int y );`, `void func(int x, int y, ..., ...);` biÃ§imindeki **variadic function** bildirimleri hatalÄ± ve illegal'dir. </br>
`void func(...);` bÃ¶yle bir **variadic function** bildirimi C23 standardÄ±ndan Ã¶nce illegaldir ama C23 ile birlikte legal hale getirilmiÅŸtir. </br>
Bir **variadic function**'Ä± Ã§aÄŸÄ±ran kod bu fonksiyonun **variadic** olan son parametresi dÄ±ÅŸÄ±ndaki parametrelerine argÃ¼man geÃ§mek zorundadÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda **variadic function** Ã§aÄŸrÄ±larÄ±nÄ±n nasÄ±l olabileceÄŸi incelenebilir.
```C
void func(int x, int y, ...);

int main(void)
{
    // func(); // Illegal function call.
    // func(2); // Illegal function call.
    func(2, 3); // Legal function call.
    func(3, 5., 3); // Legal function call.
    func(3, 6, 3, 5); // Legal function call.
    func(3, 5, 3, 5, 7, 8); // Legal function call.
}
```


ğŸ§­ C dilindeki **variadic function** yapÄ±sÄ±nÄ±n eksiklikleri;
1. **Variadic** parametre karÅŸÄ±lÄ±ÄŸÄ± Ã§aÄŸÄ±ran kod dilediÄŸi kadar argÃ¼man geÃ§ebilir ancak kaÃ§ argÃ¼man gÃ¶nderdiÄŸini bir biÃ§imde Ã§aÄŸrÄ± yapÄ±lan fonksiyona bildirmek zorundadÄ±r, bunu yapabilmek iÃ§in kullanÄ±labilecek bir mekanizma yok.
2. **variadic function**'lar **type safe** deÄŸildir, bu durum **run-time** hatalara neden olabilme potansiyeline sahiptir, en sorun Ã§Ä±karacak durum budur denilebilir.


**Variadic function**'larÄ± tanÄ±mlarken bir tÃ¼r kullanÄ±yoruz(`va_list` tÃ¼rÃ¼, bu tÃ¼r derleyiciye baÄŸlÄ±) ve Ã¼Ã§ farklÄ± **functional-makro(`va_start`, `va_end`, `va_arg`, `va_copy`)** kullanÄ±yoruz, bu makrolar `stdarg.h` baÅŸlÄ±k dosyasÄ±nda bulunmaktadÄ±r.

â—â—â— ğŸ§­ Bir **Variadic function** ilk olarak kendisine **variadic** olarak geÃ§ilen deÄŸiÅŸken sayÄ±daki argÃ¼manÄ±n sayÄ±sÄ±nÄ± anlamasÄ±nÄ± saÄŸlayacak bir mekanizmaya sahip olmalÄ±dÄ±r, aÅŸaÄŸÄ±da kullanÄ±labilecek Ã¼Ã§ farklÄ± mekanizma gÃ¶rÃ¼lebilir;
1. Bildirimi `void foo(int x, ...);` biÃ§iminde olan bir fonksiyona geÃ§ilen argÃ¼man sayÄ±sÄ± fonksiyonun ilk parametresine geÃ§ilen argÃ¼mandan anlaÅŸÄ±labilir, mesela `foo(3, 3, 4, 5);`, `foo(2, 1, 2);` biÃ§imindeki fonksiyon Ã§aÄŸrÄ±larÄ± buradaki mekanizmayÄ± kullanmaktadÄ±r.
2. Bildirimi `void foo(int x, ...);` biÃ§iminde olan bir fonksiyonun dÃ¶kÃ¼manÄ±nda belirtilen bir deÄŸer(mesela "-1" deÄŸeri) **variadic** argÃ¼manlarÄ±n sonunu belirtebilir, mesela `foo(10, 20, 30, 40, -1);`, `foo(11, 22, 33, -1);` biÃ§imindeki fonksiyon Ã§aÄŸrÄ±larÄ± buradaki mekanizmayÄ± kullanmaktadÄ±r.
3. Bildirimi `void foo(const char* *p, ...);` biÃ§iminde olan bir fonksiyonun ilk parametresinin yazÄ± adresi isteyen bir gÃ¶sterici yapmak ve gÃ¶nderilen argÃ¼man sayÄ±sÄ±nÄ± bu pointer'Ä±n gÃ¶sterdiÄŸi yazÄ±dan almka, `printf`, `scanf` fonksiyonlarÄ± bu tekniÄŸi kullanmaktadÄ±r.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 21.10-21.32 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir **variadic function** tanÄ±mlanÄ±ÅŸÄ±nÄ±n ve kullanÄ±lÄ±ÅŸÄ±nÄ± nasÄ±l olduÄŸu incelenebilir.
```C
#include <stdarg.h> // Bu baÅŸlÄ±k dosyasÄ± variadic function bildirimi yapabilmek iÃ§in 
#include <stdio.h>

// AÅŸaÄŸÄ±daki 'sum' fonksiyonu kendisine geÃ§ilen variadic argÃ¼man sayÄ±sÄ±nÄ± yukarÄ±da listelenen ilk teknikle tespitetmektedir.
int sum(int n, ...)
{
    va_list args;       // 1.adÄ±m 'va_list' tÃ¼rÃ¼nden bir deÄŸiÅŸken tanÄ±mla.
    va_start(args, n);  // 2.adÄ±m 'va_start' function-like makro'suna kullan. Ä°lk argÃ¼manÄ± 'va_list' tÃ¼rÃ¼nden bir deÄŸiÅŸken ve ikinci argÃ¼manÄ± variadic parametrelerden Ã¶nceki ilk parametre deÄŸeri.

    int sum = 0;

    for(int i = 0; i < n;++i)
        sum += va_arg(args, int); // 3.adÄ±m 'va_arg' function-like makro'suna kullanÄ±larak fonksiyona geÃ§ilen variadic parametreler elde edilir. 

    va_end(args);

    return sum;
}

int main(void)
{
    int x = 10, y = 20, z = 71;

    printf("%d\n", sum(2, x, y));
    printf("%d\n", sum(3, x, y, z));
    printf("%d\n", sum(4, x, y, z, 200));
}
```


C dilinde standardÄ±n **default arguman conversion** dediÄŸi bir tavram var, bu kayram iki yerde Ã¶nem taÅŸÄ±maktadÄ±r, 


ğŸ‘‡ AÅŸaÄŸÄ±daki programda **default arguman conversion**'Ä±n nasÄ±l uygulandÄ±ÄŸÄ± incelenebilir.
```C
#include <stdarg.h> // Bu baÅŸlÄ±k dosyasÄ± variadic function bildirimi yapabilmek iÃ§in 
#include <stdio.h>

void foo(int x, ...);

int main(void)
{
    char c = 3;
    short s = 13;
    float f = 23.54;
    int i = 234;
    long lval = 34L;
    double dval = 124.643;

    foo(6, c, s, f, i, lval, dval);

    // default arguman conversion
    // int'ten kÃ¼Ã§Ã¼k tam sayÄ± tÃ¼rleri iÃ§in 'integral promotion' uygulanÄ±r.
    // float tÃ¼rÃ¼ double.
    // DiÄŸer tÃ¼rler kendi tÃ¼rlerine atanÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **default arguman conversion** uygulanÄ±ÅŸÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#include <stdarg.h> // Bu baÅŸlÄ±k dosyasÄ± variadic function bildirimi yapabilmek iÃ§in 
#include <stdio.h>

// AÅŸaÄŸÄ±daki 'sum' fonksiyonu kendisine geÃ§ilen variadic argÃ¼man sayÄ±sÄ±nÄ± yukarÄ±da listelenen ilk teknikle tespitetmektedir.
int sum(int n, ...)
{
    va_list args;       // 1.adÄ±m 'va_list' tÃ¼rÃ¼nden bir deÄŸiÅŸken tanÄ±mla.
    va_start(args, n);  // 2.adÄ±m 'va_start' function-like makro'suna kullan. Ä°lk argÃ¼manÄ± 'va_list' tÃ¼rÃ¼nden bir deÄŸiÅŸken ve ikinci argÃ¼manÄ± variadic parametrelerden Ã¶nceki ilk parametre deÄŸeri.

    int sum = 0;

    for(int i = 0; i < n;++i)
        sum += va_arg(args, int); // 3.adÄ±m 'va_arg' function-like makro'suna kullanÄ±larak fonksiyona geÃ§ilen variadic parametreler elde edilir. 

    va_end(args); // 4.adÄ±m 'va_end' function-like makro'sun kullanÄ±lÄ±r.

    return sum;
}

int main(void)
{
    int x = 10, y = 20, z = 71;
    char c = 13;
    short s = 42;

    printf("%d\n", sum(3, x, c, s)); // Buradaki gibi bir fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±labilir, 'int' tÃ¼rÃ¼nden kÃ¼Ã§Ã¼k boyutlu tam sayÄ± tÃ¼rleri 'int' tÃ¼rÃ¼ne yÃ¼kseltilir.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **default arguman conversion** uygulanÄ±ÅŸÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#include <stdarg.h> // Bu baÅŸlÄ±k dosyasÄ± variadic function bildirimi yapabilmek iÃ§in 
#include <stdio.h>

// AÅŸaÄŸÄ±daki 'max' fonksiyonu kendisine geÃ§ilen variadic argÃ¼man sayÄ±sÄ±nÄ± yukarÄ±da listelenen ilk teknikle tespitetmektedir.
int get_max(int n, ...)
{
    int max = INT_MAX;
    va_list args;       // 1.adÄ±m 'va_list' tÃ¼rÃ¼nden bir deÄŸiÅŸken tanÄ±mla.
    va_start(args, n);  // 2.adÄ±m 'va_start' function-like makro'suna kullan. Ä°lk argÃ¼manÄ± 'va_list' tÃ¼rÃ¼nden bir deÄŸiÅŸken ve ikinci argÃ¼manÄ± variadic parametrelerden Ã¶nceki ilk parametre deÄŸeri.

    for(int i = 0; i < n;++i){
        int val = va_arg(args, int); // 3.adÄ±m 'va_arg' function-like makro'suna kullanÄ±larak fonksiyona geÃ§ilen variadic parametreler elde edilir. 

        if(val > max)
            max = val;
    }

    va_end(args); // 4.adÄ±m 'va_end' function-like makro'sun kullanÄ±lÄ±r.

    return max;
}

int main(void)
{
    int max = get_max(5, 5, 45, 76, 8, 9, 71);

    printf("max = %d\n", max);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda 2. yÃ¶ntem ile bir **variadic** fonksiyonun tanÄ±mlanÄ±ÅŸÄ± ve kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdarg.h> // Bu baÅŸlÄ±k dosyasÄ± variadic function bildirimi yapabilmek iÃ§in 
#include <stdio.h>

// AÅŸaÄŸÄ±daki 'max' fonksiyonu kendisine geÃ§ilen variadic argÃ¼man sayÄ±sÄ±nÄ± yukarÄ±da listelenen ilk teknikle tespitetmektedir.
int get_max(int x, ...)
{
    int max = x;

    va_list args;
    va_start(args, x);
    
    // Birinci yolla dÃ¶ngÃ¼nÃ¼n yazÄ±lÄ±ÅŸÄ±
    // while(1){
    //     int val = va_arg(args, int);

    //     if(val == -1)
    //         break;

    //     if(val > max){
    //         max = val;
    //     }
    // }

    // Ä°kinci yolla dÃ¶ngÃ¼nÃ¼n yazÄ±lÄ±ÅŸÄ±
    while((val = va_arg(args, int) != 1){
        if(val > max){
            max = val;
        }
    }

    va_end(args);

    return max;
}

int main(void)
{
    int max = get_max(3, 45, 76, 8, 9, 71, -1);

    printf("max = %d\n", max);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda 3. yÃ¶ntem ile bir **variadic** fonksiyonun tanÄ±mlanÄ±ÅŸÄ± ve kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdarg.h> // Bu baÅŸlÄ±k dosyasÄ± variadic function bildirimi yapabilmek iÃ§in 
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

int myprintf(const char* p, ...)
{
    va_list args;
    va_start(args, p);
    int chars_count = 0;

    while(*p){
        int ch = toupper(*p);
        if(ch == `I`){
            chars_count += printf("%d ", va_arg(args, int));
        }
        else if(ch == 'F' || ch == 'D'){
            chars_count += printf("%f ", va_arg(args, double));
        }
        else if(ch == 'L'){
            chars_count += printf("%ld ", va_arg(args, long));
        }
        else if(ch == 'C'){
            chars_count += printf("%c ", va_arg(args, int));
        }
        else if(ch == 's'){
            chars_count += printf("%s ", va_arg(args, const char*));
        }
        else if(ch == 'U'){
            chars_count += printf("%u ", va_arg(args, unsigned));
        }

        ++p;
    }

    return chars_count;
}

int main(void)
{
    int x = 45;
    double dval = 2. 3423;
    float f = 2.43f;
    char c = 'Z';
    char s[] = "bir kimse";

    // int ==> iI
    // float ==> fF
    // double ==> dD
    // char ==> cC
    // unsigned int ==> uU
    // string ==> sS

    myprintf("ScFdi", s, c, f, dval, x);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda 2. yÃ¶ntem ile `concat` adÄ±nda bir **variadic** fonksiyonun tanÄ±mlanÄ±ÅŸÄ± ve kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdarg.h> // Bu baÅŸlÄ±k dosyasÄ± variadic function bildirimi yapabilmek iÃ§in 
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

char* concat(const char* ptr, ...)
{
    va_list arg1;
    va_list arg2;

    va_start(arg1, ptr);
    
    // AÅŸaÄŸÄ±daki iki fonksiyonda birbiriyle aynÄ± iÅŸi yapmaktadÄ±r.
    va_copy(arg2, arg1); // 'va_copy' makrosu C99 ile dile eklenmiÅŸtir.
    // va_start(arg2, ptr);

    char* p;
    size_t len = strlen(ptr);
    while((p = va_arg(arg1, char*)) != NULL){
        len += strlen(p);
    }
    va_end(arg1);

    char* pd = malloc(len + 1);
    if(pd == NULL){
        return NULL;
    }

    strcpy(pd, ptr);

    while((p = va_arg(arg2, char*)) != NULL){
        strcat(pd, p);
    }

    va_end(arg2);

    return pd;
}

int main(void)
{
    char s1[] = "necati";
    char s2[] = "cengiz";
    char s3[] = "mete";

    char* p = concat(s1, s2, s3, "ece", "oguz", NULL); // 
    puts(p);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `vsnprintf` fonksiyonunun kullanÄ±mÄ± incelenebilir, bu program cppreference.com sitesinden esinlenilmiÅŸtir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdarg.h> // Bu baÅŸlÄ±k dosyasÄ± variadic function bildirimi yapabilmek iÃ§in 
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

void print_error(const char* fm, ...)
{
    char buffer[100];
    va_list args;
    va_start(args, fm);
    vsnprintf(buffer, 100, fm, args); // BaÅŸÄ±nda 'v' harfi olan printf grubu fonkisyonlarÄ±n yaptÄ±ÄŸÄ± iÅŸler baÅŸÄ±nda 'v' harfi olmayan fonksiyonlar ile aynÄ± ama tek farklarÄ± son parametrelerinin 'va_list' tÃ¼rÃ¼nden bir nesne almasÄ±dÄ±r.
    perror(buffer);
    va_end(args);
}


int main(void)
{
    char filename[] = "file.txt";
    FILE* f = fopen(filename, "r");

    if(!f){
        print_error("file open error : %s", filename);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program cppreference.com sitesinden alÄ±nmÄ±ÅŸtÄ±r, `log_vals` fonksiyonu ile tarih ve zaman bilgisiyle log kaydÄ± atÄ±lmaktadÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <time.h>
#include <stdarg.h>

void log_vals(const char* fmt, ...)
{
    char msg[50];
    time_t cln_tm;
    time(&cln_tm);
    strftime(msg, sizeof msg, "%F %T", localtime(&cln_tm));
    printf("[%s] ", msg);
    va_list args;
    va_start(args, fmt);
    vprintf(fmt, args);
    va_end(args);
}

int main(void)
{
    int ival = 34;
    double dval = 4.6;
    char str[] = "necati ergin";

    log_vals("log %d %f %s\n", ival, dval, str);
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda **v Ã¶beÄŸi** `printf` fonksiyonlarÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <time.h>
#include <stdarg.h>

void func(const char* pf, ...)
{
    va_list args;
    va_start(args, pf);

    vprintf(pf, args);
    va_end(args);
}

int main(void)
{
    func("necatinin %d kitabÄ± var toplam ederi %f TL\n", 12, 43234242.56);

    return 0;
}
```


ğŸ“Œ **Variadic** fonksiyonlar gÃ¼venilir deÄŸildir, bu tÃ¼r fonksiyonlar yazÄ±lÄ±rken ve kullanÄ±rken dikkatli olunmasÄ± gerekir.


Ders sonu ...
