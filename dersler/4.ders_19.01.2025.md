 # 4.Ders 19.01.2025 ğŸ•˜

Derse 35-38 kiÅŸi katÄ±ldÄ±.

## SayÄ± sistemleri

Derse sayÄ± sistemleriyle baÅŸladÄ±, Ã¶zellikle(en Ã§ok) ikilik sayÄ± sistemi kullanÄ±lÄ±yor. Ä°kili sayÄ± sisteminin her bir basamaÄŸÄ±na bit(binary digit) adÄ± verilmektedir.

SayÄ±lar tam sayÄ± ve kesirli sayÄ±lar(regional Number) olarak ikiye ayrÄ±lÄ±yor.

Bu derste sadecetam sayÄ±larÄ±n ikilik sayÄ± sisteminde gÃ¶sterimi konusu iÅŸlenecektir, kesirli sayÄ±lar(regional Number) bu derste iÅŸlenmeyecektir.

Tam sayÄ±lar iki baÅŸlÄ±ÄŸa ayrÄ±lmaktadÄ±r;
1. Signed Binary System(Ä°ÅŸaretli Ä°kilik Sistem)
2. Unsigned Binary System(Ä°ÅŸaretsiz Ä°kilik Sistem)


â— Ä°kilik sayÄ± gÃ¶steriminde bir sayÄ±yÄ±nÄ±n bitlerini tanÄ±mlarken hangi bitten bahsedildiÄŸini ifade edebilemk iÃ§in en saÄŸ bitte "0. bit" ve bu bitten sonraki bitlere artan deÄŸerde indeks deÄŸeri verilerek tanÄ±mlama yapÄ±lmaktadÄ±r.


â—â—â— Kurs boyunca aÅŸaÄŸÄ±daki bellek seviyeleri kullanÄ±lacaktÄ±r.
- 1 byte --> Hemen her yerde "8 bit" iftiva etmektedir..
- 1 KB --> 1024 byte
- 1 MB --> 1024 KB
- 1 GB --> 1024 MB
- 1 TB --> 1024 GB. Bu kursta en fazla bu kadarlÄ±k bellek seviyesi kullanÄ±lacak daha fazlasÄ±na deÄŸinilmeyecek


â—â—â— Ã–zellikle "**System Programming**" alanlarÄ±nda kullanÄ±lan terimler aÅŸaÄŸÄ±daki gibidir;
- 2 byte --> **1 word**
- 4 byte --> **1 dword(double word)**
- 4 bit = 0.5 byte --> **1 Nibble**, bu tanÄ±mlama Ã¶nemli Ã§Ã¼nkÃ¼ iki tabanÄ± ile 16 tabanÄ± arasÄ±ndaki dÃ¶nÃ¼ÅŸÃ¼mler bu adres bÃ¶lÃ¼mleri dikkate alÄ±narak yapÄ±lÄ±yor.

**MSD(Most Significant Digit/Bit)**: En yÃ¼ksek anlamlÄ± bit'e(en soldaki bit) verilen addÄ±r.

**LSD(List Significant Digit/Bit)**: En dÃ¼ÅŸÃ¼k anlamlÄ± bit'e(en saÄŸdaki bit) verilen addÄ±r.

Alttaki deÄŸerlerin bilinmesi Ã¶nemlidir; 
- 1 byte -> 1111_1111           -> 0-255 arasÄ± iÅŸaretsiz sayÄ± 
- 2 byte -> 1111_1111_1111_1111 -> 0-65'535 arasÄ± iÅŸaretsiz sayÄ±
- 4 byte ->        ...          -> 0-4'294'967'298 arasÄ± iÅŸaretsiz sayÄ±
- 8 byte ->        ...          -> 0-2^64 -1 arasÄ± iÅŸaretsiz sayÄ±

â— SayÄ± sistemleriyle ilgili olarak C dilini kullanabilmek iÃ§in neler bilinmesi gerekiyor: Ä°kilik sayÄ± sistemi Ã¼zerinde yapÄ±lan iÅŸlemlerin bilinmesi gerekiyor. 2, 4, 8, 16, 10 tabanlarÄ± arasÄ±nda kolayca dÃ¶nÃ¼ÅŸÃ¼m yapabilme yeteneÄŸine sahip olunmasÄ± bekleniyor.

â— Ä°kilik tabandaki bir sayÄ±nÄ±n 0. bitine bakÄ±larak bu sayÄ±nÄ±n Ã§ift mi tek mi olduÄŸu bilgisi edinilebiliyor.

### Bire tÃ¼mleyen iÅŸlemi(One's complement) 

Ä°kilik tabandaki sayÄ±larÄ±n bire tÃ¼mleyen iÅŸlemini yapmak iÃ§in sayÄ±nÄ±n tÃ¼m bitlerinin deÄŸili(0 yerine 1 ve 1 yerine 0 yazÄ±lÄ±ÅŸÄ± iÅŸlemi) alÄ±nÄ±r.

- 0101 0010 0010 1100
- 1010 1101 1101 0011 --> YukarÄ±daki sayÄ±nÄ±n 1'e tÃ¼mleyeni bu sayÄ±dÄ±r.

**Bitwise Not Operant** operatÃ¶rÃ¼ bire tÃ¼mleyen iÅŸlemini gerÃ§ekleÅŸtiren operatÃ¶re verilen addÄ±r. 

### Ä°kiye tÃ¼mleyen iÅŸlemi(Two's complement) 

Temel olarak ikilik tabandaki sayÄ±nÄ±n bire tÃ¼mleyenine bir eklenmesiyle elde edilen sayÄ±dÄ±r.
Ä°kilik tabandaki bir sayÄ±nÄ±n ikiye tÃ¼mleyenini hesaplamak iÃ§in kÄ±sa bir yol var: SaÄŸdan baÅŸlayarak ilk 1 bitini gÃ¶rene kadar basamak sayÄ±larÄ±nÄ±n aynÄ±sÄ±nÄ± yazÄ±yoruz(burada ilk gÃ¶rÃ¼len 1 biti de yazÄ±lÄ±yor) sonra her bitin tersini yazÄ±yoruz.

Ä°kiye tÃ¼mleyen iÅŸlemi Ã¶nemlidir Ã§Ã¼nkÃ¼ sistemlerin hemen hemen hepsinde iÅŸaretli sayÄ± gÃ¶sterimi ikiye tÃ¼mleyen aritmetiliyle yapÄ±lmaktadÄ±r, bu C dilinin standartlarÄ±nda zorunlu deÄŸil fakat C++ dilinde bu standart olarak zorunludur.

- 0101 0010 0010 1100
- 1010 1101 1101 0011 --> YukarÄ±daki sayÄ±nÄ±n 1'e tÃ¼mleyeni bu sayÄ±dÄ±r.
- 1010 1101 1101 0100 --> YukarÄ±daki sayÄ±nÄ±n 2'ye tÃ¼mleyeninin deÄŸeri buradaki deÄŸerdir.

â— Ä°ÅŸaretli sayÄ±larda en soldeki bit **Sign Bit** olarak adlandÄ±rÄ±lÄ±yor ve sayÄ±nÄ±n +, - iÅŸaretini temsil ediyor, bu bit "0" ise iÅŸaret "+", bu bit "1" ise iÅŸaret "-" olarak kabuledilir.

0000 0010 0011 --> Bu sayÄ±nÄ± deÄŸeri iÅŸaretli ve iÅŸaretsiz tam sayÄ± gÃ¶steriminde en sol bit "0" olduÄŸu iÃ§in aynÄ± olacaktÄ±r. Bu sayÄ±nÄ±n deÄŸeri onluk tabanda "35" olacaktÄ±r.
 
- 1110 1011 --> SayÄ±sÄ± eÄŸer iÅŸaretli bir tam sayÄ± ise bu sayÄ±nÄ±n deÄŸerini hesaplarken yÃ¼rÃ¼tÃ¼lecek mantÄ±k ÅŸÃ¶yledir: SayÄ±nÄ±n en anlamlÄ± bitinin deÄŸeri "1" ise bu sayÄ± "-" sayÄ±dÄ±r, bu sayÄ±nÄ±n deÄŸerini hesaplayabilmek iÃ§in ise bu sayÄ±nÄ±n ikiye tÃ¼mleyeninin deÄŸerine bakmamÄ±z gerekir ikiye tÃ¼mleyeninin deÄŸeri ne ise "-" sayÄ±nÄ±n deÄŸeri o olacaktÄ±r.
- 0001 0101 --> Bu sayÄ± "1110 1011" sayÄ±sÄ±nÄ±n ikiye tÃ¼mleyenidir ve bu sayÄ±nÄ±n deÄŸeri $1*2^0 + 0*2^1 + 1*2^2 + 0*2^3 + 1*2^4$ toplamÄ± "21"dir ve sayÄ±nÄ±n "-21" deÄŸerine sahip olduÄŸu gÃ¶rÃ¼lÃ¼r

- ğŸš€ 1 byte'lÄ±k alanda "-47" deÄŸerini yazalÄ±m. Bunu yapabilmek iÃ§in ilk Ã¶nce sayÄ±nÄ± "+" olarak oluÅŸturup ardÄ±ndan ikiye tÃ¼mleyenini alÄ±p ardÄ±ndan en sol bit "1" yapÄ±lÄ±r.
- ğŸš€ "47" iÃ§indeki ikinin katlarÄ± "36", "8", "2", "1" dir bu ikinin aÄŸÄ±rlÄ±klarÄ±nÄ± yazarsak sayÄ±yÄ± "0010 1011" ÅŸeklinde elde ederiz bu sayÄ±nÄ±n ikiye tÃ¼mleyeni ise "1101 0101" ÅŸeklinde olacaktÄ±r ve bu sayÄ± "-47" sayÄ±sÄ±na karÅŸÄ±lÄ±k gelecektir.

â— Ä°kilik sayÄ± sisteminin bilinmesi bit Ã¼zerinde iÅŸlemler yaparken Ã¶nemlidir, bu konu kursun sonlarÄ±nda iÅŸlenecekmiÅŸ.

1 byte'lÄ±k alanda iÅŸaretli olarak tam sayÄ± gÃ¶sterimindeki en bÃ¼yÃ¼k/en kÃ¼Ã§Ã¼k deÄŸerler aÅŸaÄŸÄ±daki gibidir;

- 0111 1111 --> Ä°ÅŸaretli tam sayÄ± olarak "127" deÄŸerine karÅŸÄ±lÄ±k gelir
- 1000 0001 --> Ä°ÅŸaretli tam sayÄ± olarak "-127" deÄŸerine karÅŸÄ±lÄ±k gelir
- 1000 0000 --> Ä°ÅŸaretli tam sayÄ± olarak "-128" deÄŸerine karÅŸÄ±lÄ±k gelir

2 byte'lÄ±k alanda iÅŸaretli olarak tam sayÄ± gÃ¶sterimindeki en bÃ¼yÃ¼k/en kÃ¼Ã§Ã¼k deÄŸerleri "**-32768 / 32767(65535)**" ÅŸeklinde olacaktÄ±r.

âš ï¸ C ve C++ dillerinde en Ã§ok yapÄ±lan hatalardan biri iÅŸaretli bir tam sayÄ± tÃ¼rÃ¼ne kapasitesini aÅŸan bir deÄŸerin yÃ¼klenmeye Ã§alÄ±ÅŸÄ±lmasÄ±dÄ±r.

### DiÄŸer SayÄ± tabanlarÄ± 

**Hexedecimal system** olan ve **hex** olarak kÄ±saltÄ±larak kullanÄ±lan 16 tabanÄ±nda toplamda 0'dan F'ye kadar toplamda 16 adet rakam vardÄ±r.

**Hex** sayÄ± sisteminin kullanÄ±lmasÄ±nÄ±n nedeni ikilik sayÄ± sistemiyle uyumlu olmasÄ±dÄ±r, ayrÄ±ca her dÃ¶rt bitlik blok **1 nibble** deÄŸerine karÅŸÄ±lÄ±k gelmektedir. 

- F2AB --> 16 tabanÄ± gÃ¶sterimi
- 1111 0010 1010 1011 --> 2 tabanÄ± gÃ¶sterimi

ğŸ§­ Ä°ÅŸaretli sayÄ± sisteminde bazÄ± Ã¶nemli gÃ¶sterimler, bu durumu bilmek gerekiyor Ã§Ã¼nkÃ¼ bu bilgiler ileride C ile kodlama yapÄ±lÄ±rken kullanÄ±lacak;
- 01111111111111...   --> En bÃ¼yÃ¼k sayÄ± gÃ¶sterimi
- 10000000000000...   --> En kÃ¼Ã§Ã¼k sayÄ± gÃ¶sterimi
- 0000 0000 0000 0001 --> 1 deÄŸerine sahiptir
- 1111 1111 1111 1111 --> -1 deÄŸerine sahiptir, "_-1 hepsi bir_" diye ifade ediyormuÅŸ Necati Ergin.

AÅŸaÄŸÄ±daki sorular bu konuda mÃ¼lakatlarda sorulabilecek sorulardÄ±r.

>â”
> 2 byte'lÄ±k alanda iÅŸaretli olarak yazÄ±labilecek en bÃ¼yÃ¼k tam sayÄ±yÄ± hex olarak ifade ediniz.
> 
> Ã‡Ã¶zÃ¼m;
> 
> En anlamÄ± bit "0" olacaktÄ±r ve geriye kalan tÃ¼m birler "1" olacaktÄ±r.
> 
> Bu sayÄ± ikilik tabanda ÅŸu ÅŸekilde yazÄ±lacaktÄ±r "0111 1111 1111 1111" ve hex tabandaki karÅŸÄ±lÄ±ÄŸÄ± "7FFF" ÅŸeklinde elde edilecektir.


> 2 byte'lÄ±k alanda iÅŸaretli olarak yazÄ±labilecek en kÃ¼Ã§Ã¼k tam sayÄ±yÄ± hex olarak ifade ediniz.
> 
> Ã‡Ã¶zÃ¼m;
> 
> Ä°ki tabanÄ±nda yazÄ±labilecek en bÃ¼yÃ¼k sayÄ± bulunur ve bunun ikiye tÃ¼mleyeni alÄ±nÄ±r bu iÅŸlem sonrasÄ±nda cevabÄ± bulmuÅŸ oluruz.
> 
> ikilik tabandaki en bÃ¼yÃ¼k sayÄ± "0111 1111 1111 1111" olacaktÄ±r.
> 
> Bunun ikiye tÃ¼mleyeni "1000 0000 0000 0001" olacaktÄ±r.
> 
> Bunun bir eksiÄŸi olan sayÄ± en kÃ¼Ã§Ã¼k sayÄ± olacaktÄ±r, o da bu "1000 0000 0000 0000" sayÄ±dÄ±r.
> 
> En son hex hesaplanan sayÄ±nÄ±n hex tabandaki karÅŸÄ±lÄ±ÄŸÄ± "8000" ÅŸeklinde elde edilecektir.


> 2 byte'lÄ±k alanda iÅŸaretli olarak "-1" deÄŸerini hex olarak ifade ediniz.
> 
> Ã‡Ã¶zÃ¼m;
> 
> "-1 hepsi bir"den ikilik tabanda "1111 1111 1111 1111" sayÄ±sÄ±nÄ± buluruz ve hex olarak "FFFF" sayÄ±sÄ±nÄ± buluruz.


## C'deki Punctuation Character 

**Punctuation Character**: Rakam karakteri ve alfabe karakteri olmayan ama bir gÃ¶rÃ¼ntÃ¼sÃ¼ olan karakterlere verilen addÄ±r. `.`, `,`, `:`, `@`, `~` vb. karakterler bu gruba girmektedir(boÅŸluk karakteri bu gruba dahil edilmez).

ASCI Karakter sisteminde toplamda 128 adet karakter vardÄ±r.

ğŸ‘‡ AÅŸaÄŸÄ±daki programda ASCI karakter kÃ¼mesindeki tÃ¼m **punctuation character** yazdÄ±rÄ±lmaktadÄ±r.
```C
#include <stdio.h>
#include <ctype.h>

int main(void)
{
    for(int i = 0; i < 128; ++i){
        if(ispunct(i)){
            printf("%3d %c\n", i, i);
        }
    }
}
```

Programlamada Ã§oÄŸunlukla parantez tÃ¼rlerini aÃ§an karakterlere **opening** ya da **left**, kapatan karakterlere **closing** ya da **right** olarak adlandÄ±rÄ±lÄ±yor; 

- `(  )` --> Bracket, Parantases(Parantez)
- `[  ]` --> Square bracket(KÃ¶ÅŸeli parantez)
- `{  }` --> Brace bracket(Curly Brace)(KÄ±vÄ±rcÄ±k Parantez)
- `<  >` --> Angular bracket(AÃ§Ä±sal Parantez)

DiÄŸer **punctuation characters**;
- `.`  --> Full stap, Period
- `,`  --> Comma
- `#`  --> Number sign
- `'`  --> Single quote
- `"`  --> Double quote
- `!`  --> Exclamation mark

- `$`  --> Bu karakter C dilinde hiÃ§ bir Ã¶zel anlam ifade etmemektedir.
- `\`` --> Bu karakter de C dilinde hiÃ§ bir Ã¶zel anlam ifade etmemektedir. AdÄ± "Back Tick" olarak geÃ§iyor.
- `@`  --> Bu karakter de C dilinde hiÃ§ bir Ã¶zel anlam ifade etmemektedir.

- `/`  --> Slash
- `\`  --> Back Slash
- `:`  --> Colon
- `;`  --> Semicolon
- `=`  --> Equal mark
- `?`  --> Question mark
- `^`  --> Caret 
- `_`  --> Under scoor
- `~`  --> Tilda
- `|`  --> Pipe, Vertical bar


## C Dili'e GiriÅŸ 

"**The C Programming Languages**" kitabÄ± programlama konusunda en Ã§ok atÄ±f alan kitaptÄ±r, bu kitabÄ±n ilk baskÄ±sÄ± 1978 yÄ±lÄ±nda yapÄ±ldÄ±, kurs sonunda bu kitabÄ±n okunabileceÄŸini belirtti. Bu kitabÄ±n yazarlarÄ± **Brian Kernighan**, **Dennis Ritchie** olduÄŸu iÃ§in "**K&R**" olarak anÄ±lmaktadÄ±r ama C Ã¶ÄŸrenmek iÃ§in okunabilecek bir kitap olmadÄ±ÄŸÄ± belirtildi, bu kitabÄ±n son baskÄ±sÄ±nÄ±n okunmasÄ±nÄ±n fayda saÄŸlayacaÄŸÄ±nÄ± belirtti fakat bu kitabÄ± okuyup C dilini Ã¶ÄŸrenilemeyeceÄŸi belirtildi.

"**The C Programming Languages**" kitabÄ± C dili henÃ¼z resmi(formal) bir standardÄ± olmadÄ±ÄŸÄ± dÃ¶nemde bir standartmÄ±ÅŸ gibi kullanÄ±lmÄ±ÅŸtÄ±r, C89 standardÄ±ndan Ã¶nce yazÄ±lan C programlarÄ±na **K&R** standardÄ± da denilebiliyor.

"**#**" ile baÅŸlayan satÄ±rlar Ã¶n iÅŸlemci komutu(talimatÄ±) olarak adlandÄ±rÄ±lÄ±yor.
"**#include <stdio.h>**" tanÄ±mlamasÄ± Ã¶n iÅŸlemci program tarafÄ±ndan iÅŸlenir, Ã¶n iÅŸlemci program bu tanÄ±m ile belirtilen dosyadaki kodlarÄ± alÄ±p bizim kendi dosyamÄ±za kopyalayÄ±p yapÄ±ÅŸtÄ±rÄ±r.

ğŸ‘‡ AÅŸaÄŸÄ±daki basit C programÄ±nÄ±n aÃ§Ä±klamasÄ± ÅŸu ÅŸekildedir: Ä°smi "**main**" olan bir fonksiyon tanÄ±mlanmÄ±ÅŸ, fonksiyonu iÃ§inden adÄ± "`printf`" olan fonksiyon Ã§aÄŸÄ±rÄ±lmÄ±ÅŸtÄ±r
```C
#include <stdio.h>

int main(void)
{
  printf("Hello World!"); // Buradaki satÄ±rdaki kod 'Expression Statement' olarak adlandÄ±rÄ±lmaktadÄ±r.
  
  return 0; // Buradaki satÄ±rdaki kod 'Control Statement' olarak adlandÄ±rÄ±lmaktadÄ±r. C99 standardÄ±ndan itabaren 'main' fonksiyonunda 'return' statement yazÄ±lmazsa derleyisi kodu derlerken bu statement'Ä± eklemektedir.
}
```


### C'de Function YapÄ±sÄ± 

"**Fonksiyon**" terimi C standardÄ±nda belirli bir iÅŸi yapmak iÃ§in kullanÄ±lan alt kod parÃ§alarÄ±na verilen addÄ±r.

"**Fonksiyon**" ile ilgili bazÄ± terimler, bu terimlerin her bir ayrÄ± ayrÄ± iÅŸlenecek konulardÄ±r;
- **To define a function(Function Definition)**: Bir fonksiyonun gÃ¶vdesiyle birlikte yazÄ±lmasÄ± iÅŸlemi iÃ§in yapÄ±lan tanÄ±mlamadÄ±r.
- **To call a function(Function Call)**: Bir fonksiyonun Ã§aÄŸÄ±rÄ±lma iÅŸlemi iÃ§in yapÄ±lan tanÄ±mlamadÄ±r. **To invoke a funvtion** tanÄ±mlamasÄ± da aynÄ± ÅŸeyi ifade etmektedir.
- **To declare function(function declaration)**: Bir fonksiyonun `int foo(int);` gibi bildiriminin yapÄ±lmasÄ± iÅŸlemi iÃ§in yapÄ±lan tanÄ±mlamadÄ±r. Bu konu iki ay sonra detaylÄ± iÅŸlenecek.

â— Her bir fonksiyonun geÃ§erli olabilmesi iÃ§in bir ana bloÄŸa sahip olmasÄ± gerekiyor. Herhangibir fonksiyonun ana bloÄŸu ÅŸu ÅŸekilde ifade edilir: "**main block of a function**". [20:32:00]

â— Bir C programÄ± Ã§alÄ±ÅŸÄ±rken ilk Ã¶nce "**main**" adÄ±ndaki fonksiyon Ã§aÄŸÄ±rÄ±lÄ±r, buna programÄ±n giriÅŸ fonksiyonu da denmektedir. DÄ°ÄŸer fonksiyonlar main fonksiyonu iÃ§erisindne Ã§aÄŸÄ±rÄ±lmaktadÄ±r.

âš ï¸ Kursta en dÃ¼ÅŸÃ¼k C standard olarak C99 standardÄ± kabul edilmektedir.

***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.42-11.03 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦
10.30 ara vereceÄŸiz dendi ama Necati Ergin hÄ±zÄ±nÄ± alamayÄ±nca 10.42'de birinci arayÄ± verdi. 

==================================================
***


## Data Types in C 

C, C++, C#, Java gibi diller **static type** yapÄ±sÄ±na sahip dillerdir, bir deÄŸiÅŸkenin ne deÄŸer alabileceÄŸi **compile-time**'da bellidir, sonradan deÄŸiÅŸmez.

Python gibi diller **dynamic type** dillerdir, bunu anlamak iÃ§in bir dilde eÄŸer bir deÄŸiÅŸkene farklÄ± tÃ¼rden deÄŸerler atanabiliyorsa o dil **dynamic type** dildir denebilir.

C dilinde "**Data Type**" deÄŸerine sahip olabilen varlÄ±klar alttakilerdir;
1. Variables(objects)[DeÄŸiÅŸkenler]
2. Constants[Sabitler]
3. Expressions[Ä°fadeler]

â— C ve C++ dillerinde deÄŸer tÃ¼rleri derleme zamanÄ±nda belirlidir kesinlikle Ã§alÄ±ÅŸma zamanÄ±nda deÄŸiÅŸken tÃ¼rleri deÄŸiÅŸmez.

ğŸ§  C dilinde kullanÄ±lan **veri tÃ¼rleri(Data Types)** ikiye ayrÄ±lÄ±r bunlar: "**Basic Data Types**", "**User defined Data Types**".

ğŸ§  "**Basic Data Types**" ifadesiyle aynÄ± anlama gelen tanÄ±mlamalar aÅŸaÄŸÄ±dakilerdir;
- Fundimental Types
- Defould Types
- Buildin Types
- Primitive Types

â—â—â— C Ã¶ÄŸrenirken dilin en karmaÅŸÄ±k konularÄ±ndan biriyle ilk baÅŸta karÅŸÄ±laÅŸÄ±lÄ±yor. Bu konu ÅŸu: C dilinde kullanÄ±lan tÃ¼rlerin storage ihtiyacÄ± derleyiciden derleyiciye gÃ¶re deÄŸiÅŸebiliyor yani mesela bir `int` tÃ¼rÃ¼nÃ¼n boyutu bazÄ± derleyiciler iÃ§in 32 bit bazÄ± derleyiciler iÃ§in 16 bit olabiliyor. BÃ¶yle olmasÄ±nÄ±n nedeni C dilinin genel amaÃ§lÄ± bir dil olmasÄ± yani C ile Ã§ok kÄ±sÄ±tlÄ± kaynaklara sahip bir **micro controller** iÃ§in de program yazÄ±labilir, 1 TB ram'e sahip cihazlara kurulacak olan iÅŸletim sistemlerinin Ã§ekirde programlarÄ± da yazÄ±labilir, gÃ¶rÃ¼leceÄŸi gibi C dilinin kullanÄ±m spektrumu geniÅŸtir.

â— C dilinin standardÄ±nda temel olarak alÄ±nan bellek birimi "**byte**" deÄŸildir bunun yerine "**character**" tanÄ±mÄ± kullanÄ±lÄ±r, bu "**character**"in kaÃ§ bit olacaÄŸÄ± kodun Ã¼zerinde Ã§alÄ±ÅŸacaÄŸÄ± donanÄ±ma gÃ¶re deÄŸiÅŸebiliyor, bunun bÃ¶yle olmasÄ±nÄ±n nedeni kÄ±sÄ±tlÄ± donanÄ±ma sahip olan iÅŸlemcilerde de C ile geliÅŸtirme yapÄ±labilmesine olanak tanÄ±maktÄ±r, Ã§ok ender kullanÄ±lan C derleyiciler ve donanÄ±mlar ezoterik sistemler olarak nitelendirilir. 


### C Dilindeki Basic Data Types

C dilinde "Integer Types", "Floating Types" olarak iki temel veri tÃ¼rÃ¼ grubu vardÄ±r.

Bir kaÃ§ istisna dÄ±ÅŸÄ±nda tÃ¼m tam sayÄ± tÃ¼rlerinin iÅŸaretli ve iÅŸaretsiz tÃ¼rÃ¼ mevcuttur.

#### Integer Types(TamsayÄ± TÃ¼rleri)

**Implementation Defined(Derleyiciye baÄŸlÄ±)**: Bu tanÄ±mlama Ã¶nemlidir, bu tanÄ±mlama C derleyicilerinin tercihine bÄ±rakÄ±lmÄ±ÅŸ durumlarÄ± belirtmek iÃ§in kullanÄ±lÄ±yor. Mesela C dilinde "`char`" veri tÃ¼rÃ¼nÃ¼n iÅŸaretli mi iÅŸaretsiz mi olarak ele alÄ±nacaÄŸÄ± derleyicilere bÄ±rakÄ±lmÄ±ÅŸtÄ±r. 


1. **_Bool(C99 standardÄ±ndan sonra dile eklenmiÅŸtir)(c dilinde bu veri tÃ¼rÃ¼ yerine int tÃ¼rÃ¼ tercih ediliyor genellikle)**: C dilinde sadece tek bir bit tutmak iÃ§in kullanÄ±lan 1 byte boyutunda olan ve sadece "0, 1" deÄŸer alabilen iÅŸaretsiz tam sayÄ± tÃ¼rÃ¼dÃ¼r. Bit seviyesinde temsil edilen bir veri tÃ¼rÃ¼ olmadÄ±ÄŸÄ± iÃ§in en kÃ¼Ã§Ã¼k veri tÃ¼rÃ¼ 1 Byte(ya da Character) yer kaplamak zorundadÄ±r. Bu veri tÃ¼rÃ¼ Ã¶nceden yokmuÅŸ ve logic(bool) veri tÃ¼rleri `int` veri tÃ¼rÃ¼nde tutuluyormuÅŸ.
   - C dilinin standart kÃ¼tÃ¼phanesinde "bool, true, false" anahtar sÃ¶zcÃ¼kleri(keyword) C dilinin standard'Ä±nda yoktur ama bazÄ± ".h" dosyalarÄ±yla "makro" eklenerek bu tÃ¼rler varmÄ±ÅŸ gibi kullanabiliyoruz. C++ dilinde "bool, true, false" anahtar sÃ¶zcÃ¼kleri(keyword) vardÄ±r.

   C dilinde "**bool**", "**true**", "**false**" ÅŸeklinde anahtar sÃ¶zcÃ¼k yoktur ama C++ dilinde bu sÃ¶zcÃ¼kler bir **keyword** olarak mevcuttur.

   ğŸ‘‡ AÅŸaÄŸÄ±daki programda C dilindeki boolean ile birlikte kullanÄ±lan makrolarÄ±la ilgili yanlÄ±ÅŸ bilinen bir ÅŸeyi belirmel iÃ§in kullanÄ±m mevcuttur.
   ```C
   #include <stdio.h>
   #include <stdbool.h> // "bool", "true", "false" expression'larÄ±nÄ±n kullanÄ±labilmesi iÃ§in eklenen ".h" dosyasÄ± tanÄ±mÄ±

   int main(void)
   {
      // 'bool', 'true', 'false' expression'larÄ± "stdbool.h" dosyasÄ±nda tanÄ±mlÄ± birer makrodur. 
      bool x = true;
   
      x = false;
   
      return 0; 
   }

   // AÅŸaÄŸÄ±daki 'main' fonksiyonu yukarÄ±dakiyle birebir aynÄ±dÄ±r
   #include <stdio.h>

    int main(void)
    {
        _Bool x = 1;

        x = 0;

        return 0; 
    }
   ```

2. "**char[0-255]**" tÃ¼rÃ¼nÃ¼n illa alfabedeki karakterleri tutmasÄ± gerekmiyor. C dilinde "`char`" veri tÃ¼rÃ¼nÃ¼n iÅŸaretli mi iÅŸaretsiz mi olarak ele alÄ±nacaÄŸÄ± derleyicilere bÄ±rakÄ±lmÄ±ÅŸtÄ±r.
    - Signed char[-128   127]
    - Unsigned char[0    255]

3. `short` veri tÃ¼rÃ¼ nerdeyse tÃ¼m sistemlerde 2 byte'tÄ±r.
    - Signed short[-32768   32767]
    - Unsigned short[0   65535] 

4. "**int**" veri tÃ¼rÃ¼ ya 2 byte ya da 4 byte yer kaplar.
    - Signed int[-2'147'483'648   2'147'483'647]
    - Unsigned int[0   4'294'967'295] 

5. "**long**" veri tÃ¼rÃ¼ ya 4 byte ya da 8 byte yer kaplar.
    - Signed long 
    - Unsigned long 

6. "**long long**" veri tÃ¼rÃ¼ C99 ile eklendi ve bu tÃ¼rÃ¼n en az 8 byte olmasÄ± dilin standardÄ±yla garanti edilmiÅŸtir ve derleyicilerin Ã§oÄŸunda 8 byte yer kaplar.
    - Signed long long
    - Unsigned long long

â— YukarÄ±daki veri tÃ¼rlerinin kapladÄ±ÄŸÄ± alanlar kullanÄ±lan derleyiciye gÃ¶re farklÄ±lÄ±k gÃ¶sterebiliyor 

â— Standart bir C derleyicisi "**Integer Types**"larda aÅŸaÄŸÄ±daki veri tÃ¼rleri kapsamÄ± kuralÄ±nÄ± saÄŸlÄ±yor olmasÄ± gerekiyor, alttaki veri tÃ¼rÃ¼ kapsamlarÄ± bÃ¼yÃ¼klÃ¼klerine gÃ¶re ufak yer kaplayan veri tÃ¼rleri kendilerinden bÃ¼yÃ¼k olmasÄ± gereken veri tÃ¼rlerine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼rken veri kaybÄ± olmamasÄ± gerekiyor. "**_Bool, char <= short <= int <= long <= long long(en az 8 byte)**"



ğŸ‘‡ AÅŸaÄŸÄ±daki programda kullanÄ±lan derleyiciye gÃ¶re hangi veri tÃ¼rÃ¼ ne kadar byte boyutunda bunun bilgisi gÃ¶zlemlenebilir.
```C
#include <stdio.h>

int main(void)
{
    printf("sizeof(_Bool) = %zu\n", sizeof(_Bool));
    printf("sizeof(char) = %zu\n", sizeof(char));
    printf("sizeof(short) = %zu\n", sizeof(short));
    printf("sizeof(int) = %zu\n", sizeof(int));
    printf("sizeof(long) = %zu\n", sizeof(long));
    printf("sizeof(long long) = %zu\n", sizeof(long long));

    return 0; 
}
```

â— "**char8_t, uchar8_t, short16_t, ushort16_t, int32_t, uint32_t** vb." ÅŸekildeki **type alias** kullanmak C dilinin farklÄ± derleyicilerinde veri tÃ¼rleri aynÄ± boyutta yer kaplayacak ÅŸekilde Ã§alÄ±ÅŸacak.

ğŸ” [wendbox.org](https//:www.wendbox.org) vb. sitelerde farklÄ± C derleyicilerini deneyebiliriz.

â— Bir Ã§ok C projesinde **logic** veri tÃ¼rÃ¼ olarak **int** tÃ¼rÃ¼nÃ¼n kullanÄ±ldÄ±ÄŸÄ± gÃ¶rÃ¼lecektir, bunun nedeni geleneksel olarak Ã¶nceden beri **logic** veriler iÃ§in **int** tÃ¼rÃ¼nÃ¼n kullanÄ±lÄ±yor olmasÄ±dÄ±r ve bu gelenek devam ettirilmektedir.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.04-12.15 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


Bellek tasarrufu konusunu Ã¼zerinde aÅŸÄ±rÄ±ya gidilmemesi gerekiyor, eÄŸer C programÄ± bellek kÄ±sÄ±tÄ± olan bir mikro denetleyici iÃ§in yazÄ±lmÄ±yorsa bir kaÃ§ deÄŸiÅŸkenin 2 byte tanÄ±mlamak yerine 4 byte tanÄ±mlamak bir sorun olmayacaktÄ±r.

"**Compiler Extension**" tanÄ±mÄ± derleyicilerin dilin standart kÃ¼tÃ¼phanesi tarafÄ±ndan desteklenmeyen kod kurallarÄ±nÄ± destekleyebilir, C dilinde en Ã§ok "**Compiler Extension**" saÄŸlayan derleyici **GCC** derleyicisidir.

Mesela "**int126_t**" gibi bir tanÄ±mlama gÃ¶rÃ¼lÃ¼yorsa bu kullanÄ±lan derleyicinin "Compiler Extension" desteÄŸinden geldiÄŸi dÃ¼ÅŸÃ¼nÃ¼lebilir. 

"**Compiler Extension**" kullanÄ±mlarÄ± yazÄ±lmÄ±ÅŸ bir C programÄ±nÄ± farklÄ± derleyicilerde Ã§alÄ±ÅŸtÄ±rÄ±nca aynÄ± Ã§Ä±ktÄ±yÄ± alamamaya neden olabilir.


#### Floating Types(Kesirli SayÄ± TÃ¼rleri) 

Toplamda Ã¼Ã§ farklÄ± "**Floating Types**" deÄŸeri vardÄ±r ve "**double**" tÃ¼rÃ¼ "**Floating Types**"larÄ±n varsayÄ±lan deÄŸeridir.
"Floating Types"'lar he zaman iÅŸaretli sayÄ±lardÄ±r.

1. "**float**" nerdeyse her derleyicide 4 Byte yer kaplar
2. "**double**" nerdeyse her derleyicide 8 Byte yer kaplar
3. "**long double**" bu veri tÃ¼rÃ¼nÃ¼n kapladÄ±ÄŸÄ± alan derleyiciden derleyiciye deÄŸiÅŸmektedir ve "**8 byte / 10 byte / 12 byte / 16 byte**" boyutunda olabilir.

ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**Floating Point Number**" tÃ¼rlerinin kaÃ§ byte olduÄŸu Ã¶ÄŸrenilebilir, 
```C
#include <stdio.h>

int main(void)
{
    printf("sizeof(float) = %zu\n", sizeof(float));
    printf("sizeof(double) = %zu\n", sizeof(double));
    printf("sizeof(long double) = %zu\n", sizeof(long double));

    return 0; 
}
```

ğŸš€ "**Floating Types**" deÄŸiÅŸkenler bellekte nasÄ±l tutuluyor diye dÃ¼ÅŸÃ¼nÃ¼ldÃ¼ÄŸÃ¼nde bunu yapmak iÃ§in bazÄ± "**Floating Point Number**" gÃ¶sterim standartlarÄ± mevcut, bunlarÄ±n detaylarÄ±na derste girilmedi. "**Floating Point Number**" gÃ¶sterim iÃ§in Ã§oÄŸunlukla "**IEEE754**" standardÄ± kullanÄ±lmaktadÄ±r.

"**Floating Point Number**" deÄŸerleri Ã¼Ã§ kÄ±sÄ±mdan oluÅŸur bu Ã¼Ã§ kÄ±sÄ±m sÄ±rasÄ±yla sayÄ±nÄ±n 
1. Ä°ÅŸaret biti, tek bit yer kaplar, Ã§oÄŸunlukla en yÃ¼ksek anlamlÄ± bittir.
2. SayÄ±nÄ±n tam kÄ±smÄ±.
3. SayÄ±nÄ±n ondalÄ±k kÄ±smÄ±(Mantisa denilmektedir).

ğŸ§­ C ve C++ dillerini Ã¶ÄŸrenirken en Ã¶nemli ÅŸey anlatÄ±lan konularÄ±n basitten zora doÄŸru formal olarak sÄ±ralanmÄ±ÅŸ ÅŸekilde Ã¶ÄŸrenilmesidir.

"**Floating Point Number**" deÄŸerlerinin varsayÄ±lan tÃ¼rÃ¼ **double** tÃ¼rÃ¼dÃ¼r;
- `double floating_number = 13314.456464;` --> Buradaki ondalÄ±klÄ± sayÄ± tanÄ±mlama iÅŸleminde **double** tÃ¼rÃ¼dÃ¼r
- `float floating_number = 13314.456464F;` --> 

## DeÄŸiÅŸkenlerin Bildirilmesi ve TanÄ±mlanmasÄ± 

EÄŸitim deneyimi olmayan kiÅŸilerin dili anlatÄ±mlarÄ± ya da yazÄ±lmÄ±ÅŸ bir kitaptaki konu anlatÄ±mÄ±ndaki konularÄ±n anlatÄ±m sÄ±ralamasÄ±nda hata yapÄ±lmaktadÄ±r, daha ilk dersten pointer anlatÄ±lmamasÄ± gerekiyor, basit ve sÄ±k kullanÄ±lan konulardan zor konulara doÄŸru bir anlatÄ±mÄ±n olmasÄ± daha doÄŸrudur. 

âš¡C dilinde "**declaration(bildirim)**" ve "**definition(tanÄ±mlama)**" terimleri Ã§oÄŸu durumda birbirinden farklÄ±dÄ±r. 
Her **definition(tanÄ±mlama)** aynÄ± zamanda bir **declaration(bildirim)**'dÄ±r.
Her **declaration(bildirim)** bir **definition(tanÄ±mlama)** olmayabilir.
1. **Definition(tanÄ±mlama)** olan **declaration(bildirim)**'lar: `int x;` buradaki gibi bir deÄŸiÅŸken bildirimi bu tanÄ±ma uymaktadÄ±r ve derleyici bu bildirimden sonra bellekte yer ayÄ±rÄ±r.
2. **Definition(tanÄ±mlama)** olmayan **declaration(bildirim)**'lar: `extern int x;` buradaki gibi bir deÄŸiÅŸken bildirimi bu tanÄ±ma uymaktadÄ±r ve derleyici bu bildirimden sonra bellekte yer ayÄ±rmak. Buradaki "**extern**" kullanÄ±mÄ±nÄ±n ne olduÄŸu ileride kursun 3. ya da 4. Ã§eyreÄŸinde Ã¶ÄŸrenilecektir.

âš¡DeÄŸiÅŸken bildirimlerinde iki farklÄ± **sÃ¶zdizim(syntax)** vardÄ±r;
1. **Pure Syntax**: `double y;` ÅŸeklindeki deÄŸer atamasÄ± yapÄ±lmayan kullanÄ±mdÄ±r.
2. **Initialization(Initializing) Syntax**: `int ival = 3251;` ÅŸeklinde ilk deÄŸer atamasÄ± yapÄ±lan deÄŸiÅŸken bildirimlerine verilen addÄ±r.

### Veri TÃ¼rleri KullanÄ±mÄ±

- `char`            --> Ä°ÅŸaretli olup olmamasÄ± derleyiciye baÄŸlÄ±dÄ±r.
- `signed char`     --> Ä°ÅŸaretli 1 byte veri tÃ¼rÃ¼.
- `unsigned char`   --> Ä°ÅŸaretsiz 1 byte veri tÃ¼rÃ¼.

AÅŸaÄŸÄ±daki deÄŸiÅŸken tÃ¼rlerinin hepsi `signed short` tÃ¼rÃ¼dÃ¼r;
- `signed short int`   --> Ä°ÅŸaretli `short` veri tÃ¼rÃ¼.
- `signed short`       --> Ä°ÅŸaretli `short` veri tÃ¼rÃ¼.
- `short int`          --> Ä°ÅŸaretli `short` veri tÃ¼rÃ¼.
- `short`              --> Ä°ÅŸaretli `short` veri tÃ¼rÃ¼.
- `int short signed`   --> Ä°ÅŸaretli `short` veri tÃ¼rÃ¼. Buradaki kullanÄ±m pek tercih edilmez ve deÄŸiÅŸken bildirimini yaparken anahtar sÃ¶zcÃ¼klerin hangi sÄ±raya gÃ¶re yazÄ±ldÄ±ÄŸÄ± Ã¶nemli deÄŸildir.

AÅŸaÄŸÄ±daki deÄŸiÅŸken tÃ¼rlerinin hepsi `unsigned short` tÃ¼rÃ¼dÃ¼r;
- `unsigned short int`    --> Ä°ÅŸaretsiz `short` veri tÃ¼rÃ¼.
- `unsigned short`        --> Ä°ÅŸaretsiz `short` veri tÃ¼rÃ¼.

AÅŸaÄŸÄ±daki deÄŸiÅŸken tÃ¼rlerinin hepsi `signed long` tÃ¼rÃ¼dÃ¼r;
- `signed long int`    --> Ä°ÅŸaretli `long` veri tÃ¼rÃ¼.
- `signed long`        --> Ä°ÅŸaretli `long` veri tÃ¼rÃ¼.
- `long int`           --> Ä°ÅŸaretli `long` veri tÃ¼rÃ¼.
- `long`               --> Ä°ÅŸaretli `long` veri tÃ¼rÃ¼.

AÅŸaÄŸÄ±daki deÄŸiÅŸken tÃ¼rlerinin hepsi `unsigned long` tÃ¼rÃ¼dÃ¼r;
- `unsigned long int`    --> Ä°ÅŸaretsiz `long` veri tÃ¼rÃ¼.
- `unsigned long`        --> Ä°ÅŸaretsiz `long` veri tÃ¼rÃ¼.

AÅŸaÄŸÄ±daki deÄŸiÅŸken tÃ¼rlerinin hepsi `long long` tÃ¼rÃ¼dÃ¼r;
- `signed long long int` --> Ä°ÅŸaretli `long long` veri tÃ¼rÃ¼.
- `signed long long`     --> Ä°ÅŸaretli `long long` veri tÃ¼rÃ¼.
- `long long int`        --> Ä°ÅŸaretli `long long` veri tÃ¼rÃ¼.
- `long long`            --> Ä°ÅŸaretli `long long` veri tÃ¼rÃ¼.

AÅŸaÄŸÄ±daki deÄŸiÅŸken tÃ¼rlerinin hepsi `unsigned long long` tÃ¼rÃ¼dÃ¼r;
- `unsigned long long int`  --> Ä°ÅŸaretsiz `long long` veri tÃ¼rÃ¼.
- `unsigned long long`      --> Ä°ÅŸaretsiz `long long` veri tÃ¼rÃ¼.

AÅŸaÄŸÄ±daki deÄŸiÅŸken tÃ¼rlerini kullanÄ±mlarÄ± biraz farklÄ± gelebilir ama bilinmesi Ã¶nemlidir;
- `signed long int` --> Ä°ÅŸaretli `long` veri tÃ¼rÃ¼.
- `int` --> Ä°ÅŸaretli `int` veri tÃ¼rÃ¼.
- `signed` --> Ä°ÅŸaretli `int` veri tÃ¼rÃ¼. `signed x = 5;` buradaki kullanÄ±m legal ve iÅŸaretli int tÃ¼rÃ¼dÃ¼r.
- `unsigned` --> Ä°ÅŸaretsiz `int` veri tÃ¼rÃ¼. `unsigned x = 23;` buradaki kullanÄ±m legal ve iÅŸaretsiz int tÃ¼rÃ¼dÃ¼r.
- `unsigned int` --> Ä°ÅŸaretsiz `int` veri tÃ¼rÃ¼.


YukarÄ±daki veri tÃ¼rÃ¼ tanÄ±mlamalarÄ±nda veri tÃ¼rÃ¼nÃ¼ tanÄ±mlayan **keyword** deÄŸerlerinin hangi sÄ±rayla yazÄ±ldÄ±ÄŸÄ± Ã¶nemli deÄŸildir, `signed short int` gÃ¶sterimi ile `short int signed` gÃ¶sterimi aynÄ±dÄ±r ama okunaklÄ±k iÃ§in yukarÄ±da verilen sÄ±rayla kullanÄ±lmasÄ± tercih ediliyor genellikle.


Ders sonu ...
