# 62.Ek Ders
---


## Abstract Data Structure(Soyut Veri Yapıları) 🌟

Bu başlık altında **kuyruk(queue)** ve **yığın(stack)** soyut veri yapısını inceleyeceğiz. </br>
Programlamayla tanışanların en çok aklında **FIFO(Fist in fist out)** ve **LIFO(Last in first out)** terimleri kalmaktadır.

**Kuyruk(queue)** soyut veri yapısında bir liste vardır ve bu yapıda ilk giren ilk çıkar(**FIFO**) mantığı uygulanmaktadır, mesela bir şey almak için beklenilen kuyruklar(sinama kuyruğu, bilet kuyruğu vb.) **FIFO** olan kuyruk türleridir. </br>
Programlamada en çok kullanılan soyut veri yapısı **kuyruk(queue)** veri yapısıdır. </br>
Bir de **öncelik kuyruğu(priority queue)** denilen başka bir soyut veri yapısı var, bu soyut veri yapısında önceliği en yüksek olan kuyruktan ilk çıkmaktadır.

**Yığın(stack)** soyut veri yapısınında ilk giren ilk çıkmaktadır, mesela sıradan bir zeminde duran bir tabak yığınının en üstüne bir tabak koyduğumuzda en zahmetsiz olarak en üstteki tabağı alıyoruz.

❗❗❗ Özellikle **özyinelemeli(recursion)** algoritmalar **yığın(stack)** veri yapısı kullanılarak iteratif biçime sokulabiliyor ve böylece özyinelemeli algoritma iteratif biçime getirilmiş olur.


### **Kuyruk(queue)** Veri Yapısı 

**Enqueue**: Kuyruğa dahil etmek anlamına gelen bir terimdir.

**Dequeue**: Kuyruktan çıkartmak anlamına gelen bir terimdir.

Ayrıca **deque** adından ayrı bir veri yapısı da vardır, çoğunlukla gerçekleştirim dinamik dizilerin dizisi biçiminde gerçekleştiriliyor, bu soyut veri yapısında baştan ve sondan eklemeler $O(1)$ zaman kamaşıklığındadır, indeks ile erişimde $O(1)$ zaman kamaşıklığındadır.
Bazı durumlarda **deque** soyut veri yapısı **dynamic array** soyut veri yapısına ciddi bir muadil olabiliyor.

Eğer **gerçekleştirimi(implementation)** de kapsıyorsa o zaman ona **veri yapısı(data structure)** deniliyor ama sadece **arayüzü(interface)** tanımına **veri yapısı(data structure)** denilmiyor. </br>
Mesela **kuyruk(queue)** ve **yığın(stack)**, **FIFO(Fist in fist out)** ve **LIFO(Last in first out)** terimleri birer arayüzdür, birer zihinsel modeldir ve o işlemin nasıl yapılacağına dair bir bilgi içermez.

Bir **kuyruk(queue)** soyut veri yapısının farklı farklı yollarla gerçekleştirimi yapılabilir, biz de burada seçeceğimiz bir yöntemle gerçekleştirimini yapacağız.


### Soyut Kuyruk Veri Yapısının Dizi ile Gerçekleştirimi(Abstract Queue Data Structure Implementation with Array) 🌟 

Bu tür gerçekleştirimlerde çoğunlukla ilk önce handle olarak kullanılacak olan yapı türünü oluşturuyoruz, böylece handle sistemnini kullandığımızda birden fazla farklı kuyruk veri yapısı oluşturulabilir durumda olacaktır.


✍️ Burada `queue.h` başlık dosyasını aşağıdaki gibi ekliyoruz, **kuyruk(queue)** veri yapısının gerçekleştiriminde kullanılacak olan başlık dosyasını aşağıdaki gibi yazıyoruz.
```C
#pragma once
// #ifndef QUEUE_H
// #define QUEUE_H

#include <stddef.h> // 'size_t' tür eş adının bildirimini içeren en hafif başlık dosyası eklendi.
#include <stdbool.h> // 'bool', 'true', 'false' gibi object-like makroları kullanabilmek için eklenmiştir.


typedef int DATATYPE;

// Queue  : 'struct tag_queue' yapı türünün eş adı.
// *HQueue: 'struct tag_queue' yapı türünden nesnelerin adresi olan türün eş adı.
typedef struct tag_queue {
    DATATYPE* m_queue;
    size_t m_head; // Push index değeri.
    size_t m_tail; // Pop index değeri.
    size_t m_size; // Kuyrukta tutulmakta olan öğe sayısı değerini tutacak olan yapı üyesi.
    size_t m_cap; // Kuyrukta tutulabilecek en fazla öğe sayısı değerini tutacak olan yapı üyesi.
} Queue, *HQueue;


// Yeni bir kuyruk veri yapısı oluşturan fonksiyon.
HQueue create_queue(size_t cap);

// Kuyruğa 'call by value' yöntemiyle öğe ekleme işlemini yapan fonksiyon.
bool push(HQueue hqueue, DATATYPE val);

// Kuyruğa 'call by reference' yöntemiyle öğe ekleme işlemini yapan fonksiyon.
bool push_p(HQueue hqueue, const DATATYPE* val);

// Kuyruktan silerek öğe çıkartan ve o öğenin bilgisini output argüman(val) ile geriye döndüren fonksiyon.
bool pop(HQueue hqueue, DATATYPE* val);

// Kuyruğun alabileceği öğe sayısını yükseltmek için kullanılan fonksiyon.
bool incrice_capacity(HQueue hqueue, size_t new_cap);

// Kuyruktaki tüm öğeleri silmek için kullanılan fonksiyon.
void clear(HQueue hqueue);

// Kuyruk nesnesini silmek için kullanılan fonksiyon.
void destroy_queue(HQueue hqueue);


// Kuyruğun boş olup olmadığı bilgisini geriye döndüren inline fonksiyon.
static inline bool is_empty(HQueue hqueue)
{
    return hqueue->m_size == 0;
}

// Kuyrukta o anda bulunan öğe sayısı bilgisini geriye döndüren inline fonksiyon.
static inline size_t get_size(HQueue hqueue)
{
    return hqueue->m_size;
}

// Kuyrukta bulunabilecek olan en fazla öğe sayısı bilgisini geriye döndüren inline fonksiyon.
static inline size_t get_capacity(HQueue hqueue)
{
    return hqueue->m_cap;
}


// #endif
```



✍️ Burada `queue.c` kaynak dosyasını aşağıdaki gibi ekliyoruz, **kuyruk(queue)** veri yapısının gerçekleştiriminde kullanılacak olan kaynak dosyayı aşağıdaki gibi yazıyoruz.
```C
#include "queue.h"
#include <stddef.h> // 'size_t' tür eş adının bildirimini içeren en hafif başlık dosyası eklendi.
#include <stdbool.h> // 'bool', 'true', 'false' gibi object-like makroları kullanabilmek için eklenmiştir.


// Yeni bir kuyruk veri yapısı oluşturan fonksiyon. 
HQueue create_queue(size_t cap)
{
    // 'struct tag_queue' veri yapısı nesnesi için bellekten yer ayrılıyor.
    HQueue hqueue = (HQueue)malloc(sizeof(Queue));
    if(!hqueue)
        return NULL;

    // 'struct tag_queue' veri yapısı nesnesinin verileri tutacak olan 'm_queue' pointer üyesine adresi verilcek olan dizi için bellekten yer ayrılıyor.
    if((hqueue->m_queue = (DATATYPE*)malloc(cap * sizeof(DATATYPE))) == NULL) {
        free(hqueue);
        return NULL;
    }

    hqueue->m_cap = cap; // 'struct tag_queue' veri yapısı nesnesinin kapasite değeri atanıyor.
    hqueue->m_size = 0; // 'struct tag_queue' veri yapısı nesnesinin o anki öğe sayısı değeri atanıyor.
    hqueue->m_head = hqueue->m_tail = 0; // 'm_head' ve 'm_tail' değerleri '0' olarka atanıyor.

    return hqueue;
}


// Kuyruğa 'call by value' yöntemiyle öğe ekleme işlemini yapan fonksiyon. 
bool push(HQueue hqueue, DATATYPE val)
{
    // Eğer 'size' değeri 'capacity' değerine eşitse ekleme işlemi yapılamamalıdır.
    // Burada 'capacity' değerinin client-code tarafından bilinçli olarak yapılmasını istediğimiz için 'capacity' değerini gerektiğinde burada arttırmıyoruz.

    if(hqueue->m_size == hqueue->m_cap)
        return false;

    hqueue->m_queue[hqueue->m_tail] = val; // Kuyruğa eklenen öğe, ilgili kuyruğun 'm_queue' dizisinin 'm_tail' değerli indeksine ekleniyor.
    ++hqueue->m_tail; // İlgili kuyruğun 'm_tail' değeri bir arttırılıyor. 
    hqueue->m_tail %= hqueue->m_cap; // Buradaki işlemin nedeni şu, burada yapılan kuyruk gerçekleştiriminde öğeler bir dizide tutulacak biçimde yapıldı ve dizideki öğe sayısı dizinin en fazla alabileceği eleman sayısından fazla olmadığı sürece döngüsel olarak yeni öğe eklenebilir olması istenmesinden kaynaklanmaktadır.
    ++hqueue->m_size; // Ekleme işleminden dolayı kuyruktaki öğe sayısı bir attığı için ilgili kuyruğun 'm_size' değeri bir arttırılıyor.
}


// Kuyruğa 'call by reference' yöntemiyle öğe ekleme işlemini yapan fonksiyon. 
bool push_p(HQueue hqueue, const DATATYPE* val)
{
    // Eğer 'size' değeri 'capacity' değerine eşitse ekleme işlemi yapılamamalıdır.
    // Burada 'capacity' değerinin client-code tarafından bilinçli olarak yapılmasını istediğimiz için 'capacity' değerini gerektiğinde burada arttırmıyoruz.

    if(hqueue->m_size == hqueue->m_cap)
        return false;

    hqueue->m_queue[hqueue->m_tail] = *val; // Kuyruğa eklenen öğe, ilgili kuyruğun 'm_queue' dizisinin 'm_tail' değerli indeksine ekleniyor.
    ++hqueue->m_tail; // İlgili kuyruğun 'm_tail' değeri bir arttırılıyor. 
    hqueue->m_tail %= hqueue->m_cap; // Buradaki işlemin nedeni şu, burada yapılan kuyruk gerçekleştiriminde öğeler bir dizide tutulacak biçimde yapıldı ve dizideki öğe sayısı dizinin en fazla alabileceği eleman sayısından fazla olmadığı sürece döngüsel olarak yeni öğe eklenebilir olması istenmesinden kaynaklanmaktadır.
    ++hqueue->m_size; // Ekleme işleminden dolayı kuyruktaki öğe sayısı bir attığı için ilgili kuyruğun 'm_size' değeri bir arttırılıyor.
}


// Kuyruktan silerek öğe çıkartan ve o öğe bilgisini output argüman(val) ile geriye döndüren fonksiyon. 
bool pop(HQueue hqueue, DATATYPE* val)
{
    if(is_empty(hqueue))
        return false;

    *val = hqueue->m_queue[hqueue->m_head];
    ++hqueue->m_head;
    hqueue->m_head %= hqueue->m_cap;
    --hqueue->m_size;

    return true;
}


// Kuyruğun alabileceği öğe sayısını yükseltmek için kullanılan fonksiyon. 
bool incrice_capacity(HQueue hqueue, size_t new_cap)
{
    if(new_cap <= hqueue->m_cap)
        return false;

    DATATYPE *pnew_queue = (DATATYPE*)malloc(new_cap * sizeof(DATATYPE));
    if(!pnew_queue)
        return false;

    size_t head = hqueue->m_head;

    for(size_t i = 0; i < hqueue->m_cap; ++i) {
        pnew_queue[i] = hqueue->m_queue[head++];
        head %= hqueue->m_cap;
    }

    hqueue->m_head = 0;
    hqueue->m_tail = hqueue->m_size;
    hqueue->m_cap = new_cap;

    free(hqueue->m_queue);
    hqueue->m_queue = pnew_queue;

    return true;
}

// Kuyruktaki tüm öğeleri silmek için kullanılan fonksiyon. 
void clear(HQueue hqueue)
{
    hqueue->m_size = 0;
    hqueue->m_head = 0;
    hqueue->m_tail = 0;
}

// Kuyruk nesnesini silmek için kullanılan fonksiyon. 
void destroy_queue(HQueue hqueue)
{
    free(hqueue->m_queue); // Yapı nesnesindeki tek gösterisi olan yapı üyesinin bellek alanı geri veriliyor.
    free(hqueue); // Yapı nesnesindeki kendisinin bellek alanı geri veriliyor.
}
```


***
==================================================

✦✦✦✦✦ 20.37-20.49 birinci ara verildi. ✦✦✦✦✦

==================================================
***


**Kuyruk(queue)** veri yapısının gerçekleştirimini **dinamic array** veri yapısını kullanarak yaptık, yazdığımız **kuyruk(queue)** veri yapısının nasıl çalıştığını aşağıdan inceleyebiliriz;

**Kuyruk(queue)** veri yapısından yapılan işlemler aşağıdan takip edilebilir;


|  Adım        | Kuyruğun Capacity Değeri  | Kuyruğun Durumu          | Yapılan işlem                                |   Head Göstesici Indeks Değeri    | Tail Göstesici Indeks Değeri   | 
|:------------:|:-------------------------:|:------------------------:|:--------------------------------------------:|:---------------------------------:|:------------------------------:| 
|  1           | 5                         | * * * * *                |  Başlangıç durumu                            | 0                                 | 0                              | 
|  2           | 5                         | 4 * * * *                |  `push(handler, 4)` işlemi sonrası durum     | 0                                 | 1                              | 
|  3           | 5                         | 4 6 * * *                |  `push(handler, 6)` işlemi sonrası durum     | 0                                 | 2                              | 
|  4           | 5                         | * 6 * * *                |  `pop(handler, val)` işlemi sonrası durum    | 1                                 | 2                              | 
|  5           | 5                         | * 6 8 * *                |  `push(handler, 8)` işlemi sonrası durum     | 1                                 | 3                              | 
|  6           | 5                         | * 6 8 2 *                |  `push(handler, 2)` işlemi sonrası durum     | 1                                 | 4                              | 
|  7           | 5                         | * * 8 2 *                |  `pop(handler, val)` işlemi sonrası durum    | 2                                 | 4                              | 
|  8           | 5                         | * * 8 2 1                |  `push(handler, 1)` işlemi sonrası durum     | 2                                 | 0                              | 
|  9           | 5                         | * * * 2 1                |  `pop(handler, val)` işlemi sonrası durum    | 3                                 | 0                              | 
|  10          | 5                         | 5 * * 2 1                |  `push(handler, 5)` işlemi sonrası durum     | 3                                 | 1                              | 
|  11          | 5                         | 5 * * * 1                |  `pop(handler, val)` işlemi sonrası durum    | 4                                 | 1                              | 
|  12          | 5                         | 5 * * * *                |  `pop(handler, val)` işlemi sonrası durum    | 0                                 | 1                              | 



1. Adım: Başlangıç durumu.
    - Capacity: 5
    - `0 1 2 3 4`   --> Indeks değerleri
    - `H _ _ _ _`   --> Head Göstesici
    - `* * * * *`   --> Kuyruktaki verilerin görünümü
    - `T _ _ _ _`   --> Tail Göstesici

2. Adım: `push(handler, 4)` işlemi sonrası durum.
    - Capacity: 5
    - `0 1 2 3 4`   --> Indeks değerleri
    - `H _ _ _ _`   --> Head Göstesici
    - `4 * * * *`   --> Kuyruktaki verilerin görünümü
    - `_ T _ _ _`   --> Tail Göstesici


3. Adım: `push(handler, 6)` işlemi sonrası durum.
    - Capacity: 5
    - `0 1 2 3 4`   --> Indeks değerleri
    - `H _ _ _ _`   --> Head Göstesici
    - `4 6 * * *`   --> Kuyruktaki verilerin görünümü
    - `_ _ T _ _`   --> Tail Göstesici


4. Adım: `pop(handler, val)` işlemi sonrası durum.
    - Capacity: 5
    - `0 1 2 3 4`   --> Indeks değerleri
    - `_ H _ _ _`   --> Head Göstesici
    - `* 6 * * *`   --> Kuyruktaki verilerin görünümü
    - `_ _ T _ _`   --> Tail Göstesici


5. Adım: `push(handler, 8)` işlemi sonrası durum.
    - Capacity: 5
    - `0 1 2 3 4`   --> Indeks değerleri
    - `_ H _ _ _`   --> Head Göstesici
    - `* 6 8 * *`   --> Kuyruktaki verilerin görünümü
    - `_ _ _ T _`   --> Tail Göstesici


6. Adım: `push(handler, 2)` işlemi sonrası durum.
    - Capacity: 5
    - `0 1 2 3 4`   --> Indeks değerleri
    - `_ H _ _ _`   --> Head Göstesici
    - `* 6 8 2 *`   --> Kuyruktaki verilerin görünümü
    - `_ _ _ _ T`   --> Tail Göstesici


7. Adım: `pop(handler, val)` işlemi sonrası durum.
    - Capacity: 5
    - `0 1 2 3 4`   --> Indeks değerleri
    - `_ _ H _ _`   --> Head Göstesici
    - `* * 8 2 *`   --> Kuyruktaki verilerin görünümü
    - `_ _ _ _ T`   --> Tail Göstesici


8. Adım: `push(handler, 1)` işlemi sonrası durum.
    - Capacity: 5
    - `0 1 2 3 4`   --> Indeks değerleri
    - `_ _ H _ _`   --> Head Göstesici
    - `* * 8 2 1`   --> Kuyruktaki verilerin görünümü
    - `T _ _ _ _`   --> Tail Göstesici(Bu adımda koddaki `%` işleminden dolayı Tail göstericisinin indeks değeri "0" oluyor)


9. Adım: `pop(handler, val)` işlemi sonrası durum.
    - Capacity: 5
    - `0 1 2 3 4`   --> Indeks değerleri
    - `_ _ _ H _`   --> Head Göstesici
    - `* * * 2 1`   --> Kuyruktaki verilerin görünümü
    - `T _ _ _ _`   --> Tail Göstesici


10. Adım: `push(handler, 5)` işlemi sonrası durum.
    - Capacity: 5
    - `0 1 2 3 4`   --> Indeks değerleri
    - `_ _ _ H _`   --> Head Göstesici
    - `5 * * 2 1`   --> Kuyruktaki verilerin görünümü
    - `_ T _ _ _`   --> Tail Göstesici


11. Adım: `pop(handler, val)` işlemi sonrası durum.
    - Capacity: 5
    - `0 1 2 3 4`   --> Indeks değerleri
    - `_ _ _ _ H`   --> Head Göstesici
    - `5 * * * 1`   --> Kuyruktaki verilerin görünümü
    - `_ T _ _ _`   --> Tail Göstesici


12. Adım: `pop(handler, val)` işlemi sonrası durum.
    - Capacity: 5
    - `0 1 2 3 4`   --> Indeks değerleri
    - `H _ _ _ _`   --> Head Göstesici(Bu adımda koddaki `%` işleminden dolayı Head göstericisinin indeks değeri "0" oluyor)
    - `5 * * * *`   --> Kuyruktaki verilerin görünümü
    - `_ T _ _ _`   --> Tail Göstesici



👇 Aşağıdaki programda yazdığımız kuyruk modülünü sınama işlemleri için yazılmış olan program incelenebilir.
```C
#include <stdit.h>
#include <stdio.h>
#include "queue.h"


int main(void)
{
    // 'h' adında bir değişkene kuyruk nesnesi atama işlemini yapıyoruz.
    HQueue h = create_queue(10);
    if(h == NULL) {
        frintf(stderr, "cannot create queue.\n");
        return 1;
    }

    // Kuyruk nesnesine yedi elemanına döngü ile ekleniyor.
    for(int i = 0; i < 7; ++i) {
        if(!push(h, i)) {
            fprintf(stderr, "cannot push the value to the queue.\n");
            return 2;
        }

        printf("the value %d pushed.\n", i);
    }

    // Kuyruktan 'pop' işlemiyle eleman siliniyor.
    int val;
    for(int i = 0; i < 5; ++i) {
        pop(h, &val);
        printf("%d poped from the queue.\n", val);
    }

    printf("queue has %zu elements.\n", get_size(h));

    
    // Kuyruk nesnesine altı tane eleman döngü ile ekleniyor.
    for(int i = 0; i < 6; ++i) {
        if(!push(h, i)) {
            fprintf(stderr, "cannot push the value to the queue.\n");
            return 2;
        }

        printf("the value %d pushed.\n", i);
    }


    (void)getchar(); // Process burada durdurulacak.
}
```


Yukarıda soyut kuyruk veri yapısını **dynamic array** kullanarak gerçekleştirdik ama bağlı listeyle de gerçekleştirme yapabiliriz, </br>
bağlı listeyle gerçekleştirmek hem daha kolay hem de daha çok tercih edilen bir yöntemdir.


### Soyut Kuyruk Veri Yapısının Bağlı Liste ile Gerçekleştirimi(Abstract Queue Data Structure Implementation with Linked List) 🌟 

✍️ Burada `queue.h` başlık dosyasını aşağıdaki gibi ekliyoruz, **kuyruk(queue)** veri yapısının gerçekleştiriminde kullanılacak olan başlık dosyasını aşağıdaki gibi yazıyoruz.
```C
#pragma once
// #ifndef QUEUE_H
// #define QUEUE_H

#include <stddef.h> // 'size_t' tür eş adının bildirimini içeren en hafif başlık dosyası eklendi.
#include <stdbool.h> // 'bool', 'true', 'false' gibi object-like makroları kullanabilmek için eklenmiştir.


typedef int DATATYPE; // Düğümde tutulacak olan tür.


typedef struct NODE {
    DATATYPE mval;
    struct NODE* mpnext;
} NODE;


// Queue  : 'struct tag_queue' yapı türünün eş adı.
// *HQueue: 'struct tag_queue' yapı türünden nesnelerin adresi olan türün eş adı.
typedef struct tag_queue {
    NODE* mphead; // Kuyruk veri yapısının ilk düğümünün adres bilgisini tutan yapı üyesi.
    NODE* mptail; // Kuyruk veri yapısının son düğümünün adres bilgisini tutan yapı üyesi.
    size_t msize; // Kuyruk veri yapısının eleman sayısını tutan yapı üyesi.
} Queue, *HQueue;


// Yeni bir kuyruk veri yapısı oluşturan fonksiyon.
HQueue create_queue(void);

// Kuyruk nesnesini silmek için kullanılan fonksiyon.
void destroy_queue(HQueue);

// Kuyruğa 'call by value' yöntemiyle öğe ekleme işlemini yapan fonksiyon.
bool push(HQueue h, DATATYPE val);

// Kuyruğa 'call by reference' yöntemiyle öğe ekleme işlemini yapan fonksiyon.
bool push_p(HQueue h, const DATATYPE* val);

// Kuyruktan silerek öğe çıkartan ve o öğenin bilgisini output argüman(val) ile geriye döndüren fonksiyon.
bool pop(HQueue h, DATATYPE* val);

// Kuyruktaki tüm öğeleri silmek için kullanılan fonksiyon.
void clear(HQueue h);


// Kuyruğun boş olup olmadığı bilgisini geriye döndüren inline fonksiyon. 
static inline bool is_empty(HQueue h)
{
    return h->m_size == 0;
}

// Kuyrukta o anda bulunan öğe sayısı bilgisini geriye döndüren inline fonksiyon.  
static inline size_t get_size(HQueue h)
{
    return h->m_size;
}


// #endif
```



✍️ Burada `queue.c` kaynak dosyasını aşağıdaki gibi ekliyoruz, **kuyruk(queue)** veri yapısının gerçekleştiriminde kullanılacak olan kaynak dosyayı aşağıdaki gibi yazıyoruz.
```C
#include "queue.h"
#include <stdlib.h>
#include <stdio.h> 


// Yeni bir kuyruk veri yapısı oluşturan fonksiyon. 
HQueue create_queue(void)
{
    // 'struct tag_queue' veri yapısı nesnesi için bellekten yer ayrılıyor.
    HQueue h = (HQueue)malloc(sizeof(Queue));
    if(!h)
        return NULL;

    h->mphead = h->mptail = NULL;
    h->msize = 0;

    return h;
}


// Kuyruğa 'call by value' yöntemiyle öğe ekleme işlemini yapan fonksiyon. 
bool push(HQueue h, DATATYPE val)
{
    // Yeni bir düğüm oluşturuyoruz.
    NODE* pnewnode = (NODE*)malloc(sizeof(NODE));
    if(!pnewnode)
        return false;

    // Yeni oluşturulan düğümün üyelerinin değerlerini atıyoruz.
    pnewnode->mval = val;
    pnewnode->mpnext = NULL; // Yeni eklenen düğüm son düğüm olacağı için bu düğümün 'mpnext' göstericisinin değeri 'NULL' yapılıyor.
     
    if(h->mptail)
        h->mptail->mpnext = pnewnode; // Kuyruk nesnesinin 'mptail' nesnesi mevcutsa, bu nesne artık sondan bir önceki düğüm olacağı için kendinden sonraki düğüm yeni oluşturulan düğüm yapılıyor.
    else
        h->mphead = pnewnode; // Kuyruk nesnesinin 'mptail' nesnesi 'NULL' ise kuyruk nesnesinin 'mphead' nesnesi de boş demektir ve yeni düğüm kuyruk nesnesinin 'mphead' nesnesi yapılıyor.

    h->mptail = pnewnode; // Yeni eklenen düğüm son düğüm olması gerektiği için gerekli atama işlemi yapılıyor.
    ++h->msize; // Kuyruk nesnesinin eleman sayısı bir arttırılıyor.
    
    return true;
}


// Kuyruğa 'call by reference' yöntemiyle öğe ekleme işlemini yapan fonksiyon. 
bool push_p(HQueue h, const DATATYPE* val)
{
    // Yeni bir düğüm oluşturuyoruz.
    NODE* pnewnode = (NODE*)malloc(sizeof(NODE));
    if(!pnewnode)
        return false;

    // Yeni oluşturulan düğümün üyelerinin değerlerini atıyoruz.
    pnewnode->mval = *val;
    pnewnode->mpnext = NULL; // Yeni eklenen düğüm son düğüm olacağı için bu düğümün 'mpnext' göstericisinin değeri 'NULL' yapılıyor.

    if(h->mptail)
        h->mptail->mpnext = pnewnode; // Kuyruk nesnesinin 'mptail' nesnesi mevcutsa, bu nesne artık sondan bir önceki düğüm olacağı için kendinden sonraki düğüm yeni oluşturulan düğüm yapılıyor.
    else
        h->mphead = pnewnode; // Kuyruk nesnesinin 'mptail' nesnesi 'NULL' ise kuyruk nesnesinin 'mphead' nesnesi de boş demektir ve yeni düğüm kuyruk nesnesinin 'mphead' nesnesi yapılıyor.

    h->mptail = pnewnode; // Yeni eklenen düğüm son düğüm olması gerektiği için gerekli atama işlemi yapılıyor.
    ++h->msize; // Kuyruk nesnesinin eleman sayısı bir arttırılıyor.
    
    return true;
}


// Kuyruktan silerek öğe çıkartan ve o öğe bilgisini output argüman(val) ile geriye döndüren fonksiyon. 
bool pop(HQueue h, DATATYPE* val)
{
    // Gönderilen kuyruk listesi boşsa ve çıkartılabilecek bir düğüm yoksa geriye false döndürülecek.
    if(!h->mphead)
        return false;
    
    NODE* node = h->mphead; // serbest bırakmak için ilk düğümün adresi düğüm türünden bir pointer değişkene alınıyor.
    *val = node->mval; // Çağıran kodun fonksiyona geçtiği adrese kuyruktan çıkartılacak olan düğümün taşıdığı değer atanıyor.

    // Eğer ilk düğümden bir sonraki düğüm 'NULL' pointer ise kuyruk nesnesinin 'mptail' pointer'ı 'NULL' pointer yapılıyor.
    if(!node->mpnext) // 'if(h->msize == 1)' olarak ta yazılabilir.
        h->mptail = NULL;

    h->mphead = node->mpnext; // Kuyruk nesnesinin ilk düğümü siliineceği için ilk düğüm silinecek düğümden sonraki düğüm olacak biçimde ayarlanıyor.
    --h->msize; // İşlem yapılan kuyruk nesnesindeki düğüm sayısı değeri bir azaltılıyor.
    
    free(node); // Kuyruk nesnesinden silinen düğümün bellek alanı iade ediliyor.

    return true;
}


// Kaynak dosya dışından çağrılamayan ve tüm düğümleri silmek için kullanılacak olan fonksiyon. 
static void free_all_nodes(HQueue h)
{
    NODE* pnode = h->mphead; // Kuyruk nesnesinin ilk düğümünün adresi bir pointer değişkene atanıyor.

    // Kuyruk nesnesindeki tüm düğümleri gezecek olan döngü.
    while(pnode) { // 'pnode' pointer'ının değeri 'NULL' olana kadar döngü dönecek.
        NODE* ptemp = pnode; // İlgili düğümün bellek bloğunun iade edilmesi için ilgili düğüm başka bir pointer değişkene alınıyor.
        pnode = pnode->mpnext; // 'pnode' düğümünden bir sonraki düğümün adresi 'pnode' göstericisine alınıyor.
        free(ptemp); // İlgili düğümün bellek bloğu iade ediliyor.
    }
}


// Kuyruktaki tüm düğümleri silmek için kullanılan fonksiyon. 
void clear(HQueue h)
{
    free_all_nodes(h); // Kuyruk nesnesindeki tüm düğümlerin bellek alanları iade ediliyor.
    
    // İlgili kuyruk nesnesinin boşaltılması için kuyruk nesnesinin üyelerinin değerleri ayarlanıyor.
    h->mphead = NULL;
    h->mptail = NULL;
    h->msize = 0;
}

// Kuyruk nesnesini silmek için kullanılan fonksiyon. 
void destroy_queue(HQueue h)
{
    free_all_nodes(h); // Kuyruk nesnesindeki tüm düğümlerin bellek alanları iade ediliyor.
    free(h); // Yapı nesnesindeki kendisinin bellek alanı geri veriliyor.
}

```



👇 Aşağıdaki programda yazdığımız kuyruk modülünü sınama işlemleri için yazılmış olan program incelenebilir.
```C
#include <stdit.h>
#include <stdio.h>
#include "queue.h"


int main(void)
{
    // 'h' adında bir değişkene kuyruk nesnesi atama işlemini yapıyoruz.
    HQueue h = create_queue();

    // Kuyruk nesnesine on tane düğüm döngü ile ekleniyor.
    for(int i = 0; i < 10; ++i) {
        push(h, i);
        printf("%d pushed!\n", i);
    }

    printf("size = %zu\n", get_size(h));
    
    int val;

    while(!ia_empty(h)) {
        pop(h, &val);
        printf("%d poped!\n", val);
        (void)getchar(); // Burada process'in akışı kullanıcı bir tuşa bazıncaya kadar bekletilecek.
    }
}
```


### Soyut Yığın Veri Yapısının Dizi ile Gerçekleştirimi(Abstract Stack Data Structure Implementation with Array) 🌟 

**FIFO(Fisr In First Out)** mekanizması **Queue** veri yapısında kullanılmaktadır. </br>
**LIFO(Last In First Out)** mekanizması **Stack** veri yapısında kullanılmaktadır.



Mülakatlarda veri yapılarıyla ilgili olarak sık sorulan bir soru aşağıdaki gibidir. </br> 
**Parantez uyumu(Brackets match)** algoritmasıyla ilgili olarak verilen bir metindeki `()`,`[]`,`{}`,`<>` parantezlerinin doğru olarak açılıp kapatıldığının sınamasını yapan programı yazınız? </br>
`<([5] - [3])> {{[<c> <f>]}}` girdisi için doğru sonucu dönülmeli, buradaki sınamayı yapacak olan fonksiyonu sen uğraşarak yazmalısın.


***
==================================================

✦✦✦✦✦ 21.45-22.00 ikinci ara verildi. ✦✦✦✦✦

==================================================
***


**Yığın(stack)** soyut veri yapısının gerçekleştirimi oldukça kolaydır.



✍️ Burada `stack.h` başlık dosyasını aşağıdaki gibi ekliyoruz, **yığın(stack)** veri yapısının gerçekleştiriminde kullanılacak olan başlık dosyasını aşağıdaki gibi yazıyoruz.
```C
#pragma once
// #ifndef QUEUE_H
// #define QUEUE_H

#include <stddef.h> // 'size_t' tür eş adının bildirimini içeren en hafif başlık dosyası eklendi.
#include <stdbool.h> // 'bool', 'true', 'false' gibi object-like makroları kullanabilmek için eklenmiştir.

typedef int DATATYPE;

// STACK  : 'struct tag_stack' yapı türünün eş adı.
// *HSTACK: 'struct tag_stack' yapı türünden nesnelerin adresi olan türün eş adı.
typedef struct tag_stack {
    DATATYPE* mpstack; // Burada yığına eklenecek olan öğeleri tutmak için dizi veri yapısı kullanılacak.
    size_t mcap;
    size_t msize;
} STACK, *HSTACK;


HSTACK create_stack(size_t cap);

void destroy_stack(HSTACK);

bool push(HSTACK, DATATYPE);

bool push_p(HSTACK, const DATATYPE*);

bool top(HSTACK, DATATYPE*);

bool pop(HSTACK, DATATYPE*);

void clear(HSTACK);

static inline size_t get_size(HSTACK h)
{
    return h->msize;
}

static inline size_t is_empty(HSTACK h)
{
    return h->msize;
}

// #endif
```



✍️ Burada `stack.c` kaynak dosyasını aşağıdaki gibi ekliyoruz, **yığın(stack)** veri yapısının gerçekleştiriminde kullanılacak olan kaynak dosyayı aşağıdaki gibi yazıyoruz.
```C
#include "stack.h"


// Yığına nesnesi oluşturmak için kullanılan fonksiyon. 
HSTACK create_stack(size_t cap)
{
    HSTACK h = (HSTACK) malloc(sizeof(HSTACK)); // Yığın nesnesi için bellekten yer ayrılıyor.
    if(!h)
        return NULL;

    h->mpstack = (DATATYPE*)malloc(cap * sizeof(DATATYPE));  // Yığın nesnesinin tutacağı verinin tutulabilmesi için bellekten yer ayrılıyor.
    if(!h->mpstack) {
        free(h);
        return NULL;
    }

    h->mcap = cap; // Yığının tutakileceği en fazla değer ilgili yığın nesnesine atanıyor.
    h->msize = 0; // İlk başta yığında tutulan öğe olmayacağı için '0' olarak veriliyor.
}


// Yığın nesnelerinin bellekten silinmesi için kullanılan fonksiyon. 
void destroy_stack(HSTACK h)
{
    free(h->mpstack);
    free(h);
}


// Yığına yeni öğe eklemek için kullanılan fonksiyon. 
bool push(HSTACK h, DATATYPE val)
{
    if(h->msize == h->mcap) {
        return false;
    }

    h->mpstack[h->msize] = val; // İlgili değer yığına ekleniyor.
    ++h->msize; // Yığındaki öğe sayısını tutan değer bir arttırılıyor.

    return true;
}


// Yığına yeni öğe eklemek için kullanılan fonksiyon. 
bool push_q(HSTACK h, const DATATYPE* val)
{
    if(h->msize == h->mcap) {
        return false;
    }

    h->mpstack[h->msize] = *val; // İlgili değer yığına ekleniyor.
    ++h->msize; // Yığındaki öğe sayısını tutan değer bir arttırılıyor.

    return true;
}


// Yığının en tepesindeki değeri ilgili değeri yığından çıkarmadan ilgili değeri döndürmek için kullanılan fonksiyon. .
bool top(HSTACK h, DATATYPE* val)
{
    // Eğer yığın boşsa başarısın geriye dönülecek.
    if(is_empty(h))
        return false;

    *val = h->mpstack[h->msize - 1]; // Yığının en tepesindeki değerin ne olduğunu geriye döndürebilmek için yapılan işlem.

    return true;
}


// Yığının en tepesindeki değeri ilgili değeri yığından çıkararak ilgili değeri döndürmek için kullanılan fonksiyon. .
bool pop(HSTACK h, DATATYPE* val)
{
    // Eğer yığın boşsa başarısın geriye dönülecek.
    if(is_empty(h))
        return false;

    *val = h->mpstack[--h->msize]; // Yığının en tepesindeki değerin ne olduğunu geriye döndürebilmek için yapılan işlem.

    return true;
}


// Yığını boşaltmak için kullanılan fonksiyon. 
void clear(HSTACK h)
{
    h->msize = 0; // Yığın nesnesinin 'msize' üyesinin değeri '0' yapılarak yığın nesnsi boşaltılmış oluyor.
}

```


### Soyut Yığın Veri Yapısının Bağlı Liste ile Gerçekleştirimi(Abstract Stack Data Structure Implementation with Linked List) 🌟


✍️ Burada `stack.h` başlık dosyasını aşağıdaki gibi ekliyoruz, **yığın(stack)** veri yapısının gerçekleştiriminde kullanılacak olan başlık dosyasını aşağıdaki gibi yazıyoruz.
```C
#pragma once
// #ifndef QUEUE_H
// #define QUEUE_H

#include <stddef.h> // 'size_t' tür eş adının bildirimini içeren en hafif başlık dosyası eklendi.
#include <stdbool.h> // 'bool', 'true', 'false' gibi object-like makroları kullanabilmek için eklenmiştir.

typedef int DATATYPE;

// Düğüm verisini tutacak olan yapı türünün tanımı.
typedef struct tag_note {
    DATATYPE mval;
    struct tag_note* mpnext;
} NODE;


// STACK  : 'struct tag_stack' yapı türünün eş adı.
// *HSTACK: 'struct tag_stack' yapı türünden nesnelerin adresi olan türün eş adı.
typedef struct tag_stack {
    NODE* mphead; // Yığının en tepesindeki düğümün adresini tutacak olan yapı üyesi.
    size_t msize; 
} STACK, *HSTACK;


HSTACK create_stack(size_t cap);

void destroy_stack(HSTACK);

bool push(HSTACK, DATATYPE);

bool push_p(HSTACK, const DATATYPE*);

bool top(HSTACK, DATATYPE*);

bool pop(HSTACK, DATATYPE*);

void clear(HSTACK);

static inline size_t get_size(HSTACK h)
{
    return h->msize;
}

static inline size_t is_empty(HSTACK h)
{
    return h->msize;
}

// #endif
```



✍️ Burada `stack.c` kaynak dosyasını aşağıdaki gibi ekliyoruz, **yığın(stack)** veri yapısının gerçekleştiriminde kullanılacak olan kaynak dosyayı aşağıdaki gibi yazıyoruz.
```C
#include "stack.h"


// Yığına nesnesi oluşturmak için kullanılan fonksiyon. 
HSTACK create_stack(size_t cap)
{
    HSTACK h = (HSTACK) malloc(sizeof(HSTACK)); // Yığın nesnesi için bellekten yer ayrılıyor.
    if(!h)
        return NULL;

    h->mphead = NULL; // İlk başta yığında boş olacağı için 'mphead' değeri 'NULL' veriliyor.
    h->msize = 0; // İlk başta yığında tutulan öğe olmayacağı için '0' olarak veriliyor.

    return h;
}


// Yığındaki tüm düğümleri temizleyen fonkisyon. 
static free_all_nodes(HSTACK h)
{
    NODE* pnode = h->mphead;

    while(pnode) {
        NODE* ptemp = pnode;
        pnode = pnode->mpnext;
        free(ptemp);
    }
}


// Yığın nesnelerinin bellekten silinmesi için kullanılan fonksiyon. 
void destroy_stack(HSTACK h)
{
    free_all_nodes(h);
    free(h);
}


// Yığına yeni düğüm eklemek için kullanılan fonksiyon. 
bool push(HSTACK h, DATATYPE val)
{
    NODE* pnewnode = (NODE*)malloc(sizeof(NODE));
    if(!pnewnode)
        return false;

    pnewnode->mval = val;
    pnewnode->mpnext = h->mphead;
    h->mphead = pnewnode;
    ++h->msize;

    return true;
}


// Yığına yeni düğüm eklemek için kullanılan fonksiyon. 
bool push_p(HSTACK h, DATATYPE* val)
{
    NODE* pnewnode = (NODE*)malloc(sizeof(NODE));
    if(!pnewnode)
        return false;

    pnewnode->mval = *val;
    pnewnode->mpnext = h->mphead;
    h->mphead = pnewnode;
    ++h->msize;

    return true;
}


// Yığının en tepesindeki düğümü ilgili düğümü yığından çıkarmadan düğümün değerini döndürmek için kullanılan fonksiyon. .
bool top(HSTACK h, DATATYPE* val)
{
    // Eğer yığın boşsa başarısın geriye dönülecek.
    if(is_empty(h))
        return false;

    *val = h->mphead->mval; // Yığının en tepesindeki değerin ne olduğunu geriye döndürebilmek için yapılan işlem.

    return true;
}


// Yığının en tepesindeki düğümü ilgili düğümü yığından çıkararak düğümün değerini döndürmek için kullanılan fonksiyon. .
bool pop(HSTACK h, DATATYPE* val)
{
    // Eğer yığın boşsa başarısın geriye dönülecek.
    if(is_empty(h))
        return false;

    *val = h->mphead->mval; // Yığının en tepesindeki değerin ne olduğunu geriye döndürebilmek için yapılan işlem.

    // Yığın nesnesinden ilk düğümü siliyoruz.
    NODE* ptemp = h->mphead;
    h->mphead = h->mphead->mpnext; // Yapı nesnesinin ilk düğümü eski ilk düğümden bir sonraki düğüm yapılıyor.
    free(ptemp); // Silinen düğümün bellek alanı iade ediliyor.

    return true;
}


// Yığını boşaltmak için kullanılan fonksiyon. 
void clear(HSTACK h)
{
    free_all_nodes(h);
    h->mphead = NULL;
    h->msize = 0;
}

```


Ders sonu ...
