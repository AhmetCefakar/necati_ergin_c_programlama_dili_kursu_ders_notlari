# 58.Ek Ders
---


## Type Qualifiers (Tür Niteleyicileri)

`const`, `volatile`, `restrict` anahtar sözcükleri niteledikleri türlerin davranışını değiştirmek için kullanılır. `restrict` anahtar sözcüğü dile C99 standardı ile eklenmiştir.


### `volatile` Anahtar Sözcüğü

Bir nesne `volatile` olarak bildirildiğinde o nesnenin program dışındaki kaynaklar tarafından değiştirilebileceği bilgisini derleyiciye ve kodu okuyacak kişiye belirtmiş oluyoruz.

**Memory map input output** biçiminde bir kavram var, özellikle sistem programlama veya gömülü sistem programlama tarafında kullanılan cihazların donanımların **yazmaçları(register)** var bunlar bellekte bazı adreslere eşlenmiş(mapping) durumda yani cihazla ilgili bir durum değişikliği olduğunda bellekte bilinen bir adrese veri aktarılıyor ve o adresteki veriye gösterici bir değişken vasıtası ile erişilebiliyor, yani elde bir adres var(bu adresler çoğunlukla object-like mokrolarla temsil ediliyor)

👇 Aşağıdaki kod parçasında bir yazmaşla ilişkilendirilmiş bellek adresinin nasıl kullanılabileceğine dair yüzeyel fikir edinilebilir.
```C
ADR_REG     (int*)0x1CAF; // Donanımda özel bir anlamı olan, bazı yazmaçlarla bağlanmış adres değeri 'ADR_REG' adındaki bir object-like makro ile temsilediliyor.

int* p = ADR_REG; // Burada özel işlemler için kullanılan adres değeri bir gösterici değişkene alınıyor sonrasında başka işlemlerde kullanılabilir.
```


🚀 Mesela bir **kesmeler(interrupt)** de program dışı kaynaklar vasıtasıyla değişkenlerin değiştirilebildiği durumlar olabilir, programda bir değişken var ve program dışından yazılımsal ya da donanımsal olarak bir kesme geliyor ve bu değişkenin değerini değiştirebildiği durumlar olabilir, bu durumu derleyicinin tespit etme imkanı yoktur.

🚀 Mesela bir **ileti(signal)** , bir programda bir global değişken olsun bu değişkenin değeri program dışı bir kaynaktan gelen **iletiler(signal)** ile değiştirebilen, bu durumu derleyicinin tespit etme imkanı yoktur.


❗❗❗ Derleyiciler yazılmış programlardan oluşturulacak olan makine ve sistem kodlarında yapacakları **iyileştirmeleri(optimization)** sadece programın kaynak dosyalarındaki kodlara bakarak yapmaktadır, bir programdaki bazı **nesnelerin(object)**  değerleri program dışından değiştirilebiliyorsa derleyici bunu doğrudan bilemez, bu gibi durumlarda bunu derleyiciye ilgili **nesneleri(object)** `volatile` olarak bildirerek belirtmek gerekecektir.


👇 Aşağıdaki programdan `volatile` bildiriminin kullanılışı incelenebilir.
```C

int g = 10;

int main(void)
{
    // Aşağıdaki iki değişken bildirimi de aynı anlama gelmektedir.
    int volatile x = 10;
    // volatile int x = 10;


    int* volatile ptr1 = &g; // Buradaki 'ptr1' gösterici değişkeni 'volatile pointer to int' olarak nitelendirilmektedir. Burada 'ptr1' gösterici değişkeninin tuttuğu adres değerinin program dışı kaynaklarca değiştirilebileceği belirtilmektedir.

    // Aşağıdaki 'ptr2' ve 'ptr3' göstericileri aynı işleve sahiptir.
    volatile int* ptr2 = &g; // Buradaki 'ptr2' gösterici değişkeni 'pointer to volatile int' olarak nitelendirilmektedir. Burada 'ptr2' gösterici değişkeninin gösterdiği adresteki nesnenin değerinin program dışı kaynaklarca değiştirilebileceği belirtilmektedir.
    int volatile * ptr3 = &g; // Buradaki 'ptr3' gösterici değişkeni 'pointer to volatile int' olarak nitelendirilmektedir. Burada 'ptr3' gösterici değişkeninin gösterdiği adresteki nesnenin değerinin program dışı kaynaklarca değiştirilebileceği belirtilmektedir.

    // Aşağıdaki 'ptr4' ve 'ptr5' göstericileri aynı işleve sahiptir.
    volatile int* volatile ptr4 = &g; // Buradaki 'ptr4' gösterici değişkeni 'volatile pointer to volatile int' olarak nitelendirilmektedir. Hem 'ptr4' göstericisinin gösterdiği adres değeri hem de göstericinin gösterdiği o adresteki nesnenin değerinin program dışı kaynaklar tarafından değiştirilebileceği belirtilmektedir.
    int volatile * volatile ptr5 = &g; // Buradaki 'ptr5' gösterici değişkeni 'volatile pointer to volatile int' olarak nitelendirilmektedir. Hem 'ptr5' göstericisinin gösterdiği adres değeri hem de göstericinin gösterdiği o adresteki nesnenin değerinin program dışı kaynaklar tarafından değiştirilebileceği belirtilmektedir.
}
```


👇 Aşağıda bir kod parçasındaki değişkenlerin program dışı kaynaklar tarafından değiştirilebileceği bildirilmediğinde nasıl assembly kodu üretilebileceği incelenebilir.
```Text

// Aşağıdaki gibi bir kod parçasının iyileştirme yapılarak nasıl bir assembly kodu üretilebileceği aşağıda görülebilir.
int a;
// some code here ...
int x = a + 10;
int y = a + 20;

// Yukarıdaki iki satır kod aşağıdaki gibi assembly koduna çevrilebilir.
mov reg1, a
mov reg2, 10
add reg2, reg1
mov x, reg2
add reg1, 20
mov y, reg1
```



👇 Aşağıda bir kod parçasındaki değişkenlerin program dışı kaynaklar tarafından değiştirilebileceği bildirildiğinde nasıl assembly kodu üretilebileceği incelenebilir.
```Text

// Aşağıdaki gibi bir kod parçasının iyileştirme yapılarak nasıl bir assembly kodu üretilebileceği aşağıda görülebilir.
volatile int a;
// some code here ...
int x = a + 10;
int y = a + 20;

// Yukarıdaki iki satır kod aşağıdaki gibi assembly koduna çevrilebilir.
mov reg1, a
mov reg2, 10
add reg2, reg1
mov x, reg2
#    ----> Burada 'a' değişkeni program dışından değiştirililebilir.
mov reg1, a
add reg1, 20
mov y, reg1
```



👇 Aşağıdaki program parçasında program dışı bir kaynak tarafından değiştirilebilir olan bir değişkene göre bir döngünün devam edip etmmesine karar verildiği kod incelenebilir.
```C
volatile int flag = 1; // Özellikle gömülü sistem programlama tarafında eksik bilgiye sahip olan kişiler buradaki 'flag' değişkeni program dışından değiştirilebilir olsa bile, bu değişkeni 'volatile' olarak bildirmeyi düşünemeyebiliyormuş!

int main(void)
{
    while(flag){ // Bu döngünün her adımına başlamadan önce 'flag' değişkeninin değerine bakılacak biçimde makine kodu üretilecektir.
        // some code here ...
    }

}
```



👇 Aşağıdaki program `volatile` bildiriminin kullanımı incelenebilir.
```C
#include <stdio.h>
#include <signal.h> // 'signal' fonksiyonunu kullanabilmek için eklendi.
#include <Windows.h> // 'Sleep' fonksiyonunu kullanabilmek için eklendi.

volatile int keep_running = 1;

void handle_sigint(int sig);

int main(void)
{
    signal(SIGINT, handle_sigint);  // Handle Ctrl+C (SIGINT)
    while (keep_running) {          // Always check `keep_running`'s latest value
        printf("Running...\n");
        Sleep(1000);
    }
    printf("Exited safely!\n");
}

void handle_sigint(int sig)
{
    keep_running = 0;  // Signal handler changes `keep_running`
}
```



👇 Aşağıdaki program `volatile` ve `const` türlerdeki tür dönüşümlerinin yapılışı incelenebilir.
```C
#include <stdio.h>
#include <signal.h>
#include <Windows.h>


int main(void)
{
    const int x1 = 10;
    int* p1 = &x1; // Bu kod geçerli değildir çünkü 'const int' türünden bir değişkenin adresi 'int*' türünden bir göstericiye atanıyor, tür uyuşmazlığı var, C dili buna izin verir ama kullanımı doğru değildir.
    int* p2 = (int*)&x1; // Bu kod geçerlidir, açık olarak tür dönüşümü yapıldığı için.


    volatile int x2 = 21;
    int* p3 = &x2; // Geçersiz kod.
    volatile int* p4 = &x2; // Geçerli kod.
    int* p5 = (int*)&x2; // Geçerli kod.
}
```



👇 Aşağıdaki programda `volatile` anahtar sözcüğü derleyicinin yapacağı iyileştirmeleri engellemek için de kullanılabildiği görülebilir.
```C
#include <stdio.h>
#include <time.h>

int main(void)
{
    // Alttaki kodda derleyici 'd' değişkeninin değerini sadece tek bir defa bellekten çekmektedir, bu da derleyicinin iyileştirme yaptıdığı anlamına gelmektedir.
    clock_t t = clock();
    double d = 0.0;
    for (int n = 0; n < 10000; ++n)
        for (int m = 0; m < 10000; ++m)
            d += d * n * m; // reads from and writes to a non-volatile
    printf("Modified a non-volatile variable 100m times. "
           "Time used: %.2f seconds\n",
           (double)(clock() - t) / CLOCKS_PER_SEC);

    // Alttaki kodda derleyici 'vd' değişkeninin değerini her adımda bellekten okuyacaktır, bu da derleyicinin iyileştirme yapmadığı anlamına gelmektedir.
    t = clock();
    volatile double vd = 0.0;
    for (int n = 0; n < 10000; ++n)
        for (int m = 0; m < 10000; ++m) {
            double prod = vd * n * m; // reads from a volatile
            vd += prod;               // reads from and writes to a volatile
        }
    printf("Modified a volatile variable 100m times. "
           "Time used: %.2f seconds\n",
           (double)(clock() - t) / CLOCKS_PER_SEC);
}
```



👇 Aşağıdaki programda bir değişkenin aynı zamanda hem `const` hem de `volatile` olarak bildirilebileceği incelenebilir. Bir değişkenin`const` olması program içinden değiştirilemeyeceğini belirtirken `volatile` o değişkenin değerinin program dışındaki kaynaklar tarafından değiştirilebileceği anlamına gelmektedir.
```C
#include <stdio.h>
#include <time.h>

int g = 101;

int main(void)
{
    const volatile int x = 101;

    const int* volatile p = &g;
}
```


### `restrict` Anahtar Sözcüğü 

`restrict` anahtar sözcüğü yalnızca gösterici değişkenleri niteleyebilir(sadece **top-lavel** olarak kullanılabilir), bunun dışında kullanılması sözdizim hatasıdır. `restrict` sözcüğü dile C99 standardıyla birlikte eklenmiştir. </br>
`restrict` anahtar sözcüğüyle bildirilmiş bir değişken derleyiciye ve okuyucuya ilgili blokta ilgili değişkeni gösteren tek göstericinin olduğunu o göstericinin de `restrict` olarak bildirilen ilgili değişken olduğu anlamına gelmektedir.


👇 Aşağıdaki kod parçasında `restrict` kullanımı incelnebilir.
```C
#include <stdio.h>
#include <time.h>

// Aşağıdaki fonksiyon parametresi olan parametrelerin 'restrict' olmaları derleyicinin daha rahat iyileştirme yapabilmesini sağlayacaktır.
void foo(int* restrict p1, int* restrict p2)
{

}
```


**Pointer aliasing**: Birden fazla farklı gösterici değişkenlerin aynı nesneyi gösterdiği durumları belirtmek için kullanılan bir terimdir.



👇 Aşağıdaki programda **pointer aliasing** durumundan dolayı derleyicinin aynı gösterici ile dereferencing işleminin tek değil iki ayrı makine kodu ile aynı değeri iki defa bellekten çekeceği görülmelidir.
```C
#include <stdio.h>
#include <time.h>

double g = 1;

void func(int* p1, int* p2, const int* p)
{
    // Derleyici iki defa '*p' işlemini yapacaktır, çünkü 'p' göstericisinin gösterdiği adresteki değer balka yerlerden değiştirilebilir.
    *p1 += *p;
    *p2 += *p;
}
```



👇 Aşağıdaki programda `restrict` bildirilen parametrelerin derleyicinin üreteceği makine kodlarını etkileyecetir.
```C
#include <stdio.h>
#include <time.h>

double g = 1;

void func(int* restrict p1, int* restrict p2, const int* restrict p)
{
    // Derleyici bir defa '*p' işlemini yapacaktır, çünkü 'p' göstericisinin gösterdiği adresteki değer sadece bu fonksiyonun kapsamı içinde değiştirilebilir olarak 'restrict' anahtar sözcüğüyle bildirilmiştir.
    *p1 += *p;
    *p2 += *p;
}
```


❗❗❗ `restrict` anahtar sözcüğü kullanıldığında **ub** oluşmamasının sağlanması kodu yazan programcıya aittir, `restrict` bildirilen iki farklı göstericinin aynı nesneyi göstermemesi programcının sorumluluğundadır, yoksa **ub** durumu oluşur.



❗❗❗ C++ dilinde `restrict` anahtar sözcüğü yoktur çünkü bu anahtar sözcük C++ dilinin bünyesine uygun olmamasından dolayıdır ama derleyiciler bu anahtar sözcüğün işlevselliğine benzer **extension**'lar sağlamaktadır.


📌 `strcpy` ve `strcpy_s` fonksiyonlarının parametreleri C99 standardından sonra `restrict` yapılmıştır bu nedenle bu fonksiyonlara gönderile dizilerin kesişiminin olmaması gerekiyor yoksa **ub** durumu oluşur.


***
==================================================

✦✦✦✦✦ 20.30-20.40 birinci ara verildi. ✦✦✦✦✦

==================================================
***


## C99 Standardıyla Dile Eklenen Özellikler

Bazı derslerde C99 ile dile gelen yenilikleri yözeysel olarak inceledik ama derinlemesine incelememiştik burada derinlemesine inceleyeceğiz.


### VLA(Variable Length Array) 

**VLA** özelliği yani Değişken boyutlu diziler ile tanımlanan dizilerin eleman sayısını belirten ifadeleri sabit ifadesi olmak zorunda değildir, **VLA** özelliği dile C99 ile eklenmiş ve C11 ile özelliğin sağlanıp sağlanmama tercihi derleyicilere bırakılmıştır.

Microsoft derleyicisi **VLA** özelliğine destek vermemektedir.



👇 Aşağıdaki programda **VLA** kullanımı incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 7;

    int ary1[x]; // VLA desteği varsa legal bir 'defination statement'.

    int ary2[x] = { 3, 4, 5, 6, 7, 7, 8 }; // VLA desteği varsa bile ilk değer verme sözdizimi illegaldir.
}
```



👇 Aşağıdaki programda **VLA** özelliğinden yararlanarak değişken eleman sayısına sahip bir static dizi nasıl kullanıldığı incelenebilir.
```C
#include <stdio.h>

void func(int n)
{
    int a[n];
    // static int a2[n]; // Bu statement'ta sözdizim hatası oluşur ve illegal'dir çünkü VLA ile tanımlanan diziler 'static' ömürlü olamaz.

    printf("sizeof(a) = %zu", sizeof(a));
    printf("size a = %zu", sizeof(a) / sizeof(a[0]));

    for(int i = 0; i < n; ++i){
        a[i] = i;
    }

    // ...

    for(int i = 0; i < n; ++i){
        printf("%d ", a[i]);
    }
    printf("\n");
}

int main(void)
{
    func(5);
    func(9);
    func(13);
}
```

❗❗❗ **VLA** özelliğiyle oluşturulan dizilerin **storage duration** durumları **outomatic storage duration** olmaktadır, bu türden değişkenler belleğin **stack** alanında yeralır.

❗❗❗ **VLA** bir dizi **outomatic** ömürlü olmak zorundadır, **static** ömürlü olamaz.



👇 Aşağıdaki programda dinamik bellek yönetimi ile değişken elemanlı dizilerin kullanımı incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "nutility.h" // 'asize' makrosunun kullanılabilmesi için eklendi.

int dcmp(const void* vp1, const void* vp2)
{
    typedef const double* CDPTR;

    *(CDPTR)vp1 > *(CDPTR)vp2 ? 1 : 
    *(CDPTR)vp1 < *(CDPTR)vp2 ? -1 : 0; 
}

double get_median(const double* pa, size_t size)
{
    double* pd = malloc(size * sizeof(double));
    if(pd == NULL){
        fprintf(strerr, "bellek yetersiz.\n");
        exit(EXIT_FAILURE);
    }

    memcpy(pd, pa, size * sizeof(double));
    qsort(pd, size, sizeof(*pd), dcmp);

    double ret = pa[size / 2];

    free(pd);

    return ret;
}

int main()
{
    double a[] = { 1.2, 5.6, 3.3, 2.6, 1.56, 7.73, 3.45, 3.56, 4.23 };

    double median = get_median(a, asize(a));

    printf("medina = %f\n", median);
}
```



👇 Aşağıdaki programda **VLA** ile değişken elemanlı dizilerin kullanımı incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "nutility.h" // 'asize' makrosunun kullanılabilmesi için eklendi.

int dcmp(const void* vp1, const void* vp2)
{
    typedef const double* CDPTR;

    *(CDPTR)vp1 > *(CDPTR)vp2 ? 1 : 
    *(CDPTR)vp1 < *(CDPTR)vp2 ? -1 : 0; 
}

double get_median(const double* pa, size_t size)
{
    double ar[size]; // Burada 'VLA' aracından yararlanılıyor.

    memcpy(ar, pa, size * sizeof(double));
    qsort(ar, size, sizeof(*ar), dcmp);

    double ret = pa[size / 2];

    return ret;
}

int main()
{
    double a[] = { 1.2, 5.6, 3.3, 2.6, 1.56, 7.73, 3.45, 3.56, 4.23 };

    double median = get_median(a, asize(a));

    printf("medina = %f\n", median);
}
```




👇 Aşağıdaki programda 
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    int ary[4] = { 3, 7, 9, 2 };

    int (*p)[4] = &ary;

    for(int i = 0; i < 4; ++i){
        printf("%d\n", (*p)[i]);
    }
}
```



👇 Aşağıdaki programda eğer derleyici **VLA** destekliyorsa **variable length** array için **variable pointer** da oluşturulabileceği görülebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void foo(int n)
{
    int ary[n];

    int (*p)[n] = &ary; 

    for(int i = 0; i < n; ++i){
        (*p)[i] = i;
    }

    for(int i = 0; i < n; ++i){
        printf("%d\n", (*p)[i]);
    }

    printf("\n", );
}

int main()
{
    foo(5);
}
```



👇 Aşağıdaki programda **VLA** ile iki boyutlu bir dizinin tanımlanabileceği görülebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void foo(int row, int col)
{
    int ar[row][col];
    int val = 0;

    for(int i = 0; i < row; ++i){
        for(int k = 0; k < col; ++k){
            ar[i][k] = val++;
        }
    }

    // some code here ...

    for(int i = 0; i < row; ++i){
        for(int k = 0; k < col; ++k){
            printf("%d", ar[i][k]);
        }
        printf("\n");
    }
}

int main()
{
    foo(5, 3);
}
```



👇 Aşağıdaki programda **VLA** ile **variable pointer** bir dizinin tanımlanabileceği görülebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void foo(int row, int col)
{
    int ar[row][col];
    
    int (*p)[row][col] = &ar;
}

int main()
{
    foo(5, 3);
}
```



👇 Aşağıdaki programda iki boyutlu dizinin kendisi değişken boyutlu olmasa da değişken boyutlu bir dizinin pointer oluşturarak dizinin kendisine dinamik olarak bellek edinilebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void foo(int row, int col)
{
    int ar[row][col];
    
    int (*p)[row][col] = &ar;
}

int main()
{
    size_t row, col;

    printf("matrisin stir ve sutun sayisini girin: ");
    scanf("%zu%zu", &row, &col);

    int (*p)[row][col] = malloc(sizeof(*p)); // Burada dizinin kendisi dinamik olarak bellekten yer ayrılıp oluşturulmaktadır.

    // some code here ...

    for(size_t i = 0; i < row; ++i){
        for(size_t k = 0; k < col; ++k){
            (*p)[i][k] = rand() % 10;
        }
    }

    for(size_t i = 0; i < row; ++i){
        for(size_t k = 0; k < col; ++k){
            printf("%d", (*p)[i][k]);
        }
        printf("\n");
    }

    free(pd);
}
```


### Compound Literals 

C++ dilinde yoktur, C diline C99 standardıyla eklenmiştir.

Bir dizi ya da bir yapı türünden nesne kullanılacağında 



👇 Aşağıdaki programda **Compound Literals** özelliği kullanımı incelenebilir.
```C
#include <time.h>
#include <stdio.h>
#include "date.h"

void func(int* p);

int main()
{
    func(&(int) { 13 }); // Burda 'compound literal' vardır.

    struct tm* p = localtime(&(time_t){ time(0) }); // Burda 'compound literal' vardır.

    print_array((int[5])  { 3, 6, 7, 4, 3 }, 5); // Burda 'compound literal' vardır.


    int* p = (int[]){ 2, 5, 7, 8, 1 }; // Burda 'compound literal' vardır.
    *p = 21;
    p[4] = 89;

    print_array(p, 5);
}
```


***
==================================================

✦✦✦✦✦ 20.36-20.47 birinci ara verildi. ✦✦✦✦✦

==================================================
***



👇 Aşağıdaki programda **Compound Literals** özelliğinin **designated initialization** ile kullanımı incelenebilir.
```C
#include <time.h>
#include <stdio.h>
#include "date.h"

typedef struct{
    char name[20];
    int age;
    double wage;
} Person;


void func(const Person*);

int main()
{
    int* p1 = (int[]){ [2] = 5, [7] = 9, [3] = 7 }; // Burda 'compound literal' aracı 'designated initialization' aracı ile birlikte kullanılmıştır.

    p = (Person){ "umay", 41, 45.78 };

    func(&(Person) { "timur", 45, 56.76 }); // Burda 'compound literal' aracı kullanılmıştır.
    func(&(Person) { .name = "tarkan", .age = 101, .wage = 5.76 }); // Burda 'compound literal' aracı 'designated initialization' aracı ile birlikte kullanılmıştır.
}
```



👇 Aşağıdaki programda **Compound Literals** aracının kullanımı incelenebilir.
```C
#include <time.h>
#include <stdio.h>
#include "date.h"

typedef struct{
    char name[20];
    int id;
    double wage;
} Person;


int main()
{
    Person ary[10];

    ary[5] = (Person) { "ulgen", 792206523, 45.54354 };

    Person* p = &(Person){ "ulgen", 292326523, 95.554 };
    p->name[0] = 'e'; // Buradaki kod legal'dir ve burada 'ub' yoktur.
    
    char* pc = (char[]){ "korhan" }; // Burda 'compound literal' aracı kullanılmıştır.
}
```




👇 Aşağıdaki programda **Compound Literals** aracının kullanımı incelenebilir.
```C
#include <time.h>
#include <stdio.h>
#include "date.h"

void bar(int* p, int size);

void foo(int x, int y, int z)
{
    // int ar[] = { x, y, z };
    // bar(ar, 3);

    bar((int[]) { x, y, z }, 3);
}

int main()
{


}
```



👇 Aşağıdaki programda **Compound Literals** aracının kullanımı incelenebilir.
```C
#include <time.h>
#include <stdio.h>
#include "date.h"


typedef struct {
    int x, y, z;

} Point;


void foo(int x, int y, int z)
{
    Point p;

    p = (Point){x, y, z };
}

int main()
{

}
```



👇 Aşağıdaki programda **Compound Literals** aracının kullanımı incelenebilir.
```C
#include <time.h>
#include <stdio.h>
#include "date.h"
#include "nutility.h"


int main()
{
    int* p;

    if(1) {
        p = (int[]) { 1, 3, 2 }; // Burada derleyici üç elemanlı bir dizi oluşturacaktır, bu dizi otomatic ömürlüdür.
    }

    print_array(p, 3); // Burada 'dangling pointer' vardır, 'p' göstericisine sadece ilgili blokta geçerli olan otomatic ömürlüdür bir nesne atandığı için blok dışında bu nesne hayatta olmadığı için.
}
```




👇 Aşağıdaki programda **Compound Literals** aracının kullanımı incelenebilir. 
```C
#include <time.h>
#include <stdio.h>
#include "date.h"


typedef struct {
    int mx, my;
} Point;


void drawpixel(Point);


void drawline(void)
{
    for(int i = 0; i < 10; ++i) {
        drawpixel(&(Pointer) { i, i });
    }
}
```


### Flexible Array Member(Esnek Dizi Elemanı) 

C99 ile dile eklenmiş olan bir araçtır.

Özellikle yapıların kullanımında ihtiyaç duyulan şöyle bir sorun var, bir yapının üyelerinden biri eleman sayısı derleme ananda belli olmayan bir dizi olduğunda bu dizinin oluşturulması sorunudur.


👇 Aşağıdaki programda 
```C
#include <stdio.h>
#include "nutility.h"

struct Student {
    char name[20];
    char surname[20];
    int id;
    int* pgrades;
};


int main()
{
    Student* ps = (Student*) malloc(sizeof(Student)); // Yapı nesnesini barındırmak için bellekten yer ayrılıyor.

    int n = 5;
    ps->pgrades = (int*) malloc(n * sizeof(int));

    free(ps->pgrades);
    free(ps);
}
```


👇 Aşağıdaki programdan bir yapının elemanının nasıl **Flexible Array Member** olarak tanımlandığı incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

struct Student {
    int id;
    char name[16];
    char surname[20];
    int grades[]; // Bu eleman 'Flexible Array Member'dır. Bu yapı üyesi ilgili yapının doğrudan bir üyesi değildir.
};

int main()
{
    printf("sizeof(struct Student) = %zu\n", sizeof(struct Student)); // Burada yapı nesnesinin bellek boyutumu '40 byte' olduğu görülecektir.

}
```



👇 Aşağıdaki programdan bir yapının elemanının nasıl **Flexible Array Member** olarak sadece yapının son elemanı olabileceği incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

struct Student {
    int id;
    char name[16];
    int grades[]; // Bu eleman 'Flexible Array Member'dır. Bu yapı üyesi yapının son elemanı olmaması sözdizim hatasıdır.
    char surname[20];
};


// Bir yapının sadece bir tane 'Flexible Array Member' üye elemanı olabilir, birden fazla olursa sözdizim hatasıdır.
struct Data {
    int x, y;
    double d;
    int ary1[]; // Bu eleman 'Flexible Array Member' olarak kullanılmak istenmiş.
    int ary2[]; // Bu eleman 'Flexible Array Member' olarak kullanılmak istenmiş.
};


int main()
{

}
```



👇 Aşağıdaki programdan bir yapının elemanının nasıl **Flexible Array Member** olarak bildirilip kullanıldığı incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "nutility.h"

typedef struct {
    int id;
    char name[16];
    int grades[]; // Bu eleman 'Flexible Array Member'dır.
} Student;

int main()
{
    int no_of_exams;

    printf("kac not: ");
    scanf("%d", &no_of_exams);

    Student* p = malloc(sizeof(Student) + (no_of_exams * sizeof(int))); // Yapı nesnesi için bellek ayrılıyor.

    // some code here  ...

    p->id = 78324;
    strcpy(p->name, "Ulku");

    for(int i = 0; i < no_of_exams; ++i) {
        p->grades[i] = rand() % 100;
    }


    Student mystudent = *p; // Bu statement legaldir, 'p' göstericisinin gösterdiği nesnenin 'grades' üyesi dışındaki üyelerine 'mystudent' nesnesi üzerinden erişilebilir.
    free(p);

    printf("ad = %s\n", mystudent.name);
    printf("id = %s\n", mystudent.id);

    for (int i = 0; i < no_of_exams; ++i) {
        printf("%d ", mystudent.grades[i]); // Burada 'ub' vardır çünkü yapı nesneleri birbirine atandığında **Flexible Array Member** üyeler iki nesne arasında atanmamaktadır.
    }
}
```


❗❗❗ Yapı nesneleri birbirine ilk değer verdiğinde ya da bir yapı nesnesi başka bir yapı nesnesine atandığında **Flexible Array Member** üyeler atanmayacaktır. Atamanın yapılabilmeis için kopyalama yapılacak olan yapı nesnesi için bellekten yer ayrıldıktan sonra `memcpy` fonksiyonu kullanılmalıdır.



👇 Aşağıdaki programdan bir yapının elemanının **Flexible Array Member** olan elemanının `memcpy` fonksiyonunu kullanarak kopyalanabildiği incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "nutility.h"


typedef struct {
    int id;
    char name[16];
    int grades[]; // Bu eleman 'Flexible Array Member'dır.
} Student;

int main()
{
    int no_of_exams;

    printf("kac not: ");
    scanf("%d", &no_of_exams);

    size_t storage_size = sizeof(Student) + (no_of_exams * sizeof(int));

    Student* p1 = malloc(storage_size); // Yapı nesnesi için bellek ayrılıyor.

    // some code here  ...

    p1->id = 78324;
    strcpy(p1->name, "Ulku");

    for(int i = 0; i < no_of_exams; ++i) {
        p1->grades[i] = rand() % 100;
    }

    Student* p2 = malloc(storage_size);

    memcpy(p2, p1, storage_size);

    printf("%d %s\n", p2->id, p1->name);
    
    for(int i = 0; i < no_of_exams; ++i) {
        ptintf("%d ", p2->grades[i]);
    }    
}
```


Ders sonu ...
