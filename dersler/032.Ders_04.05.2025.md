# 32.Ders 04.05.2025 ğŸ•˜

Derse 10(09:01)-13(09:24)-15(09:41)-16(10:01)-16(10:35)-17(11:06)-13(12:48)-12(12:56) kiÅŸi katÄ±ldÄ±.
---

## Standart C KÃ¼tÃ¼phasindeki Fonksiyonlar

### DÃ¶rt Tane Ã‡ok SÄ±k KullanÄ±lan Standart C KÃ¼tÃ¼phasindeki Arama Fonksiyonu

- `strchr`
- `strrchr`
- `strstr`
- `strpbrk`


#### Standart C fonksiyonu Olan `strchr` ve `strrchr` FonksiyonlarÄ±

AÅŸaÄŸÄ±daki iki standar C fonksiyonuyla bir yazÄ±nÄ±n sonundaki NULL karakter de aranabiliyor, bu Ã¶zellikle C standardÄ±nda belirtilmektedir.
- `char* strchr(const char*, int c);`
- `char* strrchr(const char*, int c);`



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strchr` fonksiyonunun nasÄ±l kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE 100

int main(void)
{
    char s[SIZE];

    printf("bir yazi girin: ");
    sgets(s);
    puts(s);

    int ch;

    printf("aranan karakteri girin: ");
    ch = getchar(); // Burada 'scanf("%d", ch);' ÅŸeklinde okuma yapÄ±lmaya Ã§alÄ±ÅŸÄ±lÄ±rsa hatalÄ± iÅŸlem yapÄ±lmÄ±ÅŸ olacaktÄ±r.

    char* p = strchr(s, ch);
    if(p != NULL){
        printf("bulundu: (%c) (%s) index: %d\n", *p, p, p - s);
    }
    else{
        printf("bulunamadi!\n");
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strchr` fonksiyonu ile "NULL character" aramasÄ±nÄ±n nasÄ±l yapÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE 100

int main(void)
{
    char s[SIZE];

    printf("bir yazi girin: ");
    sgets(s);

    char* p = strchr(s, '\0');
    printf("uzunluk = %d\n", p - s);
    
    *p++ = '!';
    *p = '\0';

    puts(s);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strchr` fonksiyonunun **gerÃ§ekleÅŸtirimi(implementation)** incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE 100

// 'strchr' fonksiyonun gerÃ§ekleÅŸtirimi
// p  : iÃ§inde karakter aramasÄ± yapÄ±lacak olan dizinin adresi
// ch : yazÄ±da aranacak olan karakterin karakter kodu deÄŸeri
char* mystrchr_v1(const char* p, int ch)
{
    while(*p){
        if(*p == ch)
            return (char*)p;
        ++p;
    }

    if(ch == '\0')
        return p;
    else
        return NULL;
}


// 'strchr' fonksiyonun gerÃ§ekleÅŸtirimi
// p  : iÃ§inde karakter aramasÄ± yapÄ±lacak olan dizinin adresi
// ch : yazÄ±da aranacak olan karakterin karakter kodu deÄŸeri
char* mystrchr_v2(const char* p, int ch)
{
    while(*p){
        if(*p == ch)
            return (char*)p;
        ++p;
    }

    return ch == '\0' ? (char*)p : NULL;
}


int main(void)
{
    char s[SIZE];

    printf("bir yazi girin: ");
    sgets(s);
    puts(s);

    int ch;

    printf("aranan karakteri girin: ");
    ch = getchar();

    char* p = strchr(s, ch);
    if(p){ // if(p != NULL)
        printf("bulundu: (%c) (%s), indeks: %d\n", *p, p, p - s);
    }
    else{
        printf("bulunamadi!\n");
    }

    p = mystrchr_v2(s, ch);
    if(p){
        printf("bulundu: (%c) (%s), indeks: %d\n", *p, p, p - s);
    }
    else{
        printf("bulunamadi!\n");
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strchr` ve `strrchr` fonksiyonularÄ±nÄ±n nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE 100

int main(void)
{
    char s[SIZE];

    printf("bir yazi girin: ");
    sgets(s);
    puts(s);

    int ch;

    printf("aranan karakteri girin: ");
    ch = getchar();

    char* p = strchr(s, ch);
    if(p){
        printf("bulundu: (%c) (%s), indeks: %d\n", *p, p, p - s);
    }
    else{
        printf("bulunamadi!\n");
    }

    char* p = strrchr(s, ch);
    if(p){
        printf("bulundu: (%c) (%s), indeks: %d\n", *p, p, p - s);
    }
    else{
        printf("bulunamadi!\n");
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strrchr` fonksiyonunun **gerÃ§ekleÅŸtirimi(implementation)** incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE 100

// 'strrchr' fonksiyonun gerÃ§ekleÅŸtirimi
// p  : iÃ§inde karakter aramasÄ± yapÄ±lacak olan dizinin adresi
// ch : yazÄ±da aranacak olan karakterin karakter kodu deÄŸeri
char* mystrrchr(const char* p, int ch)
{
    const char* pfound = NULL;

    while(*p){
        if(*p == ch)
            pfound = p;
        ++p;
    }

    return pfound; // Bu 'return statement' aÅŸaÄŸÄ±dakiyle aynÄ±dÄ±r.
    //return ch == '\0' ? (char*)p : NULL;
}

int main(void)
{
    char s[SIZE];

    printf("bir yazi girin: ");
    sgets(s);
    puts(s);

    int ch;

    printf("aranan karakteri girin: ");
    ch = getchar();

    char* p = strrchr(s, ch);
    if(p){
        printf("bulundu: (%c) (%s), indeks: %d\n", *p, p, p - s);
    }
    else{
        printf("bulunamadi!\n");
    }

    p = mystrrchr(s, ch);
    if(p){
        printf("bulundu: (%c) (%s), indeks: %d\n", *p, p, p - s);
    }
    else{
        printf("bulunamadi!\n");
    }
}
```


#### Standart C fonksiyonu Olan `strstr` Fonksiyonu 

Standart C fonksiyonu olan `strstr` fonksiyonu bir yazÄ±da geÃ§en bir sÃ¶zcÃ¼ÄŸÃ¼n olup olmadÄ±ÄŸÄ±nÄ± anlamak iÃ§in kullanÄ±lÄ±r, fonksiyonun prototipi `char* strstr(const char* p1, const char* p2);` ÅŸeklindedir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir yazÄ±da bir sÃ¶zcÃ¼ÄŸÃ¼n geÃ§ip geÃ§mediÄŸini tespit eden standart C fonksiyonu olan `strstr` fonksiyonunun nasÄ±l kullanÄ±ldÄ±ÄŸÄ± incelenebilir. Bu ayrÄ±ca programlama dilinden baÄŸÄ±msÄ±z olarak mÃ¼lakatlarda sorulmaktadÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE 100

// 'strstr' fonksiyonun gerÃ§ekleÅŸtirimi
char* strstr_v1(const char* p1, const char* p2);

int main(void)
{
    char s1[SIZE];
    char s2[SIZE];

    printf("birinci yaziyi girin: ");
    sgets(s1);
    printf("ikinci yaziyi girin: ");
    sgets(s2);

    puts(s1);
    puts(s2);

    char* p = strstr(s1, s2);
    if(p != NULL){
        printf("bulundu idx: %d (%s)\n", p - s1, p);
    }
    else{
        printf("bulunamadi!\n");
    }
}
```


  
ğŸ“– Ã–dev-1: C mÃ¼lakatlarÄ±nda ya da Veri yapÄ±larÄ± ve algoritmalar kitaplarÄ±nda Ã§ok deÄŸinilen, bir yazÄ±da baÅŸka bir yazÄ±nÄ±n aranmasÄ± iÅŸlemini yapan `strstr(const char* haystack, const char* needle);` fonksiyonunun **gerÃ§ekleÅŸtirimini(implementation)** yapÄ±nÄ±z.



â—â—â— Bir metinin ilk karakterini gÃ¶steren pointer deÄŸiÅŸkenin deÄŸerini metnin son karakterini gÃ¶stermesini saÄŸlamak iÃ§in kullanÄ±labilecek C idiom'larÄ±; </br>
Bir metnin baÅŸlangÄ±Ã§ adresini tutan gÃ¶stericiyi metnin sonunu gÃ¶sterir hale getirmek iÃ§in aÅŸaÄŸÄ±daki **deyimler(statement)** kullanÄ±labilir, bunlar C kodlarÄ±nÄ± okurken karÅŸÄ±mÄ±za Ã§Ä±kabilir.
- `while(*p) ++p;`
- `while(*p++) ; --p;`
- `p += strlen(p);`
- `p = strchr(p, '\0');`



Åu ana kadar aÅŸaÄŸÄ±daki standart C fonksiyonlarÄ±nÄ± inceledik;
- `strlen`
- `strchr`
- `strrchr`
- `strstr`


#### Standart C fonksiyonu Olan `strpbrk` Fonksiyonu 

`strpbrk` fonksiyonunun adÄ± "**String Pointer Break**" sÃ¶zcÃ¼klerinden gelmektedir. 

Bu fonksiyon yazÄ±larla ilgili olan en sÄ±k kullanÄ±lan arama iÅŸlemlerinden birini yapmaktadÄ±r. `strpbrk` fonksiyonunun iki tane yazÄ±nÄ±n pointer'Ä±nÄ± parametre olarak alÄ±r, ikinci aldÄ±ÄŸÄ± yazÄ±nÄ±n karakterlerinden herhangi birini ilk aldÄ±ÄŸÄ± yazÄ±da bulduÄŸunda geriye bulunan karakterin birinci yazÄ±daki indeks deÄŸerini dÃ¶ndÃ¼rÃ¼r, bu Ã¶zelliÄŸinden dolayÄ± `strstr` fonksiyonunun tek bir karakter yerine birden Ã§ok karakter iÃ§in arama yapan hali gibi dÃ¼ÅŸÃ¼nÃ¼lebilir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strpbrk` fonksiyonunun **gerÃ§ekleÅŸtirimi(implementation)** incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE 100

// Standart `strpbrk` fonksiyonun gerÃ§ekleÅŸtirimi
// p      : Ä°Ã§inde arama yapÄ±lacak olan yazÄ±nÄ±n adresi
// pchars : Aranacak karakterleri iÃ§eren yazÄ±nÄ±n adresi
// return : Soldan baÅŸlanarak ilk tespit edilen karakterin adres deÄŸeri, eÄŸer eÅŸleÅŸme bulunamazsa 'NULL pointer' deÄŸer dÃ¶ndÃ¼rÃ¼lecektir.
char* mystrpbrk(const char* p, const char* pchars)
{
    while(*p){
        if(strchr(pchars, *p) != NULL)
            return (char *)p;
        ++p;
    }

    return NULL;
}

int main(void)
{
    char haystack[SIZE];
    char needle[SIZE];

    printf("icinde arama yapilacak yazi: ");
    sgets(haystack);

    printf("aranan karakterler: ");
    sgets(needle);

    char* p = strpbrk(haystack, needle);

    if(p)
        printf("bulundu: (%c) (%d) (%s)\n", *p, p - haystack, p);
    else
        printf("bulunamadi!\n");

    p = mystrpbrk(haystack, needle);

    if(p)
        printf("bulundu: (%c) (%d) (%s)\n", *p, p - haystack, p);
    else
        printf("bulunamadi!\n");
}
```


âš ï¸ YazÄ±lan programlarÄ±n Ã§ok iyi test edilmesi gerekiyor, elle test yapÄ±labilir ya da **unite test tool** programlarÄ± kullanÄ±labilir.


### Standart C fonksiyonu Olan `strcpy` Fonksiyonu 

Bu fonksiyon bir yazÄ±yÄ± bir yerden baÅŸka bir yere kopyalamaktadÄ±r.

C dilinde Ã§ok sÄ±k kullanÄ±lan bir convensiyon'u `strcpy` fonksiyonunda gÃ¶rebiliriz, bu convensiyon ilk parametrenin hedef ikinci parametrenin kaynak dizinin adresi olmasÄ± durumudur, bunun dÄ±ÅŸÄ±nda fonksiyondan geriye kopyalama yapÄ±lan adresin baÅŸlangÄ±Ã§ adresinin dÃ¶ndÃ¼rÃ¼lmesi de baÅŸka bir convensiyon'dur.

`strcpy` Fonksiyonu prototipi `char* strcpy(char* pdest, const char* psource);` ÅŸeklindedir ve bu fonksiyonun geriye dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ deÄŸer "pdest" adresidir yani deÄŸer kopyalanan dizinin adresi dÃ¶nÃ¼lmektedir, bu ÅŸekilde kombine ÅŸekilde fonksiyonlar yazÄ±labilmektedir.



â—â—â— AÅŸaÄŸÄ±daki C dilinde kullanÄ±lan iki konvensiyon iyi bilinmelidir; </br>
C dilinin standart kÃ¼tÃ¼phenesinde;
- Bir diziye bir yazÄ± yerleÅŸtiren
- Bir dizideki bir yazÄ±yÄ± deÄŸiÅŸtiren
fonksiyonlar **void fonksiyon(geri dÃ¶nÃ¼ÅŸ deÄŸeri olmayan fonksiyon)** deÄŸildir, bÃ¶yle fonksiyonlar Ã¼stÃ¼nde iÅŸlem yaptÄ±klarÄ± dizinin adresini dÃ¶ndÃ¼rÃ¼r.

âš ï¸ Konvensiyonlar dilin kuralÄ± deÄŸildir ama C standardÄ± ve Ã¼Ã§Ã¼ncÃ¼ taraf olarak yazÄ±lan kÃ¼tÃ¼phenelerde bu konvensiyonel kullanÄ±mlara uyulmaktadÄ±r.

â—â—â— EÄŸer bir fonksiyon iki adres istiyorsa birinden okuyacak ve diÄŸerine yazacak biÃ§imde ise birinci paramentre hedef adres, ikici parametre kaynak adres olacaktÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda standart `strcpy` C fonksiyonu ile nasÄ±l yazÄ± barÄ±ndÄ±ran dizilerin birinden diÄŸerine kopyalandÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE 100

int main(void)
{
    char source[SIZE];
    char dest[SIZE];

    printf("bir yazi girin: ");
    sgets(source);

    strcpy(dest, source);

    printf("(%s)\n", source);
    printf("(%s)\n", dest);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strcpy` ve `strchr` fonksiyonlarÄ±n seri hande nasÄ±l kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE 100

int main(void)
{
    char source[SIZE];
    char dest[SIZE];

    printf("bir yazi girin: ");
    sgets(source);

    // AÅŸaÄŸÄ±daki if statement'Ä±n ifadesinde aÅŸaÄŸÄ±daki iÅŸlem yapÄ±lmaktadÄ±r;
    // Ä°Ã§ fonksiyon: source'tan desc'e yazÄ±yÄ± kopyala
    // DÄ±ÅŸ fonksiyon: kopyaladÄ±ÄŸÄ±n yazÄ±da 'a' karakterini ara
    if(strchr(strcpy(dest, source), 'a')){

    }
}
```


ğŸ“Œ C mÃ¼lakatlarÄ±nda `strcpy` fonksiyonun C idiom'larÄ±yla birlikte kullanÄ±mÄ±nÄ±n yeraldÄ±ÄŸÄ± sorularÄ±n sorulmasÄ± sÄ±klÄ±kla uygulanan bir durummuÅŸ.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strcpy` fonksiyonunun **gerÃ§ekleÅŸtirimi(implementation)** incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE 100

// Standart `strcpy` fonksiyonun gerÃ§ekleÅŸtirimi.
// pdest   : Kopyalama yapÄ±lacak hedef yazÄ±nÄ±n adresi.
// psource : Kopyalama yapÄ±lacak kaynak yazÄ±nÄ±n adresi.
// return  : Kopyalama yapÄ±lan karakter dizisinin adresi dÃ¶ndÃ¼rÃ¼lecektir.
char* mystrcpy_v1(char* pdest, const char* psource)
{
    char* prest = pdest;

    while(*psource != '\0'){
        *pdest = *psource;
        ++psource;
        ++pdest;
    }

    *psource = '\0';

    return prest;
}

// Standart `strcpy` fonksiyonun gerÃ§ekleÅŸtirimi.
// pdest   : Kopyalama yapÄ±lacak hedef yazÄ±nÄ±n adresi.
// psource : Kopyalama yapÄ±lacak kaynak yazÄ±nÄ±n adresi.
// return  : Kopyalama yapÄ±lan karakter dizisinin adresi dÃ¶ndÃ¼rÃ¼lecektir.
char* mystrcpy_v2(char* pdest, const char* psource)
{
    char* prest = pdest;

    while(*psource != '\0')
        *pdest++ = *psource++;
    
    *psource = '\0';

    return prest;
}

// Standart `strcpy` fonksiyonun gerÃ§ekleÅŸtirimi.
// pdest   : Kopyalama yapÄ±lacak hedef yazÄ±nÄ±n adresi.
// psource : Kopyalama yapÄ±lacak kaynak yazÄ±nÄ±n adresi.
// return  : Kopyalama yapÄ±lan karakter dizisinin adresi dÃ¶ndÃ¼rÃ¼lecektir.
char* mystrcpy_v3(char* pdest, const char* psource)
{
    char* prest = pdest;

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ÅŸartÄ±nÄ±n kullanÄ±lmasÄ±nda derleyiciler uyarÄ± vermeyecektir Ã§Ã¼nkÃ¼ bu ÅŸekilde kullanÄ±mlar 'C idiomatic' yapÄ±lardÄ±r.
    while((*pdest++ = *psource++) != '\0') // Bir atama iÅŸleminde atama ifadesinin deÄŸeri sol operanda atanan deÄŸerdir!
        ; // null statement
    
    return prest;
}

// Standart `strcpy` fonksiyonun gerÃ§ekleÅŸtirimi.
// pdest   : Kopyalama yapÄ±lacak hedef yazÄ±nÄ±n adresi.
// psource : Kopyalama yapÄ±lacak kaynak yazÄ±nÄ±n adresi.
// return  : Kopyalama yapÄ±lan karakter dizisinin adresi dÃ¶ndÃ¼rÃ¼lecektir.
char* mystrcpy_v4(char* pdest, const char* psource)
{
    char* prest = pdest;

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ÅŸartÄ±nÄ±n kullanÄ±lmasÄ±nda derleyiciler Ã§oÄŸunlukla uyarÄ± verecektir.
    while(*pdest++ = *psource++) // Bir atama iÅŸleminde atama ifadesinin deÄŸeri sol operanda atanan deÄŸerdir!
        ; // null statement
    
    *psource = '\0';

    return prest;
}


int main(void)
{
    char source[SIZE];
    char dest[SIZE];

    printf("bir yazi girin: ");
    sgets(source);

    strcpy_v1(dest, source);

    printf("(%s)\n", source);
    printf("(%s)\n", dest);
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.21-10.40 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


**Overlapped Block**: Okuma ve yazma yapÄ±lan dizilerin bloklarÄ±nÄ±n kesiÅŸimi olmasÄ± durumudur.

â—â—â— **Overlapped bellek bloklarÄ±** arasÄ±nda `strcpy` fonksiyonuyla kopyalama iÅŸlemi yapmak C dilinde en Ã§ok yapÄ±lan hatadÄ±r, Ã§Ã¼nkÃ¼ kopyalanan bloklarÄ±n kesiÅŸim kÃ¼mesi olmasÄ± C standardÄ±nda "**ub**" olarak belirtilmiÅŸtir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strcpy` fonksiyonuna yapÄ±lan Ã§aÄŸrÄ±da "**Overlapped Block**" durumu olduÄŸu iÃ§in "**ub**" durumu olduÄŸu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE 100

int main(void)
{
    char source[SIZE] = "gulden";

    strcpy(source + 3, source); // Buradaki iÅŸlem 'Overlapped Block' durumundan dolayÄ± 'ub' durumuna neden olacaktÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `restrict` anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE 100

// 
void foo_v1(char* p1, char* p2, char* p3)
{
    // Derleyici 'dereferencing' iÅŸleminin maliyetini azaltmak iÃ§in optimizasyon yapabilir ama ya programcÄ± 'p2' ve 'p3' pointer deÄŸiÅŸkenlere aynÄ± nesneyi geÃ§miÅŸse
    *p1 += *p3;
    *p2 += *p3;

    // derleyici yukarÄ±daki kodu aÅŸaÄŸÄ±daki gibi optimize edebilir ama bu hataya neden olabilir.
    //int temp = *p3;
    //*p1 += temp;
    //*p2 += temp;
} 

// AÅŸaÄŸÄ±daki pointer deÄŸiÅŸken parametrelerin 'restrict' olarak belirtilmesi sadece derleyicinin Ã¼reteceÄŸi makine kodunu etkileyecektir.
void foo_v2(char* restrict p1, char* restrict p2, char* restrict p3)
//void foo_v2(char* __restrict p1, char* __restrict p2, char* __restrict p3) // Microsoft derleyicisi iÃ§in bu ÅŸekilde yazÄ±lmasÄ± gerekebilir.
{
    *p1 += *p3;
    *p2 += *p3;
}

int main(void)
{
    int x = 5;
    int y = 12;

    foo_v1(&x, &y, &y);
}
```



**Pointer Aliasing**: Birden fazla **gÃ¶stericinin(pointer)** aynÄ± nesneyi gÃ¶stermesi durumudur. Derleyiciler kodu optimize ederken bu duruma dikkat etmesi gerekmektedir.

`restrict` anahtar sÃ¶zcÃ¼ÄŸÃ¼ ile iÅŸaretlenen parametrelerin aynÄ± adres deÄŸerini almayacaÄŸÄ±nÄ±n sÃ¶zÃ¼ verilmiÅŸ olur ve derleyici bu bilgiye gÃ¶re optimizasyonunu yapar, `restrict` anahtar sÃ¶zcÃ¼ÄŸÃ¼ ile iÅŸaretlenen parametrelere "**Overlapped Block**" durumunda dizi adresleri gÃ¶nderilmemelidir yoksa **ub** durumu oluÅŸur. </br>
`restrict` anahtar sÃ¶zcÃ¼ÄŸÃ¼ dile C99 standardÄ± ile eklenmiÅŸti.


>â”
> 
> Sorulan soru; 
> 
> `restrict` kullandigim durumda ve kullanmadigim durumda da **ub** mi oluyor. Yoksa kullanmadigimda yanlis bir deger atamasi mi olacak ub yerine
> Tam anlamadim kullanip/kullanmadigim durumda nasil bir fark var?
> 
> Cevap;
> 
> C dilini diÄŸer dillerle karÄ±ÅŸtÄ±rmamak gerekir C kodu yazan programcÄ± her konuda bilgili ve dikkatli olmalÄ±dÄ±r, `restrict` iÅŸaretlemesi sadece derleyicinin daha iyi bir optimizasyon yapmasÄ±nÄ± saÄŸlamaktadÄ±r.
> 
> ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strcpy` fonksiyonuna argÃ¼man olarak "**Overlapped Block**" durumunda dizi adresleri gÃ¶nderildiÄŸi iÃ§in burada "**ub**" oluÅŸur
> ```C
> #define _CRT_SECURE_NO_WARNINGS
> 
> #include <stdio.h>
> #include <string.h>
> #include "nutility.h"
> 
> #define SIZE 100
> 
> int main(void)
> {
>     char source[SIZE] = "gulden";
> 
>     strcpy(source + 3, source); // Buradaki iÅŸlem 'ub' durumuna neden olacaktÄ±r Ã§Ã¼nkÃ¼ kopyalanan deÄŸer ile copyalamanÄ±n yapÄ±ldÄ±ÄŸÄ± gÃ¶sterici deÄŸerleri aynÄ± diziye aittir.
> }
> ```


>â”
> 
> Sorulan soru; 
> 
> Kendi tanÄ±mladÄ±ÄŸÄ±m fonksiyonda `restrict` yazmazsam  peki?
> 
> Cevap;
> 
> ğŸ‘‡ AÅŸaÄŸÄ±daki programda pointer parametre alan bir fonksiyonun parametrelerinin `restrict` olup olmamasÄ±nÄ±n neyi etkilediÄŸi incelenebilir.
> ```C
> #define _CRT_SECURE_NO_WARNINGS
> 
> #include <stdio.h>
> #include <string.h>
> #include "nutility.h"
> 
> #define SIZE 100
> 
> // AÅŸaÄŸÄ±daki 'mystrcpy' isimli fonksiyonun parametre deÄŸiÅŸkenleri olan gÃ¶stericilerin alacaÄŸÄ± adres deÄŸerlerinin 'ub'ye neden olup olmamasÄ± bu fonksiyona Ã§aÄŸrÄ± yaparken gÃ¶nderilen deÄŸerlerin ne olduÄŸuna baÄŸlÄ±dÄ±r, bu fonksiyon paramatrelerinin 'restrict' iÅŸaretlenmesi sadece derleyicinin optimizasyonunu etkiler fonksiyon Ã§aÄŸrÄ±larÄ±nda 'ub' oluÅŸup oluÅŸmamasÄ±nÄ± etkilemez.
> char* mystrcpy(char* pdest, const char* psource)
> {
>     char* prest = pdest;
> 
>     // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ÅŸartÄ±nÄ±n kullanÄ±lmasÄ±nda derleyiciler uyarÄ± vermeyecektir Ã§Ã¼nkÃ¼ bu ÅŸekilde kullanÄ±mlar 'C idiomatic' yapÄ±lardÄ±r.
>     while(*pdest++ = *psource++)
>         ; // null statement
>     
>     return prest;
> }
> ```



â—â—â— Pointer parametreli fonksiyonlarÄ± belgelerken(o fonksiyon hakkÄ±nda bilgi verirken) ÅŸunlar mutlaka belirtilmelidir;
- Bildirimde pointer'Ä±n `T*` ya da `const T*` biÃ§iminde olmasÄ± kuralÄ± yapÄ±n.
- Pointer parametrelerin `restrict` olup olmamasÄ± kararÄ± verilmelidir.
- Herhangi bir pointer parametreye "**NULL pointer**" geliyorsa aÅŸaÄŸÄ±daki iki durumdan biri sÃ¶z konusudur;
    1. Ya tanÄ±msÄ±z davranÄ±ÅŸtÄ±r
    2. Ya da ilgili parametreye "**NULL pointer**" deÄŸer geÃ§ilmesi, fonksiyonu kullanan programcÄ±sÄ±na verilen bir opsiyon olabilir.
- EÄŸer fonksiyondan geri dÃ¶nÃ¼ÅŸ tÃ¼rÃ¼ pointer ise
    1. Geri dÃ¶nÃ¼ÅŸ tÃ¼rÃ¼nÃ¼n **T*** ya da **const T*** olmasÄ±na karar verilmelidir.
    2. Fonksiyonun **NULL pointer** dÃ¶ndÃ¼rme ihtimali var mÄ± ve bunun ne anlama geldiÄŸi belirtilmelidir.
    3. Adresi dÃ¶ndÃ¼rÃ¼len nesnenin Ã¶mrÃ¼nÃ¼n ne olduÄŸu dokÃ¼mente edilmelidir(bu madde bu konudaki diÄŸer maddelerden de Ã¶nemli olabilir);
        1. **Static storage duration**
        2. **Dymamic storage duration**, bu Ã¶mÃ¼r tÃ¼rÃ¼nÃ¼ henÃ¼z iÅŸlemedik ileride iÅŸleyeceÄŸiz.
        3. Fonksiyona gÃ¶nderilen bir adres mi?

    
    ğŸ‘‡ AÅŸaÄŸÄ±daki programda `const int*` tÃ¼rÃ¼nden `int*` tÃ¼rÃ¼ne tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼nÃ¼n "**ub**" durumuna neden olabileceÄŸi incelenebilir.
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include <string.h>
    #include "nutility.h"

    #define SIZE 100

    // 'bar' fonksiyonunun geri dÃ¶nÃ¼ÅŸ deÄŸeri salt okuma amaÃ§lÄ± kullanÄ±labilmesi iÃ§in 'const int*' tÃ¼rÃ¼nde bildirilmiÅŸtir.
    const int* bar(int* p, int size);

    int main(void)
    {
        int *p = (int*)bar(...);

        *p = 357; // Bu iÅŸlem duruma gÃ¶re 'ub'ye neden olabilir.
    }
    ```


### Standart C fonksiyonu Olan `strcat` Fonksiyonu 

`strcat` fonksiyonu bir yazÄ±nÄ±n sonuna baÅŸka bir yazÄ±yÄ± eklemek iÃ§in kullanÄ±lÄ±r. </br>
`strcat` kÄ±saltmasÄ±nÄ± "**String Concatanete**" sÃ¶zcÃ¼klerinden gelmektedir. </br>
`strcat` fonksiyonunun parametreleri de C99 standardÄ±yla `restrict` pointer olarak belirlenmiÅŸtir, bu nedenle bu fonksiyona gÃ¶nderilen gÃ¶stericilerin aynÄ± adresi gÃ¶stermemesi gerekiyor.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strcat` fonksiyonunun nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE 100

int main(void)
{
    char s1[SIZE];
    char s2[SIZE];

    printf("iki yazi girin: ");
    scanf("%s%s", s1, s2);

    printf("(%s)(%s)\n", s1, s2);
    strcat(s1, s2);
    printf("(%s)(%s)\n", s1, s2);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strcat` fonksiyonunun nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE 100

int main(void)
{
    char s1[SIZE];
    char s2[SIZE];
    char s3[SIZE];

    printf("uc yazi girin: ");
    scanf("%s%s%s", s1, s2, s3);

    printf("(%s)(%s)(%s)\n", s1, s2, s3);
    
    strcat(strcat(s1, s2), s3); // Bu ÅŸekildeki kullanÄ±m C dilinde idiomatic bir kullanÄ±mdÄ±r.

    // YukarÄ±daki fonksiyon Ã§aÄŸrÄ±sÄ±yla aynÄ± anlama gelen kullanÄ±m aÅŸaÄŸÄ±dan incelenebilir;
    //strcat(s1, s2);
    //strcat(s1, s3);

    printf("(%s)(%s)(%s)\n", s1, s2, s3);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strcat` fonksiyonunun **gerÃ§ekleÅŸtirimi(implementation)** incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE 100

// Standart `strcat` fonksiyonun gerÃ§ekleÅŸtirimi.
// p1     : Sonuna baÅŸka yazÄ± kopyalanacak olan hedef yazÄ±nÄ±n adresi.
// p2     : Kopyalanacak kaynak yazÄ±nÄ±n adresi.
// return : C dilinde Ã§ok kullanÄ±lan bir gelenek(convension) olarak Ã¼zerinde deÄŸiÅŸiklik yapÄ±lan yazÄ±nÄ±n adresi. 
char* mystrcat_v1(char* p1, const char* p2)
{
    char* pret = p1;

    while(*p1)
        ++p1;

    while(*p1++ = *p2++)
        ; // null statement

    return pret;
}

// AÅŸaÄŸÄ±daki fonksiyon standart C fonksiyonlarÄ± kullanÄ±larak yazÄ±lmÄ±ÅŸtÄ±r.
// Standart `strcat` fonksiyonun gerÃ§ekleÅŸtirimi.
// p1     : Sonuna baÅŸka yazÄ± kopyalanacak olan hedef yazÄ±nÄ±n adresi.
// p2     : Kopyalanacak kaynak yazÄ±nÄ±n adresi.
// return : C dilinde Ã§ok kullanÄ±lan bir gelenek(convension) olarak Ã¼zerinde deÄŸiÅŸiklik yapÄ±lan yazÄ±nÄ±n adresi. 
char* mystrcat_v2(char* p1, const char* p2)
{
    strcpy(p1 + strlen(p1), p2);
}

// AÅŸaÄŸÄ±daki fonksiyon standart C fonksiyonlarÄ± kullanÄ±larak yazÄ±lmÄ±ÅŸtÄ±r.
// Standart `strcat` fonksiyonun gerÃ§ekleÅŸtirimi.
// p1     : Sonuna baÅŸka yazÄ± kopyalanacak olan hedef yazÄ±nÄ±n adresi.
// p2     : Kopyalanacak kaynak yazÄ±nÄ±n adresi.
// return : C dilinde Ã§ok kullanÄ±lan bir gelenek(convension) olarak Ã¼zerinde deÄŸiÅŸiklik yapÄ±lan yazÄ±nÄ±n adresi. 
char* mystrcat_v3(char* p1, const char* p2)
{
    strcpy(strchr(p1, '\0'), p2);
}

int main(void)
{
    char s1[SIZE];
    char s2[SIZE];

    printf("iki yazi girin: ");
    scanf("%s%s", s1, s2);

    printf("(%s)(%s)\n", s1, s2);
    strcat(s1, s2);
    printf("(%s)(%s)\n", s1, s2);

    printf("iki yazi girin: ");
    scanf("%s%s", s1, s2);

    printf("(%s)(%s)\n", s1, s2);
    mystrcat_v3(s1, s2);
    printf("(%s)(%s)\n", s1, s2);
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 11.50-12.00 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


## YazÄ±larÄ±n KarÅŸÄ±laÅŸtÄ±rÄ±lmasÄ± 

Bu baÅŸlÄ±k altÄ±nda **equality** ve **bÃ¼yÃ¼klÃ¼k ve kÃ¼Ã§Ã¼klÃ¼k** karÅŸÄ±laÅŸtÄ±rmasÄ± incelenecektir.

â—â—â— Aksi sÃ¶ylenmediÄŸi sÃ¼rece iki yazÄ±nÄ±n bÃ¼yÃ¼klÃ¼k kÃ¼Ã§Ã¼klÃ¼k karÅŸÄ±laÅŸtÄ±rÄ±lmasÄ± "**Lexicographical Compare**" algoritmasÄ±na gÃ¶re yapÄ±lÄ±r.

ğŸ§  **Lexicographical Compare Algorithm**: Bu algoritma iki veri yapÄ±sÄ±nÄ±n(iki dizi, iki yazÄ±) bÃ¼yÃ¼klÃ¼k kÃ¼Ã§Ã¼klÃ¼k karÅŸÄ±laÅŸtÄ±rmasÄ±nÄ±n yapÄ±lmasÄ± iÃ§in kullanÄ±lmaktadÄ±r. 
1. Bu algoritmaya gÃ¶re iki veri yapÄ±sÄ±nÄ±n eleman sayÄ±larÄ± ve karÅŸÄ±lÄ±klÄ± veri yapÄ±sÄ± Ã¶ÄŸelerinin aynÄ± olmasÄ± durumunda iki veri yapÄ±sÄ± eÅŸit olacaktÄ±r. 
2. Bu algoritmaya gÃ¶re iki veri yapÄ±sÄ±nÄ±n elemanlarÄ±nÄ±n sayÄ±sal fazlalÄ±ÄŸÄ±na bakÄ±lmadan en kÃ¼kÃ¼Ã§ indeks deÄŸerinden baÅŸlayÄ±p karÅŸÄ±laÅŸtÄ±rma yapÄ±lÄ±yor, bu karÅŸÄ±laÅŸtÄ±rmalarda ilk hangi veri yapÄ±sÄ±nÄ±n aynÄ± indeks deÄŸerindeki elemanÄ± bÃ¼yÃ¼kse o veri yapÄ±sÄ± diÄŸerinden daha bÃ¼yÃ¼k kabulediliyor, kÃ¼Ã§Ã¼klÃ¼k durumu iÃ§in de aynÄ± durum geÃ§erlidir.

AÅŸaÄŸÄ±daki iki dizi "**Lexicographical Compare**" algoritmasÄ±na gÃ¶re kÄ±yaslansa, tek elemandan oluÅŸan "3" dizisi daha bÃ¼yÃ¼ktÃ¼r.
- 3
- 2 5 6 7 9 1 6 8


AÅŸaÄŸÄ±daki iki dizi "**Lexicographical Compare**" algoritmasÄ±na gÃ¶re kÄ±yaslansa, tek elemandan oluÅŸan "1 2 3 5 9" dizisi daha bÃ¼yÃ¼ktÃ¼r. Buradaki gibi karÅŸÄ±lÄ±klÄ± elemanlarÄ±n eÅŸitliÄŸi varsa eleman sayÄ±sÄ± fazla olan dizi daha bÃ¼yÃ¼k olacaktÄ±r. 
- 1 2 3 5
- 1 2 3 5 9


AÅŸaÄŸÄ±daki iki dizi "**Lexicographical Compare**" algoritmasÄ±na gÃ¶re kÄ±yaslansa, "gulden" yazÄ±sÄ± daha bÃ¼yÃ¼ktÃ¼r.
- gul
- gulden


AÅŸaÄŸÄ±daki iki dizi "**Lexicographical Compare**" algoritmasÄ±na gÃ¶re kÄ±yaslansa, "sude" yazÄ±sÄ± daha bÃ¼yÃ¼ktÃ¼r.
- su
- sude


AÅŸaÄŸÄ±daki iki dizi "**Lexicographical Compare**" algoritmasÄ±na gÃ¶re kÄ±yaslansa, "masa" yazÄ±sÄ± daha bÃ¼yÃ¼ktÃ¼r.
- masa
- MASA


AÅŸaÄŸÄ±daki iki dizi "**Lexicographical Compare**" algoritmasÄ±na gÃ¶re kÄ±yaslansa, "su" yazÄ±sÄ± daha bÃ¼yÃ¼ktÃ¼r.
- "su"
- "cumhuriye"


AÅŸaÄŸÄ±daki iki dizi "**Lexicographical Compare**" algoritmasÄ±na gÃ¶re kÄ±yaslansa, "kucuk masa" yazÄ±sÄ± daha bÃ¼yÃ¼ktÃ¼r.
- buyuk masa
- kucuk masa


â—â—â— YazÄ±larÄ±n karÅŸÄ±laÅŸtÄ±rmasÄ± iÅŸleminde bu karÅŸÄ±laÅŸtÄ±rma iÅŸlemi varsayÄ±lan olarak "**Lexicographical Compare**" algoritmasÄ±na gÃ¶re yapÄ±lÄ±r.


BaÅŸka programlama dilinde iki yazÄ±yÄ± karÅŸÄ±laÅŸtÄ±rmak iÃ§in aÅŸaÄŸÄ±daki durumlar iÃ§in ayrÄ± ayrÄ± sonuÃ§ dÃ¶ndÃ¼rÃ¼lÃ¼yor olaiblir.
- bool is_equal
- bool is_not_equal
- bool is_less
- bool is_less_orequle
- bool is_greater



â—â—â— Tek bir fonksiyon olsun, fonksiyon karÅŸÄ±laÅŸtÄ±rmasÄ±nÄ±n sonucunu dÃ¶ndÃ¼rsÃ¼n, karÅŸÄ±laÅŸtÄ±rma iÅŸleminde eÅŸitlik aÃ§Ä±sÄ±ndan Ã¼Ã§ farklÄ± durum vardÄ±r. Bunu yapmak iÃ§in C dilinde ÅŸu ÅŸekilde bir convension vardÄ±r: Fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸeri "**signed int**" yapÄ±lÄ±r ve ilk deÄŸer ikinci deÄŸerden bÃ¼yÃ¼kse pozitif, kÃ¼Ã§Ã¼kse negatif ve eÅŸitse 0 deÄŸeri dÃ¶ndÃ¼rÃ¼lÃ¼r.
- `int compare(x, y);` fonksiyonu iki deÄŸeri karÅŸÄ±laÅŸtÄ±rÄ±r ve aÅŸaÄŸÄ±daki durumlara gÃ¶re bu karÅŸÄ±laÅŸtÄ±rmanÄ±n sonucunu geriye dÃ¶ndÃ¼rÃ¼r;
    1. `x > y` ise  pozitif deÄŸer dÃ¶ndÃ¼rÃ¼lsÃ¼n.
    2. `x < y` ise  negatif deÄŸer dÃ¶ndÃ¼rÃ¼lsÃ¼n.
    3. `x == y` 0


### `strcmp` Fonksiyonu 

`strcmp` fonksiyonunun adÄ± "**String Compare**" sÃ¶zcÃ¼klerinden gelmektedir. </br>
`strcmp` fonksiyonu dÄ±ÅŸarÄ±dan aldÄ±ÄŸÄ± iki veri yapÄ±sÄ±nÄ±n adresini alÄ±r ve bunlarÄ± **lexicographical compare** algoritmasÄ±na gÃ¶re karÅŸÄ±laÅŸtÄ±rÄ±ÅŸ ve sonucu iÅŸaretli tam sayÄ± olarak geriye dÃ¶ndÃ¼rÃ¼r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda C standar fonksiyonunun karÅŸÄ±laÅŸtÄ±rma iÅŸlemleri iÃ§in kullanÄ±lan `strcmp` fonksiyonunun nasÄ±l kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int main(void)
{
    char s1[SIZE];
    char s2[SIZE];

    printf("iki sozcuk girin: ");
    scanf("%s%s", s1, s2);
    int result = strcmp(s1, s2);

    if(result > 0)
        printf("%s > %s\n", s1, s2);
    else if(result < 0)
        printf("%s < %s\n", s1, s2);
    else
        printf("%s = %s\n", s1, s2);
}
```


>â”
> 
> Sorulan soru; 
> 
> Karsilastirmanin hangi encoding gÃ¶re yapilacagi standartta sabit mi bÃ¶yle fonksiyonlar icin?
> 
> Cevap;
> 
> Bu sorunun cevabÄ± sanÄ±ldÄ±ÄŸÄ±ndan daha kapsamlÄ±dÄ±r, bu nedenden dolayÄ± aÅŸaÄŸÄ±da deÄŸinilen konular anlatÄ±lmÄ±ÅŸtÄ±r.


ğŸ§  **Local**: BazÄ± iÅŸlemlerin nasÄ±l yapÄ±lacaÄŸÄ±nÄ± belirleyen kurallarÄ±n bÃ¼tÃ¼nÃ¼dÃ¼r. FarklÄ± farklÄ± **local** tÃ¼rleri ve aynÄ± **local** tÃ¼rÃ¼n farklÄ± deÄŸerleri olabilir.

Programlama dillerinde kullanÄ±lan bazÄ± fonksiyonlarÄ±n nasÄ±l Ã§alÄ±ÅŸacaÄŸÄ± kullanÄ±lan **local** bilgisine gÃ¶re deÄŸiÅŸecektir, mesela ondalÄ±klÄ± sayÄ±larÄ±n ondalÄ±k kÄ±smÄ± TÃ¼rkiye'de virgÃ¼l ile ayrÄ±lÄ±rken Amerika'da nokta ile ayrÄ±lÄ±yor ya da Amerika'da tarih gÃ¶sterimi "MM.dd.yyyy" ÅŸeklindeyken TÃ¼rkiye'de "dd.MM.yyyy" ÅŸeklindedir.


Fonksiyonlar **local** kurallarÄ±nÄ±n iÅŸlemlesine gÃ¶re aÅŸaÄŸÄ±daki gibi ikiye ayrÄ±lmaktadÄ±r;
1. **Local Dependet(Locale baÄŸÄ±mlÄ±)**: KullanÄ±lan **local** bilgisine gÃ¶re kodun nasÄ±l Ã§alÄ±ÅŸacaÄŸÄ±nÄ±n deÄŸiÅŸtiÄŸi durumdur.
2. **Local Independet(Localden baÄŸÄ±msÄ±z)**: KullanÄ±lan **local** bilgisine gÃ¶re kodun nasÄ±l Ã§alÄ±ÅŸacaÄŸÄ±nÄ±n deÄŸiÅŸmediÄŸi durumdur.

ğŸ§  C dilinde `locale.h` baÅŸlÄ±k dosyasÄ±nda bulunan `setlocale` fonksiyonu ile kullanÄ±lan **local** deÄŸiÅŸtirilebilir.

ğŸ§  C dilinde standart fonksiyon adlarÄ±nda addaki farklÄ± sÃ¶zcÃ¼klerin ayrÄ±mÄ± iÃ§in '_' karakteri kullanÄ±lmÄ±yor ama C++ dilinde bu durum tam tersidir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `setlocale` fonksiyonu ile **local** bilgisinin nasÄ±l deÄŸiÅŸtirilebileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include <locale.h>

//char* setlocale(int category, const char* localname); // Bu 'function prototipe' bildirimi 'locale.h' baÅŸlÄ±k dosyasÄ±nda bulunuyor.

int main(void)
{
    const char* p = setlocale(LC_ALL, "turkish"); // TÃ¼m local convensiyonlarÄ±n deÄŸiÅŸtirilmesi iÃ§in istek yapÄ±lÄ±yor, 'setlocale' fonksiyonundan geriye 'NULL pointer' dÃ¶nÃ¼yorsa local deÄŸiÅŸtirilemedi anlamÄ±na geliyor, eÄŸer local deÄŸiÅŸtirilebilirse geriye deÄŸiÅŸim yapÄ±lan local bilgisi dÃ¶ndÃ¼rÃ¼lÃ¼r. 

    if(!p){
        printf("desteklenmeyen locale.\n");
        return 1;
    }

     printf("locale changed: %s\n", p);
}
```


BazÄ± fonksiyonlar iÃ§in **local** bilgisi deÄŸiÅŸtiÄŸinde fonksyonun Ã§alÄ±ÅŸmasÄ±nda bir deÄŸiÅŸiklik olmuyorsa bu fonksiyonlara **Local Independet(Locale baÄŸÄ±msÄ±z)** fonksiyon denilmektedir.

**C locale**: Derleyicinin varsayÄ±lan olarak belirlediÄŸi **local** bilgisine verilen isimdir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **local** bilgisine gÃ¶re ondalÄ±klÄ± sayÄ±larÄ±n nasÄ±l `printf` fonksiyonu(bu fonksiyon **Local Dependet(Locale baÄŸÄ±mlÄ±)** bir fonksiyondur) ile yazdÄ±rÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include <locale.h>

int main(void)
{
    double dval = 43.73543634;

    printf("dval = %f\n", dval);

    const char* p = setlocale(LC_ALL, "turkish"); // TÃ¼m local convensiyonlarÄ±n deÄŸiÅŸtirilmesi iÃ§in istek yapÄ±lÄ±yor, 'setlocale' fonksiyonundan geriye 'NULL pointer' dÃ¶nÃ¼yorsa local deÄŸiÅŸtirilemedi anlamÄ±na geliyor, eÄŸer local deÄŸiÅŸtirilebilirse geriye deÄŸiÅŸim yapÄ±lan local bilgisi dÃ¶ndÃ¼rÃ¼lÃ¼r. 

    if(!p){
        printf("desteklenmeyen locale.\n");
        return 1;
    }

    printf("locale changed: %s\n", p);

    printf("dval = %f\n", dval);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda kullanÄ±lan **locale** deÄŸerine gÃ¶re `scanf` fonksiyonunun(bu fonksiyon **Local Dependet(Locale baÄŸÄ±mlÄ±)** bir fonksiyondur) nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include <locale.h>

int main(void)
{
    double dval;
    printf("bir gercek sayi giriniz: ");
    scanf("%lf", &dval);
    
    printf("C locale, dval = %f\n", dval);

    const char* p = setlocale(LC_ALL, "turkish"); // TÃ¼m local convensiyonlarÄ±n deÄŸiÅŸtirilmesi iÃ§in istek yapÄ±lÄ±yor, 'setlocale' fonksiyonundan geriye 'NULL pointer' dÃ¶nÃ¼yorsa local deÄŸiÅŸtirilemedi anlamÄ±na geliyor, eÄŸer local deÄŸiÅŸtirilebilirse geriye deÄŸiÅŸim yapÄ±lan local bilgisi dÃ¶ndÃ¼rÃ¼lÃ¼r. 

    if(!p){
        printf("desteklenmeyen locale.\n");
        return 1;
    }
    printf("locale changed: %s\n", p);

    printf("bir gercek sayi giriniz: ");
    scanf("%lf", &dval);

    printf("TR locale, dval = %f\n", dval);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda ileride incelenilecek `time.h` kÃ¼tÃ¼phanesinin kullanÄ±mÄ± Ã¼zerinden **local** deÄŸiÅŸikliÄŸinin nasÄ±l etki ettiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include <locale.h>
#include <time.h>

int main(void)
{
    const char* lp = setlocale(LC_ALL, "turkish"); // TÃ¼m local convensiyonlarÄ±n deÄŸiÅŸtirilmesi iÃ§in istek yapÄ±lÄ±yor, 'setlocale' fonksiyonundan geriye 'NULL pointer' dÃ¶nÃ¼yorsa local deÄŸiÅŸtirilemedi anlamÄ±na geliyor, eÄŸer local deÄŸiÅŸtirilebilirse geriye deÄŸiÅŸim yapÄ±lan local bilgisi dÃ¶ndÃ¼rÃ¼lÃ¼r. 

    if(!lp){
        printf("desteklenmeyen locale.\n");
        return 1;
    }
    printf("locale changed: %s\n", lp);

    char str[100];

    time_t timer = time(NULL);
    const struct tm* p = localtime(&timer);

    strftime(str, 100, "%D %A %B %Y", p);

    puts(str);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program `strcmp` fonksiyonu ile yazÄ±larÄ± karÅŸÄ±laÅŸtÄ±rma iÅŸlemlerinin nasÄ±l yapÄ±labileceÄŸini anlamak iÃ§in incelenebilir, bu programÄ±n anlatÄ±mÄ± yarÄ±m kaldÄ±, sonraki derste devam edecektir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int main(void)
{
    char s1[SIZE];
    char s2[SIZE];

    printf("iki sozcuk girin: ");
    scanf("%s%s", s1, s2);
    int result = strcmp(s1, s2);


    // AÅŸaÄŸÄ±daki if statement 'if(strcmp(s1, s2)  == 0)' ile aynÄ±dÄ±r.
    // AÅŸaÄŸÄ±daki if deyimi kullanÄ±mÄ± idiomatic kullanÄ±mdÄ±r.
    if(!strcmp(s1, s2)){ } // EÅŸit mi karÅŸÄ±laÅŸtÄ±rmasÄ±?

    if(strcmp(s1, s2) == 0){ } // EÅŸit mi karÅŸÄ±laÅŸtÄ±rmasÄ±?

    if(strcmp(s1, s2) != 0){ } // EÅŸit deÄŸil mi karÅŸÄ±laÅŸtÄ±rmasÄ±?

    // AÅŸaÄŸÄ±daki if statement 'if(strcmp(s1, s2)  != 0)' ile aynÄ±dÄ±r.
    // AÅŸaÄŸÄ±daki if deyimi kullanÄ±mÄ± idiomatic kullanÄ±mdÄ±r.
    if(strcmp(s1, s2)){ } // EÅŸit deÄŸil mi karÅŸÄ±laÅŸtÄ±rmasÄ±?
}
```


>â”
> 
> Sorulan soru; 
> 
> Az Ã¶nce TÃ¼rkiye localinde %D formatÄ±nda neden ay/gÃ¼n/yÄ±l ÅŸeklinde verdi tÃ¼rkiye formatÄ±na uygun gÃ¼n/ay/yÄ±l vermesi gerekmiyor mu ?
> 
> Cevap;
> 
> Bu durum `strftime` fonksiyonunun formatlama iÅŸlemleriyle ilgilidir.


Ders sonu ...
