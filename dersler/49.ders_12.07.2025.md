# 49.Ders 12.07.2025 ğŸ•˜

Derse 11(09:01)-12(09:06)-13(09:11)-14(09:19)-14(09:29)-16(09:33)-15(10:22)-14(10:51)-14(11:1)-14(12:16)-14(12:59) kiÅŸi katÄ±ldÄ±.
---

## BaÄŸlÄ± Listeler Veri YapÄ±sÄ± Devam (Linklist Data Structure) ğŸŒŸ


â—â—â— Bir algoritmanÄ±n karmaÅŸÄ±klÄ±ÄŸÄ±, Ã¼zerinde iÅŸlem yapÄ±lan verinin bÃ¼yÃ¼klÃ¼ÄŸÃ¼yle de iliÅŸkilidir. </br>
Bir algoritmanÄ±n karmaÅŸÄ±klÄ±ÄŸÄ± o algoritmanÄ±n iÅŸlem maliyeti hakkÄ±nda fikir verse de Ã¼zerinde iÅŸlem yapÄ±lan verinin bÃ¼yÃ¼klÃ¼ÄŸÃ¼ de Ã§alÄ±ÅŸmas sÃ¼resini etkileyecektir. </br>
Yani dÃ¼ÅŸÃ¼k sayÄ±daki veri Ã¼zerinde Ã§alÄ±ÅŸacak olan algoritmalar, algoritmik karmaÅŸÄ±klÄ±klarÄ±ndan beklendiÄŸi gibi performanslÄ± Ã§alÄ±ÅŸmayabilir. </br>
Mesela az sayÄ±daki elemanÄ± sÄ±ralamak iÃ§in $O(n^2)$ karmaÅŸÄ±klÄ±ÄŸÄ±ndaki bir algoritma $O(n)$ karmaÅŸÄ±klÄ±ÄŸÄ±ndaki algoritmadan daha hÄ±zlÄ± Ã§alÄ±ÅŸabilir, bunun temel nedeni $O(n)$ karaÅŸÄ±klÄ±ÄŸÄ±ndaki algoritmanÄ±n kendi kodundan Ã¼retilecek olan makine kodlarÄ±nÄ±n iÅŸlem sayÄ±sÄ±nÄ±n fazlalÄ±ÄŸÄ± olduÄŸu bilinmelidir.

â—â—â— BazÄ± durumlarda(yazÄ±lÄ±mÄ±n Ã¼zerinde Ã§alÄ±ÅŸacaÄŸÄ± donanÄ±m vb.) $O(n)$ karmaÅŸÄ±klÄ±ÄŸÄ±nda ama **linked list** kullanÄ±lan bir algoritma yerine $O(n^2)$ karmaÅŸÄ±klÄ±ÄŸÄ±nda **dynamik array** kullanÄ±lan bir algoritmanÄ±n seÃ§ilmesi gerekebilir. </br>
AynÄ± iÅŸi farklÄ± karmaÅŸÄ±klÄ±kta yapan iki algoritma yazÄ±ldÄ±ktan sonra hangisini kullanmanÄ±n ilgili durumda daha doÄŸru olduÄŸunu anlamak iÃ§in **Benchmarker** ya da **Profiler** denilen programlarÄ± kullanmak gerekebilir. </br>
Dinamik dizide Ã¶ÄŸelerin bellekte ardÄ±ÅŸÄ±k olmasÄ±, dinamik dizide veri yapÄ±sÄ±nÄ±n **cache friendly** olmasÄ±(yani iÅŸlemcilerin Ã¶nbellek mekanizmasÄ±na daha iyi uyum saÄŸlamasÄ±), dinamik dizi veri yapÄ±sÄ±nda modern iÅŸlemcilerde bulunan **SIMD(Single Instruction, Multiple Data)** komutlarÄ±nÄ±n kullanÄ±labilmesi algoritmanÄ±n daha yÃ¼ksek karmaÅŸÄ±klÄ±ÄŸÄ±na karÅŸÄ±n yine de dinamik dizi veri yapÄ±sÄ±nÄ±n daha performanslÄ± olmasÄ±nÄ± saÄŸlayabilir. </br>
Bu durumda programlamayla yeni karÅŸÄ±laÅŸanlar ya da pek bilgi sahibi olmayanlar "_Ne Ã¶nemi kaldÄ± ki algoritma karmaÅŸÄ±klÄ±ÄŸÄ±nÄ±n_" diyebiliyorlar, algoritmik karmaÅŸÄ±klÄ±ÄŸÄ±n fayda saÄŸlayabilmesi iÃ§in Ã¼zerinde iÅŸlem yapÄ±lan Ã¶ÄŸe yasÄ±nÄ±n belirli belirli bir miktarÄ± geÃ§mesi gerekecektir.



â—â—â— **Dynamic array** ve **Linked list** arasÄ±ndaki farklar aÅŸaÄŸÄ±daki gibidir;
1. Ä°ndeksini bildiÄŸimiz elemana eriÅŸim;
    - **Dynamic array**     $O(1)$
    - **Linked list**       $O(n)$
2. DeÄŸer ile eriÅŸim 
    - **Dynamic array**     $O(n)$
    - **Linked list**       $O(n)$
3. Ekleme iÅŸlemleri
    - **Dynamic array** yalnÄ±zca sondan ekleme yapÄ±lÄ±rsa $O(1)$, sondan olmayan bir konumdan ekleme $O(n)$
    - **Linked list** konumu bilinen bir yerden ekleme iÅŸlemi $O(1)$ karmaÅŸÄ±klÄ±kta.
4. Silme iÅŸlemleri
    - **Dynamic array** yalnÄ±zca sondan silme yapÄ±lÄ±rsa $O(1)$, sondan olmayan bir konumdan silme $O(n)$
    - **Linked list** konumu bilinen bir yerden silme iÅŸlemi $O(1)$ karmaÅŸÄ±klÄ±kta.


### BaÄŸlÄ± Listelerin Olabilecek YararlarÄ± 

Herhangi bir konumdan ekleme ve silme iÅŸlemlerinin **constan-time($O(1)$)** olmasÄ±. </br>
**Fragmentation** durumana karÅŸÄ± direnÃ§li olmasÄ±. </br>
**DeÄŸiÅŸ tokuÅŸ(swap)** iÅŸlemlerinin yapÄ±lmasÄ±nÄ±n kolay olmasÄ±(sadece pointer deÄŸiÅŸikliÄŸiyle bu saÄŸlanabildiÄŸi iÃ§in) </br>
**Splice** iÅŸlemlerinde hÄ±zlÄ±dÄ±r(pointer deÄŸiÅŸikleri Ã¼zerinden iÅŸlem yapÄ±ldÄ±ÄŸÄ± iÃ§in).

ğŸ“Œ Neden veri yapÄ±sÄ± kullanÄ±yoruz diye dÃ¼ÅŸÃ¼nÃ¼lÃ¼rse, o veri yapÄ±sÄ±nÄ± Ã¼zerinde belirli algoritmalarÄ±n Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ± ve iÅŸlemler yapÄ±lmasÄ± iÃ§in algoritma kullanÄ±rÄ±z.


BazÄ± algoritmelar **deÄŸiÅŸ tokuÅŸ(swap)** iÅŸlemleri yaparlar;
- Sorting algorithms
- Merge algorithms
- Pertition
- Unique
- Reverse



Dinamik dizilerde **takas(swap)** iÅŸlemleri verilerin bellek bloklarÄ±nÄ±n kopyalanmasÄ±nÄ± gerektirir. </br>
BaÄŸlÄ± listelerde **takas(swap)** iÅŸlemleri verinin kopyalanmasÄ± yerine veriyi tutan dÃ¼ÄŸÃ¼m iÃ§indeki gÃ¶stericilerin kopyalanmasÄ± ile yapÄ±lÄ±r.



C++ standardÄ±nda **Splice** olarak adlandÄ±rÄ±lan aynÄ± tÃ¼rden veri yapÄ±larÄ±ndaki Ã¶ÄŸelerden birinin bir veri yapÄ±sÄ±ndan Ã§Ä±kartÄ±lÄ±p diÄŸer veri yapÄ±sÄ±na eklenmesi iÅŸlemine verilen addÄ±r. 

C dilinin standardÄ±nda sadece **static array** veri yapÄ±sÄ± desteÄŸi vardÄ±r, diÄŸer temel veri yapÄ±larÄ±na destek bulunmamaktadÄ±r, diÄŸer veri yapÄ±larÄ±nÄ± kullanabilmek iÃ§in ya kendimiz yazacaÄŸÄ±z ya da Ã¼Ã§Ã¼ncÃ¼ taraf bir kÃ¼tÃ¼phaneyi kullanmamÄ±z gerekecektir.


YazÄ±lÄ±m mÃ¼lakatlarÄ±nda programlama dilinden baÄŸÄ±msÄ±z olarak temel veri yapÄ±larÄ±nÄ±n **gerÃ§ekleÅŸtiriminin(implementetion)** yapÄ±lmasÄ± istenebilir.


## `personlist` ModÃ¼lÃ¼nÃ¼n GerÃ§ekleÅŸtirimi 

Person nesneleri bir veri yapÄ±sÄ±nda tutalÄ±m. </br>
BÃ¼tÃ¼n ekleme iÅŸlemleri baÅŸtan ve bÃ¼tÃ¼n silme iÅŸlemleri yine baÅŸtan yapÄ±lacak.


âœï¸ Burada `personlist` adÄ±ndaki kendi modÃ¼lÃ¼mÃ¼zÃ¼n baÅŸlÄ±k dosyasÄ±nÄ± aÅŸaÄŸÄ±daki gibi yazÄ±yoruz.
```C
// YazÄ±lan 'personlist.h' dosyasÄ±na eklenenler.

#ifndef PERSONLIST_H
#define PERSONLIST_H

#include "person.h" 

struct Person;

// 'get_first' fonksiyonu kendisine geÃ§ilen 'Person' tÃ¼rÃ¼nden gÃ¶stericiye listedeki ilk nesnenin adresini atar.
void get_first(Person*);

void push_front(const Person*);
void pop_front(void);
int get_list_size(void);
int is_empty(void);
void make_empty(void);
void print_list(void);

#endif
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda ilk sÄ±nama programÄ± gÃ¶rÃ¼lebilir, `person` listesine n tane person ekleyelim, ve `printlist` fonksiyonuyla eklenen Ã¶ÄŸeleri yazdÄ±ralÄ±m.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "personlist.h"
#include "nutility.h"

int main(void)
{
    int n;

    printf("listeye kaÃ§ kiÅŸi eklenecek: ");
    scanf("%d", &n);

    randomize();
    Person per;

    for(int i = 0; i < n; ++i){
        set_random_person(&per);
        print_person(&per);
        push_front(&per);
    }

    printf("listede %d kisi var\n", get_list_size());
    print_list();

    make_emptt();
    printf("listede %d kisi var\n", get_list_size());
    print_list();
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda ikinci sÄ±nama programÄ± gÃ¶rÃ¼lebilir, `person` listesine n tane person ekleyelim, ve `printlist` fonksiyonuyla eklenen Ã¶ÄŸeleri yazdÄ±ralÄ±m.
```C
#include <stdio.h>
#include <time.h>
#include "personlist.h"
#include "nutility.h"

int main(void)
{
    int n;

    printf("listeye kaÃ§ kiÅŸi eklenecek: ");
    scanf("%d", &n);

    randomize();
    Person per;

    printf("ekleme islemi basladi.\n");
    clock_t start = clock();

    for(int i = 0; i < n; ++i){
        set_random_person(&per);
        print_person(&per);
        push_front(&per);
    }

    clock_t end = clock();
    printf("ekleme islemi bitti %f saniye\n", (double)(end - start) / CLOCK_PER_SEC);
    (void)getchar(); // Program burada kullanÄ±cÄ±dan bir tuÅŸa basmasÄ± beklenilerek durduruluyor.

    printf("listede %d kisi var\n", get_list_size());
    print_list();

    make_emptt();
}
```


ğŸ‘‡ AÅŸaÄŸÄ±da Ã¼Ã§Ã¼ncÃ¼ sÄ±nama programÄ± gÃ¶rÃ¼lebilir, `person` listesine n tane person ekleyelim, ve `printlist` fonksiyonuyla eklenen Ã¶ÄŸeleri yazdÄ±ralÄ±m.
```C
#include <stdio.h>
#include <time.h>
#include "personlist.h"
#include "nutility.h"

int main(void)
{
    randomize();
    
    int n = rand() % 10 + 10;

    Person per;

    for(int i = 0; i < n; ++i){
        set_random_person(&per);
        push_front(&per);
    }

    while(!is_empty()){
        printf("listede %d kisi var.\n", get_list_size());
        print_list();
        pop_front();
        (void)getchar(); // Program burada kullanÄ±cÄ±dan bir tuÅŸa basmasÄ± beklenilerek durduruluyor.
    }
}
```



âœï¸ Burada `personlist` adÄ±ndaki kendi modÃ¼lÃ¼mÃ¼zÃ¼n kaynak dosyasÄ±nÄ± aÅŸaÄŸÄ±daki gibi yazÄ±yoruz.
```C
// YazÄ±lan 'personlist.c' dosyasÄ±na eklenenler.

#include <stddef.h>
#include <stdlib.h>
#include "person.h"
#include "personlist.h"


typedef struct Node {
    Person per;
    struct Node* pnext;
} Node; 

// 'static' olarak bildirilen yapÄ± Ã¼yeleri kaynak dosya dÄ±ÅŸÄ±ndan eriÅŸime kapatÄ±lmÄ±ÅŸtÄ±r.

static Node* gphead = NULL; // Listedeki ilk dÃ¼ÄŸÃ¼mÃ¼n adres deÄŸerini tutacak olan global deÄŸiÅŸken tanÄ±mÄ±.
static int gcount = 0; // Veri yapÄ±sÄ±ndaki eleman sayÄ±sÄ± tutacak olan global deÄŸiÅŸken tanÄ±mÄ±.

static Node* create_node(void)
{
    Node* p = (Node*)malloc(sizeof(Node));
    if(!p){
        printf("cannot allocate memory!\n");
        exit(EXIT_FAILURE);
    }

    return p;
}

int is_empty()
{
    return gcount == 0;
    // return gphead == NULL;
    // return !gphead;
}

int get_list_size(void)
{
    return gcount;
}

void printf_list(void)
{
    // Ä°lk dÃ¼ÄŸÃ¼mden baÅŸlanÄ±larak gÃ¶sterici 'NULL pointer' olana kadar tÃ¼m dÃ¼ÄŸÃ¼mler gezilip 'print_person' fonksiyonu kullanÄ±larak yazdÄ±rÄ±lÄ±yor.
    for(Node* p = gphead; p != NULL; p = p->pnext){
        print_person(&p->per);
    }

    printf("~~~~~~~~~~~~~~~~");
}

void get_fist(Person* p)
{
    if(is_empty()){
        printf("bos liste hatasi.\n");
        exit(EXIT_FAILURE);
    }

    *p = gphead->per;
}

// Listenin baÅŸÄ±na eleman ekleme iÅŸlemini yapan fonksiyon.
void push_front(const Person* p)
{
    Node* pnewnode = create_node();
    pnewnode->per = *p;
    pnewnode->pnext = gphead;
    gphead = pnewnode;

    ++gcount;
}

void pop_front(void)
{
    if(is_empty()){
        printf("bos listeden pop hatasi.\n");
        exit(EXIT_FAILURE);
    }

    Node* ptemp = gphead;
    gphead = gphead->pnext;

    free(ptemp); // Silinen dÃ¼ÄŸÃ¼m nesnesinin bellek alanÄ± iade ediliyor.
    --gcount;
}

void make_empty(void)
{
    while(!is_empty())
        pop_front();
}
```



ğŸ‘‡ AÅŸaÄŸÄ±da dÃ¶rdÃ¼ncÃ¼ sÄ±nama programÄ± gÃ¶rÃ¼lebilir, `person` listesine n tane person ekleyelim, ve `printlist` fonksiyonuyla eklenen Ã¶ÄŸeleri yazdÄ±ralÄ±m ama bu defa standart olmayan `system` fonksiyonu ile konsolu temizleyelim.
```C
#include <stdio.h>
#include <time.h>
#include "personlist.h"
#include "nutility.h"

int main(void)
{
    randomize();
    
    int n = rand() % 10 + 10;

    Person per;

    for(int i = 0; i < n; ++i){
        set_random_person(&per);
        push_front(&per);
    }

    while(!is_empty()){
        printf("listede %d kisi var.\n", get_list_size());
        print_list();
        pop_front();
        (void)getchar(); // Program burada kullanÄ±cÄ±dan bir tuÅŸa basmasÄ± beklenilerek durduruluyor.
        system("cls"); // Burada konsoldaki karakterlerin hepsi siliniyor, 
    }
}
```


ğŸ‘† YukarÄ±da yazÄ±lan sÄ±nama kodlarÄ±nÄ± Ã§alÄ±ÅŸtÄ±rÄ±p incelemelisin, yoksa liste yapÄ±sÄ±nÄ± incelemek iÃ§in yazÄ±lmÄ±ÅŸ olan kodlarÄ± anlayamazsÄ±n.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.35-10.51 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


ğŸ‘† YukarÄ±da yazdÄ±ÄŸÄ±mÄ±z `personlist` adÄ±ndaki modÃ¼l bu haliyle sadece tek bir **Signly Linked List(Tekli BaÄŸlÄ± Liste)** kullanÄ±mÄ±na izin vermektedir, bu modÃ¼l ile birbirinden ayrÄ± olarak iki ayrÄ± **Signly Linked List(Tekli BaÄŸlÄ± Liste)** nesneler oluÅŸturamayÄ±z.


## Handle TekniÄŸi


C kÃ¼tÃ¼phanelerinin bÃ¼yÃ¼k Ã§oÄŸunluÄŸunda **handle tekniÄŸi** kullanÄ±lÄ±yor, bu baÅŸlÄ±k altÄ±nda **handle tekniÄŸi** nedir, neden Ã¶nemli, nasÄ±l kullanÄ±lÄ±r bu tekniÄŸi inceleyeceÄŸiz. </br>
**Handle tekniÄŸi** temelde oluÅŸturulacak bir yapÄ± nesnesinin belleÄŸe alÄ±nmasÄ± ve bellekten silinmesi iÅŸlemlerini yÃ¶netmek iÃ§in iki ayrÄ± fonksiyon kullanÄ±lmasÄ± tekniÄŸidir. C++, C#, Java gibi dillerde olan **class(sÄ±nÄ±f)** aracÄ±ndaki **constructor** ve **deconstructor** fonksiyonlarÄ± **handle tekniÄŸinin** ileri bir kullanÄ±mÄ± olarak dÃ¼ÅŸÃ¼nÃ¼lebilir. </br>
C++ dilinde bulunan C dilindeki **struct(yapÄ±)** aracÄ±ndan daha fazla Ã¶zelliÄŸe sahip olan **class(sÄ±nÄ±f)** aracÄ± bulunuyor, sÄ±nÄ±flarÄ±n **constructor** ve **deconstructor** adÄ±nda Ã¶zel Ã¼ye fonksiyonlarÄ± bulunuyor, bu fonksiyonlar **class(sÄ±nÄ±f)** tÃ¼rÃ¼nden nesneleri belleÄŸe Ã§Ä±karmak ve bellekten silmek iÃ§in kullanÄ±lmaktadÄ±r.


YukarÄ±da yazdÄ±ÄŸÄ±mÄ±z `personlist` modÃ¼lÃ¼ sadece tek bir **instance** oluÅŸturulabilecek durumda ama aynÄ± anda birden fazla `personlist` tÃ¼rÃ¼nden farklÄ± **instance** oluÅŸturulabilmesi kullanÄ±ÅŸlÄ±lÄ±k aÃ§Ä±sÄ±ndan Ã¶nemlidir, bunun iÃ§in **Handle TekniÄŸini** kullanacaÄŸÄ±z. Bu baÅŸlÄ±ÄŸÄ±n anlaÅŸÄ±lmasÄ± Ã§ok Ã¶nemli.



ğŸ“Œ Ã–yle bir gerÃ§ekleÅŸtirim yapalÄ±m ki mÃ¼ÅŸteri kodlar diledikleri zaman diledikleri kadar `Person` tÃ¼rÃ¼nden liste oluÅŸturabilsinler.



**Cleanup Code**: **Handle tekniÄŸi** ile oluÅŸturulan kÃ¼tÃ¼phenelerde kullanÄ±cÄ± kodun ilgili kÃ¼tÃ¼pheneden Ã¼rettiÄŸi neslelerle iÅŸi bittiÄŸinde sistemden alÄ±nan kaynaklarÄ±n iade edilmesi gerekiyor, iÅŸte bu kaynak iade iÅŸlemini yapacak kodlara "**cleanup Code**" deniliyor. **Handle tekniÄŸinde** bu iÅŸlemi **deconstructor** durumundaki fonksiyondur.

KullanÄ±cÄ±(client) kodlarÄ±n **handle tekniÄŸi** ile oluÅŸturulan yapÄ± nesneleri ile iÅŸi bittikten sonra alÄ±nan bellek alanlarÄ±nÄ±n iade edilmesi, aÃ§Ä±lan dosyalarÄ±n kapatÄ±lmasÄ± vb. iÅŸlemlerini yapmak gerekiyor. 

â—â—â— **Handle tekniÄŸinde** iki tane Ã¶nemli fonksiyon var, bunlar;
- Nesneyi oluÅŸturmak iÃ§in kullanÄ±lan fonksiyon(bu fonksiyonun yaptÄ±ÄŸÄ±nÄ± C dilini temel alan OOP dillerinde yapan **constructor** olarak nitelenen fonksiyonu bulunmaktadÄ±r)
- Nesneyle iÅŸlemler bittikten sonra kullanÄ±lan kaynaklarÄ± iade etmek iÃ§in kullanÄ±lan fonksiyon(bu fonksiyonun yaptÄ±ÄŸÄ±nÄ± C dilini temel alan OOP dillerinde yapan **deconstructor** olarak nitelenen fonksiyonu bulunmaktadÄ±r)


â—â—â— **Handle tekniÄŸinde** bulunan iki tane Ã¶nemli fonksiyonun adlandÄ±rÄ±lmasÄ±nda uyulan yaklaÅŸÄ±mlar aÅŸaÄŸÄ±daki gibidir;
- BaÅŸtatÄ±cÄ± fonksiyona iÃ§inde **create** geÃ§en ad vermek ve sonlandÄ±ran fonksiyona iÃ§inde **destroy** geÃ§en ad vermek.
- BaÅŸtatÄ±cÄ± fonksiyona iÃ§inde **open** geÃ§en ad vermek ve sonlandÄ±ran fonksiyona iÃ§inde **close** geÃ§en ad vermek.



â—â—â— Linux/Unix sistem programlama tarafÄ±nda nerdeyse bÃ¼tÃ¼n sistem **handle tekniÄŸi** Ã¼zerine kuruludur.


ğŸ‘‡ AÅŸaÄŸÄ±daki programdan, sonraki derslerde gÃ¶receÄŸimiz dosya iÅŸlemlerinin yapÄ±lmasÄ±nÄ± saÄŸlayan kÃ¼tÃ¼phane modÃ¼lÃ¼nde **handle tekniÄŸi** kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include "personlist.h"
#include "nutility.h"

int main(void)
{
    File* f = fopen("filex.txt", "w"); // Dosya iÅŸleminin yapÄ±lmasÄ±nÄ± saÄŸlayan nesnenin adresini almak iÃ§in 'fopen' fonksiyonu kullanÄ±lÄ±yor.
    
    fprint(f, "naber");

    fclose(f); // Dosya iÅŸleminin yapÄ±lmasÄ±nÄ± saÄŸlayan nesne ile yapÄ±lan iÅŸlemler bittikten sonra kaynaklarÄ± iade etmek iÃ§ins 'fclose' fonksiyonu kullanÄ±lÄ±yor.
}
```


âœï¸ Burada `personlist` adÄ±ndaki kendi modÃ¼lÃ¼mÃ¼zÃ¼n baÅŸlÄ±k dosyasÄ±nÄ± yeniden **handle tekniÄŸi** ile yazÄ±yoruz.
```C
// YazÄ±lan 'personlist.h' dosyasÄ±na eklenenler.

#ifndef PERSONLIST_H
#define PERSONLIST_H

#include "person.h" 

struct Person;

// 'get_first' fonksiyonu kendisine geÃ§ilen 'Person' tÃ¼rÃ¼nden gÃ¶stericiye listedeki ilk nesnenin adresini atar.
void get_first(Person*);

typedef struct List List; // Burada 'struct List' tÃ¼rÃ¼ 'incomplate type' durumundadÄ±r ve bu nedenle 'person.h' arayÃ¼zÃ¼nÃ¼ kullanacak kullanÄ±cÄ± kodlar 'struct List' tÃ¼rÃ¼nÃ¼n Ã¶ÄŸelerini bilmediÄŸi iÃ§in kullanamaz.
typedef struct List* ListHandle;

ListHandle create_list(void);
void destroy_list(ListHandle);

// TÃ¼m fonksiyonlarÄ±n ilk parametreleri 'ListHandle' tÃ¼r eÅŸ adÄ± olacak biÃ§imde gÃ¼ncelleme yapÄ±yoruz, bu yÃ¶ntemle modÃ¼lÃ¼mÃ¼z birden fazla farklÄ± tekli baÄŸlÄ± listeye hizmet verebilece hale geliyor.
void get_first(ListHandle, const Person*);
void push_front(ListHandle, const Person*);
void pop_front(ListHandle);
int get_list_size(ListHandle);
int is_empty(ListHandle);
void make_empty(ListHandle);
void print_list(ListHandle);

#endif
```



âœï¸ Burada `personlist` adÄ±ndaki kendi modÃ¼lÃ¼mÃ¼zÃ¼n kaynak dosyasÄ±nÄ± yeniden **handle tekniÄŸini** ile yazÄ±yoruz.
```C
// YazÄ±lan 'personlist.c' dosyasÄ±na eklenenler.

#include <stddef.h>
#include <stdlib.h>
#include "person.h"
#include "personlist.h"


typedef struct Node {
    Person per;
    struct Node* pnext;
} Node; 


// Birden fazla farklÄ± liste oluÅŸturulabilmesi iÃ§in eklenen modÃ¼l Ã¶ÄŸesi, herbir liste nesnesini ayÄ±rabilmek iÃ§in 'gphead' ve 'gcount' deÄŸiÅŸkenleri bir yapÄ±da toplandÄ±. 
struct List {
    Node* gphead; // Listedeki ilk dÃ¼ÄŸÃ¼mÃ¼n adres deÄŸerini tutacak olan global deÄŸiÅŸken tanÄ±mÄ±.
    int gcount; // Veri yapÄ±sÄ±ndaki eleman sayÄ±sÄ± tutacak olan global deÄŸiÅŸken tanÄ±mÄ±.
};


// 'personlist' modÃ¼lÃ¼nÃ¼ kullanÄ±rken nesne oluÅŸturmak iÃ§in kullanÄ±lacak olan kurucu fonksiyon.
ListHandle create_list(void)
{
    ListHandle h = (ListHandle)malloc(sizeof(struct List));
    if(!h)
        return NULL;

    h->gphead = NULL;
    h->gcount = 0;

    return h;
}


static Node* create_node(void)
{
    Node* p = (Node*)malloc(sizeof(Node));
    if(!p){
        printf("cannot allocate memory!\n");
        exit(EXIT_FAILURE);
    }

    return p;
}


int is_empty(ListHandle h)
{
    return h->gcount == 0;
    // return h->gphead == NULL;
    // return !h->gphead;
}


int get_list_size(ListHandle h)
{
    return h->gcount;
}


void printf_list(ListHandle h)
{
    // Ä°lk dÃ¼ÄŸÃ¼mden baÅŸlanÄ±larak gÃ¶sterici 'NULL pointer' olana kadar tÃ¼m dÃ¼ÄŸÃ¼mler gezilip 'print_person' fonksiyonu kullanÄ±larak yazdÄ±rÄ±lÄ±yor.
    for(Node* p = h->gphead; p != NULL; p = p->pnext){
        print_person(&p->per);
    }

    printf("~~~~~~~~~~~~~~~~");
}


void get_fist(ListHandle h, Person* p)
{
    if(is_empty(h)){
        printf("bos liste hatasi.\n");
        exit(EXIT_FAILURE);
    }

    *p = h->gphead->per;
}


// Listenin baÅŸÄ±na eleman ekleme iÅŸlemini yapan fonksiyon.
void push_front(ListHandle h, const Person* p)
{
    Node* pnewnode = create_node();
    pnewnode->per = *p;
    pnewnode->pnext = h->gphead;
    h->gphead = pnewnode;

    ++h->gcount;
}


void pop_front(ListHandle h)
{
    if(is_empty(h)){
        printf("bos listeden pop hatasi.\n");
        exit(EXIT_FAILURE);
    }

    Node* ptemp = h->gphead;
    h->gphead = h->gphead->pnext;

    free(ptemp); // Silinen dÃ¼ÄŸÃ¼m nesnesinin bellek alanÄ± iade ediliyor.
    --h->gcount;
}


void make_empty(ListHandle h)
{
    while(!is_empty(h))
        pop_front(h);
}

void destroy_list(ListHandle h)
{
    make_empty(h);
    free(h);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda en son **handle tekniÄŸine** gÃ¶re oluÅŸturduÄŸumuz `personlist` kÃ¼tÃ¼phane modÃ¼lÃ¼mÃ¼zÃ¼ sÄ±nama iÅŸlemleri incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "person.h"
#include "personlist.h"

void bar(void)
{
    printf("bar cagirildi.\n");
    printf("Person listesi oluÅŸturuluyor.\n");

    ListHandle h = create_list();
    Person p;
    
    for(int i = 0; i < 5; ++i){
        set_random_person(&p);
        push_front(h, &p);
    }

    printf("var'daki listede %d kisi var.\n", get_list_size(h));
    print_list(h);
    destroy_list(h);
    printf("bar sona erdi.\n");
    (void) getchar();
}


void foo(void)
{
    printf("foo cagirildi.\n");
    printf("Person listesi oluÅŸturuluyor.\n");

    ListHandle h = create_list();
    Person p;
    
    for(int i = 0; i < 5; ++i){
        set_random_person(&p);
        push_front(h, &p);
    }
    bar();

    printf("foo 'daki listede %d kisi var.\n", get_list_size(h));
    print_list(h);
    destroy_list(h);
    printf("foo sona erdi.\n");
    (void) getchar();
}


int main(void)
{
    printf("main cagirildi.\n");
    printf("Person listesi oluÅŸturuluyor.\n");

    ListHandle h = create_list();
    Person p;
    
    for(int i = 0; i < 16; ++i){
        set_random_person(&p);
        push_front(h, &p);
    }

    foo();

    printf("main'deki listede %d kisi var.\n", get_list_size(h));
    print_list(h);
    destroy_list(h);
    printf("bar sona erdi.\n");
    (void) getchar();
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda 1000 tane liste nesnesinin nasÄ±l oluÅŸturulup kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "person.h"
#include "personlist.h"


#define SIZE 1000

int main(void)
{
    ListHandle handles[SIZE];

    randomize();

    for(int i = 0; SIZE; ++i){
        handles[i] = create_list();
    }

    // Her listeye 5-25 arasÄ±nda Perfon nesnesi ekleyelim.
    Person per;

    for(int i = 0; SIZE; ++i){
        int n = rand() % 20 + 5;
        while(n--){
            set_random_person(&per);
            pust_front(handles[i], &per);
        }
    }

    for(int i = 0; SIZE; ++i){
        print("%d. listede %d kisi var.\n ", i + 1, get_list_size(handles[i]));
        print_list(handles[i]);
        (void) getchar();
        ststem("cls"); // Ekran siliniyor.
    }

    // Momoer leak oluÅŸmamasÄ± iÃ§in bellek kaynaÄŸÄ± iade ediliyor.
    for(int i = 0; SIZE; ++i){
        destroy_list(handles[i]);
    }
}
```



â—â—â— Bir yapÄ±nÄ±n elemanlarÄ±nÄ± gizlemek iÃ§in en sÄ±k kullanÄ±lan yÃ¶ntemlerden biri baÅŸlÄ±k dosyasÄ±nda ilgili deÄŸiÅŸkenlerin **incomplate type** yapÄ±lmasÄ±dÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `ListHandle` tÃ¼rÃ¼nÃ¼n `personlist.h` baÅŸlÄ±k dosyasÄ±nda **incomplate type** durumda olmasÄ±ndan kaynaklÄ± alÄ±nacak sÃ¶zdizim hatasÄ± incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "person.h"
#include "personlist.h"

int main(void)
{
    ListHandle h = create_list();

    h->gpfirst(); // Burada sÃ¶zdizimi hatasÄ± alÄ±nacaktÄ±r Ã§Ã¼nkÃ¼ 'incomplate type' bir nesneye eriÅŸilmeye Ã§alÄ±ÅŸÄ±lÄ±yor.
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 11.53-12.00 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


## Alignment(Hizalama)

DeÄŸiÅŸkenler oluÅŸturulduÄŸunda, derleyiciyi bu deÄŸiÅŸkenlere bellekten yer ayarlar ve derleyicinin deÄŸiÅŸkenlere ayÄ±rdÄ±ÄŸÄ± yerin adresleri var, derleyici hansi sistem(donanÄ±m + varsa iÅŸletim sistemi) iÃ§in derleyici ise o sistemin gereklerine uygun biÃ§imde bellekten yer ayarlamaktadÄ±r. </br>
Her derleyici derlediÄŸi kaynak dosyadaki deÄŸiÅŸkenlerin bellekteki adreslerinin ne olacaÄŸÄ±na derleme iÅŸlemini yaptÄ±ÄŸÄ± sistemin kurallarÄ±na gÃ¶re belirlemektedir.



â—â—â—
**Alignment Requirement(Hizalama gereksinimleri)**: Derleyicilerin sistemin gereklerine gÃ¶re kaynak dosyalardaki deÄŸiÅŸkenlerin bellekte bulunacaÄŸÄ± adreslerin ne olacaÄŸÄ±na(baÅŸlangÄ±ÅŸ adresi) karar verirken, bazÄ± deÄŸiÅŸkenleri herhangi bir adrese, bazÄ± deÄŸiÅŸkenleri sadece ikinin katÄ± olan adreslere, bazÄ± deÄŸiÅŸkenleri sadece dÃ¶rdÃ¼n katÄ± olan adreslere, bazÄ± deÄŸiÅŸkenleri sadece sekizin katÄ± olan adreslere vb. yerleÅŸtirmesi durumuna verilen addÄ±r.

BazÄ± durumlarda **alignment requirement(hizalama gereksinimleri)** kurallarÄ±na uyulmasÄ± donanÄ±msal zorunluluktan dolayÄ± mecburidir, bazÄ± donanÄ±mlarda belirli deÄŸiÅŸkenlerin belirli bir belleÄŸe yerleÅŸtirilmesi gerekiyor, aksi halde Ã§alÄ±ÅŸma zamanÄ±nda iÅŸlemcide hata oluÅŸacaktÄ±r. </br>
BazÄ± durumlarda **alignment requirement(hizalama gereksinimleri)** kurallarÄ±na uyulmasÄ± donanÄ±msal zorunluluk olmamakla birlikte derlenmiÅŸ kodun donanÄ±m Ã¼zerinde yavaÅŸ Ã§alÄ±ÅŸmasÄ±na neden olabilir.


BÃ¼tÃ¼n sistemlerde **alignment requirement(hizalama gereksinimleri)** var ama kurallar sistemden sisteme farklÄ±dÄ±r, mesela `int` tÃ¼rÃ¼nÃ¼n 2'nin katÄ± olan yoksa 4'Ã¼n katÄ± olan bir belleÄŸe yerleÅŸtirilmesinin gerekmesi durumu sistemden sisteme deÄŸiÅŸebilir.



**Absract Binary Interface**: **Alignment requirement(hizalama gereksinimleri)** kurallarÄ±nÄ±n dokÃ¼mente edildiÄŸi yerdir. Her bir derleyicinin Ã¼zerinde Ã§alÄ±ÅŸacaÄŸÄ± sisteme(donanÄ±m + varsa iÅŸletim sistemi) Ã¶zel olarak ayrÄ± ayrÄ± **absract binary interface** dokÃ¼manÄ± mevcuttur.


Mesela Microsoft C derleyicisinde `int` tÃ¼rÃ¼ iÃ§in **Alignment Requirement** 4'Ã¼n katlarÄ± olan bellek alanlarÄ±na yerleÅŸtirilmektedir.


C99 standardÄ±ndan Ã¶nce **alignment requirement(hizalama gereksinimleri)** deÄŸerini elde etmenin standart bir yolu yoktu, C99 standardÄ±yla dile eklenen bir operatÃ¶r ile bir tÃ¼rÃ¼n **alignment requirement(hizalama gereksinimleri)** deÄŸerinin ne olduÄŸu Ã¶ÄŸrenilebiliyor.

`_Alignof` ve `_Alignas` operatÃ¶rleri C99 standardÄ±yla dile eklenmiÅŸtir. AyrÄ±ca `stdalign.h` baÅŸlÄ±k dosyasÄ±nda `_Alignof` operatÃ¶rÃ¼ iÃ§in `alignof` ve `_Alignas` operatÃ¶rÃ¼ iÃ§in `aligas` tÃ¼r eÅŸ adÄ± bulunmaktadÄ±r, `sizeof` operatÃ¶rÃ¼ gibi bu operatÃ¶rler de derleme zamanÄ± operatÃ¶rleridir.




ğŸ‘‡ AÅŸaÄŸÄ±daki programda `alignof` kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdalign.h>
#include <stdio.h>

int main(void)
{
    printf("%zu\n", alignof(int));
    printf("%zu\n", alignof(double));
    printf("%zu\n", alignof(char));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `int` tÃ¼rÃ¼nÃ¼n gÃ¶stericisinin adres deÄŸerini bir tam sayÄ± tÃ¼rÃ¼nden deÄŸiÅŸkende veri kaybÄ± olmaksÄ±zÄ±n tutmak iÃ§in C99 ile dile eklenen `uintptr_t` tÃ¼r eÅŸ adÄ±nÄ±n kullanÄ±labileceÄŸi gÃ¶rÃ¼lebilir.
```C
#include <stdio.h>
#include <stdint.h> // uintptr_t iÃ§in eklendi.

int main(void)
{
    int x  = 30;
    int* ptr = &x;

    printf("%p\n", ptr); // 'ptr' pointer deÄŸiÅŸkenin deÄŸeri olan adres standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderiliyor.
    printf("Adress in decimal: %ju\n", (uintmax_t)(uintptr_t)ptr); // 'ptr' pointer deÄŸiÅŸkenin adres deÄŸerini tam sayÄ± tÃ¼rÃ¼nden kayÄ±psÄ±z biÃ§imde elde edebilmek iÃ§in ilk Ã¶nce 'uintptr_t' tÃ¼rÃ¼ne Ã§evriliyor, ardÄ±ndan 'uintmax_t' tÃ¼r eÅŸ adÄ± sistemdeki tam sayÄ± tÃ¼rlerinden en bÃ¼yÃ¼ÄŸÃ¼nÃ¼ temsil etmektedir.

    double dval  = 232.534;
    printf("Adress in decimal: %ju\n", (uintmax_t)(uintptr_t)&dval); // 'dval' deÄŸiÅŸkeninin adresini tam sayÄ± tÃ¼rÃ¼nden kayÄ±psÄ±z biÃ§imde elde edebilmek iÃ§in ilk Ã¶nce 'uintptr_t' tÃ¼rÃ¼ne Ã§evriliyor, ardÄ±ndan 'uintmax_t' tÃ¼r eÅŸ adÄ± sistemdeki tam sayÄ± tÃ¼rlerinden en bÃ¼yÃ¼ÄŸÃ¼nÃ¼ temsil etmektedir.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `double` ve `long double` tÃ¼rlerinin **alignment requirement(hizalama gereksinimleri)** deÄŸerlerinin ne olduÄŸu incelenebilir.
```C
#include <stdio.h>
#include <stdint.h> // uintptr_t iÃ§in eklendi.
#include <stdalign.h>

int main(void)
{
    printf("%zu\n", alignof(double));
    printf("%zu\n", alignof(long double));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `Nec` adÄ±ndaki yapÄ± tÃ¼rÃ¼nÃ¼n **alignment requirement(hizalama gereksinimleri)** deÄŸerlerinin ne olduÄŸu incelenebilir.
```C
#include <stdio.h>
#include <stdint.h>
#include <stdalign.h>

typedef struct {
    int x, y;
    double d;
    short s;
} Nec;


int main(void)
{
    printf("%zu\n", alignof(Nec)); // 'Nec' yapÄ±sÄ±nÄ±n 'alignment requirement' deÄŸeri standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderiliyor.
}
```



â—â—â— YapÄ± tÃ¼rlerinin **alignment requirement(hizalama gereksinimleri)** deÄŸerleri, yapÄ±nÄ±n Ã¶ÄŸesi olan en bÃ¼yÃ¼k **alignment requirement(hizalama gereksinimleri)** deÄŸerlerine sahip olan tÃ¼rÃ¼n **alignment requirement(hizalama gereksinimleri)** deÄŸerleridir.



**Alignment Requirement** neden ilgilendiriyor;
- YapÄ± tÃ¼rlerinin bellekte hangi adreslere konumlandÄ±rÄ±labileceÄŸi bilgisi aÃ§Ä±sÄ±ndan bizi ilgilendiriyor. 
- BazÄ± iÅŸlemcilerde bazÄ± iÅŸlemci komutlarÄ±ndan yararlanabilmek iÃ§in sÄ±radan bir tÃ¼rÃ¼n **alignment requirement(hizalama gereksinimleri)** deÄŸerlerinin Ã¼zerinde bir **alignment requirement(hizalama gereksinimleri)** deÄŸerlerinin kullanÄ±lmasÄ± gerekiyor, mesela programÄ±n Ã¼zerinde Ã§alÄ±ÅŸacaÄŸÄ± bir iÅŸlemcide olan **SIMD(Single Instruction Multiple Data)** komutlarÄ±ndan yararlanabilmek iÃ§in **alignment requirement(hizalama gereksinimleri)** deÄŸerlerinin en az 8 olmasÄ± gerekebilir. Bu kullanÄ±m bu kursun kapsamÄ±nÄ± biraz aÅŸmaktadÄ±r, daha derin bilgi iÃ§in ayrÄ±ca araÅŸtÄ±rabilirsin.


**Padding Bytes or Hole Bytes**: **alignment requirement(hizalama gereksinimleri)** deÄŸerlerinden dolayÄ± bellekte tutulan veri tÃ¼rlerinin bellekte hizalanmasÄ±nda aralarda bÄ±rakÄ±lan kullanÄ±lmayan boÅŸ byte deÄŸerleridir.



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programda farklÄ± yapÄ± tÃ¼rlerinin bellekte ne kadar yer kaplayacaklarÄ± gÃ¶rÃ¼lebilir. </br> 
Bu programÄ± anlamak bu dersin en Ã¶nemlim noktalarÄ±ndan biridir.
```C
#include <stdio.h>
#include <stdint.h>
#include <stdalign.h>

// 'Nec1' tÃ¼rÃ¼nden bir yapÄ± nesnesi, sistemde int tÃ¼rÃ¼ 4 byte ise, bellekte 12 byte yer kaplayacaktÄ±r.
typedef struct {
    char c1;
    int i;
    char c2;
} Nec1;


// 'Nec2' tÃ¼rÃ¼nden bir yapÄ± nesnesi, sistemde int tÃ¼rÃ¼ 4 byte ise, bellekte 8 byte yer kaplayacaktÄ±r.
typedef struct {
    char c1;
    char c2;
    int i;
} Nec2;


// 'Nec3' tÃ¼rÃ¼nden bir yapÄ± nesnesi, sistemde int tÃ¼rÃ¼ 4 byte ise, bellekte 8 byte yer kaplayacaktÄ±r.
typedef struct {
    char c1;
    char c2;
    char c3;
    int i;
} Nec3;


// 'Nec4' tÃ¼rÃ¼nden bir yapÄ± nesnesi, sistemde int tÃ¼rÃ¼ 4 byte ise, bellekte 8 byte yer kaplayacaktÄ±r.
typedef struct {
    char c1;
    char c2;
    char c3;
    char c4;
    int i;
} Nec4;


// 'Nec5' tÃ¼rÃ¼nden bir yapÄ± nesnesi, sistemde int tÃ¼rÃ¼ 4 byte ise, bellekte 12 byte yer kaplayacaktÄ±r.
typedef struct {
    char c1;
    int i;
    char c2;
    char c3;
    char c4;
    char c5;
} Nec5;


// 'Nec6' tÃ¼rÃ¼nden bir yapÄ± nesnesi, sistemde int tÃ¼rÃ¼ 4 byte ise, bellekte 12 byte yer kaplayacaktÄ±r.
typedef struct {
    char c1;
    char c2;
    int i;
    char c3;
    char c4;
} Nec6;


// 'Nec7' tÃ¼rÃ¼nden bir yapÄ± nesnesi, sistemde int tÃ¼rÃ¼ 4 byte ise, bellekte 28 byte yer kaplayacaktÄ±r.
typedef struct {
    char c1;
    int i1;
    char c2;
    int i2;
    char c3;
    int i3;
    char c4;
} Nec7;


int main(void)
{
    printf("sizeof(Nec1) = %zu\n", sizeof(Nec1));
    printf("sizeof(Nec2) = %zu\n", sizeof(Nec2));
    printf("sizeof(Nec3) = %zu\n", sizeof(Nec3));
    printf("sizeof(Nec4) = %zu\n", sizeof(Nec4));
    printf("sizeof(Nec5) = %zu\n", sizeof(Nec5));
    printf("sizeof(Nec6) = %zu\n", sizeof(Nec6));
    printf("sizeof(Nec7) = %zu\n", sizeof(Nec7));
}
```


â—â—â— ğŸ‘† YukarÄ±daki program detaylÄ± bir biÃ§imde incelenirse, o programdan ÅŸu sonuca varÄ±lacaktÄ±r: Bir yapÄ± tÃ¼rÃ¼nÃ¼n Ã¶ÄŸeleri **alignment requirement(hizalama gereksinimleri)** deÄŸerlerleri gÃ¶z Ã¶nÃ¼ne alÄ±narak sÄ±ralanÄ±rsa o yapÄ±n nesnesinin bellekte kaplayacaÄŸÄ± alan ve o yapÄ± nesnesinin bellek alanÄ±ndaki **Padding Bytes** o kadar az olacaktÄ±r.


âš ï¸âš ï¸âš ï¸ BazÄ± derleyiciler **compiler switch** ayarlarÄ± ile ya da `#pragma` makrolar ile deÄŸiÅŸkenlerin **alignment requirement(hizalama gereksinimleri)** deÄŸerlerini dikkate almamasÄ± saÄŸlanabiliyor, ama bu duruma programÄ±n Ã¼zerinde koÅŸacaÄŸÄ± donanÄ±mÄ±n izin veriyor olmasÄ± gerekir ve programÄ±n da bu duruma gÃ¶re yazÄ±lmÄ±ÅŸ olmasÄ± gerekir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Microsoft C derleyicisinde `#pragma` kullanÄ±mÄ± ile derleye deÄŸiÅŸkenlerin **alignment requirement(hizalama gereksinimleri)** deÄŸerlerini dikkate almadan belleÄŸe Ã§Ä±kartmasÄ± sÃ¶ylenebileceÄŸi incelenebilir.
```C
#include <stdio.h>
#include <stdint.h>
#include <stdalign.h>

#pragma pack(1) // Microsoft C derleyicisinde geÃ§erli

typedef struct {
    char c1;
    int i;
    char c2;
} Nec;


int main(void)
{
    printf("sizeof(Nec) = %zu\n", sizeof(Nec));
}
```



â—â—â— C dilinin standardÄ± bir yapÄ± tÃ¼rÃ¼nden bir yapÄ± nesnesinin ilk elemanÄ±nÄ±n adresi ile yapÄ± nesnesinin kendi adresinin(sayÄ±sal olarak) aynÄ± olacaÄŸÄ±nÄ± belirtir, yani bir yapÄ± nesnesinin ilk Ã¶ÄŸesinin adresinin yapÄ± tÃ¼rÃ¼ne tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapÄ±lmasÄ± kullanÄ±lan bir yÃ¶ntemdir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `#pragma pack(1)` makrosunun kullanÄ±mÄ± ile **Padding Bytes** oluÅŸmadan makine kodu Ã¼retileceÄŸi incelenebilir.
```C
#include <stdio.h>
#include <stdint.h>
#include <stdalign.h>

#pragma pack(1) // Microsoft C derleyicisinde geÃ§erli

typedef struct {
    int x, y;
    double z;
} Nec;


int main(void)
{
    Nec nec1 = { 4, 6, 4.2342 };
    printf("%d\n", *(int)&nec1);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `#pragma pack(1)` makrosunun kullanÄ±mÄ± ile **Padding Bytes** oluÅŸmadan makine kodu Ã¼retileceÄŸi incelenebilir.
```C
#include <stdio.h>
#include <stdint.h>
#include <stdalign.h>

#pragma pack(1) // Microsoft C derleyicisinde geÃ§erli

typedef struct {
    double z;
    int x, y;
} Nec;


int main(void)
{
    Nec nec1 = { 6.2761, 4, 6 };
    printf("%f\n", *(double*)&nec1);
}
```


â—â—â— ğŸ‘† YukarÄ±daki iki programdan anlaÅŸÄ±labileceÄŸi gibi bir yapÄ± nesnesinin baÅŸÄ±na **Padding Bytes** bulunmaz.

 
> â” 
> 
> Sorulan soru;
> 
> Ayni sekilde alignmenti 4 olan bir nec nesnesini dinamik olarak yaratirken derleyici baslangic adresini 4'e bÃ¶lÃ¼nencek sekilde secer diyebilir miyiz?
> 
> Cevap;
> 
> Evet.



### **Padding Bytes** Bizi Neden Ä°lgilendiriyor 

**Padding Bytes** bilgisinin ne anlama geldiÄŸi aÅŸaÄŸÄ±da maddeler haline dizilenmiÅŸtir, inceleyebilirsin;

1. Bir YapÄ± nesnesinin bir elemanÄ±nÄ±n adresinden haraketle bir baÅŸka elemanÄ±na eriÅŸirken **pedding byte** durumundaki byte'lar dikkate alÄ±nmak zorundadÄ±r. Ã–zellikle gÃ¶mÃ¼lÃ¼ sistem programlama tarafÄ±nda bu durum dikkate alÄ±nmadÄ±ÄŸÄ± iÃ§in sÄ±k hata yapÄ±lmaktadÄ±r.

    
    ğŸ‘‡ AÅŸaÄŸÄ±daki program bir yapÄ± nesnesinin ilk deÄŸiÅŸkeninden haraketle **pedding byte** durumundaki byte'larÄ±n dikkate alÄ±ndÄ±ÄŸÄ± ve alÄ±nmadÄ±ÄŸÄ± durumda ne olacaÄŸÄ±nÄ± anlamak iÃ§in incelenebilir.
    ```C
    #include <stdio.h>
    #include <stdint.h>
    #include <stdalign.h>

    typedef struct {
        char c1;
        int ival;
        char c2;
    } Nec;

    int main(void)
    {
        Nec nec1 = { 1, 3, 5 };
        char * p1 = &nec1.c1;

        printf("%d\n", *(int*)(p1 + 1)); // Buradaki pointer ariptmetiÄŸi 'pedding bytes' durumundan dolayÄ± 'ub' durumuna neden olacaktÄ±r.
        printf("%d\n", *(int*)(p1 + 4)); // 'pedding bytes' deÄŸerleri atlanarak yapÄ± nesnesinin 'int' tÃ¼rÃ¼nden olan 'ival' deÄŸiÅŸkenine eriÅŸiliyor.
    }
    ```

    
    â—â—â— Standart `offsetof` fonksiyonel makrosu C mÃ¼lakatlarÄ±nda sÄ±klÄ±kla sorulmaktadÄ±r. 

2. Bir YapÄ± tÃ¼rÃ¼nden oluÅŸturulacak olan nesnelerin bellek boyutunun hesaplandÄ±ÄŸÄ± durumlarda **pedding byte** durumunun hesaba katÄ±lmasÄ± gerekecektir, `sizeof` operatÃ¶rÃ¼ bunu hesaba kattÄ±ÄŸÄ± iÃ§in tÃ¼rlerin bellek boyutunu hesaplamak iÃ§in `sizeof` operatÃ¶rÃ¼ kullanÄ±lmalÄ±dÄ±r.

3. Ä°ki yapÄ± nesnesi byte seviyesinde karÅŸÄ±laÅŸtÄ±rÄ±lÄ±rken eÄŸer yapÄ± nesnelerinde **pedding byte** bulunuyorsa ve bu byte'lar temizlenmediyse tÃ¼m elemanlarÄ±nÄ±n deÄŸeri birbirine eÅŸit olan yapÄ±lar birbirine eÅŸit deÄŸilmiÅŸ gibi gÃ¶zlemlenecektir.

    
    ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki yapÄ± nesnesinin eÅŸitliÄŸini sÄ±narken **pedding byte** dikkat edilmesi gerektiÄŸi incelenebilir.
    ```C
    #include <stdio.h>
    #include <stdint.h>
    #include <stdalign.h>
    #include <string.h>

    typedef struct {
        char c1;
        int ival;
        char c2;
    } Nec;

    int main(void)
    {
        // AÅŸaÄŸÄ±da oluÅŸturulan 'Nec' yapÄ± tÃ¼rÃ¼nden olan nesnelerda 'pedding bytes' olacaktÄ±r ve o byte'lar Ã§Ã¶p deÄŸerdedir.
        Nec nec1 = { 'a', 34242423, 'b' };
        Nec nec2 = { 'a', 34242423, 'b' };

        // AÅŸaÄŸÄ±daki nesne karÅŸÄ±laÅŸtÄ±rmasÄ± doÄŸru Ã§alÄ±ÅŸtÄ±rÄ±lacaktÄ±r ama bu kullanÄ±m deÄŸiÅŸken adlarÄ±nÄ±n yanlÄ±ÅŸ yazÄ±lma hatasÄ±na aÃ§Ä±ktÄ±r.
        if(nec1.c1 == nec2.c1 && nec1.ival == nec2.ival && nec1.c2 == nec2.c2){
            printf("evet esit.\n");
        }
        else{
            printf("hayir esit degil.\n");
        }

        // 'memcmp' fonksiyonu 'pedding bytes' bilgisinden anlamadÄ±ÄŸÄ± iÃ§in eÅŸitlik karÅŸÄ±laÅŸtÄ±rmasÄ± doÄŸru Ã§alÄ±ÅŸmayacaktÄ±r.
        if(memcmp(&nec1, &nec2, sizeof(nec1))) {
            printf("evet esit.\n");
        }
        else{
            printf("hayir esit degil.\n");
        }
    }
    ```


    
    ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki yapÄ± nesnesinin eÅŸitliÄŸini sÄ±narken **pedding bytes** dikkat edilmesi gerektiÄŸi incelenebilir.
    ```C
    #include <stdio.h>
    #include <stdint.h>
    #include <stdalign.h>
    #include <string.h>

    typedef struct {
        char c1;
        int ival;
        char c2;
    } Nec;


    int main(void)
    {
        // AÅŸaÄŸÄ±da oluÅŸturulan 'Nec' yapÄ± tÃ¼rÃ¼nden olan nesnelerda 'pedding bytes' olacaktÄ±r ve o byte'lar Ã§Ã¶p deÄŸerdedir.
        Nec nec1, nec2;

        // YapÄ± nesnelerinin byte deÄŸerleri 0 yapÄ±lÄ±yor.
        memset(&nec1, 0, sizeof(nec1)); 
        memset(&nec2, 0, sizeof(nec2));

        nec1.c1 = nec2.c1 = 56;
        nec1.c2 = nec2.c2 = 32;
        nec1.ival = nec2.ival = 214453242;

        // 'memcmp' fonksiyonu 'pedding bytes' bilgisinden anlamÄ±yor ama o byte'lar 0 olduÄŸu iÃ§in eÅŸitlik karÅŸÄ±laÅŸtÄ±rmasÄ± doÄŸru Ã§alÄ±ÅŸacaktÄ±r.
        if(memcmp(&nec1, &nec2, sizeof(nec1)){
            printf("evet esit.\n");
        }
        else{
            printf("hayir esit degil.\n");
        }
    }
    ```

    
    ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki yapÄ± nesnesinin eÅŸitliÄŸini sÄ±narken **pedding bytes** alanlarÄ±nÄ±n ilk baÅŸtan temizlenmesinden dolayÄ± yapÄ± nesnelerinin karÅŸÄ±laÅŸtÄ±rmasÄ±nÄ±n doÄŸru olacaÄŸÄ± gÃ¶rÃ¼lmelidir.
    ```C
    #include <stdio.h>
    #include <stdint.h>
    #include <stdalign.h>
    #include <string.h>

    #define clear_struct(x)         memset(&x, 0, sizeof(x))

    typedef struct {
        char c1;
        int ival;
        char c2;
    } Nec;


    int main(void)
    {
        // AÅŸaÄŸÄ±da oluÅŸturulan 'Nec' yapÄ± tÃ¼rÃ¼nden olan nesnelerda 'pedding bytes' olacaktÄ±r ve o byte'lar Ã§Ã¶p deÄŸerdedir.
        Nec nec1, nec2;

        // YapÄ± nesnelerinin byte deÄŸerleri 0 yapÄ±lÄ±yor.
        clear_struct(nec1);
        clear_struct(nec2);

        nec1.c1 = nec2.c1 = 56;
        nec1.c2 = nec2.c2 = 32;
        nec1.ival = nec2.ival = 214453242;

        // 'memcmp' fonksiyonu 'pedding bytes' bilgisinden anlamÄ±yor ama o byte'lar 0 olduÄŸu iÃ§in eÅŸitlik karÅŸÄ±laÅŸtÄ±rmasÄ± doÄŸru Ã§alÄ±ÅŸacaktÄ±r.
        if(memcmp(&nec1, &nec2, sizeof(nec1)){
            printf("evet esit.\n");
        }
        else{
            printf("hayir esit degil.\n");
        }
    }


Ders sonu ...
