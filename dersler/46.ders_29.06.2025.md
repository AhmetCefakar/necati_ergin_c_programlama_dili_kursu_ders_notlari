# 46.Ders 29.06.2025 ğŸ•˜

Derse 4(09:02)-7(09:04)-7(09:20)-8(09:33)-10(09:45)-10(10:01)-11(10:51)-12(11:15)-11(12:15)-10(12:28) kiÅŸi katÄ±ldÄ±.
---


## Standart C KÃ¼tÃ¼phanesinin `time` ModÃ¼lÃ¼(time Library)

`time` modÃ¼lÃ¼nde Ã¶ÄŸrenilecek kavramlarÄ±n her programlama dilinde karÅŸÄ±lÄ±ÄŸÄ± vardÄ±r, baÅŸka dillerde de C dilinnin standart kÃ¼tÃ¼phanesindeki `time.h` modÃ¼lÃ¼ndekine benzer iÅŸlemleri yapan o dilin standart kÃ¼tÃ¼phenesinin bir bileÅŸeni olacaktÄ±r.


**Epoch**: Bir bilgisayar sisteminde tarih-saat bilgisini sadece rakamsal olarak gÃ¶sterbilmek iÃ§in belirli bir tarih-saat anÄ±ndan itibaren geÃ§en saniye ya da salise sayÄ±sÄ± olarak tutmak istendiÄŸinde o belirli tarih-saat anÄ±na **epoch** adÄ± veriliyor.

**Time-point(Zaman noktasÄ±)**: Bir **zaman noktasÄ±** sadece zaman Ã§izelgesindeki bir andÄ±r. C'de bu genellikle hesaplama kolaylÄ±ÄŸÄ±ndan dolayÄ± `time_t` tÃ¼rÃ¼nde tutulur. **Calendar time(takvim zamanÄ±)** ile aynÄ±dÄ±r, ancak insan tarafÄ±ndan okunabilir tarih yerine soyut bir nokta olarak dÃ¼ÅŸÃ¼nÃ¼lÃ¼r.

**Calendar Time(Takvim ZamanÄ±)**: C'deki **calendar time** `time_t` tÃ¼rÃ¼ ile temsil edilir. Kavramsal olarak, "**Unix Epoch**" dan bu yana geÃ§en saniye sayÄ±sÄ±dÄ±r (_1 Ocak 1970'te 00: 00: 00_). BasitÃ§e, makine aÃ§Ä±sÄ±ndan verimli bir **time-point(zaman noktasÄ±)** Ã¶lÃ§Ã¼sÃ¼ olarak hizmet eder.

**Broken-down time**: ParÃ§alanmÄ±ÅŸ zaman, bir `time_t` tÃ¼rÃ¼nÃ¼n yÄ±l, ay, gÃ¼n, saat, dakika, saniye vb. olarak insan tarafÄ±ndan okunabilir bir ÅŸekilde ayrÄ±ÅŸtÄ±rÄ±larak tanÄ±mlandÄ±ÄŸÄ± tarih gÃ¶sterim biÃ§imidir. `struct tm` yapÄ± tÃ¼rÃ¼ tarafÄ±ndan temsil edilir.

**Timestamp(Zaman DamgasÄ±)**: **Zaman damgasÄ±** genellikle bir gÃ¼nlÃ¼ÄŸe veya veritabanÄ±na damgalanmÄ±ÅŸ, kaydedilmiÅŸ bir zaman noktasÄ± anlamÄ±na gelir.


**Time-point(Zaman noktasÄ±)** deÄŸerini nasÄ±l ifade edebiliriz? 
1. **Calendar Time(Takvim ZamanÄ±)**: **Epoch** anÄ±ndan itibaren(Ã§oÄŸu zaman "_01:01:1970 00:00:00_" tarihinden itibaren) geÃ§miÅŸ olan saniye deÄŸeridir ve `time_t` tÃ¼r eÅŸ adÄ±nda tutulan bir deÄŸerdir, bu deÄŸer insanÄ±n okuyabileceÄŸi ve anlamlÄ± bir deÄŸer deÄŸildir ama tarihler Ã¼zerinde hesaplama yapmak iÃ§in kullanÄ±labilecek ÅŸekilde tarihi tutmanÄ±n kolay bir yoludur.
2. **Broken-down time(AyrÄ±ÅŸtÄ±rÄ±lmÄ±ÅŸ zaman bilgisi)**: Ä°nsanÄ±n bir bakÄ±ÅŸta bulunulan anÄ±n(time-point) ne olduÄŸunu anlayabileceÄŸi zamanÄ±n ifade ediliÅŸ biÃ§imidir ama bu tarih bilgisini bu ÅŸekilde tutmak daha fazla bellek gerektirmektedir ve Ã¼zerinde iÅŸlem yapmak zordur. Mesala "_01.01.1973 00:00:007_" zaman gÃ¶sterimi **broken-down time(ayrÄ±ÅŸtÄ±rÄ±lmÄ±ÅŸ zaman bilgisi)** olarak gÃ¶sterimdir. Bu tarih formatÄ±nÄ± tutmak iÃ§in yapÄ± tÃ¼rÃ¼ olan `struct tm` tÃ¼rÃ¼ kullanÄ±lÄ±r.


â—â—â—AÅŸaÄŸÄ±daki bilgiler Ã¶nemlidir
- `time_t` tÃ¼r eÅŸ adÄ±nÄ±n hangi tÃ¼re karÅŸÄ±lÄ±k geleceÄŸi derleyiciye bÄ±rakÄ±lmÄ±ÅŸtÄ±r, derleyiciye gÃ¶re `long long` ya da `long` tÃ¼rÃ¼ne karÅŸÄ±lÄ±k geliyor olabilir.
- C standardÄ± **epoch** deÄŸerinin ne olacaÄŸÄ±nÄ±n kararÄ±nÄ± derleyiciye bÄ±rakÄ±lmÄ±ÅŸtÄ±r, Unix/Linux sistemlerinde **epoch** deÄŸeri olarak "_01:01:1970 00:00:00_" tarihi kullanÄ±lÄ±yor ve sistemlerin Ã§oÄŸunda **epoch** deÄŸeri "_01:01:1970 00:00:00_" tarihidir.
- `time.h` modÃ¼lÃ¼ndeki `struct tm` yapÄ± tÃ¼rÃ¼ **C tarzÄ± kÃ¼tÃ¼phane** yapÄ± tÃ¼rÃ¼dÃ¼r ve yapÄ±daki tÃ¼m Ã¼yelerin ne olduÄŸunun programcÄ± tarafÄ±ndan bilinmesi gerekmektedir.


ğŸ‘‡ AÅŸaÄŸÄ±daki program parÃ§asÄ±ndan `struct tm` yapÄ±sÄ±nÄ±n bildirimi incelenebilir.
```C
struct tm {
    int tm_year; // YÄ±l deÄŸeri. 1900 deÄŸerinden sonraki deÄŸeri tutmaktadÄ±r, '213' deÄŸeri '2113' yÄ±lÄ±nÄ± ifade etmektedir.
    int tm_mon; // YÄ±lÄ±n kaÃ§Ä±ncÄ± ayÄ± olduÄŸunu ifade eden sayÄ± deÄŸeri. 0: Ocak, 1: Åubat, ... , 11: AralÄ±k.
    int tm_mday; // AyÄ±n kaÃ§Ä±ncÄ± gÃ¼nÃ¼ olduÄŸunu ifade eden sayÄ± deÄŸeri. Bu deÄŸer '21' ise ayÄ±n 21. gÃ¼nÃ¼ olduÄŸu anlamÄ±na gelmektedir.
    int tm_wday; // HaftanÄ±n kaÃ§Ä±ncÄ± gÃ¼nÃ¼ olduÄŸunu ifade eden sayÄ± deÄŸeri. 0: Pazar, 1: Pazartesi, 2: SalÄ±, 3: Ã‡arÃ§amba, 4: PerÅŸembe, 5: Cuma, 6: Cumartesi.
    int tm_yday; // YÄ±lÄ±n kaÃ§Ä±ncÄ± gÃ¼nÃ¼ olduÄŸunu ifade eden sayÄ± deÄŸeri. 0: 1 Ocak, 1: 2 Ocak, ..., 29: 30 Ocak, ... . 
    int tm_hour; // Saat deÄŸeri. [0-23] deÄŸer aralÄ±ÄŸÄ±nda 24 saat Ã¼zerinden tutulan bilgi.
    int tm_min; // Dakika deÄŸeri. [0-59] deÄŸer aralÄ±ÄŸÄ±nda.
    int tm_sec; // Saniye deÄŸeri. [0-59] deÄŸer aralÄ±ÄŸÄ±nda.
    int tm_isdst; // 'daylight saving time(gÃ¼n Ä±ÅŸÄ±ÄŸÄ± tasarruf modu)' deÄŸeri. Bu deÄŸer 'tm_isdst < 0' ise veri tutulmadÄ±ÄŸÄ± anlamÄ±na geliyor, bu deÄŸer 'tm_isdst = 0' ise gÃ¼n Ä±ÅŸÄ±ÄŸÄ± tasarrufunda olunmadÄ±ÄŸÄ± anlamÄ±na geliyor, bu deÄŸer 'tm_isdst > 0' ise gÃ¼n Ä±ÅŸÄ±ÄŸÄ± tasarrufunda olunduÄŸu anlamÄ±na geliyor.
};
```


## YapÄ±lar ve TÃ¼r EÅŸ AdÄ±(`typedef`) Bildirimleri 

ğŸ§­ C kursunda `typedef` bildirimleri Ã¼Ã§ kÄ±sÄ±ma ayrÄ±lmÄ±ÅŸtÄ±;
1. `size_t`, `ptrdiff_t`, `int8_t` `int16_t`, `int_least8_t` `int_least16_t`, `int_fast8_t` `int_fast16_t` vb. tÃ¼r eÅŸ adlarÄ±nÄ±n kullanÄ±mÄ±nÄ±n incelendiÄŸi ilk kÄ±sÄ±m.
2. **Function pointers** konusundaki karmaÅŸÄ±k fonksiyon bildirimlerinin daha sade biÅŸimde gÃ¶sterilebilmesi iÃ§in `typedef` anahtar sÃ¶zcÃ¼ÄŸÃ¼nden faydalanÄ±lmaktadÄ±r.
3. Åu anda da `typedef` bildiriminin Ã¼Ã§Ã¼ncÃ¼ kÄ±smÄ± olan `typedef` bildiriminin **kullanÄ±cÄ± tanÄ±mlÄ± tÃ¼rler(user defined types)** ile kullanÄ±mÄ±nÄ± gÃ¶receÄŸiz.


ğŸ‘‡ AÅŸaÄŸÄ±daki program **kullanÄ±cÄ± tanÄ±mlÄ± tÃ¼rler(user defined types)** varlÄ±klar iÃ§in tÃ¼ reÅŸ adÄ± bildiriminin nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#include <time.h>

// YapÄ± bildirimi.
// 'nec' adÄ± 'structer tag' olarak adlandÄ±rÄ±lmaktadÄ±r.
struct nec {
    int x, y, z;
};

// Birlik bildirimi.
// 'erg' adÄ± 'union tag' olarak adlandÄ±rÄ±lmaktadÄ±r.
union erg {
    int x, y, z;
};

// NumaralandÄ±rÄ±m bildirimi.
// 'pos' adÄ± 'enum tag' olarak adlandÄ±rÄ±lmaktadÄ±r.
enum pos {off, on, hold, standby};


typedef struct nec nec_t;
typedef union erg erg_t;
typedef enum pos pos_t;
```


> â” 
> 
> SorduÄŸum soru;
> 
> "user defined type"larÄ±n adlandÄ±rÄ±lmalarÄ±ndaki genel convension tÃ¼m harfler kÃ¼Ã§Ã¼k olmasÄ± biÃ§iminde miydi?
> 
> Cevap;
> 
> HayÄ±r. C dilinde en Ã§ok kullanÄ±lan convension ilk farfin bÃ¼yÃ¼k diÄŸer harflerin kÃ¼Ã§Ã¼k olmasÄ±dÄ±r, C++ dilinde tÃ¼m farflerin kÃ¼Ã§Ã¼k olmasÄ± daha Ã§ok tercih edilen bir convension.


ğŸ‘‡ AÅŸaÄŸÄ±daki program parÃ§asÄ±nda yapÄ±larla `typedef` bildirimi kullanÄ±mÄ± incelenebilir.
```C
struct Nec {
    int x, y, z;
};


typedef struct Nec Nec; // Burada 'struct Nec' tÃ¼rÃ¼nden 'Nec' adÄ±nda tÃ¼r eÅŸ adÄ± bildiirmi yapÄ±lÄ±yor.
typedef struct Nec* NecPtr; // Burada 'struct Nec*' tÃ¼rÃ¼nden 'NecPtr' adÄ±nda tÃ¼r eÅŸ adÄ± bildiirmi yapÄ±lÄ±yor.
```


ğŸ‘‡ AÅŸaÄŸÄ±daki program parÃ§asÄ±nda yapÄ±larla `typedef` bildirimi kullanÄ±mÄ± incelenebilir.
```C
struct Nec {
    int x, y, z;
};

typedef struct Nec Nec; // Burada 'struct Nec' tÃ¼rÃ¼nden 'Nec' adÄ±nda tÃ¼r eÅŸ adÄ± bildiirmi yapÄ±lÄ±yor.

typedef Nec* NecPtr; // Burada 'struct Nec*' tÃ¼rÃ¼nden 'NecPtr' adÄ±nda tÃ¼r eÅŸ adÄ± bildiirmi yapÄ±lÄ±yor. 'Nec*' ifadesi 'struct Nec*' ifadesine denktir.
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program parÃ§asÄ±nda yapÄ±larla `typedef` bildirimi kullanÄ±mÄ± incelenebilir.
```C
struct Nec {
    int x, y, z;
};

typedef struct Nec Nec, *NecPtr; // Burada tek bir statement ile 'Nec' ve 'NecPtr' adÄ±nda tÃ¼r eÅŸ adÄ± bildirimi yapÄ±lmÄ±ÅŸtÄ±r. 'struct Nec' tÃ¼rÃ¼ne 'Nec' adÄ± ve 'struct Nec*' tÃ¼rÃ¼ne 'NecPtr' adÄ± verildi.
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda yapÄ± bildirimini yaparken aynÄ± zamanda `typedef` bildiriminin de nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
// AÅŸaÄŸÄ±daki gibi kullanÄ±m ile tek seferde hem yapÄ±nÄ±n bildirimi hem de 'typedef' bildirimi yapÄ±lmÄ±ÅŸ oluyor.
// En Ã§ok kullanÄ±lan yapÄ± bildirimi yÃ¶ntemi budur;
typedef struct Nec {
    int a, b, c;
}Nec; // Buradaki 'Nec' adÄ± bir deÄŸiÅŸken deÄŸil bir tÃ¼r eÅŸ adÄ±dÄ±r.


int main(void)
{
    // AÅŸaÄŸÄ±da iki tane 'struct Nec' tÃ¼rÃ¼nden deÄŸiÅŸken bildirimi yapÄ±lmÄ±ÅŸtÄ±r, statement'lar farklÄ± ama oluÅŸturulan tÃ¼rlerin aynÄ± olduÄŸu gÃ¶rÃ¼lmelidir.
    struct Nec mynec;
    Nec x;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda yapÄ± bildirimini yaparken aynÄ± zamanda `typedef` bildiriminin de nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir. 
```C
#include <stdlib.h>
#include <stdio.h>

// AÅŸaÄŸÄ±daki gibi kullanÄ±m ile tek seferde hem yapÄ±nÄ±n bildirimi hem de 'typedef' bildirimleri yapÄ±lmÄ±ÅŸ oluyor.
// En Ã§ok kullanÄ±lan yapÄ± bildirimi yÃ¶ntemi budur;
typedef struct Nec {
    int a, b, c;
}Nec, * NecPtr; // Buradaki 'struct Nec' tÃ¼rÃ¼ne 'Nec' tÃ¼r eÅŸ adÄ± verildi ve 'struct Nec*' tÃ¼rÃ¼ne 'NecPtr' tÃ¼r  eÅŸ adÄ± verildi.


int main(void)
{
    Nec x = { 4, 5, 7 };
    NecPtr ptr = &x;
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programdan bir yapÄ±nÄ±n kullanÄ±labilmesinin nasÄ±l sadece tÃ¼r eÅŸ adÄ± Ã¼zerinden kullanÄ±mÄ±na zorlanabileceÄŸi incelenebilir.
```C
#include <stdlib.h>
#include <stdio.h>

// AÅŸaÄŸÄ±da yapÄ±nÄ±n etiketi(tag) eklenmediÄŸi iÃ§in 'anonymous' olarak bildirilmiÅŸ oluyor, 'Nec' adÄ± da 'typedef' bildirimi oluyor, bu durumda bu yapÄ±nÄ±n nesnesini oluÅŸturmak iÃ§in sadece 'Nec' tÃ¼r eÅŸ adÄ± kullanÄ±labilir.
// En Ã§ok kullanÄ±lan yapÄ± bildirimi yÃ¶ntemi budur;
typedef struct {
    int a, b, c;
}Nec; // Burada 'Nec' adÄ±nda tÃ¼r eÅŸ adÄ± bildiriliyor.


int main(void)
{
    Nec x = { 4, 5, 7 };
}
```



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programda **anonymous structure** bildiriminin **pointer** tÃ¼rÃ¼nden yapÄ±larak ilgili `struct` tÃ¼rÃ¼nÃ¼n sadece dinamik Ã¶mÃ¼rlÃ¼ bir nesne olarak tanÄ±mlanmaya zorlanmasÄ± incelenebilir.
```C
#include <stdlib.h>
#include <stdio.h>

// AÅŸaÄŸÄ±daki yapÄ± tÃ¼rÃ¼nÃ¼n bir adÄ± yok, bir eÅŸ adÄ± da yok, ancak bu yapÄ± tÃ¼rÃ¼ne pointer tÃ¼rÃ¼nÃ¼n eÅŸ adÄ± var.
// AÅŸaÄŸÄ±daki gibi bir yapÄ± bildirimi yapÄ±lÄ±rsa, bir adÄ± olmayan bu yapÄ± tÃ¼rÃ¼nden, otomatik Ã¶mÃ¼rlÃ¼ ve static Ã¶mÃ¼rlÃ¼ deÄŸiÅŸken tanÄ±mlama ÅŸansÄ±mÄ±z yoktur sadece dinamik Ã¶mÃ¼rlÃ¼ bir nesne tanÄ±mlanabilir.
typedef struct {
    int a, b, c;
} *NecPtr;


int main(void)
{
    NecPtr p;

    printf("%zu\n", (sizeof(p)); // Burada standart Ã§Ä±ktÄ± akÄ±mÄ±na sistemdeki pointer tÃ¼rÃ¼nÃ¼n byte deÄŸeri gÃ¶nderilecektir.
    printf("%zu\n", (sizeof(*p)); // Burada standart Ã§Ä±ktÄ± akÄ±mÄ±na sistemde 'int' tÃ¼rÃ¼ 4 byte olduÄŸunda en az '12\n' deÄŸeri gÃ¶nderilecektir.
}
```


**Unevaluated context(Ä°ÅŸlem kodu Ã¼retilmeyen baÄŸlam)**: C++ dilinde iÅŸlem kodu Ã¼retilmeyen 8, 9 farklÄ± durum vardÄ±r.

â—â—â— Ä°ÅŸlem kodu Ã¼retilmeyen durumlarda tanÄ±msÄ±z davranÄ±ÅŸ oluÅŸturan ifadeler kullanÄ±ldÄ±ÄŸÄ±nda iÅŸlem kodu Ã¼retilmediÄŸi iÃ§in **ub** durumu oluÅŸmamaktadÄ±r.


â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programda iÅŸlem kodu Ã¼retilen ve Ã¼retilmeyen durumlarda **ub** olup olmayacaÄŸÄ± incelenebilir.
```C
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
    int ary[12] = { 0 };

    int x = ary[21]; // Burada 'ary' dizisi taÅŸÄ±rÄ±ldÄ±ÄŸÄ± iÃ§in 'ub' durumu oluÅŸur.
    size_t sz = sizeof(ary[21]); // Burada iÅŸlem kodu Ã¼retilmediÄŸi iÃ§in 'ub' de yoktur.

    int* p;
    int* ptr = NULL;

    // AÅŸaÄŸÄ±daki durumlarÄ±n hiÃ§birinde 'ub' yoktur.
    printf("%d\n", sizeof(ary[765]));
    printf("%zu\n", sizeof(p));
    printf("%zu\n", sizeof(*p));
    printf("%zu\n", sizeof(*ptr));
}
```



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programda **anonymous structure** bildiriminin **pointer** tÃ¼rÃ¼nden yapÄ±larak ilgili `struct` tÃ¼rÃ¼nÃ¼n sadece dinamik Ã¶mÃ¼rlÃ¼ bir nesne olarak tanÄ±mlanmaya zorlanmasÄ± incelenebilir.
```C
#include <stdlib.h>
#include <stdio.h>

// AÅŸaÄŸÄ±daki yapÄ± tÃ¼rÃ¼nÃ¼n bir adÄ± yok, bir eÅŸ adÄ± yok, ancak yapÄ± tÃ¼rÃ¼ne pointer tÃ¼rÃ¼nÃ¼n eÅŸ adÄ± var.
// AÅŸaÄŸÄ±daki gibi bir yapÄ± bildirimi yapÄ±lÄ±rsa, bir adÄ± olmayan bu yapÄ± tÃ¼rÃ¼nden, otomatik Ã¶mÃ¼rlÃ¼ ve static Ã¶mÃ¼rlÃ¼ deÄŸiÅŸken tanÄ±mlama ÅŸansÄ±mÄ±z yoktur sadece dinamik Ã¶mÃ¼rlÃ¼ bir nesne tanÄ±mlanabilir.
typedef struct {
    int a, b, c;
} *NecPtr;

int main(void)
{
    // KÃ¼tÃ¼phenelerde kullanÄ±lan bir C idiyomu
    NecPtr p = (NecPtr)malloc(sizeof(*p)); // Buradaki 'p' deÄŸiÅŸkeninin tÃ¼rÃ¼ sadece 'NecPtr' tÃ¼r eÅŸ adÄ±yla eriÅŸile bilen 'struct' tÃ¼rÃ¼nden deÄŸerdir. 'p' deÄŸiÅŸkeni 'NecPtr p' ile tanÄ±mlanan deÄŸiÅŸkendir, aynÄ± statement iÃ§inde aynÄ± deÄŸiÅŸken kullanÄ±lÄ±yor.
}
```


> â” 
> 
> Sorulan soru;
> 
> DoÄŸrudan *Necptr de diyemez miyiz, sizeof icinde
> 
> Cevap;
> 
> Tabiki de hayÄ±r, Ã§Ã¼nkÃ¼ iÃ§erip operatÃ¶rÃ¼nÃ¼n operandÄ± bir tÃ¼r olamaz, yukarÄ±daki programda `NecPtr` bir tÃ¼rdÃ¼r bir ifade deÄŸildir, iÃ§erip Ã¶peratÃ¶rÃ¼nÃ¼n operandÄ± sadece adres olan ifadeler olabilir. </br>
> `*NecPtr` demek `*(int*)` demek gibi bir kullanÄ±m olacaÄŸÄ± iÃ§in hatalÄ±dÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **dereferencing(iÃ§erik)(`*`)** ve **subscript(index of)(`[]`)** operatÃ¶rleri gÃ¶rÃ¼lebilir.
```C
#include <stdlib.h>
#include <stdio.h>


typedef struct {
    int x, y, z;
} *NecPtr;


int main(void)
{
    int x = 5;
    int* ptr = &x;
    int a[5] = { 0 };

    // AslÄ±nda iki tane 'dereferencing(iÃ§erik)' operatÃ¶rÃ¼ vardÄ±r.
    // AÅŸaÄŸÄ±daki iki ifade de iki farklÄ± iÃ§erik operatÃ¶rÃ¼ gÃ¶rÃ¼lebilir, ikisini birbirinden ayÄ±rmak iÃ§in farklÄ± adlar veriliyor ama iki operatÃ¶r de bir adresteki nesneye eriÅŸmek iÃ§in kullanÄ±lÄ±yor.
    *ptr;
    a[3];
}
```



MÃ¼lakatlarda Ã§ok sÄ±k sorulan bir soru aÅŸaÄŸÄ±daki gibidir? </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda bildirimi yapÄ±lan `x` ve `y` yapÄ± deÄŸiÅŸkenlerinin birbirine atanmasÄ± iÅŸlemi yapÄ±lÄ±p yapÄ±lamayacaÄŸÄ± mÃ¼lakatlarda sorulmaktadÄ±r.
```C
typedef struct {
    int a, b, c;
}x;

typedef struct {
    int a, b, c;
}y;

int main(void)
{
    x = y; // Buradaki atama iÅŸlemi hatalÄ±dÄ±r, derleyici 'x' ve 'y' tÃ¼rlerini farklÄ± tÃ¼rler olarak yorumladÄ±ÄŸÄ± iÃ§in bu atama sÃ¶zdizim hatasÄ±dÄ±r(syntax error).
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda C ve C++ dillerinde `struct` tÃ¼rÃ¼nden deÄŸiÅŸken bildirimlerinin legal/illegal olma durumlarÄ± incelenebilir.
```C
#include <time.h>

int main(void)
{
    // tm x; // Buradaki gibi bir bildirim C dilinde illegal, C++ dilinde legal durumdadÄ±r.
    
    // struct tm tm; // Buradaki gibi bir bildirim C ve C++ dillerinde legal durumdadÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda farklÄ± **kapsamlarda(csope)** aynÄ± ada sahip **adlarÄ±n(identifier)** kullanÄ±labileceÄŸi incelenebilir.
```C
#include <time.h>

struct x{
    int x, y;
};


void x(void) // function
{
    struct x x; // decleration x is in block scope

x: // 
    x.x = 5; // local x( in block scope)
}
```


ğŸ“Œ Label varlÄ±klarÄ±nÄ±n `goto` ile kullanmanÄ±n dÄ±ÅŸÄ±nda kullanÄ±ldÄ±ÄŸÄ±nda derleyiciler uyarÄ± iletisi verecektir. Bazen prograncÄ±lar  **Ã§Ä±plak label(goto ile baÄŸlÄ± olmayan etiket)** kullanÄ±mÄ±nÄ± debug amaÃ§lÄ± kullanmaktadÄ±rlar ama pek iyi bir fikir deÄŸildir.


## `time` BaÅŸlÄ±k DosysÄ±ndaki Fonksiyonlar 

`time.h` baÅŸlÄ±k dosyasÄ±ndaki fonksiyonlar aÅŸaÄŸÄ±daki gibidir;
- `time`
- `localtime`
- `gmtime`
- `asctime`
- `difftime`
- `strftime`
- `mktime`


### `time` Fonksiyonu

Prototipi `time_t time(time_t *);` olan fonksiyonunun Ã¶zellikleri aÅŸaÄŸÄ±daki gibidir;
- **output** parametre almaktadÄ±r. 
- **calendar time** deÄŸerini hesaplayan bir fonksiyondur.
- `time_t` tÃ¼rÃ¼nden kendisine geÃ§ilen nesneye deÄŸer atama iÅŸlemi yapan bir fonksiyondur ve aynÄ± nesneyi geriye dÃ¶ndÃ¼rÃ¼r.
- Bu fonksiyona `NULL pointer` geÃ§ilirse tanÄ±msÄ±z davranÄ±ÅŸ oluÅŸmaz, fonksiyondan geriye istek yapÄ±lan andaki tarih deÄŸerine sahip `time_t` tÃ¼rÃ¼nden yapÄ± nesnesi dÃ¶nÃ¼lÃ¼rdÃ¼.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `time` fonksiyonunun kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include <time.h>

int main(void)
{
    time_t sec;
    time(&sec);

    printf("calendar time: %lld\n", sec); // Burada Microsoft derleyicisi iÃ§in '1970.01.01 00:00:00' tarihinden itibaren geÃ§en saniye deÄŸeri yazdÄ±rÄ±lacaktÄ±r.
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `time` fonksiyonunun kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include <time.h>

int main(void)
{
    time_t sec = time(NULL);

    printf("calendar time: %lld\n", sec);
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `time` fonksiyonuna **NULL pointer** geÃ§ildiÄŸinde ne olacaÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include <time.h>

int main(void)
{
    printf("calendar time: %lld\n", time(NULL));
    printf("calendar time: %lld\n", time(0)); // Burada pointer beklenen yerde '0' tam sayÄ± deÄŸeri geÃ§ilirse derleyici 'NULL pointer'a dÃ¶nÃ¼ÅŸÃ¼m yapacaktÄ±r.

    time_t s1, s2;
    s2 = time(&s1); // Buradaki atamanÄ±n bir anlamÄ± yoktur ama yapÄ±labildiÄŸi gÃ¶rÃ¼lmelidir.
}
```


### `localtime` ve `gmtime` FonksiyonlarÄ± 

BirÃ§ok kodda `time_t` deÄŸerinden `struct tm` tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸÃ¼m gerekir. </br>
`localtime` ve `gmtime` fonksiyonlarÄ± `time_t` deÄŸerini `struct tm` deÄŸerine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r. </br>
`gmtime` fonksiyonu ile `localtime` fonksiyonu arasÄ±ndaki tek bir fark mevcut o fark ta `gmtime` fonksiyonunun Ä°ngilteredeki **greenwich** meridyeninin tarih bilgisi ile iÅŸlem yapmasÄ±dÄ±r.


â—â—â— Prototipi `struct tm* localtime(const time_t *);` olan fonksiyon dÄ±ÅŸarÄ±dan `time_t*` tÃ¼rÃ¼nden adres deÄŸeri alÄ±r ve `time_t` tÃ¼rÃ¼nden `struct tm` tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸÃ¼m yapÄ±p geriye **static storage duration** Ã¶zellikteki `struct tm` tÃ¼rÃ¼nden bir nesne adresini dÃ¶ndÃ¼rmektedir.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.30-10.50 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***



`time` kÃ¼tÃ¼phenesiyle ilgili olarak mÃ¼lakatlarda sorulabilecek olan Ã§ok basit bir soru. </br>
MÃ¼lakat sorusu: Bir C programÄ± yazÄ±nÄ±z, Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda iÃ§inde bulunulan anÄ±n tarih bilgisini "_29 Haziran 2025 10:25:51_" gibi yazan programÄ± yazÄ±nÄ±z. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda buradaki mÃ¼lakat sorusunun yazÄ±lmÄ±ÅŸ hali incelenebilir.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

int main(void)
{
    time_t sec;
    time(&sec);

    struct tm* p = localtime(&sec);

    const char* const pmons[] = { "Ocak", "Subat", "Mart", "Nisan", "Mayis", "Haziran", "Temmuz", "Agustos", "Eylul", "Ekim", "Kasim", "Aralik", };
    const char* const pdays[] = { "Pazar", "Pazartesi", "Sali", "Carsamba", "Persembe", "Cuma", "Cumartesi", };

    printf("%02d-%02d-%d\n", p->tm_mday, p->tm_mon, p->tm_year); // Burada tarih hatalÄ± gÃ¶rÃ¼necektir.

    printf("%02d-%02d-%d\n", p->tm_mday, p->tm_mon + 1, p->tm_year + 1900); // Burada yapÄ±lan dÃ¼zenleme sonrasÄ±nda tarih doÄŸru gÃ¶rÃ¼necektir.

    printf("%02d-%02d-%d %02d:%02d:%02d\n", p->tm_mday, p->tm_mon + 1, p->tm_year + 1900, p->tm_hour, p->tm_min, p->tm_sec); // Tam tarihin yazdÄ±rÄ±lmasÄ±. 
    
    printf("%02d %s %d %02d:%02d:%02d\n", p->tm_mday, pmons[p->tm_mon], p->tm_year + 1900, p->tm_hour, p->tm_min, p->tm_sec); // Ay bilgisi yazÄ± olarak yazÄ±ldÄ±ÄŸÄ±nda nasÄ±l gÃ¶rÃ¼ndÃ¼ÄŸÃ¼ incelenebilir.

    printf("%02d %s %d %s %02d:%02d:%02d\n", p->tm_mday, pmons[p->tm_mon], p->tm_year + 1900, pdays[p->tm_wday], p->tm_hour, p->tm_min, p->tm_sec); // Ay ve haftanÄ±n gÃ¼nÃ¼ bilgisi yazÄ± olarak yazÄ±ldÄ±ÄŸÄ±nda nasÄ±l gÃ¶rÃ¼ndÃ¼ÄŸÃ¼ incelenebilir.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `localtime` fonksiyonuna deÄŸeri dÄ±ÅŸarÄ±dan tanÄ±mlanmÄ±ÅŸ olan `time_t` tÃ¼rÃ¼nden bir deÄŸiÅŸkenin argÃ¼man olarak geÃ§ilmesi sonucundaki tarihin yazdÄ±rÄ±lÄ±ÅŸÄ± incelenebilir.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

int main(void)
{
    time_t sec = 1'500'000'000;
    struct tm* p = localtime(&sec);

    const char* const pmons[] = { "Ocak", "Subat", "Mart", "Nisan", "Mayis", "Haziran", "Temmuz", "Agustos", "Eylul", "Ekim", "Kasim", "Aralik", };
    const char* const pdays[] = { "Pazar", "Pazartesi", "Sali", "Carsamba", "Persembe", "Cuma", "Cumartesi", };

    printf("%02d %s %d %s %02d:%02d:%02d\n", p->tm_mday, pmons[p->tm_mon], p->tm_year + 1900, pdays[p->tm_wday], p->tm_hour, p->tm_min, p->tm_sec); // Ay ve haftanÄ±n gÃ¼nÃ¼ bilgisi yazÄ± olarak yazÄ±ldÄ±ÄŸÄ±nda nasÄ±l gÃ¶rÃ¼ndÃ¼ÄŸÃ¼ incelenebilir.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `localtime` fonksiyonu kullanÄ±larak `struct tm` tÃ¼rÃ¼nden bir deÄŸiÅŸkenin `tm_isdst` Ã¼yesinin durumunun ne olduÄŸu incelenebilir.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

int main(void)
{
    time_t sec = 1'500'000'000;

    struct tm* p = localtime(&sec);

    const char* const pmons[] = { "Ocak", "Subat", "Mart", "Nisan", "Mayis", "Haziran", "Temmuz", "Agustos", "Eylul", "Ekim", "Kasim", "Aralik", };
    const char* const pdays[] = { "Pazar", "Pazartesi", "Sali", "Carsamba", "Persembe", "Cuma", "Cumartesi", };

    printf("%02d %s %d %s %02d:%02d:%02d\n", p->tm_mday, pmons[p->tm_mon], p->tm_year + 1900, pdays[p->tm_wday], p->tm_hour, p->tm_min, p->tm_sec); // Ay ve haftanÄ±n gÃ¼nÃ¼ bilgisi yazÄ± olarak yazÄ±ldÄ±ÄŸÄ±nda nasÄ±l gÃ¶rÃ¼ndÃ¼ÄŸÃ¼ incelenebilir.

    if(p->tm_isdst < 0){
        printf("gun isigi tasarruf modu verisi tutulmuyor.\n");
    }
    else if(p->tm_isdst > 0){
        printf("gun isigi tasarrufu modunda.\n");
    }
    else{
        printf("gun isigi tasarrufu modunda degil.\n");
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `gmtime` fonksiyonu kullanÄ±larak `struct tm` tÃ¼rÃ¼nden bir deÄŸiÅŸkenin `tm_isdst` Ã¼yesinin durumunun ne olduÄŸu incelenebilir.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

int main(void)
{
    time_t sec = 1'500'000'000;

    struct tm* p = gmtime(&sec);

    const char* const pmons[] = { "Ocak", "Subat", "Mart", "Nisan", "Mayis", "Haziran", "Temmuz", "Agustos", "Eylul", "Ekim", "Kasim", "Aralik", };
    const char* const pdays[] = { "Pazar", "Pazartesi", "Sali", "Carsamba", "Persembe", "Cuma", "Cumartesi", };

    printf("%02d %s %d %s %02d:%02d:%02d\n", p->tm_mday, pmons[p->tm_mon], p->tm_year + 1900, pdays[p->tm_wday], p->tm_hour, p->tm_min, p->tm_sec); // Ay ve haftanÄ±n gÃ¼nÃ¼ bilgisi yazÄ± olarak yazÄ±ldÄ±ÄŸÄ±nda nasÄ±l gÃ¶rÃ¼ndÃ¼ÄŸÃ¼ incelenebilir.

    if(p->tm_isdst < 0){
        printf("gun isigi tasarruf modu verisi tutulmuyor.\n");
    }
    else if(p->tm_isdst > 0){
        printf("gun isigi tasarrufu modunda.\n");
    }
    else{
        printf("gun isigi tasarrufu modunda degil.\n");
    }
}
```


### `ctime`, `asctime`, `strftime` FonksiyonlarÄ± 

EÄŸer bir **time point** deÄŸerini bir fonksiyon yardÄ±mÄ±yla bir yazÄ±ya dÃ¶nÃ¼ÅŸtÃ¼rmek istiyorsak `time` modÃ¼lÃ¼nde bulunan `ctime`, `asctime`, `strftime` fonksiyonlarÄ±nÄ± kullanabiliriz.


#### `ctime`, `asctime` FonksiyonlarÄ±nÄ±n KullanÄ±mÄ±

`ctime` fonksiyonunun adÄ± "calendar time to string" sÃ¶zcÃ¼klerinden gelmektedir, bu fonksiyon `time_t` tÃ¼rÃ¼nden aldÄ±ÄŸÄ± deÄŸiÅŸkeni insanlarÄ±n okuyabileceÄŸi `Www Mmm dd hh:mm:ss yyyy\n\0` formatÄ±nda tarih yazÄ±sÄ±na Ã§evirir, formatÄ±n sonundaki `\n` ve `\0` karakterlerine gÃ¶r.

`asctime` fonksiyonunun adÄ± "ASCII time" sÃ¶zcÃ¼klerinden gelmektedir, bu fonksiyon `struct tm*` tÃ¼rÃ¼nden aldÄ±ÄŸÄ± gÃ¶sterici deÄŸiÅŸkeni insanlarÄ±n okuyabileceÄŸi `Www Mmm dd hh:mm:ss yyyy\n\0` formatÄ±nda tarih yazÄ±sÄ±na Ã§evirir, formatÄ±n sonundaki `\n` ve `\0` karakterlerine gÃ¶r.

Bu fonksiyonlarÄ±n **bildirimleri(Prototype)** aÅŸaÄŸÄ±daki gibidir;
- `char* ctime(const time_t* timer);`
- `char* asctime(const struct tm* timeptr);`


â—â—â— `ctime`, `asctime` fonksiyonlarÄ±yla ilgili aÅŸaÄŸÄ±daki bilgiler Ã¶nemlidir;
- Bu fonksiyonlar 26 karakter uzunluÄŸunda sonunda new-line(`\n`) karakteri olan yani **yeni satÄ±rla sonlanan yazÄ±(new-line terminated byte stream)[bu adÄ± be uydurdum dikkate almayabilirsin]** bir yazÄ± adresi dÃ¶ndÃ¼rÃ¼r.
- Her iki fonksiyon da aynÄ± static Ã¶mÃ¼rlÃ¼ dizinin adresini dÃ¶ndÃ¼rÃ¼r.
- YazÄ±nÄ±n formatÄ± Ã¶nceden belirlenmiÅŸtir, derleyiciye baÄŸlÄ± deÄŸildir, deÄŸiÅŸtirilemez.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `ctime`, `asctime` fonksiyonlarÄ±nÄ±n kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

int main(void)
{
    time_t tx;
    time(&tx);

    const char* pstr = ctime(&tx);
    struct tm* tp = localtime(&tx);
    const char* tpstr = asctime(tp);

    printf("(%p) (%p)\n", pstr, tpstr); // Buradaki fonksiyon Ã§aÄŸrÄ±sÄ±nÄ±n yapÄ±lma nedeni 'ctime' ve 'asctime' fonksiyonlarÄ±nÄ±n aynÄ± static Ã¶mÃ¼rlÃ¼ dizinin adresini dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼nÃ¼ gÃ¶rebilmek iÃ§indir.

    // AÅŸaÄŸÄ±daki `printf` Ã§aÄŸrÄ±larÄ±ndan yazÄ±larÄ±n sonunda '\n' olduÄŸunu anlayabilmek iÃ§in kÃ¶ÅŸeli parantez ile yazÄ±lar yazdÄ±rÄ±lmÄ±ÅŸtÄ±r.
    printf("[%s]", pstr);
    printf("[%s]", tpstr);
}
```


ğŸ‘† YukarÄ±daki program Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ± anda(yazÄ±lardaki kÃ¶ÅŸeli parantezler silinmiÅŸti) ğŸ‘‡ aÅŸaÄŸÄ±daki gibi bir Ã§Ä±ktÄ± alÄ±ndÄ± ve buradan analitik prikolojinin kurucusu kabuledilen "**Carl Jung**"dan bahsedildi;
```bash

(01114DBO) (01114DBO)
Sun Jun 29 11:11:11 2025
Sun Jun 29 11:11:11 2025
```


#### `strftime` Fonksiyonunun KullanÄ±mÄ± 

Bu fonkisyonunun kullanÄ±lmasÄ±nÄ±n Ã¶ÄŸrenilmesi biraz ilgi istemektedir. </br>
`strftime` fonksiyonunun adÄ± "**string format time**" sÃ¶zcÃ¼klerinden gelmektedir ve `struct tm*` tÃ¼rÃ¼nden gÃ¶sterici nesnesinin gÃ¶sterdiÄŸi `struct tm` tÃ¼rÃ¼nden nesneyi istenilen formatta bir yazÄ±ya dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in kullanÄ±lmaktadÄ±r, bir Ã§ok formatlama yÃ¶ntemi olduÄŸu iÃ§in ihtiyaca gÃ¶re inceleme yapÄ±p kullanmak gerekecektir, ezberlemeye Ã§alÄ±ÅŸmadan sadece ihtiyaca gÃ¶re kullanmak gerekir.

Bildirimi `size_t strftime(char* _Buffer, size_t _SizeInBytes, const char* _Format, const struct tm* _TM);` biÃ§imindedir ve 
- `_Buffer`: Ä°lk parametredir, `sprintf` fonksiyonundaki gibi yazÄ±nÄ±n oluÅŸturulacaÄŸÄ± adres deÄŸeri.
- `_SizeInBytes`: Ä°kinci parametredir, ilk parametrede geÃ§ilen yazÄ±ya deÄŸer yazarken taÅŸma olmamasÄ± iÃ§in yazÄ±nÄ±n en fazla kaÃ§ karakter olabileceÄŸi bilgisini alan parametredir.
- `_Format`: ÃœÃ§Ã¼ncÃ¼ parametredir, yazÄ±ya dÃ¶nÃ¼ÅŸtÃ¼rme iÅŸleminin hangi formata gÃ¶re yapÄ±lacaÄŸÄ± bilgisi.
- `_TM`: DÃ¶rdÃ¼ncÃ¼ parametredir, yazÄ±ya dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmek istenilen `struct tm*` gÃ¶sterici tÃ¼rÃ¼nden `struct tm` nesnesinin adres deÄŸeri.



Windows sistem programlama tarafÄ±da "Windows Api"leri var yani Windows iÅŸletim sistemi iÃ§in C dilinde yazÄ±lmÄ±ÅŸ sistem fonksiyonlarÄ±, pencereleri Ã§Ä±kartmak iÃ§in bu "Windows Api" fonksiyonlarÄ± Ã§aÄŸÄ±rÄ±lÄ±yor. "Windows Api" fonksiyonlarÄ±nÄ±n arasÄ±nda 10-15 arasÄ±nda parametre alan fonksiyonlar var.


> â” 
> 
> Sorulan soru;
> 
> windows iÅŸletim sistemi bildiÄŸim kadarÄ±yla tamamen c++ ile yazÄ±lmÄ±ÅŸ
> Cevap;
> 
> HayÄ±r, Mindows iÅŸletim sistemi tamamen C diliyle yazÄ±ldÄ± fakat iÅŸletim sistemi tarafÄ±nda nesne yÃ¶nelimli programlamanÄ±n saÄŸlayacaÄŸÄ± faydalar olduÄŸu iÃ§in sonradan C++'Ä±n eski dÃ¶nemlerinde C++'nin sÄ±nÄ±flarÄ±yla C fonksiyonlarÄ±nÄ± sarmalÄ±yorlar(**function wraper**), esasen tÃ¼m fonksiyonlar C fonksiyonu ama C++ fonksiyonlarÄ±yla C fonksiyonlarÄ± sarmalanÄ±yor.



**MFC**: "**Microsoft Fundation Classes**" sÃ¶zcÃ¼klerinin kÄ±saltmasÄ±dÄ±r. C Api'lerini daha kolay kullanÄ±labilsin diye C++ sÄ±nÄ±flarÄ±yla sarmalÄ±yorlar(eski dÃ¶nemlerde kullanÄ±lan kÃ¼tÃ¼ C++ sÄ±nÄ±flarÄ±yla sarmalÄ±yorlar)



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `windows.h` baÅŸlÄ±k dosyasÄ± ile Windows sisten fonksiyonlarÄ±nÄ±n kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <windows.h> // Windows iÅŸletim sisteminin API fonksiyonlarÄ±nÄ±n olduÄŸu baÅŸlÄ±k dosyasÄ±.

int main(void)
{
    Sleep(); // Windows API fonksiyonuna Ã§aÄŸrÄ± yapÄ±lÄ±yor.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strftime` fonksiyonunun kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

#define SIZE 100

int main(void)
{
    char str[SIZE];
    time_t sec;
    time(&sec);

    struct tm* p = localtime(&sec);

    strftime(str, SIZE, "weekday: %A", p); // 'str' yazÄ±sÄ±na haftanÄ±n gÃ¼nÃ¼ yazdÄ±rÄ±lÄ±yor.
    printf("[%s]\n\n", str);


    strftime(str, SIZE, "mounth: %B weekday: %A", p); // 'str' yazÄ±sÄ±na ay ve haftanÄ±n gÃ¼nÃ¼ yazdÄ±rÄ±lÄ±yor.
    printf("[%s]\n", str);

    
    strftime(str, SIZE, "%B-%A %y", p);
    printf("[%s]\n", str);


    strftime(str, SIZE, "%F", p);
    printf("[%s]\n", str);

    strftime(str, SIZE, "%EX", p);
    printf("[%s]\n", str);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strftime` fonksiyonunun TÃ¼rkiye local belirlendiÄŸi durumdaki kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <locale.h>

#define SIZE 100

int main(void)
{
    char* lp;

    if((lp = setlocal(LC_ALL, "turkish")) == NULL){
        printf("local degistirilemedi.\n");
        return 1;
    }

    char str[SIZE];
    time_t sec;
    time(&sec);

    struct tm* p = localtime(&sec);

    strftime(str, SIZE, "%d %B %A %Y", p);
    printf("[%s]\n", str);
}
```


### `mktime` Fonksiyonu 

`mktime` fonksiyonunun adÄ± "**Make Time**" sÃ¶zcÃ¼klerinden gelmektedir ve adÄ±nÄ±n aksine bir dÃ¶nÃ¼ÅŸÃ¼m fonksiyonudur, `localtime` fonksiyonunun yaptÄ±ÄŸÄ±nÄ±n tersini yapan fonksiyondur. `struct tm` tÃ¼rÃ¼nÃ¼ `time_t` tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rmektedir. </br>
`mktime` fonksiyonunun bildirimi `stataic inline time_t mktime(struct tm* const _Tm);` biÃ§imindedir, fonkisyondan geriye `-1` deÄŸeri dÃ¶ndÃ¼rÃ¼lmesi dÃ¶nÃ¼ÅŸÃ¼mÃ¼n yapÄ±lamadÄ±ÄŸÄ±nÄ± hata oluÅŸtuÄŸu anlamÄ±na gelir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `mktime` fonksiyonunun kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <locale.h>

#define SIZE 100

int main(void)
{
    struct tm tx = {
        .tm_yday = 1987 - 1900, // 1987
        .tm_mon = 4, // Nisan
        .tm_mday = 1, // 1 Nsan 1987 
    };

    time_t sec = mktime(&tx);

    if(sec == -1){
        printf("donusum yapilamadi.\n");
        return 1;
    }

    printf("calendar time: %lld seconds\n", sec);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `mktime` fonksiyonunun **olaÄŸanlaÅŸtÄ±rma(normalization)** Ã¶zelliÄŸinin olduÄŸu incelenebilir.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <locale.h>

#define SIZE 100

int main(void)
{
    struct tm tx = {
        .tm_yday = 1987 - 1900, // 1987
        .tm_mon = 69, // Buradaki deÄŸer gerÃ§ek bir ay deÄŸeri deÄŸil.
        .tm_mday = 1, // 1 Nsan 1987 
    };

    time_t sec = mktime(&tx); // 'mktime' fonksiyonunun 'olaÄŸanlaÅŸtÄ±rma(normalization)' Ã¶zelliÄŸi olduÄŸu gÃ¶rÃ¼lmelidir.

    if(sec == -1){
        printf("donusum yapilamadi.\n");
        return 1;
    }

    printf("calendar time: %lld seconds\n", sec);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bu gÃ¼nÃ¼n tarihinden n gÃ¼n Ã¶ncesinin ya da sonrasÄ±nÄ±n nasÄ±l hesaplanabileceÄŸi incelenebilir, programda `mktime` fonksiyonunun **olaÄŸanlaÅŸtÄ±rma(normalization)** Ã¶zelliÄŸinden yararlanÄ±lÄ±yor.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <locale.h>

#define SIZE 100

int main(void)
{
    time_t sec;
    time(&sec);

    printf("today : %s", ctime(&sec);
    printf("kac gun : ");
    int n;
    scanf("%d", &n);

    struct tm tm = *localtime(&sec);
    tm.tm_mday += n;
    //tm.tm_mday -= n;

    time_t ft = mktime(&tm);
    printf("%d gun sonrasi : %s", n, ctime(&ft);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program yÄ±l deÄŸeri "1955" tarihi olduÄŸunda MS derleyicisinde doÄŸru Ã§alÄ±ÅŸmadÄ±ÄŸÄ±nÄ± gÃ¶rdÃ¼k, bu bana MS derleyicisinin gÃ¼venilmez olduÄŸu izlenimi bÄ±raktÄ±!
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <locale.h>

#define SIZE 100

int main(void)
{
    int d, m, y;

    printf("bir tarih girin: ");
    scanf("%d%d%d", &d, &m, &y);

    struct tm tx = {
        .tm_yday = y - 1900, 
        .tm_mon = m -1,
        .tm_mday = d,
        .tm_isdst = -1
    };

    if(mktime(&tx) != (time_t)-1){
        const char* const weekdays[] = { 
            "Pazar", "Pazartesi", "Sali", "Carsamba", "Persembe", "Cuma", "Cumartesi",
        };

        printf("yilin gunu : %d\n", tx.tm_yday);
        printf("haftanin gunu : %s\n", weekdays[tx.tm_wday]);
    }
    else{
        printf("donusum yapilamadi.\n");
    }
}
```


> â” 
> 
> SorduÄŸum soru;
> 
> 1900 Ã¶ncesi tarihler kullanÄ±lmak istense kullanÄ±lamÄ±yor o zaman 'time' kÃ¼tÃ¼phanesiyle, 1900 Ã¶ncesi tarihlerle iÅŸlem yapÄ±lmasÄ± gereken durumlar olduÄŸunda ne yapÄ±lmasÄ± gerekiyor
> 
> Cevap;
> 
> Ä°ÅŸaretli tam sayÄ± gÃ¼rÃ¼yse kullanÄ±lmasÄ±nda bir engel yok. Burada `struct tm` tÃ¼rÃ¼nÃ¼n `tm_yday` Ã¼ye deÄŸiÅŸkeni `1900` tarihinden itibaren tam sayÄ± deÄŸeri olarak tutulmasÄ±ndan dolayÄ± yanlÄ±ÅŸ dÃ¼ÅŸÃ¼nmÃ¼ÅŸÃ¼m, `tm_yday` Ã¼ye deÄŸiÅŸkenine eksi tam sayÄ± deÄŸerleri verildiÄŸinde `1900` Ã¶ncesinin yÄ±l deÄŸerleri elde edilecektir.


### `difftime` Fonksiyonu 

`difftime` fonksiyonunun adÄ± "**Different Time**" sÃ¶zcÃ¼klerinden gelmektedir ve iki tane `time_t` tÃ¼rÃ¼nden deÄŸiÅŸkenin arasÄ±ndaki zaman farkÄ±nÄ±n hesaplanmasÄ± iÃ§in kullanÄ±lan bir fonksiyonudur, fonksiyonun geri dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ tam sayÄ± tÃ¼rÃ¼ saniye(ya da salise) deÄŸeridir.



ğŸ‘‡ AÅŸaÄŸÄ±daki program `difftime` fonksiyonu kullanÄ±larak iki tane `time_t` tÃ¼rÃ¼nden deÄŸiÅŸkenin arasÄ±ndaki zaman farkÄ±nÄ±n nasÄ±l hesaplandÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <locale.h>

#define SIZE 100

int main(void)
{
    struct tm t1 = { 0 };
    struct tm t2 = { 0 };

    // BaÅŸlangÄ±Ã§ tarihi: 1 Ocak 2020
    t1.tm_year = 2020 - 1900;
    t1.tm_mon = 0;
    t1.tm_mday = 1;

    // BitiÅŸ tarihi: 28 Haziran 2025
    t1.tm_year = 2025 - 1900;
    t1.tm_mon = 5;
    t1.tm_mday = 28;

    time_t time1 = mkdir(&t1);
    time_t time2 = mkdir(&t2);

    if(time1 == (time_t)-1 || time2 == (time_t)-1){
        printf("Zaman donusum hatasi.\n");
        return 1;
    }

    double seconds = difftime(time2, time1);
    double weeks = floor(seconds / (7 * 24 * 60 * 60));

    printf("Tarihler arasÄ±nda yaklaÅŸÄ±k %.0f hafta geÃ§miÅŸtir.\n", weeks);
}
```



ğŸ§­ Åu ana kadar `time` modÃ¼lÃ¼nÃ¼n incelediÄŸimiz fonksiyonlarÄ± aÅŸaÄŸÄ±daki gibidir;
- `time`
- `localtime`
- `gmtime`
- `ctime`
- `asctime`
- `strftime`
- `difftime`


### `clock` Fonksiyonu 

`clock` fonksiyonu, sÃ¼re hesaplamak iÃ§in kullanÄ±lmaktadÄ±r, bu fonksiyonun geriye dÃ¶nÃ¼ÅŸ deÄŸeri `clock_t` tÃ¼rÃ¼dÃ¼r, `clock_t` tÃ¼rÃ¼nÃ¼n neyin eÅŸ adÄ± olduÄŸu derleyiciden derleyiciye deÄŸiÅŸmektedir(iÅŸaretli iÅŸaretsiz bir tam sayÄ± tÃ¼rÃ¼ ya da ondalÄ±klÄ± sayÄ± tÃ¼rÃ¼ olabilir). </br>
`clock` fonksiyonunun bildirimi `clock_t clock(void);` biÃ§imindedir ve programÄ±n Ã§alÄ±ÅŸmaya baÅŸlamasÄ±ndan fonksiyonun Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ± noktaya kadar Ã§alÄ±ÅŸma zamanÄ±nda geÃ§en sÃ¼reyi dÃ¶ndÃ¼rmektedir. </br>
`clock` fonksiyonunun geri dÃ¶nÃ¼ÅŸ deÄŸeri "**tick count**" deÄŸeridir, "**tick count**" deÄŸeri yazÄ±lÄ±msal ya da donanÄ±msal bir birim olabilir, "**tick count**" deÄŸerinin ne olduÄŸu derleyiciden derleyiciye deÄŸiÅŸtiÄŸi iÃ§in standart bir birim deÄŸildir, `time.h` dosyasÄ±nda bulunan `CLOCKS_PER_SEC` adÄ±ndaki makro bir saniyenin ne kadarlÄ±k "**tick count**" deÄŸerine karÅŸÄ±lÄ±k geldiÄŸi bilgisini iÃ§ermektedir, `CLOCKS_PER_SEC` makrosu da `clock_t` tÃ¼rÃ¼ndendir. </br>



C mÃ¼lakatlarÄ±nda geÃ§en zamanÄ±n hesaplanmasÄ±yla ilgili sorulabilecek sorularda yararlanÄ±labilecek olan bilgi aÅŸaÄŸÄ±daki gibidir; </br> 
ğŸ‘‡ AÅŸaÄŸÄ±daki program Ã§alÄ±ÅŸma sÃ¼resi Ã¶lÃ§Ã¼lmek istenilen kodun saniye tÃ¼rÃ¼nden hesaplayan programÄ±n nasÄ±l yazÄ±labileceÄŸi incelenebilir, programdaki kullanÄ±m idiomatic bir kullanÄ±mdÄ±r.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <locale.h>

#define SIZE 100

int main(void)
{
    clock_t tpstart = clock();

    // some code here ...

    clock_t tpend = clock();

    double _passedtime = (double)(tpend - tpstart) / CLOCKS_PER_SEC;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan 5 milyon elemanlÄ± bir tam sayÄ± dizisini standart `qsort` iÅŸleviyle kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe sÄ±ralayan ve sÄ±ralama iÅŸleminin kaÃ§ saniye sÃ¼rdÃ¼ÄŸÃ¼nÃ¼ **standard output** tarafna gÃ¶nderen program incelenebilir.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <locale.h>

#define SIZE 100

static icmp(const int* vp1, const int* vp2)
{
    int x = *(const int*)vp1;
    int y = *(const int*)vp2;

    return x > y ? 1 : x < y ? -1 : 0;
}

void mysort(int* p, size_t size)
{
    qsort(q, size, sizeof(*p), &icmp);
}

int main(void)
{
    // 5 milyon elemanlÄ± bir tam sayÄ± dizisini standart qsorth iÅŸleviyle kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe doÅŸru sÄ±ralayÄ±nÄ±z ve bu sÄ±ralama iÅŸleminin kaÃ§ saniye sÃ¼rdÃ¼ÄŸÃ¼nÃ¼ yazdÄ±rÄ±r.
    int* p = (int*)malloc(sizeof(int) * 5'000'000u);
    if(!p){
        printf("bellek yetersiz.\n");
        return 1;
    }
    
    set_array_random(p, SIZE);
    printf("siralama basladi.\n");
    
    // 'clock()' iÅŸlevini kullanarak yapÄ±lacak hesaplama ile aÅŸaÄŸÄ±daki gibi bir kod parÃ§asÄ±nÄ±n ne kadar sÃ¼re aldÄ±ÄŸÄ± Ã¶ÄŸrenilebilir.
    clock_t start = clock();
    mtsort(p, SIZE);
    clock_t end = clock();

    printf("siralama bitti '%.2f' saniye.\n", (double)(end -start) / CLOCKS_PER_SEC);
}
```

 

Bu arada az Ã¶nceki kodu denerken farkettim ki, Visual Studio 2022 ile derlendiÄŸinde, 2 Ocak 1970'den Ã¶nceki tarihlerde sonuÃ§ vermiyor(derse katÄ±lanlardan biri bÃ¶yle bir yorum ekledi).


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.20 -12.27 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


`time` kÃ¼tÃ¼phanesi bir **C tarzÄ± kÃ¼tÃ¼phane**, bazÄ± kÃ¼tÃ¼pheneler **OOP tarzÄ± kÃ¼tÃ¼phene** ve bu kÃ¼tÃ¼phaneler kullanÄ±cÄ±nÄ±n kendilerinin Ã¼yelerini gerekmedikÃ§e dÄ±ÅŸarÄ±ya aÃ§mÄ±yorlar ve dÄ±ÅŸarÄ±dan bilinmesini istemiyorlar. </br>
**OOP tarzÄ± kÃ¼tÃ¼phenelerde** bir yapÄ±nÄ±n nÄ±n elemanlarÄ± ya hiÃ§ dÄ±ÅŸarÄ±dan eriÅŸilebilir olmuyor ya da elemanlarÄ±n belirli durumlar haricinde dÄ±ÅŸarÄ±dan deÄŸiÅŸtirilmesi istenmiyor, bÃ¶yle kÃ¼tÃ¼phanelerde en ufak iÅŸleri yapmak iÃ§in bile fonksiyon Ã§aÄŸrÄ±larÄ± kullanÄ±lmasÄ± gerekmektedir.


> â” 
> 
> Sorulan soru;
> 
> OOP tarzinda da fonk ve nasil cagirildigini bilmek gerek sanirim. ikisi arasinda tercih krikteri nasil omali kendimiz kÃ¼tÃ¼phane yazarken
> 
> Cevap;
> 
> Sistem programlama tarafÄ±nda aÄŸÄ±rlÄ±klÄ± olarak **C tarzÄ± kÃ¼tÃ¼phane** kullanÄ±lmasÄ± tercih ediliyor, **OOP tarzÄ± kÃ¼tÃ¼phene** kullanÄ±lmasÄ± daha Ã§ok uygulama programcÄ±lÄ±ÄŸÄ± tarafÄ±nda tercih ediliyor.


## Complete Types and Incomplate Types KavramlarÄ± 

Bu konu baÅŸlÄ±ÄŸÄ± C++ kursuna katÄ±lacaklar aÃ§Ä±sÄ±nda da Ã§ok Ã¶nemli bir konu ve iyi bilinmesi gerekiyor.

â—â—â— **Incomplate type** kavramÄ± daha Ã§ok **kullanÄ±cÄ± tanÄ±mlÄ± tÃ¼rler(user defined types)** ile ilgilidir. **KullanÄ±cÄ± tanÄ±mlÄ± tÃ¼rler(user defined types)** olmayan tÃ¼rlerden sadece **void pointer tÃ¼rÃ¼(`void*`)** tÃ¼rÃ¼ **incomplate type** diÄŸerleri **complete type**.

Derleyicisinin bakÄ±ÅŸ aÃ§Ä±sÄ±ndan bir **kullanÄ±cÄ± tanÄ±mlÄ± tÃ¼r(user defined type)** ya **complete type** ya da **incomplate type**.

**Complete type**: EÄŸer derleyici bir tÃ¼rÃ¼n bildiriminin tamamÄ±nÄ± gÃ¶rÃ¼yorsa(o tÃ¼r yapÄ± tÃ¼rÃ¼yse yapÄ±nÄ±n tÃ¼m Ã¼yelerini gÃ¶rebiliyorsa) o tÃ¼re **complete type** deniliyor.

**incomplate type**: EÄŸer derleyici bir tÃ¼rÃ¼n bildiriminin tamamÄ±nÄ± gÃ¶remiyorsa o tÃ¼re **incomplate type** deniliyor.


ğŸ‘‡ AÅŸaÄŸÄ±daki program parÃ§asÄ±nda **complete type** ve **incomplate type** kavramlarÄ±nÄ±n ne olduklarÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
// AÅŸaÄŸÄ±daki 'struct Nec' tÃ¼rÃ¼ 'complete type' durumundadÄ±r.
struct Nec {
    int x, y;
    double d;
};


// AÅŸaÄŸÄ±daki fonksiyon bildiriminde 'struct Nec2' tÃ¼rÃ¼ 'incomplete type' durumundadÄ±r.
struct Nec2 foo(struct Nec2);

// AÅŸaÄŸÄ±daki bildiriminde 'struct Nec3' tÃ¼rÃ¼  'incomplete type' durumundadÄ±r. Burada derleyiciye 'struct Nec3' adÄ±ndaki bir tÃ¼rÃ¼n olduÄŸu sÃ¶yleniyor ama o tÃ¼rÃ¼n ne olduÄŸuna dair bir bilgi verilmiyor ve bÃ¶yle olunca da ortada eksik bilgi oldÄŸu iÃ§in 'tamamlanmamÄ±ÅŸ tÃ¼r' anlamÄ±na gelen 'incomplate type' deniliyor.
struct Nec3;


int main(void)
{

}
```



â—â—â— **incomplate type** ve **complate type** tÃ¼rlerle ilgili aÅŸaÄŸÄ±daki tespitler Ã¶nemlidir;
- BazÄ± bildirimler ya da bazÄ± ifadeler, sÃ¶z konusu tÃ¼rÃ¼n **incomplate type** olmasÄ± durumunda da geÃ§erlidir.
- BazÄ± ifadelerin geÃ§erli olmasÄ± iÃ§in kullanÄ±lan tÃ¼rÃ¼n **complate type** olmasÄ± zorunludur.


**Incomplate type** kullanabilen ifadelerde Ã§oÄŸu zaman tÃ¼rÃ¼n **complate type** yapÄ±lmasÄ± istenmez.

â—â—â— EÄŸer bir modÃ¼ldeki bir ya da bir kaÃ§ varlÄ±ÄŸÄ±n kullanÄ±lmasÄ± gerekiyorsa, ilgili modÃ¼lÃ¼n kaynak dosyaya eklenmesi yerine sedece kaynak dosyadaki gerekli olan veri tÃ¼rleri **incomplate type** olarak eklenebilir ve fonksiyonlarÄ±n bildirimleri yazÄ±labilir.

â—â—â— Bir kaynak dosyasÄ±na bir Ã§ok baÅŸlÄ±k dosyasÄ±nÄ±nÄ±n eklenmesi aÅŸaÄŸÄ±daki sorunlara neden olabilir;
- BÃ¼yÃ¼k projelerde derleme zamanÄ± uzar(extended compile time).
- Gereksiz modÃ¼llerin eklenmesi gereksiz yere BaÄŸÄ±mlÄ±lÄ±k oluÅŸturmaktadÄ±r(kaynak dosyalarÄ±nÄ±n baÅŸlÄ±k dosyalarÄ±na baÄŸÄ±mlÄ±lÄ±ÄŸÄ±). BaÄŸÄ±mlÄ±lÄ±klarda bir baÅŸlÄ±k dosyasÄ±nda yapÄ±lan deÄŸiÅŸikliÄŸin baÅŸka bir dosyada da deÄŸiÅŸiklil yapÄ±lmasÄ±na neden olabilir.



En Ã§ok yapÄ±lan hata, programcÄ±nÄ±n **incomplate type** kavramÄ±nÄ±n ne olduÄŸunu bilmediÄŸi ve anlamadÄ±ÄŸÄ± iÃ§in bir baÅŸlÄ±k dosyasÄ±nÄ±n eklenmesinin zorunlu olduÄŸunu dÃ¼ÅŸÃ¼ndÃ¼ÄŸÃ¼ iÃ§in o baÅŸlÄ±k dosyasÄ±nÄ± kaynak koda ekliyor(`#include` ile). </br>
Bir baÅŸlÄ±k dosyasÄ±ndaki bir kaÃ§ tÃ¼rÃ¼ kullanmak iÃ§in `#include` iÅŸlemi ile o tÃ¼rlerin bildirimlerinin yer aldÄ±ÄŸÄ± baÅŸlÄ±k dosyasÄ±nÄ± eklemek yerine o tÃ¼rlerin kullanÄ±lacaÄŸÄ± dosyaya o tÃ¼rlerin bildirimlerinin **incomplate type** olarak eklenmesi yeterli olacaktÄ±r, bu iÅŸlem ile eklenen **incomplate type** tÃ¼rler bir baÄŸÄ±mlÄ±lÄ±k oluÅŸturmamaktadÄ±r.


**Incomplate type** aÅŸaÄŸÄ±daki durumlarda kullanÄ±labilir;
1. Fonksiyon bildirimlerindeki tÃ¼rlerin **complate type** olmasÄ± gerekmemektedir.

    
    ğŸ‘‡ AÅŸaÄŸÄ±daki program parÃ§asÄ±nda fonksiyon bildirimlerindeki parametre ve geri dÃ¶nÃ¼ÅŸ tÃ¼rleri **complate type** olmasÄ± gerekmediÄŸi gÃ¶rÃ¼lmelidir.
    ```C
    struct Nec; // Buradaki 'struct Nec' tÃ¼rÃ¼ Ã¼yelerinin tamanÄ± bilinmediÄŸi iÃ§in 'incomplate type' durumundadÄ±r.

    // AÅŸaÄŸÄ±daki fonksiyon bildirimlerindeki parametre ve geri dÃ¶nÃ¼ÅŸ tÃ¼rleri 'incomplate type' durumundadÄ±r.
    struct Nec foo(struct Nec);
    struct Nec* bar(struct Nec*);
    ```


2. TÃ¼r eÅŸ adÄ± bildirimlerinde bildirilen tÃ¼rler **incomplate type** olabilir. 

    ğŸ‘‡ AÅŸaÄŸÄ±daki program parÃ§asÄ±nda **incomplate type** yapÄ± tÃ¼rÃ¼ Ã¼zerinden bildirimleri yapÄ±lan tÃ¼r eÅŸ adlarÄ± incelenebilir.
    ```C
    struct Nec; // Buradaki 'struct Nec' tÃ¼rÃ¼ Ã¼yelerinin tamanÄ± bilinmediÄŸi iÃ§in 'incomplate type' durumundadÄ±r.

    // typedef declerations 
    typedef struct Nec Nec; // 'struct Nec' yapÄ± tÃ¼rÃ¼ne 'Nec' tÃ¼r eÅŸ adÄ± verilmiÅŸtir.
    typedef struct Nec* NecPtr; // 'struct Nec*' yapÄ± tÃ¼rÃ¼ gÃ¶stericisi tÃ¼rÃ¼ne 'NecPtr' tÃ¼r eÅŸ adÄ± verilmiÅŸtir.
    typedef Nec(*Fptr)(Nec); // Burada 'struct Nec(*)(struct Nec)' fonksiyon gÃ¶stericisi iÃ§in 'Fptr' adÄ±ndan bir 'function pointer' tÃ¼r eÅŸ adÄ± bildirimi yapÄ±lmÄ±ÅŸtÄ±r.
    ```

3. `extern` bildirimlerinde **incomplate type** kullanÄ±labilir.

    
    ğŸ‘‡ AÅŸaÄŸÄ±daki program parÃ§asÄ±nda `extern` ile bildirilen tÃ¼rlerin **incomplate type** olabileceÄŸi gÃ¶rÃ¼lebilir.
    ```C
    struct Nec; // Buradaki 'struct Nec' tÃ¼rÃ¼ Ã¼yelerinin tamanÄ± bilinmediÄŸi iÃ§in 'incomplate type' durumundadÄ±r.

    extern struct Nec x;
    extern struct Nec ar[20];
    ```

4. **Incomplate type** durumunda gÃ¶sterici deÄŸiÅŸkenler oluÅŸturulabilir.

    
    ğŸ‘‡ AÅŸaÄŸÄ±daki program parÃ§asÄ±nda **incomplate type** durumundaki yapÄ± tÃ¼rÃ¼nÃ¼n kullanÄ±labildiÄŸi gÃ¶rÃ¼lebilir, buradan da anlaÅŸÄ±lacaÄŸÄ± gibi tamamlanmamÄ±ÅŸ bir tÃ¼r ile fonksiyon bildirimleri yapÄ±labilir ve kaynak dosya derlenebilir durumdadÄ±r fakat **baÄŸlama(linker)** aÅŸamasÄ±nda bu **incomplate type** varlÄ±klarÄ±n **complate type** hallerinin bulunabilir olmasÄ± gerekiyor diÄŸer tÃ¼rlÃ¼ baÄŸlama iÅŸleminde hata oluÅŸur.
    ```C
    struct Nec; // Buradaki 'struct Nec' tÃ¼rÃ¼ Ã¼yelerinin tamanÄ± bilinmediÄŸi iÃ§in 'incomplate type' durumundadÄ±r.

    struct Nec* create_nec(int, int); 
    void foo(struct Nec*);
    void bar(struct Nec*);


    int main(void)
    {
        struct Nec* necptr = create_nec(3, 6);
        foo(necptr);
        bar(necptr);
    }
    ```


Ders sonu ...
