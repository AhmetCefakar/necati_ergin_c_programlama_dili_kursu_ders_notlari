# 35.Ders 17.05.2025 🕘

Derse 13(09:01)-14(09:05)-16(09:23)-17(09:43)-15(10:45)-15(11:13)-15(12:25)-15(12:45) kişi katıldı.
---

## Pointer To Pointer Devam


❗❗❗ Programcılar başlangış aşamasında **değişkenlerin türü(decleration type)** ve **ifadelerin türü(expression type)** kavramlarını birbirine karıştırıyormuş ama bu terimler birbirlerinden farklıdır ve farkları iyi bilinmelidir.

`int x = 10; int* ptr = &x;` burada `x` değişkeninn türü `int` ve `ptr` değişkeninn türü `int*` türüdür.


👇 Aşağıdaki sözde kodda değişkenlerin türünün başka ifadelerin türünün başka olma durumu incelenebilir, **integral promotion** durumuna da değiniliyor 
```C

int x1; // 'x1' değişkeninin türü 'int'
int* x2; // 'x2' değişkeninin türü 'int*'
int** x3; // 'x3' değişkeninin türü 'int**'
int x4[10]; // 'x4' değişkeninin türü 'int[10]'

char c = 6; // 'c' değişkeninin türü 'char'

+c; // '+c' ifadesinin türü 'integral promotion' nedeniyle 'int', buradan da görülüyor ki değişkenlerin türü başka ifadelerin türü başkadır.


int x = 10;
int* ptr = &x;

/*

'ptr' ifadesinin türü 'int*'

'*ptr' ifadesinin türü 'int'

*/
```


❗❗❗ **Value Category**: C standardında bu terim kullanılmasa da C++ standardı bu terim kullanılıyor ve ifadelerin **value category** değerlerinin ne olduğu o ifadelerin hangi işlemlerde kullanılabileceğini belirliyor, bellekte bir yazılımsal varlığa erişilebilmesini sağlayacak olan ifadeler **L-value**, tam tersi bir nesneye erişim sağlamayan ifadeler **R-value** ifadelerdir.
- **Adres operatörü(`&`)** ile oluşturulan tüm ifadeler **R-value** grubuna dahildir.
- Tüm değişken adları(identifier) **L-value** grubuna dahildir, çünkü bellekte yer alan nesnelerdir.
- **Dereferencing(içerik) operatörü(`*`)** ile oluşturulan tüm ifadeler **L-value** grubuna dahildir.



❗❗❗ 👇 Aşağıdaki programda ifadelerin türleri ve **value category** değerlerinin ne olduğu incelenebilir, buradaki bilgiler iyi bilinmelidir yoksa konularda ilerlenemeyecektir.
```C
#include <stdio.h>

int main(void)
{
    int x = 10;
    int* p = &x;
    int** ptr = &p;

    /*

    ifade   Type    Value
    x       int     L
    &x      int*    R
    p       int*    L
    *p      int     L
    &p      int**   R
    ptr     int**   L
    *ptr    int*    L
    **ptr   int     L
    &ptr    int***  R
    
    */
}
```



👇 Aşağıdaki program **pointer to pointer** değişkenlerin temel olarak nasıl çalıştığını anlamak için incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 10;
    int y = 45;
    int* p = &x;
    int** ptr = &p;

    //*ptr = &y;
    **ptr = 99; // '*(*ptr)' ile denktir ve buradaki kod 'x' değişkeninin değerini '99' yapar. '**ptr' ifadesi sözel olarak şuna denktir: 'ptr değişkeninin gösterdiği nesne olan p nesnesinin gösterdiği x nesnesi demektir.'
    
    printf("x = %d\n", x);
    ++**ptr; // 'x' değişkeninin değeri bir arttırılıyor.
    printf("x = %d\n", x);
}
```



👇 Aşağıdaki programda **double dereferencing** ya da **double indirection** olarak adlandırılan işlemin ne olduğu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 10;
    int 7 = 45;
    int* p = &x;
    int** ptr = &p;

    // '**' operatörü ile iki defa bir nesnenin değerine erişme işlemine 'double-dereferencing' ya da 'double-indirection' deniliyor.
    **ptr = 99;
    
    printf("x = %d\n", x);
    ++**ptr;
    printf("x = %d\n", x);
}
```



👇 Aşağıdaki programda **pointer to pinter** değişkenlerde bazı kafa karıştırıcı durumlar incelenebilir, buradaki işlemler iyi anlaşılmalıdır ve anlaşılmadan ilerlenmemelidir(ayrıca bu konuyla ilgili olarak internetten yeterli sayıda soru bulup anlaşılarak çözülmelidir)
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[] = { 1, 3, 5, 7, 9 };
    int* p = a;
    int** ptr = &p;

    print_array(a, 5);
    ++*ptr; // Buradaki ifade '++(*ptr)' ile aynıdır ve burada '*ptr' ifadesi ile 'p' nesnesinin değeri '1' arttırılıyor 'p' nesnesi bir pointer olduğu için pointer aritmetiği kuralları gereği gösterdiği adres değeri bir 'int' türü kadar ötelenen adres değeri olacaktır ve böylece 'a' dizisinin 1 indisli elemanını işaret eder durumu gelecektir.
    ++**ptr; // Buradaki ifade '++(**ptr)' ile aynıdır ve burada '**ptr' ifadesi ile 'p' nesnesinin gösterdiği nesneye erişiliyor, bir önceki kodda 'p' nesnesinin gösterdiği nesne 'a' dizisinin 1 indisli elemanı yapılmıştı ve bu nesnenin değeri bir arttırılıyor, 'a' dizisinin 1 indisli elemanının türü 'int' olduğu için bu değer bir arttırılacaktır, ilk değer '3' ve son değeri '4' olacaktır.
    print_array(a, 5);

    // C ve C++ dillerinde aşağıdaki gibi karmaşık bir ifade yazılabiliyor, bu kısmıda '*&' alt ifadesinin birbirini nötürlediği anlaşılmalıdır.
    ++*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&**ptr;
    print_array(a, 5);
}
```


### Pointer To Pointer Ne İşe Yarar 

**Pointer to pointer** ne işe yarar sorusunun kendisi gereksiz bir sorudur çünkü pointer ne için kullanılıyorsa "**Pointer to pointer**" da o amaçla kullanılıyor.


👇 Aşağıdaki programda `iswap` adındaki `int*` türünden iki nesnenin gösterdiği adreslerdeki nesnelerin değerlerini takas eden fonksiyon incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

//  'iswap' adı 'int swap' sözcüklerinden gelmektedir.
// 'int*' türden iki pointer nesnenin gösterdiği adreslerdeki nesnelerin değerlerini takas eden fonksiyon
void iswap(int* p1, int* p2)
{
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}

int main(void)
{
    int x = 13;
    int y = 23;

    printf("x = %d, y = %d\n", x, y);
    iswap(&x, &y);
    printf("x = %d, y = %d\n", x, y);
}
```



👇 Aşağıdaki programda `foo` adında kendisine `int*` türünden göstericinin işaret ettiği nesnenin değerini değiştiren fonksiyon incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

void foo(int* p)
{
    *p = 7623;
}

int main(void)
{
    int x = 10;

    printf("x = %d\n", x);
    foo(&x);
    printf("x = %d\n", x);
}
```



👇 Aşağıdaki programda `foo` adında kendisine `int**` türünden bir göstericiyi gösteren nesne iletilince o nesnenin gösterdiği nesne adresi değerini global ad alanında olan "g" değişkeninin adresi olarak değiştiren fonksiyon incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int g = 47;

void foo(int** p)
{
    *p = &g; // Burada 'p' parametresinin gösterdiği nesnenin(ki o nesne 'int*' türündedir yani 'int' türünden bir nesneyi gösteren bir pointer) değeri global 'g' nesnesinin adresi yapılıyor.
}

int main(void)
{
    int x = 13;
    int* ptr = &x;
    
    printf("*ptr = %d\n", *ptr);
    foo(&ptr);
    printf("*ptr = %d\n", *ptr);
}
```



👇 Aşağıdaki programda iki pointer değişkenin değerlerinin(yani tuttukları adres değerlerinin) nasıl takas edildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a = 133;
    int b = 513;

    int* p1 = &a;
    int* p2 = &b;
    
    printf("*p1 = %d    *p2 = %d\n", *p1, *p2);

    // Aşağıda pointer değişkenlerin değerleri takas edilmektedir, burada takas edilen pointer değişkenlerin tuttuğu adres değerleridir.
    int* temp = p1;
    p1 = p2;
    p2 = temp;

    printf("*p1 = %d    *p2 = %d\n", *p1, *p2);
}
```



👇 Aşağıdaki programda `pswap` adındaki `int**` türünden iki nesnenin değerlerini takas eden fonksiyon incelenebilir, `pswap` fonksiyonu kendisine gönderilen `int` türünden nesnelerin adreslerini tutan pointer nesnelerin adres değerlerini takas etmektedir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

void pswap(int** ptr1, int** ptr2)
{
    int** temp = *ptr1;
    *ptr1 = *ptr2;
    *ptr2 = temp;
}

int main(void)
{
    int a = 133;
    int b = 513;

    int* p1 = &a;
    int* p2 = &b;
    

    printf("*p1 = %d    *p2 = %d\n", *p1, *p2);

    pswap(&p1, &p2);

    printf("*p1 = %d    *p2 = %d\n", *p1, *p2);
}
```



👇 Aşağıdaki programda "setptr" adındaki `int**` türünden bir pointer parametre alan ve aldığı bu `int*` türünden nesnenin adres değerini `NULL` olarak değiştiren fonksiyon incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

void setptr(int** p)
{
    //p = NULL; // Buradaki işlem ile sadece fonksiyonun kendi içinde var olan 'p' adındaki parametre değişkeninin değeri 'NULL pointer' olarak değiştirilmiş oluyor.

    *p = NULL;
}

int main(void)
{
    int* ptr;

    setptr(&ptr);

    if(ptr == NULL)
        pritf("dogru\n");
    else
        pritf("yanlis\n");
}
```



👇 Aşağıdaki program çalıştırılmak için yazılmamıştır sadece **pointer to pointer** değişkenlerin kullanımını iyi anlayabilmek için bazı bilgiler için incelenmelidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

void foo(int);

void bar(int** p)
{
    *p; // '*p'ye atama yapılsa main fonksiyonundaki locak değişken olan 'ptr' değişkeninin değeri değişecektir.
    **p; // '**p' ye atama yapılsa main fonksiyonundaki locak değişken olan 'x' değişkeninin değeri değişecektir.
}

int main(void)
{
    int x = 5;
    int* ptr = &x;

    foo(ptr); // 'foo' fonksiyonu 'ptr'nin değerini değiştiremez ama 'foo' fonksiyonu 'ptr'nin gösterdiği nesnenin(yani 'x' nesnesinin) değerini değiştirebilir.

    bar(&ptr); // 'bar' fonksiyonu 'ptr'nin değerini değiştirebilir ve aynı zamanda 'ptr'nin gösterdiği nesnenin değerini de değiştirebilir.
}
```



❗❗❗ Aşağıdaki program bu dersin en zorlayıcı bilgilerini içeriyor, dikkatli incelenmelidir. </br>
👇 Aşağıdaki programdan bir dizinin hem en büyük hem de en küçük elemanını geriye döndüren fonksiyonun nasıl yazıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 20

// 'get_array_min_max' fonksiyonu dışarıdan alacağı tam 
void get_array_min_max(const int* pa, size_t size, int** ptrmin, int** ptrmax)
{
    // Dizinin en küçük elemanının adresini *ptrmin değişkenine yaz.
    // Dizinin en büyük elemanının adresini *ptrmax değişkenine yaz.
    *ptrmin = *ptrmax = (int*)pa;

    for(size_t i = 0; i < size; ++i){
        if(pa[i] < **ptrmin){
            *ptrmin = (int*)(pa + i);
            //*ptrmin = &pa[i];
        }
        else if(pa[i] > **ptrmax){
            *ptrmax = (int*)(pa + i);
            //*ptrmax = &pa[i];
        }
    }
}

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    int* pmin;
    int* pmax;

    get_array_min_max(ar, SIZE, &pmin, &pmax);

    printf("min = %d, indeks = %d\n", *pmin, pmin - ar);
    printf("max = %d, indeks = %d\n", *max, max - ar);

    swap(pmini, pmax);
    print_array(ar, SIZE);
}
```


>❔
> 
> Sorulan soru; 
> 
> Geçen derslerde yazığımız fonksiyonları da böyle kullanabiliriz değil mi? 
> 
> void get_array_minmax(const int *pa, size_t size, int **ptrmin, int **ptrmax)
> {
>     *ptrmax = get_array_max(pa, size);
>     *ptrmin = get_array_min(pa, size);
> }
> 
> Cevap;
> 
> Aşağıdaki ilk C programı bu soru üzerine yazılmıştır.



👇 Aşağıdaki programda `get_array_min_max` fonksiyonu iki ayrı fonksiyonu kullanacak şekilde yazılmıştır, bu kullanım ile **reusability(yeniden kullanılabilirlik)** kullanımının güzel bir misali görülebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 10

int* get_array_max(const int* pa, size_t size)
{
    int* pmax = (int*)pa;

    for(size_t i = 0; i < size; ++i){
        if(pa[i] > *pmax){
            pmax = (int*)(pa + i);
        }
    }

    return pmax;
}

int* get_array_min(const int* pa, size_t size)
{
    int* pmin = (int*)pa;

    for(size_t i = 0; i < size; ++i){
        if(pa[i] < *pmax){
            pmin = (int*)(pa + i);
        }
    }

    return pmin;
}

void get_array_min_max(const int* pa, size_t size, int** ptrmin, int** ptrmax)
{
    // Dizinin en küçük elemanının adresini *ptrmin değişkenine yaz.
    // Dizinin en büyük elemanının adresini *ptrmax değişkenine yaz.
    *ptrmin = get_array_min(pa, size);
    *ptrmax = get_array_max(pa, size);
}

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random();
    print_array(ar, SIZE);

    int* pmin;
    int* pmax;

    get_array_min_max(ar, SIZE, &pmin, &pmax);

    printf("min = %d, indeks = %d\n", *pmin, pmin - ar);
    printf("max = %d, indeks = %d\n", *max, max - ar);

    swap(pmini pmax);
    print_array(ar, SIZE);
}
```



👇 Aşağıdaki programda pointer dizisi üzerinde yapılan işlemler incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

// Aşağıdaki foo fonksiyonu 'int** ptr' parametresiyle dışarıdan bir pointer dizisinin elemanının ilk adresini alıp işleyecek şekilde yazılmıştır.
void foo(int** ptr, int size)
{
    printf("foo' function called. => ");

    for(int i = 0; i < size; ++i){
        printf("%d ", *ptr[i]);
        ++*ptr[i]; // Burada dizinin 
    }
}

int main(void)
{
    int x = 10, y = 20, z = 30, t = 40;

    printf("%d %d %d %d", x, y, z, t);

    int* ptr_ary[4] = { &x, &y, &z, &t };
    foo(ptr_ary, 10);

    printf("%d %d %d %d", x, y, z, t);
}
```



👇 Aşağıdaki programda `int*` ve `int**` parametre alan fonksiyonlara hangi türden değerlerin geçilebileceği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

void foo(int* ptr, int size);
void bar(int** ptr, int size);

int main(void)
{
    int a[5];
    foo(a, 5); // Buradaki statement derleyici tarafından 'array decay' işlemiyle 'foo(&a[0], 5);' olarak yorumlanacaktır.

    int* b[5];
    bar(b, 5); // Buradaki statement derleyici tarafından 'array decay' işlemiyle 'bar(&b[0], 5);' olarak yorumlanacaktır.
}
```

 

👇 Aşağıdaki programda `int**` türünden elemanları olan dizi kullanımı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int x = 3, y = 5, z = 7, t = 9;

    printf("%d %d %d %d", x, y, z, t);

    int* px = &x;
    int* py = &y;
    int* pz = &z;
    int* pt = &t;

    int** ar[4] = { &px, &py, &pz, &pt, };

    for(int i = 0; i < size; ++i){
        ++**ar[i];
    }

    printf("%d %d %d %d", x, y, z, t);
}
``` 



👇 Aşağıdaki programda `char*` türünden elemanları yazı olan bir dizinin referansını bir fonksiyona geçerek o dizinin elemanlarının nasıl standart çıktı akımına gönderilebileceği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

void print_names(char** pa, size_t size)
{
    for(size_t i = 0; i < size; ++i){
        printf("%s ", pa[i]);
    }
    printf("\n\n");
}

int main(void)
{
    char* p[] = {  
        "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
        "hakki", "haldun", "halime", "haluk", "handan" "hande", "handesu", "hasan", "helin", "hikmet",
        "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
        "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata", // Burada iki yazı arasında olması gereken ',' token'ı unutulmuştur.
    };

    for(size_t i = 0; i < asize(p); ++i){
        printf("%s ", p[i]);
    }

    printf("\n~~~~~~~~~~~~~~~~~~~~~\n");

    print_names(p, asize(p));
}
``` 



👇 Aşağıdaki programda "sort_name" adlı fonksiyon elemanları `char*` türünden yazılar olan bir pointer dizisindeki elemanları "booble-sort" algoritmasıyla sıralamaktadır.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h> // Yazıları karşılaştırmak için 'strcmp' fonksiyonunu kullanabilmek için eklenen başlık dosyası.
#include "nutility.h"

void print_names(char** pa, size_t size)
{
    for(size_t i = 0; i < size; ++i){
        printf("%s", pa[i]);
    }
    printf("\n\n");
}

void sort_name(char** pa, size_t size)
{
    // 
    for(size_t i = 0; i < size - 1; ++i){
        for(size_t k = 0; k < size - 1; ++k){
            if(strcmp(p[k], p[k + i]) > 0){
                char* ptemp = p[k];
                p[k] = p[k + 1];
                p[k + 1] = ptemp;
            }
        }
    }
}

int main(void)
{
    const char* p[] = {  
        "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
        "hakki", "haldun", "halime", "haluk", "handan" "hande", "handesu", "hasan", "helin", "hikmet",
        "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
        "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata", // Burada iki yazı arasında olması gereken ',' token'ı unutulmuştur.
    };

    print_names(p, asize(p));
    sort_name(p, asize(p));
    print_names(p, asize(p));

    /*
        'p' ifadesi ile '&p[0]' ifadesi birbirine denktir, bu ifadelerin denk olmasının nedeni 'p' kullanılan çoğu yerde(bunun birkaç istisnası var) 'array decay conversion' uygulanmasıdır!

    */
}
``` 

>❔
> 
> Sorulan soru; 
> 
> Türleri farkli olsa da 
> p ile "refika" dizisinin adresleri sayisal olarak ayni mi?
> p array decay
> 
> Cevap;
> 
> Buradaki soruda sorulmak istenilen 'char' türünden elemanları olan dizi türlerinden birden fazlası kendi elemanı olan bir değişkenin 



❗❗❗ 👇 Aşağıdaki programda yazıları tutan dizilerle pointer değişken ve pointer ifadelerin kullanımları incelenebilir, bu programdaki bilgiler önemlidir ve iyi anlaşılmalıdır.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

int main(void)
{
    // 'p' değişkeninin türü 'char*[5]'tir. 'p' ifadesinin çoğu yerde 'array decay'den dolayı '&p[0]' olarak yorumlanır ve bu ifadenin türü de 'char**' türüdür.
    char* p[] = { 
        "ozan", "fersen", "zerpin", "necati", "cavzen", "aypar" 
    };

    puts(p[0]); // Burada ekrana dizinin ilk char dizisini yazar.
    puts(&p[0]); // Buradaki kod hatalıdır, 'ub' vardır çünkü '&p[0]' demek 'p' dizisinin ilk elemanının adresi demek ve o adreste 'string literal' bir varlığın ilk adresi değer olarak bulunuyor.
    
    puts(p); // Bu işlem 'ub' durumuna neden olur. 'p' dizi adı olduğu için derleyici 'array decay' ile '&p[0]' olarak yorumlanacaktır, fakat 'p' değişkeni bir 'char*' türünden elemanları olan pointer dizi olduğu için '&p[0]' ifadesinin 'puts' fonksiyonuna geçilmesi tanımsız davranıştır.
    puts(*p); // Bu kod legal ve geçerlidir, standart çıktı akımına 'p' dizisinin ilk elemanı olan yazı gönderilir.
}
```



❗❗❗ 👇 Aşağıdaki programda yazıları tutan dizilerle ilgili **pointer to pointer** kullanımı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

void print_names(char** pa, size_t size)
{
    for(size_t i = 0; i < size - 1; ++i){
        printf("%c\n", *pa[i]); // Burada yazı dizisinin her bir elemanının ilk karakteri yazdırılır. 
        printf("%s\n", pa[i]); // Burada yazı dizisinin her bir elemanı yazdırılır.
    }

    // Aşağıdaki döngü yukarıdaki döngü ile aynı verileri yazdırmaktadır.
    for(size_t i = 0; i < size - 1; ++i){
        putchar(*pa[i]); // Burada yazı dizisinin her bir elemanının ilk karakteri yazdırılır. 
        putchar('\n');
        puts(pa[i]); // Burada yazı dizisinin her bir elemanı yazdırılır.
    }
}

int main(void)
{
    char* p[] = { 
        "ozan", "furkan", "zeynep", "necati", "cavit", "ayhan" 
    };

    print_names(p, asize(p));
}
```


***
==================================================

✦✦✦✦✦ 10.49-11.12 birinci ara verildi. ✦✦✦✦✦

==================================================
***



👇 Aşağıdaki programda bu derste önceden yazılan bir yazı dizisinin elemanlarını sıralayan fonksiyondaki takas işlemi yapan kısım `cswap` adında ayrı bir fonksiyona alınmıştır ve `print_names` adındaki fonksiyon C dilinin idiomatic yapısında yeniden yazılmıştır.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

void print_names(char** pa, size_t size)
{
    while(size--)
        printf("%s ", *pa++);
    
    // Yukarıdaki döngünün idiom kullanılmadan yazılmış hali aşağıdaki gibidir
    //while(size--){
    //    printf("%s ", *pa);
    //    pa++;
    //}
}

//void print_names_old(char** pa, size_t size)
//{
//    for(size_t i = 0; i < size; ++i){
//        printf("%s", pa[i]);
//    }
//    printf("\n");
//}

void cswap(char** p1, char** p2)
{
    char* ptemp = *p1*;
    *p1 = *p2;
    *p2 = ptemp;
}

void sort_name(char** pa, size_t size)
{
    for(size_t i = 0; i < size - 1; ++i){
        for(size_t k = 0; k < size - 1; ++k){
            if(strcmp(p[k], p[k + i]) > 0){
                //cswap(&p[k], &p[k + i]);
                cswap(p + k, p + k + i); // Buradaki kullanım yukarıdaki kullanımın pointer aritmetiği kullanılmış halidir.
            }
        }
    }
}

int main(void)
{
    const char* p[] = {  
        "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
        "hakki", "haldun", "halime", "haluk", "handan" "hande", "handesu", "hasan", "helin", "hikmet",
        "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
        "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata", // Burada iki yazı arasında olması gereken ',' token'ı unutulmuştur.
    };

    print_names(p, asize(p));
    sort_name(p, asize(p));
    print_names(p, asize(p));
}
``` 


### Pointer To Pointer And cost 


❗❗❗ **const** anahtar sözcüğü neyden önce gelirse **const** olan odur. 
- `int * const p = &x;` burada **const** anahtarı `p` değişkeninden önce geliyor ve bu bildirim **const pointer to int** olarak adlandırılır, bu durumda `p` pointer değişkeninin adres değeri değiştirilmesi **sözdizim hatasına(syntax error)** neden olur ama `*p` ifadesine atama işlemi yapılırsa **sözdizim hatası(syntax error)** olmaz.
- `int const * p = &x;` ya da `const int * p = &x;` burada **const** anahtarı `*p` den önce geliyor ve bu bildirim **pointer to const int** olarak adlandırılır. bu durumda `p` pointer değişkeninin adres değerinin değiştirilmesi **sözdizim hatası(syntax error)** değildir ama `*p` ifadesine atama işlemi yapılırsa **sözdizim hatası(syntax error)** olur.
- `const int * const p = &x;` ya da `int const * const p = &x;` birdiriminda hem `p` hem de `*p` ifadelerine değer atanması **sözdizim hatası(syntax error)** olacaktır.



❗❗❗ 👇 Aşağıdaki programda pointer değişkenlerin **const** bildirilmesi durumları incelenebilir, buradaki bildirimleri anlamak önemlidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

int main(void)
{
    int x = 19;
    int y = 37;
    int* p1 = &x;
    int* p2 = &y;

    int** ptr1 = &p1; 

    // Aşağıdaki atamaların hiçbirinde sözdizim hatası(syntax error) yoktur
    ptr1 = &p2; // Legal atama işlemi.
    *ptr1 = &y; // Legal atama işlemi.
    **ptr1 = 98; // Legal atama işlemi.


    int** const ptr2 = &p1; // Burada 'ptr2' pointer değişkeni 'const' bildiriliyor.

    ptr2 = &p2; // Bu atama işleminde sözdizim hatası(syntax error) oluşur.
    *ptr2 = &y; // Legal atama işlemi.
    **ptr2 = 98; // Legal atama işlemi.


    int* const * ptr3 = &p1;

    ptr3 = &p2; // Legal atama işlemi.
    *ptr3 = &y; // Bu atama işleminde sözdizim hatası(syntax error) oluşur.
    **ptr3 = 98; // Legal atama işlemi.


    int const ** ptr4 = &p1;

    ptr4 = &p2; // Legal atama işlemi.
    *ptr4 = &y; // Legal atama işlemi.
    **ptr4 = 98; // Bu atama işleminde sözdizim hatası(syntax error) oluşur.

    const int** ptr5 = &p1;

    ptr5 = &p2; // Legal atama işlemi.
    *ptr5 = &y; // Legal atama işlemi.
    **ptr5 = 98; // Bu atama işleminde sözdizim hatası(syntax error) oluşur.

    const int* const * const ptr6 = &p1;

    ptr6 = &p2; // Bu atama işleminde sözdizim hatası(syntax error) oluşur.
    *ptr6 = &y; // Bu atama işleminde sözdizim hatası(syntax error) oluşur.
    **ptr6 = 98; // Bu atama işleminde sözdizim hatası(syntax error) oluşur.

    const int* const * const ptr7 = &p1;

    ptr7 = &p2; // Bu atama işleminde sözdizim hatası(syntax error) oluşur.
    *ptr7 = &y; // Bu atama işleminde sözdizim hatası(syntax error) oluşur.
    **ptr7 = 98; // Bu atama işleminde sözdizim hatası(syntax error) oluşur.

    int const * const * const ptr8 = &p1;

    ptr8 = &p2; // Bu atama işleminde sözdizim hatası(syntax error) oluşur.
    *ptr8 = &y; // Bu atama işleminde sözdizim hatası(syntax error) oluşur.
    **ptr8 = 98; // Bu atama işleminde sözdizim hatası(syntax error) oluşur.
}
```



👇 Aşağıdaki programda "sort_name" adlı fonksiyon elemanları `char*` türünden yazılar olan bir pointer dizisindeki elemanları "booble-sort" algoritmasıyla sıralamaktadır, buradaki değişken bildirimlerinde **const** olması gereken değişkenlerin bildirimlerine dikkat edilerek bildirimler yapılmıştır.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h> // Yazıları karşılaştırmak için 'strcmp' fonksiyonunu kullanabilmek için eklenen başlık dosyası.
#include "nutility.h"

void print_names(char* const * pa, size_t size)
{
    pa[i] = NULL; // Bu bildirim sözdizim hatasıdır(syntax error), 'pa' dizisi elemanları yazı olan bir dizi olduğu için bu atamaya izin verilmemesi gerektiğinden 'pa' parametresinin bildirimi buna uygun yapılmıştır.

    for(size_t i = 0; i < size; ++i){
        printf("%s", pa[i]);
    }
    printf("\n\n");
}

void cswap(char** p1, char** p2)
{
    char* ptemp = *p1*;
    *p1 = *p2;
    *p2 = ptemp;
}

void sort_name(char** pa, size_t size)
{
    // 
    for(size_t i = 0; i < size - 1; ++i){
        for(size_t k = 0; k < size - 1; ++k){
            if(strcmp(p[k], p[k + i]) > 0){
                char* ptemp = p[k];
                p[k] = p[k + 1];
                p[k + 1] = ptemp;
            }
        }
    }
}

int main(void)
{
    const char* p[] = {  
        "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
        "hakki", "haldun", "halime", "haluk", "handan" "hande", "handesu", "hasan", "helin", "hikmet",
        "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
        "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata", // Burada iki yazı arasında olması gereken ',' token'ı unutulmuştur.
    };

    print_names(p, asize(p));
    sort_name(p, asize(p));
    print_names(p, asize(p));
}
``` 



❗❗❗ 👇 Aşağıdaki programda "**Bir fonksiyonun parametresi dizi olamaz.**" cümlesinde belirtilen ifadenin doğruluğu incelenebilir, aşağıdaki programı derleyip çalıştırarak inceleme yap.
```C
#include <stdio.h>
#include <string.h>
#include "nutility.h"

// Aşağıdaki fonksiyon bildirimlerinin hepsi aynıdır, C dilince diziler 'array-decay' işlemine tabi olacağı için bir fonksiyonun parametresi dizi olamaz.
void foo1(int* p);
void foo2(int p[]);
void foo3(int p[10]);

void foo(int p[10])
{
    printf("sizeof(a) = %zu", sizeof(a)); // Burada 'sizeof(a)' değeri fonksiyonun 'int p[10]' olarak bildirilen parametresinin türünü pointer olduğu için programın derleneceği donanımın adres kapasitesine uygun değeri ekrana yazacaktır.
}

int main(void)
{
    int a[10]  = { 0 };

    printf("sizeof(a) = %zu", sizeof(a));

    foo(a);
}
```



❗❗❗ 👇 Aşağıdaki programda "**Bir fonksiyonun parametresi dizi olamaz.**" cümlesinde belirtilen ifadenin doğruluğu incelenebilir
```C
#include <stdio.h>
#include <string.h>
#include "nutility.h"

// Aşağıdaki fonksiyon bildirimlerinin ikise de aynıdır.
void foo1(int** p);
void foo2(int* p[]);


void foo(int p[])
{
    printf("sizeof(a) = %zu", sizeof(a));
}

int main(void)
{
    int a[10]  = { 0 };

    printf("sizeof(a) = %zu", sizeof(a));

    foo(a);
}
```

>❔
> 
> Sorulan soru; 
> 
> İki boyutlu diziyi adresiyle fonk.'a gectigimde (mesela p[8][8]) debugger davranisindan bi farklilik goruyorum. Bazen fonksiyon icinde debugger'la diziye bakinca dizinin sadece ilk row'unu goruyorum. Ama Bunun anlami nedir?
> 
> Cevap;
> 
> Bu soruya cevap verilmeyecek çünkü sorulan soru **multi-dimensional arrays** konusuyla ilgili ve bu konu pointerlar ile ilgili olan zor başlıkların en sonuncu konusu.



⚠️ Biz aynı zamanda C++ dilini öğreniyoruz, C++ dilinin içerisinde C kursunda anlatılanlar anlatılmıyor ve C++ kursuna gelenlerin en az %70 oranında C dilini iyi bildiği kabul ediliyormuş ve C++ dilinin konuları ona göre anlatılıyor.


## void Pointers 

### `void` Type

❗❗❗ C ve C++ dillerinde `void` bir türdür(void is a type) ama bir değeri olmayan türdür.

❗❗❗ `void` bir değişkenin türü olamaz ama `void` bir ifadenin türü olabilir. C++ dilinde daha önemli bir yeri vardır.


👇 Aşağıdaki programda değişken türü bildirimi gereken yerlerde `void` kullanılamayacağı incelenebilir.
```C
int main(void)
{
    void x; // Burada bir değişkenin türü 'void' olamayacağı için sözdizim hatası(syntax error) oluşacaktır.
    void ary[10]; // Bir dizinin elemanlarının türü 'void' olamayacağı için sözdizim hatası(syntax error) oluşacaktır.
}
```



`void` ifadeler aşağıdaki gibi iki şekilde oluşturulabilir;
- `void` fonksiyonlara yapılan çağrı ifadelerinin türü `void` türüdür.
- Tür dönüştürme operatörü ile `void` türden ifadeler oluşturulabilir.


👇 Aşağıdaki programda geri dönüş değeri olmayan(yani void olan) bir donksiyona yapılan çağrı ifadesinin türünün ne olacağı incelenebilir.
```C
#include <stdio.h>
#include <string.h>
#include "nutility.h"

void foo(int); // void function

int main(void)
{
    foo(12321); // Bu statement'taki 'foo(12321)' ifadesinin türü 'void' türüdür.
}
```


🧠 Neden bir ifadeyi `void` yapma ihtiyacı hissederiz;
- 👇 Aşağıdaki programda `(void)` tür dönüşümünün kullanıldığı bir durum incelnebilir.
```C
#include <stdio.h>
#include <string.h>
#include "nutility.h"

void foo();

int main(void)
{
    for(int i = 0; i < 10; ++i){
        printf("%d ", i);
        (void)getchar(); // Standart input'tan tek bir karakter okunuyor ama bu fonksiyonun geri dönüş değerini 'discard' edildiğini vurgulamak için '(void)' tür dönüştürme operatörü kullanılıyor.
    }
}
```



`void` türü bir tür gerektiren hiç bir ifadede kullanılamaz. </br>
👇 Aşağıdaki programda yukarıdaki cümleyle ilgili kullanımlar incelenebilir.
```C
#include <stdio.h>
#include <string.h>
#include "nutility.h"

void foo(int);

int main(void)
{
    int x = foo(9); // Fonksiyondan döenn değer 'void' ve bu değer 'int' türüne ilk değer olarak verilmek istendiği için sözdizim hatası(syntax error).

    // Aşağıdaki if deyiminin kullanılması sözdizim hatasıdır(syntax error).  
    if(foo(21)){

    }
}
```



❗❗❗ Derleyicilerin bakış açısından türler iki öbeğe ayrılmaktadır, bu öbekler aşağıdaki gibidir(bu konu detaylı olarak bir ay sonra işlenecekmiş);
1. **Complate Type(Eksik olmayan, Tamamlanmış tür)**
2. **Incomplate Type(Tamamlanmamış, Eksik olan tür)**

❗❗❗ Dilin kuralı şudur: "**Incomplate**" türlerden değişken tanımlanamaz yani tanımlanan bir değişkenin türü "**Incomplate Type**" olamaz. </br>
❗❗❗ `void` türü **incomplate** bir türdür ama tek **incomplate** tür `void` türü değildir, ileride bu konu detaylı işlenecekmiş.



👇 Aşağıdaki programda C++ dilinde legal bir kullanım içeren `baz` fonksiyonu incelenebilir ama ne için kullanıldığına değinilmedi, kısaca bir değinildi.
```Cpp
#include <stdio.h>
#include <string.h>
#include "nutility.h"

// Aşağıdaki fonksiyon tanımı hatalıdır çünkü geri dönüş değeri olmayan bir fonksiyondan değer döndürülmeye çalışılıyor, bu C ve C++ dilinde hatalıdır.
void foo(void)
{
    return 1;
}

void bar(void);

void baz()
{
    return bar(); // C++'da legal, C'de illegal.
}
```



❗❗❗ 👇 Aşağıdaki programda `void` türünün fonksiyon bildirimlerinde iki farklı kullanımı incelenebilir. </br>
C dilinin ilk zamanlarında `void` türü yoktu bu nedenden dolayı fonksiyon bildirimlerinde parametre olmadığında boş bırakılıyordu ve fonksiyon çağrılarının doğru yapılma sorumluluğu programcıya bırakılıyordu.
```C

// Aşağıdaki iki farklı fonksiyon bildirimi aldığı parametre ve geri dönüş değeri açısından C++ dili için aynı anlama gelirken C dili için aynı anlama gelmemektedir.
void foo(); // Buradaki bildirim C dilinde geriye doğru uyumluluktan dolayı 'foo' fonksiyonunun parametre değişkeni konusunda bilgi vermiyorum anlamına geliyor ve burada C dili için 'implicit int(gizli int)' vardır.
void bar(void);

int main(void)
{
    foo(1, 3, 44); // Bu fonksiyon çağrısında C derleyicisi uyarı vermez ama C++ derleyicisi uyarı verir.

    bar(3, 5); // Burada C ve C++ diline derleyici uyarı verecektir.
}
```


### void Pointer Type(`void*` Türü) 

❗❗❗Aşağıdaki bilgiler önemlidir;
- `void` türü ile `void*` birbirinden faklıdır, `void*` türünden bir değişken tanımlanabilir, `void*` türü bir **object pointer** türüdür. </br>
- `void*` pointer türü herhangi bir türden değişkenin adresini değer olarak alabilir, kısaca ne tür adres olursan ol gel diyor 😊.
- `void*` pointer `*` ve `&` operatörlerinin operandı olamaz. </br>
- `void*` pointer türünden nesneler ile poiner aritmetiği yapılamaz. </br>
- `sizeof` operatörünün operandı sadece **complate type** olabilir bu nedenle de `void` türü `sizeof` operatörünün operandı olamaz.


👇 Aşağıdaki programda farklı pointer türlerinin bildirimlerinin yapıldığı gibi `void` türünden de pointer değişken bildirimi yapılabileceği görülebilir.
```C
#include <stdio.h>

int main(void)
{
    void* vptr; // 'vptr' değişkeninin türü 'void*' türüdür.
    int* iptr; // 'iptr' değişkeninin türü 'int*' türüdür.
    double* dptr; // 'dptr' değişkeninin türü 'double*' türüdür.
}
```


❗❗❗ 👇 Aşağıdaki programda `sizeof` operatörünün operandının `void` türü olamayacağı esasen `sizeof` operatörünün operandının herhangi bir **incomplate type(tamamlanmamış, eksik olan tür)** olamaz ve farklı pointer türlerinin byte değerlerinin ne olduğu incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    //size_t sz1 = sizeof(void); // Burada sözdizim hatası(syntax error) oluşur.

    printf("sizeof(int*) = %zu\n", sizeof(int*));
    printf("sizeof(double*) = %zu\n", sizeof(double*));
    printf("sizeof(double****) = %zu\n", sizeof(double****));
    printf("sizeof(void*) = %zu\n", sizeof(void*));
}
```



👇 Aşağıdaki programda bir pointer değişkenin kendi göstermesi gereken tür dışında bir türün adres değerini almasının yanlış olduğu durum incelenebilir. 
```C
#include <stdio.h>

int main(void)
{
    int x = 10;
    double* p = &x; // C++ dilinde sözdizim hatasıdır(syntax error), C dilinde derleyiciler uyarı bildirimi yaparlar.
}
```



👇 Aşağıdaki programda `void*` türünün farklı değerleri alabileceği incelenebilir.
```C
#include <stdio.h>

// Aşağıdaki 'func' fonksiyonu herhangi bir türden bir değişken alabilir, bu gibi değişkenlere 'generic function' denilmektedir.
void func(void*);

int main(void)
{
    int x = 10;
    double d = 3.4; 
    char str[] = "eren";

    void* vptr;

    // `void*` türünden bir değişken her türlü adres değerini tutabilir.
    vptr = &x;
    vptr = &d;
    vptr = str;
}
```



👇 Aşağıdaki programdan `void*` türünden nesnelerin `*` ve `&` operatörlerinin operandı olamaz, `void*` türünden nesneler ile poiner aritmetiği yapılamaz kuralları incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 10;
    double d = 3.4;

    void* vp = &x;

    *vp; // Burada sözdizim hatası(syntax error) vardır.
    vp + 3; // Burada sözdizim hatası(syntax error) vardır.


    int ary[10] = { 0 };
    void* vp1 = a + 8;
    void* vp2 = a + 3;

    vp1 - vp2; // Buradaki pointer aritmetiği işlemi sözdizim hatasıdır(syntax error) çünkü 'void*' türden değişkenlerle pointer aritmetiği yapılamaz.
}
```



❗❗❗ 👇 Aşağıdaki programda `void*` türünün adres türü tuttuğu incelenebilir ama `void*` türünden değişkenler ne tuttuklarını bilmez, tutulan türü anca programı yazan **_bilinçli bir varlık_** bilebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 23;
    void* vptr = &x;
    
    printf("&x = &p\n", &x);
    printf("vptr = &p\n", vptr);
}
```


***
==================================================

✦✦✦✦✦ 12.13-12.24 ikinci ara verildi. ✦✦✦✦✦

==================================================
***



❗❗❗ `void*` türüyle ilgili C ve C++ dillerindeki ortak ve farklı kurallar iyi bilinmelidir;
- C ve C++ dillerinde herhangi bir adres türü `void*` türüne örtülü olarak dönüşebilir yani konunun başında belirtildiği gibi `void*` türden bir değişkene herhengi bir türden nesnenin adresi açık şekilde tür dönüşümü yapmadan atanabilir.
- `void*` türünden herhangi bir adres türüne örtülü tür dönüşümü C dilinde vardır ama C++ dilinde yoktur, yapıldığında **sözdizim hatasıdır(syntax error)**.



👇 Aşağıdaki programda `void*` türünden herhangi bir adres türüne örtülü tür dönüşümünün C ve C++ dillerinde nasıl olduğu incelenebilir.
```C
#include <stdio.h>

// Aşağıdaki 'foo' fonksiyonu dışarıdan gelecek 'vptr' parametresinin türü bilmez, bu türü sadece bu fonksiyona çağrı yapan bilebilir. (!bu bilgi önemli!)
void foo(void* vptr)
{
    // Some code here.
}

int main(void)
{
    int x = 10;
    void* vptr = &x;

    int* iptr = vptr; // Bu atama işlemi C dilinde legal'dir ve kullanılmaktadır ama C++ dilinde legal değildir(legal olması için tür dönüşümü yapılması gerekir).

    printf("%d\n", *iptr);
}
```


>❔
> 
> Sorulan soru; 
> 
> Pointer kullanan bir fonksiyona void* ptr ile arguman gondersek, fonksiyon icinde turunu bilmeden mesela icerde int* turune cast edip uzerinde islem yapmak mantikli mi?
> 
> Cevap;
> 
> Hayır, bununla ilgili bilgiler şimdi görülecek



📌 Şu ana kadar `void*` türüne ait **sözdizimi(syntax)** anlatıldı, ne işe yarıyor sorusunun cevabına şimdi cevap verilmeye başlanacak, bundan sonrası çok daha önemli!

❗❗❗ C dilinde bir pointer türünden başka bir pointer türüne örtülü olarak tür dönüşümü yapmak(mesela `int*` türünden `double*` türüne atama yapmak) yanlış bir işlemdir ama C dilinde bu tür bir işlem legaldir(sözdizim hatasına neden olmaz) ama yapılmamalıdır.


### Generic Functions 

**Generic programlama paradigması** programlama dillerinin geneli için bir terimdir, C++ dilinin en güçlü olduğu alan **generic programlama** denilebilir.

C++ dilinin **sözdiziminin(syntax)** yarıdan fazlası **Generic programlama** yaklaşımıyla ilgilidir.

**Generic programlama paradigması** türden bağımsız olarak kodlama yapayı ifade eder ve her programlama dilinin bir ya da daha fazla **generic programlama** yöntemi olabilir. 

Öyle bir fonksiyon ki birden fazla farklı tür için kullanılabiliyor, işte böyle fonksiyonlara **Generic Function** deniliyor.

Türden bağımsız fonksiyon yazmak farklı farklı araçlarla yapılabilir, kursun ilerleyen saatlerinde bunun için C dilinde nasıl araçlar var anlatılacaktır. 

❗❗❗ `void*` türü genellikle **generic function** larda kullanılan bir türdür, bir fonksiyonun birden fazla türe hizmet vermesi isteniyorsa(birden fazla farklı türden argümanlarla çağırılabilmesi isteniyorsa) o fonksiyonun bir ya da daha fazla argümanı `void*` türünden olmalıdır.



👇 Aşağıdaki programda türden bağımsız olarak kendisine gönderilen aynı türden iki türü takas edecek `gswap` fonksiyonunun nasıl yazıldığı incelenebilir, bu takas işlemini yapacak olan fonksiyon iki tane taks edilecek `void*` türünden parametre almalı ve takas edilecek türün byte boyutu bilgisini almalı ve bu bilgileri kullanarak türü bilinmeyen bu nesnelerin değerleri byte byte takes edilerek takas işlemi yapılabilir.
```C
#include <stdio.h>
#include "nutility.h"

// 'gswap' adı 'Generic Swap' sözcüklerinden gelmektedir.
// Aşağıdaki 'gswap' fonksiyonu herhangi bir tür için takas işlemi yapmaktadır.
// 'gswap' fonksiyonu ile sadece aynı türden nesneler takas edilmelidir.
// vp1  : Takas edilecek ilk nesnenin adresi.
// vp2  : Takas edilecek ikinci nesnenin adresi.
// sz   : Kaç byte alan takas edileceği bilgisi.
void gswap(void* vp1, void* vp2, size_t sz)
{
    char* p1 = (char*)vp1; // '(char*)' tür dönüştürme operatörü ile yapılan tür dönüşümü işlermi hem kodu okuyana hem de derleyiciye açık şekilde bildirilmiş olacaktır.
    char* p2 = (char*)vp2;

    // Aşağıdaki döngünün koşul ifadesinde idiomatik yapı kullanılmıştır ama döngü gövdesinde idiomatik yapılar kullanılmamıştır.
    //while(sz--){
    //    char temp = *p1;
    //    *p1 = *p2;
    //    *p2 = temp;
    //    ++p1;
    //    ++p2;
    //}

    // Aşağıdaki döngünün koşul ifadesinde ve gövdesinde idiomatik yapılar kullanılmıştır.
    while(sz--){
        char temp = *p1;
        *p1++ = *p2;
        *p2++ = temp;
    }
}

int main(void)
{
    int x = 3423, y = 5532;

    printf("x = %d, y = %d", x, y);
    gswap(&x, &y, sizeof x);
    printf("x = %d, y = %d", x, y);

    double d1 = 43.543543;
    double d2 = 13.543543;

    printf("d1 = %f, d2 = %f", d1, d2);
    gswap(&d1, &d2, sizeof d1);
    printf("d1 = %f, d2 = %f", d1, d2);

    int ary1[] = { 1, 3, 5, 7, 9, };
    int ary2[] = { 9, 3, 2, 6, 8, };

    print_array(ary1, 5);
    print_array(ary2, 5);
    gswap(&ary1, &ary2, sizeof ary2);
    print_array(ary2, 5);
}
```



Generic takas işlemini yapan `gswap` fonksiyonunu "nutility.h" dosyasına alınması işlemi;

✍️ "nutility" dosyalarına `gswap` fonksiyonu dahil edildi, bu `gswap` fonksiyonunu ileride sıkça kullanacağız.
```C
// 'nutility.h' dosyasına aşağıdaki 'fuction decleration' eklenmiştir.

void gswap(void* vp1, void* vp2, size_t sz);

```


```C
// 'nutility.c' dosyasına aşağıdaki 'fuction defination' eklenmiştir.

// 'gswap' adı 'Generic Swap' sözcüklerinden gelmektedir.
// Aşağıdaki 'gswap' fonksiyonu herhangi bir tür için takas işlemi yapmaktadır.
// 'gswap' fonksiyonu ile sadece aynı türden nesneler takas edilmelidir.
// vp1  : Takas edilecek ilk nesnenin adresi.
// vp2  : Takas edilecek ikinci nesnenin adresi.
// sz   : Kaç byte alan takas edileceği bilgisi.
void gswap(void* vp1, void* vp2, size_t sz)
{
    char* p1 = (char*)vp1; // '(char*)' tür dönüştürme operatörü ile yapılan tür dönüşümü işlermi hem kodu okuyana hem de derleyiciye açık şekilde bildirilmiş olacaktır.
    char* p2 = (char*)vp2;

    // Aşağıdaki döngünün koşul ifadesinde idiomatik yapı kullanılmıştır ama döngü gövdesinde idiomatik yapılar kullanılmamıştır.
    //while(sz--){
    //    char temp = *p1;
    //    *p1 = *p2;
    //    *p2 = temp;
    //    ++p1;
    //    ++p2;
    //}

    // Aşağıdaki döngünün koşul ifadesinde ve gövdesinde idiomatik yapılar kullanılmıştır.
    while(sz--){
        char temp = *p1;
        *p1++ = *p2;
        *p2++ = temp;
    }
}
```



Yukarıda yazılmış olan `gswap` fonksiyonuyla ilgili bazı soruların ve cevaplarının ne olduğunu inceleyelim;
1. `gswap` fonksiyonunun takas edilecek nesneleri tutan parametrelerinin türü `char*` olamaz mıydı?
    - `gswap` fonksiyonunun bildirimi `void gswap(char* vp1, char* vp2, size_t sz)` olsaydı, bu fonksiyonun bildirimine bakıldığında bu fonksiyonun **generic function** olduğu anlaşılmazdı.
    - `gswap` fonksiyonunun bildirimi `void gswap(char* vp1, char* vp2, size_t sz)` olsaydı, bu fonksiyona `char*` türü dışındaki türler ile çağrı yapılacağı zaman fonksiyon çağrısı yapılan yerde tür dönüşümü yapılması gerekecekti.
2. `gswap` fonksiyonunun takas eteceği kendisine parametre olarak gelecek olan nesnelerin takas edilmesi işlemi `char*` türüne dönüşüm yapılmadan yapılabilir mi?
    - Hayır yapılamaz çünkü `vp1` ve `vp2` parametre değişkenlerinin türü belli olmalığı için bu pointer değişkenlerin gösterdiği nesnelere erişilemez.



❗❗❗ C standardı şunu açıkça belirtiyor, herhangi bir adres türünden `char*` türüne tür dönüşümü yapılabilir, bu işlem bir istisnadır zaten bu istisna üzerine C dilinde "**Generic Programing**" yaklaşımı inşa ediliyor.



👇 Aşağıdaki programda farklı türlerden `char*` türüne tür dönüşümü yapılıp, bu pointer üzerinden nasıl o nesnenin değerinin değiştirilebildiği incelenebilir ve bu işlem hem legal hem de mantıken doğru kullanımı olan bir yaklaşımdır.
```C
#include <stdio.h>

int main(void)
{
    int x = 1212414;
    char* p = (char*)&x; // Buradaki tür dönüşümü legaldir ve burada bir 'ub' yoktur, 

    for(size_t i = 0; i < sizeof(int); ++i){
        p[i] = 0;
    }

    printf("x = %d\n", x);


    double y = 21421.56435;
    p = (char*)&y; // Buradaki tür dönüşümü legaldir ve burada bir 'ub' yoktur, 

    for(size_t i = 0; i < sizeof(double); ++i){
        p[i] = 0;
    }

    printf("y = %d\n", y);
}
```

⚠️ Bir sonraki dersin önemli bir kısmında "**void Pointers**" konusu devam edecek ondan sonra da **Function Pointers** konusuna geçilecek.


Ders sonu ...
