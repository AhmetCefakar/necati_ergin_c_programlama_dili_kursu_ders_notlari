# 20.Ders 16.03.2025 ğŸ•˜

Derse 9(09:00)-11(09:02)-16(09:32)-18(10:02)-19(10:41)-19(11:30)-18(12:18) kiÅŸi katÄ±ldÄ±.
---

## `#pragma` Ã–n-iÅŸlemci Komutu Devam


FarklÄ± derleyicilerin farklÄ± `#pragma` **Ã¶niÅŸlemci kullanÄ±mÄ±** bulunmaktadÄ±r, Ã¶zellikle Gcc derleyicisinde bir Ã§ok `#pragma` **Ã¶niÅŸlemci kullanÄ±mÄ±** mevcuttur.

ğŸ§  BazÄ± `#pragma`'lar iÅŸimizi kolaylaÅŸtÄ±rmaktadÄ±r, mesela derleyici programÄ± **buyruk satÄ±rÄ±ndan(command line)** Ã§alÄ±ÅŸtÄ±rÄ±rken bazÄ± **switch**'lari vermek yerine doÄŸrudan kaynak kodda `#pragma`'lar kullanÄ±labilir.

ğŸ“Œ MSVC derleyicisi Microsoft derleyicisidir.

ğŸ‘‡ AÅŸaÄŸÄ±daki programda **MSVC derleyicisinde** kullanÄ±labilecek bazÄ± `#pragma` kullanÄ±mlarÄ± gÃ¶rÃ¼lebilir.
```C
#pragma warning(disable: 4996) // Bir uyarÄ±nÄ±n gizlenmesini saÄŸlar.
#pragma warning(push) // Mevcut uyarÄ± seviyelerini yÃ¼kler.
#pragma warning(default: 4996) // Bir varsayÄ±lan haline getirilmesi.

#pragma warning(pop) // En son belirlenen uyarÄ± seviyelerini yÃ¼kler.

#pragma inline_depth(3) // Bu kod iÃ§ iÃ§e Ã¼Ã§ fonksiyon Ã§aÄŸrÄ±sÄ±na kadar 'inline extension' yapmaya Ã§alÄ±ÅŸ anlamÄ±na gelmektedir.



#define NEC 10


#if NEC > 5

#pragma message("burada derleme anÄ±nda Output ekranÄ±na bu yazÄ± yazdÄ±rÄ±lacaktÄ±r.")

#endif


#include <stdio.h>

int main(void)
{
    int x = 20;

    // AÅŸaÄŸÄ±daki gibi 'region' kullanÄ±labiliyor, kodu mantÄ±ksal bloklara ayÄ±rmak iÃ§in kullanÄ±lÄ±yor.
    #pragma region region01

    ++x;
    ++x;
    ++x;
    ++x;
    ++x;
    ++x;

    #pragma endregion region01
}
```


C dilindeki kontrol deyimleri(statement) aÅŸaÄŸÄ±daki gibidir, bu derste `switch` ve `goto` deyimleri(statement) incelenecektir. 
- `if`
- `for`, `while`, `do while`
- `break`, `continue`, `return`
- `switch` 
- `goto`


## `switch` Statement 

`switch` deyiminin varlÄ±k nedeni bazÄ± **if-else merdivenlerinin** yerine kullanÄ±labilecek bir deyimdir.</br>
**switch statement** olmasaydÄ± bu deyim ile yazÄ±labilen her ÅŸey **if-else ladder** ile yapÄ±labilirdi.</br>
`switch` deyimi bazÄ± durumlarda kodun daha okunup yazÄ±labilmesi iÃ§in kullanÄ±lÄ±r.</br>
Her **switch statement** yapÄ±sÄ± **if-else ladder** ile yazÄ±labilir ama her **if-else ladder** yapÄ±sÄ± **switch statement** yazÄ±lamaz.</br>
`switch` daha Ã¶zel bir deyimken if-else daha Ã¶zel bir deyimdir, `switch` deyimiyle yazÄ±lan her ÅŸey if-else deyimiyle de yazÄ±labilir ama tersi doÄŸru deÄŸildir.


â—**switch deyimi(statement)** bir tam sayÄ± ifadesinin farklÄ± deÄŸerleri iÃ§in programÄ±n akÄ±ÅŸÄ±nÄ± farklÄ± noktalara Ã§ekmek iÃ§in kullanÄ±lmaktadÄ±r.

â—â—â— `switch` deyiminde "expr" **ifadesi(expression)** bir tam sayÄ± tÃ¼rÃ¼nden olmak zorundadÄ±r.

â—â—â— `case` bir label(etiket) Ã¶zelliÄŸindedir ve "**case value:**" deyimindeki "value" sabit(constant) tam sayÄ±(integer type) deÄŸerinde olmak zorundadÄ±r.


"**case value:**" deyiminden sonra bir deyim(statement) gelmesi gerekiyor yoksa **sÃ¶zdizim hatasÄ±(syntax error)** oluÅŸacaktÄ±r.</br>
C ve C++ dillerine bir `case` deyiminin sonunda `break` deyimi kullanÄ±lmazsa `switch` iÃ§erisinden Ã§Ä±kÄ±lmaz. **break statement** sadece ya **if statement** ya da **switch statement** iÃ§erisinde kullanÄ±labilir.</br>
`case` label'Ä±n alacaÄŸÄ± deÄŸer `switch` iÃ§erisinde sadece tek bir label'a verilebilir.</br>
`case` label'Ä±n ifadesi **constand(`3`, `5` vb. sayÄ±sal deÄŸerler)** ya da **constant expression(`3 * 5 + 5` ÅŸeklinde ifadeler)** olabilir.


ğŸ‘‡ AÅŸaÄŸÄ±daki kodda basit bir `switch` statement nasÄ±l olduÄŸu incelenebilir.
``` C
switch(expr){
    case 45:
        // some code here...
    break;
    case 3:
        // some code here...
    break;
    case 42:
    ; // NULL statement
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda **switch statement** kullanÄ±mÄ±na dair hangi kullanÄ±mlarÄ±n legal hangilerinin illegal olduÄŸu gÃ¶rÃ¼lebilir. `break;` statement kullanÄ±lmÄ±yor.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x;

    int a = 7;
    const int b = 8; // Burada ki 'b' 'constand variable' olarak tanÄ±mlanÄ±r ama bu tanÄ±m adÄ±ndan da anlaÅŸÄ±lacaÄŸÄ± gibi oksi-moron gibidir.

    double dval = 234.45;

    printf("bir tam sayi giriniz: ");
    scanf("%d", &x);

    // AÅŸaÄŸÄ±daki `switch` kullanÄ±mÄ± legal'dir
    switch(x){

    }

    // AÅŸaÄŸÄ±daki `switch` kullanÄ±mÄ± legal'dir
    switch(x){
        int y = 12;
    }

    // AÅŸaÄŸÄ±daki `switch` kullanÄ±mÄ± illegal'dir
    switch(dval){

    }

    switch(x){
        case 1: printf("bir\n");
        case 5: printf("bes\n");
        case 2: printf("iki\n");
        case 3: printf("uc\n");
        case 4: printf("dort\n");
        case 6: printf("alti\n");
        case a: printf("yedi\n"); // Burada C ve C++ dilinde sÃ¶zdizim hatasÄ±(syntax error) oluÅŸacaktÄ±r.
        case b: printf("sekiz\n"); // Burada C dilinde sÃ¶zdizim hatasÄ±(syntax error) oluÅŸacaktÄ±r ama C++ dilinde legal bir kullanÄ±mdÄ±r.
    }

    printf("main fonksiyonu Ã§alÄ±ÅŸmaya devam ediyor...");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **switch statement** kullanÄ±mÄ±nda `case` ifadesinde verilen deÄŸerin eÅŸsiz olmak zorunda olduÄŸu durum incelenebilir. `break;` statement kullanÄ±lmÄ±yor.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x;
    printf("bir tam sayi giriniz: ");
    scanf("%d", &x);

    // AÅŸaÄŸÄ±daki gibi `switch` kullanÄ±mÄ± illegal'dir Ã§Ã¼nkÃ¼ '1' deÄŸeri iki defa kullanÄ±lmÄ±ÅŸtÄ±r.
    switch(x){
        case 1: printf("bir\n");
        case 5: printf("bes\n");
        case 2: printf("iki\n");
        case 3: printf("uc\n");
        case 1: printf("dort\n"); // Bu koddan dolayÄ± sÃ¶zdizim hatasÄ±(syntax error) oluÅŸacaktÄ±r Ã§Ã¼nkÃ¼ iki defa 'case 1:' kullanÄ±lmÄ±ÅŸ oluyor.
        case 6: printf("alti\n");
    }

    printf("main fonksiyonu Ã§alÄ±ÅŸmaya devam ediyor...");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **switch statement** kullanÄ±mÄ±nda `case` ifadesine verilen deÄŸerin bir sabit ifadesi olmak zorunda olduÄŸu incelenebilir. `break;` statement kullanÄ±lmÄ±yor.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x;
    printf("bir tam sayi giriniz: ");
    scanf("%d", &x);

    int a = 7;
    const int b = 8;

    // AÅŸaÄŸÄ±daki gibi `switch` kullanÄ±mÄ± illegal'dir Ã§Ã¼nkÃ¼ 'a' ve 'b' ifadeleri sabit ifadesi deÄŸildir.
    switch(x){
        case 1: printf("bir\n");
        case 5: printf("bes\n");
        case 2: printf("iki\n");
        case 3: printf("uc\n");
        case 1: printf("dort\n");
        case 6: printf("alti\n");
        case a: printf("yedi\n"); // Burada C ve C++ dilinde sÃ¶zdizim hatasÄ±(syntax error) oluÅŸacaktÄ±r.
        case b: printf("sekiz\n"); // Burada C dilinde sÃ¶zdizim hatasÄ±(syntax error) oluÅŸacaktÄ±r ama C++ dilinde legal bir kullanÄ±mdÄ±r.
    }

    printf("main fonksiyonu Ã§alÄ±ÅŸmaya devam ediyor...");
}
```



ğŸ§­ `case` ifadesindeki deÄŸerler ne olabilir; 
- `case float_constant:` deyimi geÃ§ersizdir.
- `case int_constant:` deyimi geÃ§erlidir.
- `case 'C':` deyimi geÃ§erlidir Ã§Ã¼nkÃ¼ `'C'` bir int tÃ¼rÃ¼dÃ¼r. `'C'`, `'r'`, `'\n'` ÅŸeklindeki varlÄ±klar C dilinde **character constant(karakter sabiti)** ve C++ dilinde **character literal(karakter sabiti)** olarak adlandÄ±rÄ±lmaktadÄ±r.
- `case "C":` deyimi geÃ§ersizdir Ã§Ã¼nkÃ¼ "C" bir **string constant** olduÄŸu iÃ§in.
- `case ON:**, **case OFF:** deyimleri eÄŸer `ON` `OFF` ifadeleri int tÃ¼rÃ¼nden **object-like macro** ise bu kullanÄ±m legal olacaktÄ±r.
- `case 2 * 3 - 1 + 6:` deyimi geÃ§erlidir, `2 * 3 - 1 + 6` ifadesi bir **constant expression** ifadesidir.



> â” 
> Sorulan soru;
> 
> Gcc de `case x:` diye bir label oluÅŸturdum c dilinde, daha sonra const int olmadÄ±ÄŸÄ± hatasÄ±nÄ± verdi x i const yaptÄ±ktan sonra hata vermedi normalde vermesi gerekmiyor muydu. ben ÅŸÃ¶yle derledim hocam ozgurcicek@ozgur-MacBook-Air algo % gcc "4test.c". bende extension ile alakalÄ± olduÄŸunu dÃ¼ÅŸÃ¼ndÃ¼m hocam emin olmak iÃ§in sormak istedim
> 
> ```C
> #include <stdio.h>
> 
> int main(void)
> {
>     const int x = 5;
> 
>     switch(x)
>     {
>         case 1:
>                 break;
>         case x:
>                 break;
>     }
> }
> ```
> 
> Cevap;
> 
> Derleme C++ dilinde yapÄ±ldÄ±ysa hata oluÅŸmayacaktÄ±r ama C dilinde yapÄ±lÄ±rsa derleyici hata verecektir ya da kullanÄ±lan derleyicinin bu konuda uyguladÄ±ÄŸÄ± **compiler extension** kullanÄ±mÄ±ndan dolayÄ± **sÃ¶zdizim hatasÄ±(syntax error)** vermeyebilir.
> 



ğŸ‘‡ AÅŸaÄŸÄ±daki program en temel **if-else ladder** kullanÄ±mÄ±nÄ±n nasÄ±l **switch statement** ile birlikte yazÄ±labileceÄŸini anlamak iÃ§in incelenebilir. `break;` statement kullanÄ±lÄ±yor.
```C
#include <stdio.h>

int main(void)
{
    int x;

    printf("bir tam sayi giriniz: ");
    scanf("%d", &x);

    switch(x){
        case 1: printf("bir\n"); break;
        case 2: printf("iki\n"); break;
        case 3: printf("uc\n"); break;
        case 4: printf("dort\n"); break;
        case 5: printf("bes\n"); break;
        case 6: printf("alti\n"); break; // Bu kÄ±sma 'break;' deyimi eklenmesi ya da eklenmemesi bir ÅŸeyi deÄŸiÅŸtirmez ama okunaklÄ±lÄ±k iÃ§in eklenmesi tavsiye edilir.
    }

    printf("main fonksiyonu buradan Ã§alÄ±ÅŸmaya devam ediyor.");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki gibi bir program yazÄ±labilir, `switch` iÃ§inde bloklar kullanÄ±labilir. `break;` statement kullanÄ±lÄ±yor.
```C
#include <stdio.h>

int main(void)
{
    int x;

    printf("nir tam sayi giriniz: ");
    scanf("%d", &x);

    switch(x){
        case 1: printf("bir\n"); break;
        {
        case 2: printf("iki\n"); break;
        case 3: printf("uc\n"); break;
        case 4: printf("dort\n"); break;
        case 5: printf("bes\n"); break;
        }
        case 6: printf("alti\n"); break; // Bu kÄ±sma 'break;' deyimi eklenmesi ya da eklenmemesi bir ÅŸeyi deÄŸiÅŸtirmez ama okunaklÄ±lÄ±k iÃ§in eklenmesi tavsiye edilir.
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **switch sttament** ve **if-else ladder** kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x;
    printf("bir tam sayi giriniz: ");
    scanf("%d", &x);

    switch(x){
        case 1: printf("bir\n"); break;
        case 2: printf("iki\n"); break;
        case 3: printf("uc\n"); break;
        case 4: printf("dort\n"); break;
        case 5: printf("bes\n"); break;
        case 6: printf("alti\n"); break;
    }


    if(x == 1)
        printf("bir\n");
    else if(x == 2)
        printf("iki\n");
    else if(x == 3)
        printf("uc\n");
    else if(x == 4)
        printf("dort\n");
    else if(x == 5)
        printf("bes\n");
    else if(x == 6)
        printf("alti\n");

    printf("main fonksiyonu buradan Ã§alÄ±ÅŸmaya devam ediyor.");
}
```


â— Derleyiciler eÄŸer `switch` deyimindeki **case label** deÄŸerleri sÄ±ralÄ±ysa **jump table ladder** ÅŸeklinde bir optimizasyon uyguluyor.



ğŸ‘‡ AÅŸaÄŸÄ±daki program **switch statement** ile birlikte `default` label kullanÄ±mÄ± incelenebilir. 
```C
#include <stdio.h>

int main(void)
{
    int x;

    printf("haftanÄ±n kacinci gunu oldugunu giriniz: ");
    scanf("%d", &x);

    switch(x){
        case 1: printf("pazartesi\n"); break;
        case 2: printf("sali\n"); break;
        case 3: printf("carsamba\n"); break;
        default: printf("gecersiz gun!\n"); break; // Arada da kullanÄ±labilir her 'case' etiketi 'break' statement ile sonlandÄ±rÄ±ldÄ±ÄŸÄ± iÃ§in farklÄ±lÄ±k olmayacaktÄ±r.
        case 4: printf("persembe\n"); break;
        case 5: printf("cuma\n"); break;
        case 6: printf("cumartesi\n"); break;
        case 7: printf("pazar\n"); break;
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki iki kullanÄ±m da aynÄ± anlama gelmektedir ve kullanÄ±mlarÄ± legal'dir.
```C
#include <stdio.h>

int main(void)
{
    int x = 5;

    if(x == 5)
        printf("dogru\n");

    // 'switch' deyiminde tek bir 'case' olursa block olmadan kullanÄ±labilir ama birden fazla 'case' iÃ§erecekse blok kullanÄ±lmasÄ± gerekir.
    switch(x)
        case 5: printf("dogru\n");
}
```



Bu derste **Obfuscate** ve **Obfuscation** terimlerinden bahsedilecek.



ğŸ‘‡ AÅŸaÄŸÄ±daki program **switch statement** kullanÄ±mlarÄ±nda legal ve illegal kullanÄ±mlarÄ± anlayabilmek iÃ§in incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 5;

    // AÅŸaÄŸÄ±daki kullanÄ±mda sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur Ã§Ã¼nkÃ¼ 'case' etiketinden sonra en az bir statement olmak zorundadÄ±r.
    switch(x){
        case 1:
        case 2:
        case 3:
    }

    // AÅŸaÄŸÄ±daki kullanÄ±mda sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur Ã§Ã¼nkÃ¼ 'case 3:' etiketinden sonra statement(deyim) kullanÄ±lmamÄ±ÅŸtÄ±r.
    switch(x){
        case 1:
        ;
        case 2:
        ;
        case 3:
    }

    // AÅŸaÄŸÄ±daki kullanÄ±mda sÃ¶zdizim hatasÄ±(syntax error) oluÅŸmaz Ã§Ã¼nkÃ¼ tÃ¼m 'case' etiketlerinden sonra bir 'null statement(;)' kullanÄ±lmÄ±ÅŸtÄ±r.
    switch(x){
        case 1:
        case 2:
        case 3:
        ;
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki kullanÄ±m legal'dir ve hiÃ§ bir sonlandÄ±rÄ±cÄ± token kullanmadan ekrana yazÄ± yazdÄ±rmak iÃ§in yazÄ±lan bir programdÄ±r, bunu bazen mÃ¼lakatlarda soruluyormuÅŸ.
```C
#include <stdio.h>

int main(void)
{
    switch(printf("bir yazi yazilacak!")){

    }         
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda kullanÄ±lan `if-else` statement ve `switch` statement yapÄ±larÄ± aynÄ± anlama gelmektedir.
```C
#include <stdio.h>

void foo(void);
void bar(void);
void baz(void);

int main(void)
{
    int x;

    printf("bir tam sayi giriniz: ");
    scanf("%d", &x);
    

    if(x == 1 || x == 7)
        foo();
    else if(x == 8 || x == 9 || x == 24)
        bar();
    else if(x == 21 || x == 24 || x == 34)
        baz();

    // YukarÄ±daki 'if-else' ile aynÄ± anlama gelmektedir.
    switch(x){
        case 1:
        case 7:
            foo();
            break;
        case 8:
        case 9:
        case 24:
            bar();
            break;
        case 21:
        case 24:
        case 34:
            baz();
            break;
    }

    // AÅŸaÄŸÄ±daki gibi bir 'if-else' merdiveni 'stich-case' ile yazÄ±lamaz
    if(x > 5)
        foo();
    else if(y == 6)
        bar();
    else if(z > x)
        baz();

    // 'switch' ifadesi aÅŸaÄŸÄ±daki gibi de yazÄ±labilir.
    switch(x){
        case 1: case 7: foo(); break;
        case 8: case 9: case 24: bar(); break;
        case 21: case 24: case 34: baz(); break;
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program bazÄ± ÅŸÃ¼pheli `switch` statement kullanÄ±mlarÄ±ndaki `case` etiketlerinin bilinÃ§li olarak kodu okuyana nasÄ±l belirtildiÄŸini anlamak iÃ§in incelenebilir.
```C++
#include <stdio.h>

void foo(void);
void bar(void);
void baz(void);
void bom(void);

int main(void)
{
    int x;

    printf("bir tam sayi giriniz: ");
    scanf("%d", &x);
    
    // AÅŸaÄŸÄ±daki `switch` deyiminde aÅŸaÄŸÄ±daki gibi 'break;' statement kullanÄ±lmadÄ±ÄŸÄ±nda bunu kodu okuyana bildirmek iyi bir yaklaÅŸÄ±m olacaktÄ±r.
    switch(x){
        case 1: foo(); // fallthrough // --> Bu kullanÄ±m C dili iÃ§in 'break;' unutulmadÄ± demek iÃ§in ekleniyor.
        case 2: bar(); break;
        case 3: baz(); [[fallthrough]]; // --> Bu kullanÄ±m C++ dili iÃ§in 'break;' unutulmadÄ± demek iÃ§in ekleniyor. 
        case 4: bom(); break;
    }
}
```


â— `switch` deyimi genellikle object-like makro'lar ile birlikte kullanÄ±lmaktadÄ±r.
```C
switch(card_suit){
    case CLUB:
    case DIAMOND:
    case SPADE:
    case HEARD:
}
```



â—â—â—
ğŸ‘‡ AÅŸaÄŸÄ±daki program event driven bir programÄ±n tipik main fonksiyonu incelenebilir.
```C

int main(void)
{
    for(;;){
        int message = getMessageFrom Queue();
        switch(message){
            case MOUSE_CLICK:

            break;
            case MOUSE_DRAG:

            break;
        }
    }
}
```


> â”
> Sorular soru?
> 
> Bu arada az once su gibi bir kullanimdan bahsetmistim:unsigned char switch_var = 0;  // 8-bit variable (all bits 0)
> 
> switch_var |= (x > 5 && y == 3 << 0);  // Set bit 0
> switch_var |= (x == 5 && y == 2 << 1);  // Set bit 1
> switch_var |= (x < 5 && y == 88 << 2);  // Set bit 2
> switch_var |= (x == 5 && y == 76 << 3);  // Set bit 3
> 
> `switch` (switch_var)
> case(0):...
> case(1):...
> case(2):...
> ...
> 
> Cevap;
> 
> Burada sorulan soru ÅŸu ana kadar iÅŸlenen konularÄ±n dÄ±ÅŸÄ±nda operatÃ¶r kullanÄ±mÄ± iÃ§eriyor.
> 
> Sorulmak istenilen ÅŸey `switch` statement'Ä±n bitsel veriler ile nasÄ±l birlikte kullanÄ±labileceÄŸine dair ama bu kullanÄ±m okunurluÄŸu Ã§ok olumsuz etkilediÄŸi iÃ§in bu ÅŸekile yazmak doÄŸru olmayacaktÄ±r sonucu Ã§Ä±karÄ±lmalÄ±dÄ±r.
> 



ğŸš€ **Obfuctcate** ve **Obfucation** terimleri: Kodun anlamÄ±nÄ± deÄŸiÅŸtirmeden kodun anlaÅŸÄ±labilirliÄŸini zorlaÅŸtÄ±rma iÅŸlemiyle ilgili terimlerdir, bu iÅŸlemi yapan programlara **obfuctcator** adÄ± veriliyor. 

ğŸ” **Obfuctcate C Contest** yarÄ±ÅŸmasÄ± varmÄ±ÅŸ bunu araÅŸtÄ±r. [www.ioccc.org](https://www.ioccc.org/), [Github Ioccc Page](https://github.com/ioccc-src)

ğŸš€ **Obfuctcater Programs**: Bir programlama dilinde yazÄ±lmÄ±ÅŸ kodun Ã§alÄ±ÅŸmasÄ±nÄ± deÄŸiÅŸtirmeden kodu okunmaz hale getiren programlardÄ±r.

    

ğŸ‘‡ AÅŸaÄŸÄ±daki programda en basit haliyle **obfucation** iÅŸleminin programa nasÄ±l uygulandÄ±ÄŸÄ± gÃ¶rÃ¼lebilir.
```C
#include <stdio.h>

int main(void)
{
    int _xyz876588jhhkjb = 8;

    (&*&*&*_xyz876588jhhkjb)[10<5] = 9;

    printf("%d\n", _xyz876588jhhkjb);
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.47-11.11 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


### `switch` Ä°fadesi(Statement) KullanÄ±mÄ±yla Ä°lgili BazÄ± Misal Programlar


ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**Military Format**" ÅŸeklinde tarihi yazdÄ±rma iÅŸleminin yapÄ±lmasÄ±nÄ± saÄŸlayan fonksiyonlar nasÄ±l `switch` statement ile yazÄ±labiliyor incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

void printf_date(int d, int m, int y)
{
    printf("%02d", d);

    switch(d){
        case 1:
        case 21:
        case 31: printf("st "); break;
        case 2:
        case 22: printf("nd "); break;
        case 23: printf("rd "); break;
        default: printf("th "); break;
    }

    switch(m){
        case 1: printf("Jan"); break;
        case 2: printf("Feb"); break;
        case 3: printf("Mar"); break;
        case 4: printf("Apr"); break;
        case 5: printf("May"); break;
        case 6: printf("Jun"); break;
        case 7: printf("Jul"); break;
        case 8: printf("Aug"); break;
        case 9: printf("Sep"); break;
        case 10: printf("Oct"); break;
        case 11: printf("Nov"); break;
        case 12: printf("Dec"); break;
    }

    printf(" %d", y);
}

int main(void)
{
    int day, month, year;

    printf("ente a day(d m y): ");
    scanf("%d%d%d", &day, &month, &year);
    
    printf_date(day, month, year);

}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda yÄ±lÄ±n kaÃ§Ä±ncÄ± gÃ¼nÃ¼ olduÄŸunu hesaplayan programÄ±n `switch` statement ile nasÄ±l yazÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

#define ISLEAP(y) (((y) % 4 == 0) && ( (y % 100 != 0) || (y % 400 == 0)))
// #define ISLEAP(y) (((y) % 4 == 0) && ( (y % 100) || (y % 400 == 0))) // 'ISLEAP(y)' makrosu bu ÅŸekilde de yazÄ±labilir, '(y % 100)' ifadesi 100'e tam bÃ¶lÃ¼nmediÄŸi sÃ¼rece sonuÅŸ 'non-zero(true)' olacaktÄ±r

void get_year_day(int d, int m, int y)
{
    int sum = d;
    
    switch(m - 1){
        case 11: sum += 30; // fallthrough
        case 10: sum += 31; // fallthrough
        case 9: sum += 30; // fallthrough
        case 8: sum += 31; // fallthrough
        case 7: sum += 31; // fallthrough
        case 6: sum += 30; // fallthrough
        case 5: sum += 31; // fallthrough
        case 4: sum += 30; // fallthrough
        case 3: sum += 31; // fallthrough
        case 2: sum += ISLEAP(y) ? 29 : 28; // fallthrough
        case 1: sum += 31;
    }

    return sum;
}

int main(void)
{
    int day, month, year;

    printf("ente a day(d m y): ");
    scanf("%d%d%d", &day, &month, &year);
    
    printf("yilin %d. gunu.\n", get_year_day(day, month, year));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **enum** ile **switch** nasÄ±l birlikte kullanÄ±lÄ±yor incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

typedef enum {CLUB, DIAMOND, HEART, SPADE}Suit;

Suit get_card_suit(void);

int main(void)
{
    switch(get_card_suit()){
        case CLUB: 
        case DIAMOND: 
        case HEART: 
        case SPADE:
        ;
    }
}
```


## `goto` statement 


â—`goto` deyimi kullanÄ±lmamasÄ± gereken yerlerde kullanÄ±lmadan sadece gerekli olduÄŸu yerlerde kullanÄ±ldÄ±ÄŸÄ±nda kullanÄ±mÄ± yararlÄ±.
â—`goto` deyimi assembly dillerinde **jump** deyimine tekabÃ¼l etmektedir(dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmektedir).



Programlama diline baÄŸlÄ± olmadan kodda **sÄ±Ã§rama(jump)** yÃ¶ntemi ikiye ayrÄ±lmaktadÄ±r, C dilinde bu iki **sÄ±Ã§rama(jump)** yÃ¶ntemi tÃ¼re aÅŸaÄŸÄ±daki gibidir;
1. **Local jump(near jump)**: AynÄ± fonksiyon iÃ§erisinde yapÄ±lan programÄ±n akÄ±ÅŸÄ±nÄ±n bir yerden baÅŸka yere atlatÄ±lmasÄ± iÅŸlemlerine verilen terimdir. Bu kullanÄ±m `goto` atahtarÄ± ile yapÄ±lmaktadÄ±r.
2. **Long jump**: Bir fonksiyondan baÅŸka bir fonksiyona yapÄ±lan programÄ±n akÄ±ÅŸÄ±nÄ±n bir yerden baÅŸka yere atlatÄ±lmasÄ± iÅŸlemlerine verilen terimdir.


> â”
> 
> Sorulan soru?
> 
> C'deki **Long jump** implementasyonu neyle oluyor acaba? 
> 
> Cevap;
> 
> C dilinde bunu gÃ¶stermek kursun ÅŸu aÅŸamasÄ± iÃ§in aÄŸÄ±r gelecektir bunun yerine C++ ile bir kod paylaÅŸalÄ±m.
> C dilinde **Long jump** iÅŸlemi, **setjmp** standart fonksiyonel makro ve **longjmp** standart fonksiyonu kullanÄ±larak yapÄ±lmaktadÄ±r.
> 
> ğŸ‘‡ AÅŸaÄŸÄ±daki program C++ dilinde en babit haliyle **throw** kullanÄ±mÄ±yla nasÄ±l **Long jump** yapÄ±ldÄ±ÄŸÄ± incelenebilir.
> ```Cpp
> #define _CRT_SECURE_NO_WARNINGS
> 
> #include  <stdio.h>
> 
> void fnk1(void)
> {
>     printf("fnk1() basladi.");
>     fnk2();
>     printf("fnk1() sona erdi.");
> }
> 
> void fnk2(void)
> {
>     printf("fnk2() basladi.");
>     fnk3();
>     printf("fnk2() sona erdi.");
> }
> 
> void fnk3(void)
> {
>     printf("fnk3() basladi.");
>     fnk4();
>     printf("fnk3() sona erdi.");
> }
> 
> void fnk4(void)
> {
>     printf("fnk4() basladi.");
>     fnk5();
>     printf("fnk4() sona erdi.");
> }
> 
> void fnk5(void)
> {
>     printf("fnk5() basladi.");
>     if(1)
>         throw 1;
>     printf("fnk5() sona erdi.");
> }
> 
> int main(void)
> {
>     printf("main basladi.");
>     
>     try
>     {
>         fnk1();
>     }
>     chatch(int){
>         printf("Hata alindi.");
>     }
>     
>     printf("main sona erdi.");
> }
> ```



â— "**A label is an identifier!**" yani "**Bir etiket bir addÄ±r!**". </br>
â— `goto` kullanÄ±mÄ±nda programÄ±n akÄ±ÅŸÄ±nÄ±n yÃ¶nlendiÄŸi yerdeki **label**'dan sonra en az bir tane statement olmasÄ± zorunludur aksi halde **sÃ¶zdizim hatasÄ±(syntax error)** oluÅŸacaktÄ±r. </br>
â— C dilinde kullanÄ±lan **label**'lar `goto` deyimi(statement) ile birlikte kullanÄ±lÄ±rlar ama tek baÅŸlarÄ±na da kullanÄ±lmalarÄ± da legal'dir ama bu kullanÄ±mÄ±n herhangi bir faydasÄ± yoktur(tabi ezoterik bazÄ± yazÄ±lÄ±mlar haricinde). </br>
â— `goto` ile kullanÄ±lan **label** kapsamÄ± **function scope** tÃ¼rÃ¼ndedir ve bir **label** bir fonksiyon gÃ¶vdesinde nerede tanÄ±mlanmÄ±ÅŸ olursa olsun tanÄ±mlandÄ±ÄŸÄ± konumdan yukarÄ±daki bir konumdan da eriÅŸilebilir, zaten bu nedenden dolayÄ± **block scope**'tan farklÄ± olduÄŸu gÃ¶rÃ¼lecektir.



ğŸ§­ C dilinde olan kapsamlarÄ±(scope) yeniden tekrar edersek; 
- **File scope**
- **Block scope**
- **Function prototype scope**
- **Function scope**


ğŸ˜± C dilini profesyonel olarak yÄ±llarca kullanan kiÅŸilerden bile birbirinden Ã§ok farklÄ± olan "**Block scope**" ve "**Function scope**" kavramlarÄ±nÄ±n ne olduÄŸunu bilmeyen Ã§Ä±kabiliyormuÅŸ.



â—â—â— label olan adlarÄ±n(identifier) kapsamÄ± **block scope** deÄŸildir **function scope** Ã¶zelliÄŸindedir. </br>
â—â—â— **Function scope** Ã¶zelliÄŸine sahip adlar(identifier) sadece **label** adlardÄ±r(identifier). </br>
â—â—â— **Function scope** ve **block scope** aynÄ± adda deÄŸiÅŸken adÄ± kullanÄ±lmasÄ±na izin verilmektedir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programÄ±n main metodunda **label01** adÄ±(identifier) iki farklÄ± varlÄ±ÄŸa verilmiÅŸtir ama bu kullanÄ±m legal'dir, **Function scope** ve **block scope** farkÄ±ndan dolayÄ± bu ÅŸekilde kullanÄ±mlarla Ã¼retim ortamÄ±nda karÅŸÄ±laÅŸÄ±labilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include  <stdio.h>

int main(void)
{
    int label01 = 0;

    label01:
    ;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "nec" adÄ±nda birden Ã§ok farklÄ± varlÄ±k olduÄŸu gÃ¶rÃ¼lecektir, bu varlÄ±klarÄ±n tÃ¼rleri ya da **kapsamlarÄ±(scope)** birbirlerinden farklÄ± olduÄŸu iÃ§in herhangi bir **sÃ¶zdizim hatasÄ±(syntax error)** oluÅŸmamaktadÄ±r, kursun ilerleyen kÄ±sÄ±mlarÄ±nda buradaki bilgi Ã¶nemli olacak.
```C
#define _CRT_SECURE_NO_WARNINGS

#include  <stdio.h>

struct nec{
    int nec;
}

void nec(struct nec nec)
{
    goto nec;

    // some code here ...

    nec: 
        nec.nec = 6;
}

int main(void)
{
    
}
```



C mÃ¼lakatlarÄ±nda sorulan eÄŸlenceli bir soru?
- ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir yanlÄ±ÅŸlÄ±k var mÄ±dÄ±r, aÃ§Ä±klayÄ±nÄ±z?
```C
#include  <stdio.h>

int main(void)
{
    void foo(void){
        switch(x){
            case 1: /* ... */ break;
            case 2: /* ... */ break;
            case 3: /* ... */ break;
            case 4: /* ... */ break;
            defualt: x++; // Buradaki 'defualt' yanlÄ±ÅŸ yazÄ±lmÄ±ÅŸtÄ±r doÄŸrusu 'default' olmalÄ±ydÄ± ama sÃ¶zdizim hatasÄ±(syntax error) yoktur
        }
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `goto` deyimi ile nasÄ±l `while` benzeri dÃ¶ngÃ¼ kullabileceÄŸi gÃ¶rÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include  <stdio.h>

int main(void)
{
    int i;

    i = 0;

repeat:
    printf("%d\n", i);
    ++i;
    if(i < 9)
        `goto` repeat;

    printf("main devam ediyor.");
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.11-12.22 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


â— `goto` deyiminin programda gereksiz yere ve fazla defa kullanÄ±lmasÄ± durumlarÄ±nda, kodun okunabilirliÄŸi azalacaktÄ±r, kodun **maintain** edilmesi yorlaÅŸacaktÄ±r, kodun debug edÅŸilmesi zorlaÅŸacaktÄ±r.


ğŸ§­ `goto` deyiminin kullanÄ±lmasÄ± gerektiÄŸi yerler aÅŸaÄŸÄ±daki gibi sÄ±ralanabilir;
1. Birden fazla iÃ§ iÃ§e dÃ¶ngÃ¼ olduÄŸu durumlarda iÃ§teki dÃ¶ngÃ¼lerdeyken tÃ¼m dÃ¶ngÃ¼lerden Ã§Ä±kÄ±lmak istendiÄŸinde Ã§ok daha karmaÅŸÄ±k olarak bayrak deÄŸiÅŸken kullanmak yerine `goto` kullanÄ±ldÄ±ÄŸÄ± durumlar.

    ğŸ‘‡ AÅŸaÄŸÄ±daki programda iÃ§ iÃ§e dÃ¶ngÃ¼lerden `goto` statement ile tek seferde nasÄ±l Ã§Ä±kÄ±ldÄ±ÄŸÄ± incelenebilir.
    ```C
    #include <stdio.h>

    int foo(int, int, int);

    int main(void)
    {
        for(int i = 0; i < 10; ++i){
            for(int j = 0; j < 10; ++j){
                for(int k = 0; k < 10; ++k){
                    if(foo(i, j, k)){
                        goto out;
                    }
                }
            }
        }

        out:
        
        // some code here ...
        
        ;
    }
    ```

2. Fonksiyonlarda Ã§oÄŸunlukla(ters sÄ±rada) kaynak geri verilmesi iÃ§in `goto` deyimi kullanÄ±lmaktadÄ±r. En sÄ±k kullanÄ±lan `goto` deyimi kullanÄ±mÄ± tÃ¼rÃ¼ budur denilebilir fakat kursun ÅŸu anda bulunulan kÄ±smÄ±na kadarlÄ±k bilgilerle bunu anlamak zordur.
    
    Bu kullanÄ±m tÃ¼rÃ¼nÃ¼ anlayabilmek iÃ§in aÅŸaÄŸÄ±daki terimlerin ne olduÄŸunun bilinmesi gerekiyor;
    - **Resource(Kaynak)**
    - **Acquire resource(Kaynak edinmek, Kaynak almak, Kaynak tahil edilmesi)**
    - **Release resource(KaynaÄŸÄ± geri vermek)**

    ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki `foo` fonksiyonu hafÄ±zadan bellek alÄ±p bazÄ± iÅŸlemler yaptÄ±ktan sonra alÄ±nan bellek alanlarÄ±nÄ± geri verme iÅŸlemini yapmaktadÄ±r.
    ```C
    #include <stdio.h>

    int memory_allocate(void);
    void memory_deallocate(int handle);

    int foo1(void){
        int ret1, ret2, ret3, ret4, ret5;

        ret1 = memory_allocate();
        if(!ret1){
            return 0;
        }

        ret2 = memory_allocate();
        if(!ret2){
            memory_deallocate(ret1);
            return 0;
        }
        
        ret3 = memory_allocate();
        if(!ret3){
            memory_deallocate(ret1);
            memory_deallocate(ret2);
            return 0;
        }
        
        ret4 = memory_allocate();
        if(!ret4){
            memory_deallocate(ret1);
            memory_deallocate(ret2);
            memory_deallocate(ret3);
            return 0;
        }

        ret5 = memory_allocate();
        if(!ret5){
            memory_deallocate(ret1);
            memory_deallocate(ret2);
            memory_deallocate(ret3);
            memory_deallocate(ret4);
            return 0;
        }
        
        // do something ...

        memory_deallocate(ret1);
        memory_deallocate(ret2);
        memory_deallocate(ret3);
        memory_deallocate(ret4);
        memory_deallocate(ret5);

        return 1;
    }

    int foo2(void){
        int ret1, ret2, ret3, ret4, ret5;
        int return_value = 0;

        ret1 = memory_allocate();
        if(!ret1){
            `goto` EXIT1;
        }

        ret2 = memory_allocate();
        if(!ret2){
            `goto` EXIT2;
        }
        
        ret3 = memory_allocate();
        if(!ret3){
            `goto` EXIT3;
        }
        
        ret4 = memory_allocate();
        if(!ret4){
            `goto` EXIT4;
        }

        ret5 = memory_allocate();
        if(!ret5){
            `goto` EXIT5;
        }
        
    // do something ...

    return_value = 1;
    memory_deallocate(ret5);

    EXIT5:
        memory_deallocate(ret4);
    EXIT4:
        memory_deallocate(ret3);
    EXIT3:
        memory_deallocate(ret2);
    EXIT2:
        memory_deallocate(ret1);
    EXIT1:
        return return_value;
    }

    int main(void)
    {


    }
    ```

3. Algoritmik olarak karmaÅŸÄ±k program parÃ§alarÄ±ndan oluÅŸan yerlerde **goto statemet** kullanÄ±mÄ± gerekebilir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda iÃ§ iÃ§e dÃ¶ngÃ¼ler yok ve bellekten ayrÄ±lan kaynak ve o kaynaÄŸÄ±n geriye verilmesi iÅŸlemi yok ama algoritmik olarak iÅŸlem sayÄ±sÄ±nÄ± azaltmak(gereksiz `if` kontrolÃ¼nden kaÃ§Ä±nmak iÃ§in vb.) iÃ§in de `goto` statement nasÄ±l kullanÄ±lÄ±yor incelenebilir.
```C
#include <stdio.h>

int process_array(const int* p, int size)
{
    int sum = 0;

    for(int i = 0; i < size; ++i){
        if(p[i] < 0){
            goto end;
        }
        sum += p[i];
    }

end:
    printf("islem tamamlandi!");
}

int main(void)
{
    
}
```


ğŸ§  BugÃ¼nkÃ¼ derste **block scope** ve**function scop** farkÄ±nÄ± net ÅŸekilde anlamÄ±ÅŸ oldum.


Ders sonu ...
