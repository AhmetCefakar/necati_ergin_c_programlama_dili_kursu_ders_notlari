# 52.Ders 18.07.2025 🕘

Derse 5(19:31)-6(19:38)-7(19:54)-8(20:16)-9(20:41)-8(21:10)-7(21:48)-7(22:25) kişi katıldı.
---


## Bitsel Operatörler Devam(Bitwise Operations)


👇 Aşağıdaki programda temel bit işlemlerinin makro olarak yasılışı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#define SETBIT(x, n)        ((x) |= (<1 << (n))
#define RESETBIT(x, n)      ((x) &= ~(<1 << (n))
#define FLIPBIT(x, n)       ((x) ^= (<1 << (n))
#define ISBITSET(x, n)      ((x) & (<1 << (n))
#define ISBITNOTSET(x, n)   (!ISBITSET(x, n)) // Burada bir makroda başka bir makronun kullanılabildiği görülecektir.
```




👇 Aşağıdaki programda endianness farklılıklarında dönüşümün nasıl yapılması gerektiğini anlamak için incelenebilir. </br>
Aşağıdaki bitsel işlemlerde kullanılan makrolar C mülakatlarında sorulmaktadır.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdint.h>

// 16 bit endian dönüşümünün yapılmasını sağlayan mokro.
#define BSWAP16(x) ( (((x) & 0x00FF) << 8)  |  (((x) & 0xFF00) >> 8) )

// 32 bit endian dönüşümünün yapılmasını sağlayan mokro.
// Her bir byte kendisinin ayna karşılığı olan byte ile değiş tokuş edilmektedir, bu işlemi uzun uzadıya yazmayacağım bu nedenle zihninde canlandırman gerekiyor eğer canlandıramıyorsan kağıt kalem alıp görselleştirerek anlayabilirsin. 
#define BSWAP32(x) (  \
    (((x) & 0x000000FFU) << 24) | \
    (((x) & 0x0000FF00U) << 8)  | \
    (((x) & 0x00FF0000U) >> 8)  | \
    (((x) & 0xFF000000U) >> 24)   \
)

// 64 bit endian dönüşümünün yapılmasını sağlayan mokro.
#define BSWAP64(x) (  \
    (((x) & 0x00000000000000FFULL) << 56)  | \
    (((x) & 0x000000000000FF00ULL) << 40)  | \
    (((x) & 0x0000000000FF0000ULL) << 24)  | \
    (((x) & 0x00000000FF000000ULL) << 8)   | \
    (((x) & 0x000000FF00000000ULL) >> 8)   | \
    (((x) & 0x0000FF0000000000ULL) >> 24)  | \
    (((x) & 0x00FF000000000000ULL) >> 40)  | \
    (((x) & 0xFF00000000000000ULL) >> 56)    \
)


int main(void)
{
    uint16_t val16 = 0x1234;
    uint32_t val32 = 0x1234578;
    uint64_t val64 = 0x12345789ABCDEFULL;

    primtf("BSWAP16: 0x%04X\n", BSWAP16(val16));
    primtf("BSWAP32: 0x%08X\n", BSWAP32(val32));
    primtf("BSWAP64: 0x%08X\n", BSWAP64(val64));
}
```


❗❗❗ Endianness dönüşümleri her zaman byte byte yapılmaktadır.

👇 Aşağıda 2 byte büyüklüğündeki bir tam sayının endianness dönüşümünün nasıl olacağı gösterilmiştir(byte byte değişim yapılıyor).
| Hex Number    | Binary Number       |
| ------------- | ------------------- |
| FC34          | 1111 1100 0011 0100 |
| 34FC          | 0011 0100 1111 1100 |



Mülakatlarda sorulan soru: Bir tam sayının ikinin kuvveti olup olmadığını sınayan fonksiyonel makro yazınız. Bu makro C diliyle çalışılıyorsa mutlaka bir yerde karşımıza çıkar. </br>
👇 Aşağıdaki programda yukarıda tanımı belirtilen makronun gerçekleştirimi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdint.h>
#include <stdio.h>

#define POWER_OF_TWO(x)   ((x) && !((x) & ((x) - 1))) // Bir tam sayıyı kedisinin bir eksiğiyle ve işlemine sokarsak sayının en sağ ilk bitini 0 yapmış oluruz. 


int main(void)
{
    printf("bir tam sayi giriniz: ");
    unsigned x;
    scanf("%u", &x);

    if(POWER_OF_TWO){
        printf("evet dogru.\n");
    }
    else{
        printf("hayir yanlis.\n");
    }
}
```



👇 Aşağıdaki programda  bir tam sayının ikinin katı olma durumunu sınayan makronun 0-UINT_MAX arasındaki tam sayılar için nasıl sonuç verdiğini anlamak için incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdint.h>
#include <stdio.h>
#include <limits.h>

#define POWER_OF_TWO(x)   ((x) && !((x) & ((x) - 1)))

int main(void)
{
    for(unsigned int i = 0; i != UINT_MAX; ++i){
        if(POWER_OF_TWO(i)){
            printf("%u", i);
        }
    }
}
```



👇 Aşağıdaki programda bir sayının ikinin kuvveti oluş olmadığını tespit etmek için `POWER_OF_TWO` makrosu dışında kullanılabilecek başka bir yöntemi görebilirsiniz.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x;

    printf("enter an integer: ");
    (void)scanf("%d", &x);

    if(x && (x & -x) == x)
        printf("power of two\n");
    else
        printf("not power of two\n");
}
```



👇 Aşağıdaki programda bir işaretli tam sayının kendisinin tesr işaretli sayısıyla bitsel ve işlemine sokulmaıs sonucunda elde edilecek değerin bitlerinn nasıl dizileneceği görülebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int x1 = 87234;

    bprint(x1);
    bprint(-x1);
    bprint(x1 & -x1);


    int x2 = 4096;

    bprint(x2);
    bprint(-x2);
    bprint(x2 & -x2);
}
```



👇 Aşağıdaki programda ilginç işlemlerden biri incelenebilir. </br>
Programdaki `x`in değeri `a` değişkenine eşitse `x`in değeri `b`nin değeri yapılacak ya da `x`in değeri `b` değişkenine eşitse `x`in değeri `a`nin değeri yapılacak. </br>
Buradaki mantığı anlamayı sana bırakıyorum, neden bunun doğru olduğunu kağıt ve kalem ile zaman sarfederek kendin anlamalısın.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a = 23, b = 37;
    int x = a;

    printf("x = %d\n", x);

    x = a ^ b ^ x;

    printf("x = %d\n", x);

    x = a ^ b ^ x;

    printf("x = %d\n", x);
}
```



👇 Aşağıdaki programda iki tam sayının en büyük ve en küçük değerinin ne olduğunu dallanma(if else) kullanmadan bitsel işlemler ile nasıl yapıldığını anlamak için inceleyebilirsin.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x, y;

    printf("enter two integer: ");
    (void)scanf("%d%d", &x, &y);

    int min = (y ^ (x ^ y) & -(x < y));
    int max = (x ^ (x ^ y) & -(x < y));

    printf("min(%d, %d) => %d \n", x, y, min);
    printf("max(%d, %d) => %d \n", x, y, max);
}
```



👇 Aşağıdaki programda 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"


int main(void)
{
    int x = 56;

    x = ~-x; // Burada 'x'in değeri bir azalacaktır.
    
    printf("x = %d\n", x);

    x = -~x; // Burada 'x'in değeri bir artacaktır.

    printf("x = %d\n", x);
}
```


### Neden Bitsel İşlemleri Kullanıyoruz Devam 

Sistem programlama tarafında en sık yapılan işlemlerden biri tam sayının bitlerini adeta bit dizisi(boolean dizisi) gibi kullanmaktır. 


Bir dosyanın bazı özelliklere sahip olup olmadığı bilgisini işaretsiz bir tam sayı türünün bitlerinde saklayabiliriz. </br>
👇 Aşağıdaki programda bir dosyanın durum bilgisini tutmak için bir tam sayının bitlerinin nasıl kullanılabileceği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

// Aşağıdaki makro değerleri maske olarak kullanılmaktadır. 
// Object-like mokroların değerleri genllikle hex formatında verilir ama burada okuması kolay olması için onluk tabanda verilmişti.
#define ARCHIVE         1
#define READONLY        2
#define HIDDEN          4
#define DIRECTORY       8
#define SYSTEM          16


int main(void)
{
    unsigned int file_flags; // Dosyanın durum bilgileri tutacak işaretsiz tam sayı türünden değişken tanımı.

    // Aşağıdaki koşul ifadesinde 'file_flags' değişkeninin 2 indisli bitinin bir olup olmasığı sorgulanmaktadır. 
    if(file_flags & HIDDEN){
        // Do something ...
    }


    file_flags |= DIRECTORY; // Burada 'file_flags' değişeninin bitlerinde tutulan dosyanın 'DIRECTORY' özelliğine sahip değilse sahip olması sağlanıyor.


    file_flags &= ~HIDDEN; // Burada 'file_flags' değişeninin bitlerinde tutulan dosyanın 'HIDDEN' özelliğinin kapatılması sağlanıyor, bunu yaparken ilgili bit 0 yapılıyor.


    file_flags ^= HIDDEN; // Burada 'file_flags' değişeninin bitlerinde tutulan dosyanın 'HIDDEN' özelliğinin flipping(0 ise 1, 1 ise 0 yapılması işlemi) yapılmaktadır.
}
```



👇 Aşağıdaki programda makro yerine enum değişken kullanılarak bir önceki programda yapılan işlemlerin aynılarının yapılabileceği görülebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"


typedef enum 
{
    ARCHIVE = 1,
    READONLY = 2,
    HIDDEN = 4,
    DIRECTORY = 8,
    SYSTEM = 16
}


int main(void)
{
    unsigned int file_flags; // Dosyanın durum bilgileri tutacak işaretsiz tam sayı türünden değişken tanımı.

    // Aşağıdaki koşul ifadesinde 'file_flags' değişkeninin 2 indisli bitinin bir olup olmasığı sorgulanmaktadır. 
    if(file_flags & HIDDEN){
        // Do something ...
    }


    file_flags |= DIRECTORY; // Burada 'file_flags' değişeninin bitlerinde tutulan dosyanın 'DIRECTORY' özelliğine sahip değilse sahip olması sağlanıyor.


    file_flags &= ~HIDDEN; // Burada 'file_flags' değişeninin bitlerinde tutulan dosyanın 'HIDDEN' özelliğinin kapatılması sağlanıyor, bunu yaparken ilgili bit 0 yapılıyor.


    file_flags ^= HIDDEN; // Burada 'file_flags' değişeninin bitlerinde tutulan dosyanın 'HIDDEN' özelliğinin flipping(0 ise 1, 1 ise 0 yapılması işlemi) yapılmaktadır.
}
```



✍️ Burada `ctype.h` kütüphanesinin basit bir benzerinin gerçeleştirimini yapmak için `myctype.h` başlık dosyasını yazıyoruz.
```C
// Yazılan 'myctype.h' dosyasına eklenenler.

#pragma once

#define UPPER       1
#define LOWER       2
#define DIGIT       4
#define HEXDIGIT    8
#define PUNCT       16
#define SPACE       32
#define PRINTABLE   64
#define CNTRL       128 // 'Control' sözcüğünün kısaltmasından makro adı türetilmiştir.


extern uint8_t flags_[];

#define ISUPPER(c)      (flags_[c] & UPPER)
#define ISLOWER(c)      (flags_[c] & LOWER)
#define ISALPHA(c)      (flags_[c] & (UPPER | LOWER))
#define ISDIGIT(c)      (flags_[c] & DIGIT)
#define ISALNUM(c)      (flags_[c] & (UPPER | LOWER | DIGIT))
#define ISPUNCT(c)      (flags_[c] & PUNCT)
#define ISHEXDIGIT(c)   (flags_[c] & HEXDIGIT)
#define ISSPACE(c)      (flags_[c] & SPACE)
#define ISPRINTABLE(c)  (flags_[c] & PRINTABLE)
#define ISCNTRL(c)      (flags_[c] & CNTRL)

```


✍️ Burada `ctype.h` kütüphanesinin basit bir benzerinin gerçeleştirimini yapmak için `myctype.c` kaynak dosyasını yazıyoruz.
```C
// Yazılan 'myctype.c' dosyasına eklenenler.

#include <stdint.h>

const uint8_t flags_[128] = {
    0X80, 0X80, 0X80, 0X80, 0X80, 0X80, 0X80, 0X80, 
    0X80, 0XA0, 0XA0, 0XA0, 0XA0, 0XA0, 0X80, 0X80, 
    0X80, 0X80, 0X80, 0X80, 0X80, 0X80, 0X80, 0X80, 
    0X80, 0X80, 0X80, 0X80, 0X80, 0X80, 0X80, 0X80, 
    0X60, 0X50, 0X50, 0X50, 0X50, 0X50, 0X50, 0X50, 
    0X50, 0X50, 0X50, 0X50, 0X50, 0X50, 0X50, 0X50, 
    0X4C, 0X4C, 0X4C, 0X4C, 0X4C, 0X4C, 0X4C, 0X4C, 
    0X4C, 0X4C, 0X50, 0X50, 0X50, 0X50, 0X50, 0X50, 
    0X50, 0X49, 0X49, 0X49, 0X49, 0X49, 0X49, 0X41, 
    0X41, 0X41, 0X41, 0X41, 0X41, 0X41, 0X41, 0X41, 
    0X41, 0X41, 0X41, 0X41, 0X41, 0X41, 0X41, 0X41, 
    0X41, 0X41, 0X41, 0X50, 0X50, 0X50, 0X50, 0X50, 
    0X50, 0X4A, 0X4A, 0X4A, 0X4A, 0X4A, 0X4A, 0X42, 
    0X42, 0X42, 0X42, 0X42, 0X42, 0X42, 0X42, 0X42, 
    0X42, 0X42, 0X42, 0X42, 0X42, 0X42, 0X42, 0X42, 
    0X42, 0X42, 0X42, 0X50, 0X50, 0X50, 0X50, 0X80,
};

```



👇 Aşağıdaki programda kendi yazdığımız `myctype` kütüphane modülünün `myctype.c` dosyasında tanımı bulunacak `flags_[128]` türünün elemanlarının nasıl elde edildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include "myctype.h"
#include <ctype.h>

int main(void)
{
    for(int i = 0; i < 128; ++i){
        unsigned int result  = 0;

        if(isupper(i)) result |= UPPER;
        if(islower(i)) result |= LOWER;
        if(isdigit(i)) result |= DIGIT;
        if(isxdigit(i)) result |= HEXDIGIT;
        if(ispunct(i)) result |= PUNCT;
        if(isspace(i)) result |= SPACE;
        if(isprint(i)) result |= PRINTABLE;
        if(iscntrl(i)) result |= CNTRL;

        if(i && i % 8 == 0)
            printf("\n");
        printf("0X%02X, ", result);
    }
}
```




👇 Aşağıdaki programda makro içinde makro kullanılabileceğini göstermek için yasılmıştır.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <stdlib.h>

int main(void)
{
    int ar[] ? { 2, 4, 6, 9, 1, 3, 7, 21, 98, 34, 45 };
    
    randomize();

    for(int i = 0; i < 10; ++i){
        printf("%d ", RANDOM_ELEM(ar)); // Buradaki statement'taki makro sırasıyla aşağıdaki gibi açılacaktır.
        // printf("%d ", ar[rand() % ASIZE(ar)]);
        // printf("%d ", ar[rand() % sizeof(ar) / sizeof(ar[0])]);
    }
}
```



👇 Aşağıdaki programda kendi yazdığımız `myctype.h` kütüphenesinin `ISDIGIT` fonksiyonunun kullamın incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include "myctype.h"
#include <stdlib.h>

int main(void)
{
    int ch;

    printf("bir karakter girin: ");
    ch = getchar();

    if(ISHEXDIGIT(ch))
        printf("evet hex karakter.\n");
    else
        printf("hayir hex karakter degil.\n");
}
```


***
==================================================

✦✦✦✦✦ 20.49-21.10 birinci ara verildi. ✦✦✦✦✦

==================================================
***


Bir byte'lık bir alanda birden fazla değişken saklanabilir mi, mesela 1 byte(8 bit olsun) alanda `xxxyyzzz` biçiminde üç farklı değişken saklanabilir, bu 1 byte alandan veri okumak için maskelar ve bitsel kaydırma işlemleri uygulanmaktadır? Bu bize şunkarı sağlar;
1. Daha az bellek kullanımı.
2. Bitsel işlemler daha hızlı olacağı için, işlem maliyeti düşürülmüş olur.
3. Mantıksal ilişki içinde olan değişkenleri aynı bellek bloğunda tutulması yapılacak işlemlerin kolay olmasını sağlar(fonksiyonel makrolar kullanılır genellikle).


## Yapıların Bit Alanı Elemanları(Bitfield Members) 

Bu konunun aslında yapılar konusunda anlatılamsı gerekirdi ama o aşamada henüz bitsel işlemler bilinmediği için bu ana kadar beklenmiştir.


👇 Aşağıdaki program parçasında yapıların üyelerinin bitfield yapıldığı değişik durumlar incelenebilir.
```C
struct Nec {
    int x : 3; // Burada derleyiciye 'x' değişkeninin değerinin üç bitlik alanda tutulması söylenmiş oluyor.
};

// Aşağıdaki yapıda bitfield üyelerle bitfield olmayan üyeler birlikte bulunmaktadır.
struct Nec2 {
    int x;
    double dval;
    unsigned int b : 5;
};

// Aşağıdaki yapı bildiriminde tek bir byte'lık alanda üç farklı değişken tutulmaktadır.
struct Nec3 {
    unsigned int a : 3;
    unsigned int b : 4;
    unsigned int b : 5;
};
```



👇 Aşağıdaki program parçasında **bitfield** yapı üyelerinin kaç bitlik büyüklüğe sahip olacaklarını belirten ifadenin sabit ifadesi olması gerektiği görülebilir.
```C
// Aşağıdaki yapı bildiriminde tek bir byte'lık alanda üç farklı değişken tutulmaktadır.

int x = 3;

struct Nec3 {
    unsigned int a : x; // Burada sözdizimi hatası oluşur çünkü bitfield üyenin bit değerini belirten ifade sabit(constant) ifadesi olmak zorundadır.
    unsigned int b : 4;
    unsigned int b : 5;
};
```



❗❗❗ C dilinin sözdiziminde sabit(constant) ifadesi kullanılması gereken yerler;
1. `switch` bildirimlerinde `case` ifadeleri.
2. Dizilerin eleman sayısını belirten ifadeler(Derleyicilerin opsiyonel olarak verdiği VLA dersteği dışında).
3. Global değişkenlerin ilk değer vermekte kullanılan ifadeler. 


Bitfield yapı üyeleri çoğunlukla işaretsiz tam sayılar olur ama işaretli tam sayı olarak ta bildirilebilirler.



👇 Aşağıdaki programda **bitfield** yapı üyelerinin kullanımının diğer yapı üyeleri ile benzer olduğu incelenebilir.
```C
typedef struct {
    unsigned int a : 3;
    unsigned int b : 4;
    unsigned int b : 5;
} Nec;

int main(void)
{
    Nec nec1;

    Nec* p = &nec1;
    p->a;

    Nec nec2 = { 2, 12, 3 };

    Nec nec2 = { .a = 6, .b = 4 }; // Designated Initializer ile ilk değer verilebilir, ilk değer verilmeyen yapı üyeleri hayata 0 değeri ile gelirler. 
}
```


👇 Aşağıdaki programda **bitfield** yapı üyelerinin **anonymous structure** türünden olabileceği incelenebilir.
```C
typedef struct {
    int x, y, z;
    struct { // 'Nec' türünün bünyesinde bildirilen anonim yapı üyesi.
        unsigned int a : 3;
        unsigned int b : 4;
        unsigned int b : 5;
    };
} Nec;

int main(void)
{
    Nec nec1;

    nec1.a;
}
```



❗❗❗ C dilinin sözdiziminde bit adreslenebilir bir varlık değildir, bu nedenden dolayı **bitfield** yapı üyeleri adres operatörünün(`&` operator) operandı olamaz. </br>
👇 Aşağıdaki programda **bitfield** yapı üyelerinin adres operatörünün(`&` operator) operandı olamadığı görülecektir.
```C
typedef struct {
    unsigned int a : 3;
    unsigned int b : 4;
    unsigned int b : 5;
} Nec;

int main(void)
{
    Nec nec1;

    &nec1.a; // Burada sözdizim hatası alınacaktır.
}
```



❗❗❗ Bir **bitfield members** yapı üyelerinin bellek büyüklüğünün en az ne olacağı derleyiciye bırakılmıştır, derleyicilerdeki "**Storage Unit**" değerinin ne olduğuna göre bu değerin katları biçiminde artacaktır, mesela Microsoft derleyicisinde "**Storage Unit**" değeri 4 byte'tır. </br>
👇 Aşağıdaki programda sadece iki tane **bitfield** üyeye sahip olan yapının bellek büyüklüğünün ne olacağı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

typedef struct {
    unsigned int a : 3;
    unsigned int b : 4;
} Nec;

int main(void)
{
    printf("sizeof(Nec) = %zu", sizeof(Nec));
}
```


👇 Aşağıdaki program "**Storage Unit**" değerinin yapı türlerinin bellek büyüklüklerini nasıl etkiledğini analmak için incelenebilir
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

// 'Nec1' yapı nesnesi 4 byte'lık bellek ihtiyacına sahip olacaktır.
typedef struct {
    unsigned int x1 : 7;
    unsigned int x2 : 1;
} Nec1;

// 'Nec2' yapı nesnesi 4 byte'lık bellek ihtiyacına sahip olacaktır, çünkü toplamda 32 bit alana ihtiyaç mevcut.
typedef struct {
    unsigned int x1 : 7;
    unsigned int x2 : 7;
    unsigned int x3 : 7;
    unsigned int x4 : 7;
    unsigned int x5 : 4;
} Nec2;


// 'Nec3' yapı nesnesi 8 byte'lık bellek ihtiyacına sahip olacaktır, çünkü toplamda 33 bit alana ihtiyaç mevcut ve bellek ihtiyacı 'Storage Unit' değerinin katları biçiminde gidiyor.
typedef struct {
    unsigned int x1 : 7;
    unsigned int x2 : 7;
    unsigned int x3 : 7;
    unsigned int x4 : 7;
    unsigned int x5 : 5;
} Nec3;

int main(void)
{
    printf("sizeof(Nec) = %zu", sizeof(Nec));
}
```



❗❗❗ Bir yapı türünün **bitfield** üyelere sahip olduğunda bu üyelerin bitlerinin nesnenin hangi bitlerinde tutulacağı derleyiciye bağlıdır(endianness'a da bağlıdır), bu nedenden dolayı yapının **bitfield** üyelerine bitsel işlemlerle erişilmeye çalışılmamalıdır. </br>
👇 Aşağıdaki program parçasında `Nec` türünün(esasında tür eş adı) **bitfield** üyelerinin bellekte nesnenin neresinde tutulacağı bilinemeyeceğ için bu üyelere sadece `.` ya da `->` oparetörü ile erişmek gerekmektedir.
```C
#define _CRT_SECURE_NO_WARNINGS

typedef struct {
    unsigned int x : 2;
    unsigned int y : 4;
    unsigned int z : 2;
} Nec;

int main(void)
{
    
}
```




👇 Aşağıdaki programda **bitfield** üyelere sahip olan yapılarda **bitfield** üyelerin bellekte performanslı işlem yapılmasını sağlayabilecek biçimde yerleştirilebilmesi için "**Pedding Bits**" kullanımı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

// 'Nec1' türü bellekte tek bir byte'lık alanda tutulabilir.
typedef struct {
    unsigned int x : 3;
    unsigned int y : 4;
    unsigned int z : 1;
} Nec1;

// 'Nec2' türü bellekte 2 byte'lık alanda tutulacaktır, 'Pedding bits' alanı ile 'x' ve 'y' değişkenlerinin bellekte ayrı byte alanlarında tutulması sağlanıyor.
typedef struct {
    unsigned int x : 4;
    unsigned int   : 4; // 'Pedding bits' alanı bildiriliyor.
    unsigned int y : 5;
} Nec2;

//  'storage unit' değeri 2 byte ise 'Nec3' türünün kullanılmayan bitlerini belirtmek için 'reserved' ya da 'unused' ya da 'notused' yapı üyesi eklenebilir.
typedef struct {
    unsigned int x : 4;
    unsigned int y : 5;
    unsigned int z : 3;
    unsigned int reserved : 4; // Kullanılmayan bitleri belirtmek için kullanılan bildirim, buranın 
    // unsigned int unused : 4; // Kullanılmayan bitleri belirtmek için kullanılan bildirim.
    // unsigned int notused : 4; // Kullanılmayan bitleri belirtmek için kullanılan bildirim.
} Nec3;


int main(void)
{
    
}
```




👇 Aşağıdaki programda yapı üyelerini hizalamak için **bitfield** üyelerin bit boyutu 0 olarak bildirilmesiyle nasıl ayarlanabildiği incelenebilir.
```C
typedef struct {
    unsigned int x : 4;
    unsigned int y : 5;
    unsigned int   : 0; // Bu üye kullanımı bir sonraki yapı üyesinin bir sonraki 'storage unit'e yerleştirilsin demektir.
    unsigned int z : 3;
} Nec;

int main(void)
{
    printf("sizeof(Nec) = %zu", sizeof(Nec));
}
```

### Bit Alanı Elemanların Kullanılma Nedenleri 


#### Bellek alanından tasarruf sağlanması



👇 Aşağıdaki programda DOS işletim sisteminde "Tarih-Zaman" bilgisinin tutulmasında yerden tasarruf için **bitfield** yapı üyelerinin nasıl kullanıldığı incelenebilir.
```C

struct Date {
    unsigned int mday : 5; // Ayın günü bilgisi en çok 31 olabildiği için 5 bitte tutulabilir.
    unsigned int mmon : 4; // Yılın ayı bilgisi en çok 12 olabildiği için 4 bitte tutulabilir.
    unsigned int myear : 7; // DOS-OS doğum yılı 1980 kabul edilir ve 7 bitte de [0, 127] arasında sayı tutulabiliyor, 1980 + 127 olarak yıl bilgisi tutulmaktadır.
};


struct Time {
    unsigned int mhour : 5; // Saat bilgisi en fazla 23 olabidiği için 5 bitte tutulabilir.
    unsigned int mmin : 6; // Dakika bilgisi en fazla 59 olabidiği için 6 bitte tutulabilir.
    unsigned int msec : 5; // `struct Time` türünü 2 byte alanı sığabilmesi için saniye bilgisi 6 bitlik değil 5 bitlik alanda tutulmuştur, bunun sonucu olarak ta sadece çift saniyeler tutulmuştur tek saniyeler tutulmamıştır.
}

int main(void)
{

}
```



👇 Aşağıdaki programda DOS benzeri kendi "Tarih-Zaman" bilgisini tutan yapı türünün nasıl yazıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


typedef struct Date {
    unsigned int day : 5;
    unsigned int mon : 4;
    unsigned int year : 7;
    unsigned int hour : 5;
    unsigned int min : 6;
    unsigned int sec : 5;
} DateTime;


int main(void)
{
    printf("sizeof(DateTime) = %zu\n", sizeof(DateTime));

    DateTime dt = {
        .day = 18,
        .mon = 7,
        .year = 2025 - 1980,
        .hour = 22,
        .min = 2,
        .sec = 54 / 2
    };
}
```


#### Birlikler ile Bit Alanı Üyelerine Sahip Yapıların Birlikte Kullanılması 

Bir birlik türünde bir veriyi iki farklı biçimde temsiledebiliriz.



👇 Aşağıdaki programda **union(birlik)** türünü kullanarak DOS tipi tarih-saat bilgisinin nasıl tutulabileceği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdint.h>
#include <stdio.h>

typedef union {
    uint32_t uval;
    struct {
        unsigned int day : 5;
        unsigned int mon : 4;
        unsigned int year : 7;
        unsigned int hour : 5;
        unsigned int min : 6;
        unsigned int sec : 5;
    };
} DateTime;


int main(void)
{
    printf("sizeof(DateTime) = %zu\n", sizeof(DateTime));

    DateTime dt = {
        .day = 18,
        .mon = 7,
        .year = 2025 - 1980,
        .hour = 22,
        .min = 11,
        .sec = 48 / 2
    };

    printf("%u\n", st.uval);
}
```



👇 Aşağıdaki programda kendi oluşturduğumuz DOS işletim sisteminin tarih-zaman yapı türünün taklidi bir yapı türünün nasıl kullanıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdint.h>
#include <stdio.h>

typedef union {
    uint32_t uval;
    struct {
        unsigned int day : 5;
        unsigned int mon : 4;
        unsigned int year : 7;
        unsigned int hour : 5;
        unsigned int min : 6;
        unsigned int sec : 5;
    };
} DateTime;


int main(void)
{
    printf("sizeof(DateTime) = %zu\n", sizeof(DateTime));

    DateTime dt = {
        .uval = 3245759218u
    };

    printf("%02u-%02u-%u %02u-%02u-%02u\n", 
        dt.day, dt.mon, dt.year + 1980, dt.hour, dt.min, dt.sec * 2);
}
```



👇 Aşağıdaki programda bir birlik türünden değişken bildiriminde birlik türünün hem 4 byte'lık bir değişken hem de 32 faklı bitten oluşan 32 farklı boolean özellikte değişken gibi kullanılabildiği incelenebilir.
```C
#include <stdio.h>
#include <stdint.h>

typedef struct{
    _Bool bit0: 1;
    _Bool bit1: 1;
    _Bool bit2: 1;
    _Bool bit3: 1;
    _Bool bit4: 1;
    _Bool bit5: 1;
    _Bool bit6: 1;
    _Bool bit7: 1;
    _Bool bit8: 1;
    _Bool bit9: 1;
    _Bool bit10: 1;
    _Bool bit11: 1;
    _Bool bit12: 1;
    _Bool bit13: 1;
    _Bool bit14: 1;
    _Bool bit15: 1;
    _Bool bit16: 1;
    _Bool bit17: 1;
    _Bool bit18: 1;
    _Bool bit19: 1;
    _Bool bit20: 1;
    _Bool bit21: 1;
    _Bool bit22: 1;
    _Bool bit23: 1;
    _Bool bit24: 1;
    _Bool bit25: 1;
    _Bool bit26: 1;
    _Bool bit27: 1;
    _Bool bit28: 1;
    _Bool bit29: 1;
    _Bool bit30: 1;
    _Bool bit31: 1;
} Bits1;


typedef union{
    struct{
        _Bool bit0: 1;
        _Bool bit1: 1;
        _Bool bit2: 1;
        _Bool bit3: 1;
        _Bool bit4: 1;
        _Bool bit5: 1;
        _Bool bit6: 1;
        _Bool bit7: 1;
        _Bool bit8: 1;
        _Bool bit9: 1;
        _Bool bit10: 1;
        _Bool bit11: 1;
        _Bool bit12: 1;
        _Bool bit13: 1;
        _Bool bit14: 1;
        _Bool bit15: 1;
        _Bool bit16: 1;
        _Bool bit17: 1;
        _Bool bit18: 1;
        _Bool bit19: 1;
        _Bool bit20: 1;
        _Bool bit21: 1;
        _Bool bit22: 1;
        _Bool bit23: 1;
        _Bool bit24: 1;
        _Bool bit25: 1;
        _Bool bit26: 1;
        _Bool bit27: 1;
        _Bool bit28: 1;
        _Bool bit29: 1;
        _Bool bit30: 1;
        _Bool bit31: 1;
    };
    uint32_t uval;
} Bits2;


int main(void)
{
    // for(int i = 0; i < 32; ++i){
    //     printf("_Bool bit%d: 1;", i);
    // }

    printf("sizeof(Bits1) = %zu\n", sizeof(Bits1));
    printf("sizeof(Bits2) = %zu\n", sizeof(Bits2));

    Bits2 x1 = { 
        .uval = 768214u
    };

    printf("%d\n", x.bit13);

    Bits2 x2 = { 
        .bit0 = 1,
        .bit4 = 1,
        .bit7 = 1,
    };

    printf("%d\n", x2.uval);
}
```


> ❔ 
> 
> Sorulan soru;
> 
> Şimdi C dilinde 1 byte hafizam var. bu int olarak tutarsam bir sayiyi ifade eder. bunun yaninda bitwise islemler yaparak 8 tane on off bilgiyi tutabilirim. onun disinda sadece bunlardan biri olacak sekilde de 2 üzeri 8 = 256 tane farkli bilgiyi de tutabilirim. C araclari ile bunu ifade etmemin yolu enum yapisi midir?
>
> ```C
> typedef enum {
>   STATE_IDLE = 0,
>   STATE_INIT = 1,
>   STATE_READY = 2,
>   // ...
>   STATE_MAX = 255
> } SystemState;
> 
> SystemState s = STATE_READY;
> ```
> 
> Benim sorum şuydu bir byte'ı 256 farkli bilgiyi gösterecek biçimde C de nasıl kullanırım?
> 
> Cevap;
> 
> Burada sorulan soru tam analaşılamadı o nedenle tam bir cevap verilemedi ama 1 byte ile [0-255] aralığında değer tutulabilir.


Ders sonu ...
