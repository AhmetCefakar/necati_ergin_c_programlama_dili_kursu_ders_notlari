# 17.Ders 08.03.2025 ğŸ•˜

Derse 12(09:01)-22(09:26)-21(10:46)-20(12:12)-22(12:32) kiÅŸi katÄ±ldÄ±.
---

**Fonksiyon Ã§aÄŸÄ±rmak(function call)** ve **fonksiyon tanÄ±mlamak(function definition)** konularÄ± Ã¶nceki derslerde detaylÄ± iÅŸlendi ama **fonksiyon bildirimi(function declaration)** konusu iÅŸlenmemiÅŸti bu derste bu konu iÅŸlenecektir.

## Function Declaration(Function Prototype, Function Prototype Declaration)

Bu konu kursun zor konularÄ±ndan biridir ve dikkatli Ã§alÄ±ÅŸÄ±lmasÄ± gerekiyor.

**Function declaration** bir fonksiyonu bildirmek anlamÄ±na gelmektedir.

**Function declaration(fonksiyon bildirimi)**, **Function prototype** ve **To declare a function** aynÄ± anlamdadÄ±r ve bir fonksiyonu bildirmek anlamÄ±na gelir.


â— **Function prototype(fonksiyon prototipi)** ile derleyiciye bildirilen fonksiyon hakkÄ±nda bazÄ± bilgiler verilir, bu bilgiler aÅŸaÄŸÄ±daki gibidir;
1. Fonksiyonun adÄ± bilgisi.
2. Fonksiyonun parametre deÄŸiÅŸkeni sayÄ±sÄ±.
3. Fonksiyonun her bir parametre deÄŸiÅŸkeninin tÃ¼rÃ¼.
4. Fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸeri tÃ¼rÃ¼.

`double foo(int, int);` bu statement bir **function declaration**'dÄ±r.

Derleyici fonksiyon bildirimi ile verilen bilgilerden nasÄ±l faydalanÄ±r?</br>
Derleyici fonksiyon bildirimine bakarak aÅŸaÄŸÄ±daki logic kontrolleri yapar;
1. Derleyici programdaki fonksiyon Ã§aÄŸrÄ±larÄ±nÄ± yorumlayÄ±p makine koduna Ã§evirirken fonksiyonun kaÃ§ tane argÃ¼man almasÄ± gerektiÄŸini kontrol ederken Ã§aÄŸrÄ± yapÄ±lan fonksiyonun bildirimine bakmaktadÄ±r.
2. Derleyici programdaki fonksiyon Ã§aÄŸrÄ±larÄ±nÄ± yorumlayÄ±p makine koduna Ã§evirirken fonksiyonun hangi sÄ±rada hengi tÃ¼r argÃ¼man almasÄ± gerektiÄŸini kontrol ederken Ã§aÄŸrÄ± yapÄ±lan fonksiyonun bildirimine bakmaktadÄ±r.


â—
Derleyici bir fonksiyon Ã§aÄŸrÄ±sÄ± iÃ§in nasÄ±l bir kod Ã¼retiyor?
- Kaynak dosyanÄ±n derlenebilmesi iÃ§in derleyicinin **fonksiyonun bildirimini(function decleration)** gÃ¶rmesi yeterlidir, mesela aÅŸaÄŸÄ±daki kod parÃ§asÄ±nda "foo" fonksiyonunun sadece bildirimi var ama tanÄ±mlamasÄ± yok fakat derleyici kodu derleyecektir.
- Derleyicinin gÃ¶revi fonksiyon bildirimlerinin tanÄ±mlarÄ±nÄ±n(gÃ¶vdelerinin) olduÄŸunu kontrol etmek deÄŸil, bu kontrol **linker** program tarafÄ±ndan yapÄ±lmaktadÄ±r ve bir fonksiyonun gÃ¶vdesinin olmamasÄ± durumunda **linker** program tarafÄ±ndan hata verilecektir.

```C
#define _CRT_SECURE_NO_WARNINGS

#include<stdio.h>

double foo(double, int);

int main(void)
{
    foo(2.4, 5);
}
```


â—
ğŸ§­ **Compiler(derleyici)** bir fonksiyon Ã§aÄŸrÄ±sÄ± iÃ§in nasÄ±l bir kod Ã¼retir, bunu anlamaya Ã§alÄ±ÅŸalÄ±m.
1. Ã–nce derleyici fonksiyon Ã§aÄŸrÄ±sÄ±nÄ±n yapÄ±ldÄ±ÄŸÄ± kodda **sÃ¶zdizimi hatalarÄ±nÄ±(syntax error)** kontrol eder.
2. Ondan sonra derleyicinin Ã¼rettiÄŸi assembly kodunda bu fonksiyona gÃ¶nderilen argÃ¼manlar, yerel deÄŸiÅŸkenlerin bulunduÄŸu bellek(stack, yÄ±ÄŸÄ±n) alanÄ±na ya da iÅŸlemcinin register(yazmaÃ§) alanlarÄ±na kaydediliyor. Yani bir yÃ¶ntem ile fonksiyona yollanacak argÃ¼manlar donanÄ±m Ã¼zerinde bir yere yerleÅŸebilmesi iÃ§in derleyici buna uygun assembly kodunu Ã¼retir.
3. ProgramÄ±n akÄ±ÅŸÄ± **run-time**'da bu fonksiyonun koduna yÃ¶nlenmesi iÃ§in bir makine komutu(call command) var, derleyici Ã¼reteceÄŸi assembly kodunda bu komutu ilgili yere ekler.



â—**Derleyici(compiler)**, fonksiyon Ã§aÄŸrÄ±sÄ± karÅŸÄ±lÄ±ÄŸÄ±nda **baÄŸlayÄ±cÄ±(linker)** programa yÃ¶nelik bir referans adÄ± yazar. Yani baÄŸlayÄ±cÄ± program derleyicinin yazdÄ±ÄŸÄ± o referans adÄ± Ã§Ã¶zÃ¼mleyerek hangi fonksiyonun derlenmiÅŸ koduyla birleÅŸtirmesi gerektiÄŸini anlÄ±yor.

â—**Derleyici program(compiler)** sadece fonksiyonun bildirimi verilmiÅŸ olan bir fonksiyonun Ã§aÄŸrÄ±ldÄ±ÄŸÄ± yerlerde fonksiyona giriÅŸ kodlarÄ± ve fonksiyondan Ã§Ä±kÄ±ÅŸ kodlarÄ±yla ilgilenir, Ã§aÄŸrÄ±lan fonksiyonun derlenmiÅŸ haliyle Ã§aÄŸÄ±ran fonksiyonun derlenmiÅŸ halinin birleÅŸtirilmesi **linker(baÄŸlayÄ±cÄ±)** programÄ±n gÃ¶revidir.



ğŸ‘‡ AÅŸaÄŸÄ±daki ufak programda `math.h` head dosyasÄ±ndaki `sqrt` fonksiyonu kullanÄ±larak hesaplanan deÄŸer **standart output**'a gÃ¶nderiliyor.
- Bu programda Ã§aÄŸÄ±rÄ±lan `sqrt` fonksiyonun tanÄ±mÄ± `math.h` dosyasÄ±nda yoktur sadece fonlsiyon bildirimi vardÄ±r, derleyici fonksiyon tanÄ±mÄ±(fonksiyon gÃ¶vdesi) olamyan fonksiyonlarÄ±n sadece bildirimlerine bakarak senteks kontrolÃ¼ yapar ardÄ±ndan **object file** Ã¼retir.
- Linker programÄ± bakmasÄ± gereken yer ya da yerlerde `sqrt` fonksiyonu derlenmiÅŸ olarak tanÄ±mÄ±nÄ± bulur, eÄŸer bulamazsa linker aÅŸamasÄ±nda **sÃ¶zdizim hatasÄ±(syntax error)** oluÅŸacaktÄ±r eÄŸer hata yoksa baÄŸlama iÅŸlemini yapÄ±lÄ±r.
```C
#include <stdio.h>
#include <math.h>

int main(void)
{
    double x = 4.7;
    
    double d = sqrt(x);
    
    printf("d = %f\n", d);
}
```


âš ï¸ C Ã¶ÄŸrenenlerin en tipik modelleme hatalarÄ±ndan biri standart C **fonksiyonlarÄ±nÄ±n kodlarÄ±nÄ±n(fonksiyon gÃ¶vdeleri)** `head(.h)` dosyalarÄ±nda olduÄŸunu dÃ¼ÅŸÃ¼nmeleridir, hatta C programlama diliyle uzun yÄ±llar Ã§alÄ±ÅŸan kiÅŸiler bile bu ÅŸekilde yanlÄ±ÅŸ bilgiye sahip olabiliyorlarmÄ±ÅŸ(Necati Ergin yaptÄ±ÄŸÄ± mÃ¼lakatlarda bu tÃ¼r kiÅŸilerle karÅŸÄ±laÅŸabiliyormuÅŸ).
`head(.h)` dosyalarÄ±nda fonksiyonlarÄ±n sadece **bildirimleri(declaration, prototype)** vardÄ±r, **fonksiyonlarÄ±n tanÄ±mlarÄ±(definition)** `head(.h)` dosyalarÄ±nda yer almaz.



â—Ä°lk Ã¶nce Ã¶n iÅŸlemci program Ã§alÄ±ÅŸÄ±r ve `#include` ile verilen dosyadaki fonksiyon bildirimlerini de iÃ§eren kodlarÄ± alÄ±p "**.c**" uzantÄ±lÄ± dosyasÄ±nÄ±n ilgili yerlerine yapÄ±ÅŸtÄ±rÄ±r(bunun dÄ±ÅŸÄ±nda baÅŸka iÅŸlemler de yapÄ±lÄ±r ama burada deÄŸinilmiyor) ve bu iÅŸlem sonrasÄ±nda **translation unit** dosyasÄ±nÄ± oluÅŸturur.</br>
ArdÄ±ndan derleyici **translation unit** dosyasÄ±nÄ± alÄ±r ve iÅŸleyerek **object** dosyasÄ±nÄ± oluÅŸturur.</br>
ArdÄ±ndan **linker(baÄŸlayÄ±cÄ± program)** derleyicinin oluÅŸturduÄŸu **object** dosyalarÄ±nÄ± alÄ±p gerekli baÄŸlama iÅŸlemlerini yapÄ±yor ve en son Ã§alÄ±ÅŸtÄ±rÄ±labilir dosyayÄ± oluÅŸturur.

â—Derleyicinin Ã¼rettiÄŸi kodun kullanÄ±lan **fonksiyonlarÄ±n tanÄ±mlarÄ±yla(definition)** bir ilgisi yoktur, derleyici sadece **fonksiyonlarÄ±n bildirimlerini(declaration, prototype)** kontrol eder.

ğŸ§  Projeyi derlemek Ã¶n iÅŸlemci programÄ±n ve derleyici programÄ±n Ã§alÄ±ÅŸmasÄ±dÄ±r.</br>
ğŸ§  Projeyi build etmek, programÄ± derleyip, linker programÄ±nÄ±n Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ± iÅŸlemidir.


### Default Function Declaration(VarsayÄ±lan Fonksiyon Bildirimi)

Derleyici bir adÄ±(identifier) arayÄ±p bulamadÄ±ÄŸÄ±nda eÄŸer o ad fonksiyon Ã§aÄŸrÄ± operatÃ¶rÃ¼nÃ¼n operandÄ± olmuÅŸsa bu durumda derleyici o varlÄ±ÄŸÄ± geri dÃ¶nÃ¼ÅŸ deÄŸeri `int` olan ve parametre deÄŸiÅŸkenleri hakkÄ±nda bilgi verilmemiÅŸ bir fonksiyonun global alanda bildirilmiÅŸ gibi yorumlamaktadÄ±r. 

âš ï¸ YazÄ±lacak programlarda **default function declaration(varsayÄ±lan fonksiyon bildirimi)** Ã¶zelliÄŸinden yararlanarak kodlama yapÄ±lmamalÄ±dÄ±r.


ğŸ‘‡ â— AÅŸaÄŸÄ±daki kaynak dosyayÄ± derleme iÅŸlemine sokarsak ne olur?
- C++ dilinde **sÃ¶zdizim hatasÄ±dÄ±r(syntax error)**.
- C dilinin C99 standardÄ±ndan sonra **sÃ¶zdizim hatasÄ±(syntax error)** verir.
- C89 standardÄ±nda **default function declaration(varsayÄ±lan fonksiyon bildirimi)** iÅŸlemi yapÄ±lÄ±r, C89 standardÄ± `foo` fonksiyonu iÃ§in `int foo();` ÅŸeklinde bir fonksiyon bildirimi varmÄ±ÅŸ gibi derleme iÅŸlemi yapar.
```C
#define _CRT_SECURE_NO_WARNINGS

#include<stdio.h>

int main(void)
{
    foo(1, 4, 8); // Buradaki 'foo' adlÄ± varlÄ±k global alanda 'int foo();' olarak bildirilmiÅŸ bir fonksiyon olarak yorumlanacaktÄ±r.
}
```


## Fonksiyon Prototip Bildirimi SÃ¶zdizimi 

Fonksiyon prototip bildirimi genel olarak `<fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸeri tÃ¼rÃ¼> <fonksiyonun adÄ±>(<fonksiyon parametreleri>);` ÅŸeklindedir. 

`double foo(int x, int y);`, `double foo(int, int);` ya da `double foo(int v1, int);` fonksiyon bildirimleri aynÄ±dÄ±r, buradan gÃ¶rÃ¼lebileceÄŸi gibi, 

â­ Fonksiyon bildiriminde fonksiyon parametrelerine ad verip vermemenin bir Ã¶nemi yoktur, fonksiyon bildirimi ile fonksiyon tanÄ±mÄ±ndaki fonksiyon parametrelerinin deÄŸiÅŸken adlarÄ±nÄ±n aynÄ± olup olmamasÄ± da Ã¶nemli deÄŸildir.

â— Her **adÄ±n(identifier)** geÃ§erli olduÄŸu bir **kapsamÄ±(scope)** vardÄ±r(kapsam bir identidier'Ä±n kullanÄ±labileceÄŸi kod aralÄ±ÄŸÄ±nÄ± belirler). 


ğŸ§­ C dilinin standardÄ±ndaki **kapsam(scope)** tÃ¼rleri aÅŸaÄŸÄ±daki gibidir;
- File scope
- Block scope
- Function scope
- Function prototype scope

**Function prototype scope**: Bu kategori diÄŸer Ã¼Ã§Ã¼nden ayrÄ±dÄ±r. Sadece fonksiyon bildirimlerinde tercihe baÄŸlÄ± olarak bildirilen adlarÄ±n kapsamÄ±nÄ± ifade eden tanÄ±mlamadÄ±r.
`return_type foo(int parameter1_type, int parameter2_type);` ÅŸeklindeki fonksiyon tanÄ±mlamasÄ±ndaki `(...)` parantezinin iÃ§i **function prototype scope** olarak tanÄ±mlanÄ±r ve burada alÄ±nabilecek tek **sÃ¶zdizim hatasÄ±(syntax error)** farklÄ± parametrelere aynÄ± adÄ±n verilmesidir.


â— Fonksiyon Bildirimde parametrelere ad vermenin en Ã¶nemli faydasÄ± **IDE**'lerin fonksiyon Ã§aÄŸrÄ±sÄ±nÄ±n yapÄ±ldÄ±ÄŸÄ± yerde fonksiyonun prototype'ine bakÄ±p fonksiyon Ã§aÄŸrÄ±sÄ± yaparken bu prototype'i gÃ¶stermektedir, bu da fonksiyon parametrelerinin adlarÄ±nÄ±n anlamlÄ± olmasÄ± durumlarÄ±nda faydalÄ±dÄ±r.


â” 
ğŸ‘‡ MÃ¼lakatlarda en Ã§ok sorulan sorulardan biri aÅŸaÄŸÄ±daki bilgiyle ilgilidir.
- âš ï¸ C dilinde aÅŸaÄŸÄ±daki fonksiyon bildiriminde parametre parantezinin iÃ§inin boÅŸ bÄ±rakÄ±lmasÄ± fonksiyonun parametre deÄŸiÅŸkeninin olmadÄ±ÄŸÄ± anlamÄ±na gelmiyor.
- C++ dilinde `int foo();` ve `int foo(void);` fonksiyon bildirimleri aynÄ± anlama gelmektedir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include<stdio.h>

int foo(); // Parametre deÄŸiÅŸkeni sayÄ±sÄ± ve tÃ¼rleri hakkÄ±nda bilgi verilmemektedir.

int main(void)
{
    // AÅŸaÄŸÄ±daki fonksiyon Ã§aÄŸrÄ±larÄ± legal'dir ve derleme hatasÄ± oluÅŸmaz.
    foo();
    foo(1);
    foo(1, 2);
    foo(1, 3, 8);
}
```

ğŸ‘‡ AÅŸaÄŸÄ±daki programda `bar` fonksiyonunun bildiirminden hiÃ§ parametre almadÄ±ÄŸÄ± anlaÅŸÄ±lmaktadÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include<stdio.h>

int bar(void); // Bu fonksiyon tanÄ±mÄ± ile 'bar' fonksiyonunun herhangi bir parametre almayacaÄŸÄ± belirtilmiÅŸ olur.

int main(void)
{
    // AÅŸaÄŸÄ±daki fonksiyon Ã§aÄŸrÄ±larÄ± illegal'dir ve derleme hatasÄ± oluÅŸur.
    bar();
    bar(1);
    bar(1, 2);
    bar(1, 3, 8);
}
```

â— C99 standardÄ±na kadar **default function declaration** kuralÄ± vardÄ±r, bu kural sadece eskiden yazÄ±lmÄ±ÅŸ C kodlarÄ±nÄ± okurken kullanÄ±ÅŸlÄ±dÄ±r, yeni yazÄ±lan C kodlarÄ±nda bu kullanÄ±m tercih edilmemelidir, bu kullanÄ±m bir Ã§ok Ã§alÄ±ÅŸma zamanÄ± hatasÄ±na neden olabilmektedir.


âš ï¸ Bir fonksiyona Ã§aÄŸrÄ± yaptÄ±ÄŸÄ±nÄ±zda derleyicinin ilgili fonksiyonun bildirimini ya da tanÄ±mÄ±nÄ± bulacaÄŸÄ±ndan emin olunmasÄ± gerekiyor.

ğŸš€ `foo();` fonksiyon bildirimi kodda kullanÄ±lÄ±rsa C89 standardÄ±nda fonksiyon `int foo();` ÅŸeklinde tanÄ±mlanmÄ±ÅŸ olarak kabul edilir.


â— **Default Argument Conversion**: **Default function declaration** bildirimlerinde derleyiciler fonksiyona geÃ§ilen argÃ¼manlarÄ± aÅŸaÄŸÄ±daki gibi iÅŸleyecektir, bu ÅŸekildeki iÅŸleme ÅŸekline **default argument conversion** denilmektedir;
- `int` altÄ± tÃ¼rler `int` tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r.
- Kayan noktalÄ± tÃ¼rler double tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r.
- DiÄŸer tÃ¼rler kendi tÃ¼rlerinde kabul edilecektir.


## BÃ¼yÃ¼k Resim(C Dilinde Kaynak Dosyalar HakkÄ±nda) 

Biz C programlarÄ±nÄ± yazarken programlarÄ± farklÄ± dosyalara ayÄ±rarak yazÄ±yoruz, standart kÃ¼tÃ¼phaneden ya da baÅŸkalarÄ±nÄ±n yazmÄ±ÅŸ olduklarÄ± kodlarÄ±n kaynak dosyalarÄ±nÄ± ya da object dosyalarÄ±nÄ± kullanarak yazÄ±yoruz.

 
**Module**: DiÄŸer kaynak dosyalara hizmet veren(yani diÄŸer kaynak dosyalarÄ±n kullandÄ±ÄŸÄ± varlÄ±klarÄ± barÄ±ndÄ±ran birime) birime verilen addÄ±r.

**Seperate Compilation Module**: C dilinde kÃ¼tÃ¼phaneler birden Ã§ok modÃ¼lden oluÅŸur ve her modÃ¼l tek bir dosyadan oluÅŸuyorsa **.c** ve **.h** uzantÄ±lÄ± dosyalardan oluÅŸur, bu dosyalarla ilgili bilgiler aÅŸaÄŸÄ±daki gibidir;
1. **file.h** dosyalarÄ±na "**header file**" ya da "**header**" denmektedir.
2. **file.c** "**implementation file**", "**code file**", "**source file**" olarak adlandÄ±rÄ±labiliyor.

 
**header files** aslÄ±nda sadece yazÄ±lÄ±msal varlÄ±klarÄ±n bildirimlerini iÃ§eren dosyalardÄ±r ve **.c** dosyalarÄ±nÄ±n baÅŸÄ±nda kullanÄ±lan **#include** kod satÄ±rlarÄ±nÄ± Ã¶n iÅŸlemci program Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda ilgili **.h** uzantÄ±lÄ± dosyanÄ±n iÃ§eriÄŸini alÄ±p kaynak dosyaya yapÄ±ÅŸtÄ±rÄ±r ve derleyicinin iÅŸleyeceÄŸi **translation unit** dosyasÄ±nÄ± Ã¼retir.

Mesela C dilinde bir modÃ¼l yazdÄ±k(.c ve .h uzantÄ±lÄ± dosyalar halinde iki tane dosya yazÄ±ldÄ±) bu yazÄ±lan modÃ¼lÃ¼ baÅŸkalarÄ±nÄ±n kullanabilmesi iÃ§in iki farklÄ± ÅŸekilde paylaÅŸabiliriz;
1. **.h** ve **.c** uzantÄ±lÄ± dosyalarÄ± paylaÅŸabiliriz, bu ÅŸekilde kaynak dosya olan **.c** dosyasÄ±nÄ± paylaÅŸtÄ±ÄŸÄ±mÄ±z kiÅŸi paylaÅŸtÄ±ÄŸÄ±mÄ±z modÃ¼lÃ¼ kullanabilir ve isterse kaynak kodda(.c dosyasÄ±) dÃ¼zenleme de yapabilir.
2. **.h** dosyasÄ± ve **.c** dosyasÄ±nÄ±n derlenmiÅŸ hali olan **object** dosyasÄ±nÄ± paylaÅŸabiliriz, bu ÅŸekilde kaynak **.c** dosyasÄ± paylaÅŸmamÄ±ÅŸ oluruz ve modÃ¼lÃ¼n paylaÅŸÄ±ldÄ±ÄŸÄ± kiÅŸi modÃ¼lÃ¼ kullanabilmek iÃ§in **object** dosyasÄ±nÄ± **linker** programÄ±n arama yapacaÄŸÄ± dizine kopyalamalÄ±dÄ±r(bu da ayrÄ± bir konu, sonradan deÄŸinilecek).

 
BazÄ± durumlarda Ã§aÄŸrÄ±lan fonksiyonun bildirimi ile Ã§aÄŸÄ±ran fonksiyonun tanÄ±mÄ± aynÄ± dosyada olabilir, bu da Ã§ok sÄ±k karÅŸÄ±laÅŸÄ±lan bir kullanÄ±mdÄ±r.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.46-11.05 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***

> â” 
> Sorulan soru;
> 
> Ã‡ok temel bi sorum olacaktÄ±. Compile, linkage, run vs.. Build surecinin toplam kaÃ§ aÅŸamasÄ± var, ve bunlar neler?
> 
> Cevap;
> 
> Kursun ilk baÅŸlarÄ±nda bunlar anlatÄ±lmÄ±ÅŸtÄ± ÅŸu an deÄŸinilmesi dersi bÃ¶lecektir, ileride tekrardan anlatÄ±labilir.


â— C dilinde genel kodlama yÃ¶ntemi olarak kaynak kodu yazarken **.c** ve **.h** olarak iki farklÄ± dosyaya kodlarÄ± ayÄ±rarak yazmaktÄ±r, kullanÄ±lan varlÄ±klarÄ±n **bildirimleri(decleration)** **.h** dosyasÄ±na yazÄ±lÄ±r ve varlÄ±klarÄ±n **tanÄ±mlarÄ±(definition, implementation)** **.c** dosyasÄ±na yazÄ±lÄ±r.


## Compiler Optimization(Derleyici Optimizasyonu) 

â—â—â— Derleyici kodun anlamÄ±nÄ± deÄŸiÅŸtirmeden kodu farklÄ± ÅŸekilde yazÄ±lmÄ±ÅŸ gibi yorumlayabilir, bu iÅŸlem kodun optimize edilmesi iÃ§in yapÄ±lmaktadÄ±r, bu iÅŸlem yapÄ±lÄ±rken **observable behavior(gÃ¶zlenebilir davranÄ±ÅŸ)** deÄŸiÅŸmemektedir.

ğŸ‘‡ AÅŸaÄŸÄ±daki programda derleyicinin kodda gereksiz olan bazÄ± iÅŸlemleri nasÄ±l optimize edebileceÄŸiyle ilgili bilgi edinilebilir;
```C
#define _CRT_SECURE_NO_WARNINGS

#include<stdio.h>

int main(void)
{
    // AÅŸaÄŸÄ±daki gibi bir kodlama yapÄ±ldÄ±ÄŸÄ±nda.
    int cnt = 0;
    for(int i = 0; i < 10; i++){
        cnt++;
    }
    printf("cnt = %d", cnt);
    

    // Derleyici optimizasyon sonrasÄ±nda yukarÄ±daki kodu aÅŸaÄŸÄ±daki gibi tek satÄ±ra indirgeyebilir.
    printf("cnt = 10");
}
```



âš¡ Derleyicilerin derleme iÅŸlemini yaparken bazÄ± parametrelere gÃ¶re Ã§alÄ±ÅŸÄ±r ve derleme aÅŸamasÄ±nda derlemenin nasÄ±l yapÄ±lacaÄŸÄ± **compiler switches(derleyicilerin Ã¶zellilerini aÃ§ma kapama dÃ¼ÄŸmeleri)** ile ayarlanabilmektedir.</br>
âš¡ **Compiler optimization** nasÄ±l yapÄ±lacaÄŸÄ± **compiler switches** ile ayarlanabiliyor yani derleyicinin hangi tÃ¼r optimizasyonlarÄ± yapÄ±p hangi tÃ¼r optimizasyonlarÄ± yapmayacaÄŸÄ± ayarlanabiliyor.



â— BazÄ± programlar birincil Ã¶ncelik programÄ±n daha az iÅŸlem koduna sahip olmasÄ± deÄŸil programÄ±n Ã¼zerinde Ã§alÄ±ÅŸacaÄŸÄ± donanÄ±mÄ±n belleÄŸinde daha az yer kaplamasÄ± olabilir, bu durumlarda ilgili programÄ± derlerken derleyicinin yapacaÄŸÄ± optimizasyonlar ihtiyaca gÃ¶re ayarlanmaasÄ± gerekecektir.


ğŸš€ **As If Rule**: Bu terim derleyicinin yapacaÄŸÄ± optimizasyon sonrasÄ±nda Ã¼retilecek makine kodlarÄ±nÄ±n(ya da assembly kodu) **gÃ¶zlenebilir davranÄ±ÅŸ(observable behavior)** deÄŸiÅŸmeyecek ÅŸekilde ele alÄ±nmasÄ±nÄ± ifade eder.


ğŸ§  Derleyicilerin yaptÄ±ÄŸÄ± optimizasyonlardan bazÄ±larÄ± aÅŸaÄŸÄ±daki gibidir;
- **Loop Reversal Optimization**: Derleyicini bir dÃ¶ngÃ¼nÃ¼n Ã§alÄ±ÅŸma akÄ±ÅŸÄ±nÄ± terse Ã§evirdiÄŸi optimizasyon iÅŸlemidir.
- **Loop Unrolling Optimization**: Derleyicini dÃ¶ngÃ¼ deyimi iÃ§inde yazÄ±lmÄ±ÅŸ kodlarÄ± dÃ¶ngÃ¼ yokmuÅŸ gibi(dÃ¶ngÃ¼ adÄ±mÄ± kadar kodlarÄ± tekrarlÄ± yazma iÅŸlemi) yorumlamasÄ±na optimizasyon iÅŸlemine verilen addÄ±r.
- **Inline Expansion Optimization**

[11:25:30-11:35:00]
ğŸš€ **Inline Expansion Optimization**: Derleyiciler bir fonksiyon tanÄ±mÄ±nÄ± gÃ¶rmeleri durumunda kodda fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±lan yerlerde sanki fonksiyon Ã§aÄŸrÄ±sÄ± yokmuÅŸ gibi fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±lan yerlerde fonksiyonun yaptÄ±ÄŸÄ± iÅŸlemleri ilgili yere doÄŸrudan ekleyebilir, bu optimizasyon **Inline Expansion Optimization** olarak adlandÄ±rÄ±lÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include<stdio.h>

// AÅŸaÄŸÄ±daki fonksiyon pure function Ã¶zelliÄŸindedir
int foo(int x, int y)
{
    // statements
    return x * y - 2;
}

int main(void)
{
    int x = 10;
    int y = 57;

    int z = foo(x, y);  
}
```

ğŸ§­ Derleyici hangi durumlarda **inline expansion optimization** yapma kararÄ±nÄ± verebilir;
1. Derleyicinin fonksiyonun tanÄ±mÄ±nÄ± gÃ¶rÃ¼yor olmasÄ± gerekiyor, yoksa **inline expansion optimization** zaten yapÄ±lamaz. "No function code no inline expansion" diye Ã¶zetlenebilir.
2. Derleyicinin **inline expansion optimization** yapmasÄ±nÄ±n fayda saÄŸlÄ±yor olmasÄ± gerekiyor, derleyici bunun iÃ§in bir analiz yapar ve analiz neticesine gÃ¶re yapÄ±p yapÄ±lmayacaÄŸÄ±na karar verilir.
3. KullanÄ±lan derleyicinin kabiliyeti **inline expansion optimization** yapÄ±lÄ±p yapÄ±lmayacaÄŸÄ±nÄ± belirler.
4. KullanÄ±lan derleyicinin **switch**'lerinin nasÄ±l ayarlandÄ±ÄŸÄ± **inline expansion optimization** yapÄ±lÄ±p yapÄ±lmayacaÄŸÄ±nÄ± belirler.


## Header Files(BaÅŸlÄ±k DosyalarÄ±) 

Bir C programÄ± yazarken kendi yazdÄ±ÄŸÄ±mÄ±z **.h** dosyalarÄ±nÄ±, standart kÃ¼tÃ¼phaneden gelen **.h** dosyalarÄ±nÄ± ya da Ã¼Ã§Ã¼ncÃ¼ taraflarÄ±n(firmalarÄ±n, kiÅŸilerin) yazdÄ±ÄŸÄ± **.h** dosyalarÄ±nÄ± kullanabiliriz.


ğŸ§­ Header Files iÃ§inde neler olabilir;
1. **Function declarations(FonksiyonlarÄ±n bildirimleri)** olabilir.
2. **Preprocessing directives(Ã–n iÅŸlemci komutlarÄ±)** olabilir, **define** ile bildirilen bildirimlere **makro** deniyor ve iki tÃ¼re ayrÄ±lÄ±yor;
    1. **Object-like macro**
    2. **Function-like macro**
3. **User defined type declarations** olabilir.
4. **Type alias declarations(Typedef declarations)** olabilir.
5. **Preprocessor directives** olabilir.



â—â—â— Bir **identifier** derleyicinin ya da Ã¶n iÅŸlemci programÄ±n gÃ¶rebileceÄŸi bir ad olabilir. Ã–n iÅŸlemci programÄ±n iÅŸlediÄŸi(gÃ¶rebildiÄŸi) adlara **makro** deniliyor.



âš ï¸ BaÅŸlÄ±k dosyalarÄ±na **fonksiyon tanÄ±mlarÄ±(function definition)** yazÄ±lmamalÄ±, fakat bunun istisnalarÄ± vardÄ±r, `inline` anahtar sÃ¶zcÃ¼(C99 ile C dilinin standardÄ±na eklendi) ve `static` anahtar sÃ¶zcÃ¼kleriyle tanÄ±mlanan **fonksiyonlarÄ±n tanÄ±mlarÄ±(definition)** yazÄ±labilir.


ğŸ‘‡ AÅŸaÄŸÄ±daki C kodundan temel bir **.h** dosyasÄ± nasÄ±l olabilir bu incelenebilir.
```C
#program once

// Preprocessor directives
#include <stdion.h>


// User defined type declarations
struct Data{
    int x;
    int y;
};


// Preprocessing directives
#define SIZE 1000 // Object-like makro
#define max(a, b) ((a) > (b) ? (a) : (b)) // Function-like makro


// Type alias declarations
typedef int Word;


// Function declarations(Function Prototypes)
int foo(void);
double bar(int, int);
long long baz(int x, int y, int z);
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.01-12.12 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


ğŸ§­ Bu derste "11:07:00" anÄ±nda sorulan soru iÃ§in verilen Ã¶zet bir aÃ§Ä±klama aÅŸaÄŸÄ±daki gibi yapÄ±ldÄ±;
1. **Preprocessing(Preprocessor)** -> Kaynak dosyalarÄ±nÄ±(**.c** files) iÅŸler ve **translation unit** dosyalarÄ±nÄ± oluÅŸturur.
2. **Compilation(Compiler)** -> **Translation unit** dosyalarÄ±nÄ± iÅŸler ve **object** dosyalarÄ±nÄ± oluÅŸturur.
3. **Linking(Linker)** -> **object** dosyalarÄ±nÄ± iÅŸlem ve Ã§alÄ±ÅŸtÄ±rÄ±labilir dosya(.exe vb. dosyalar) oluÅŸturur.


ğŸ§  TÃ¼m sÃ¼reÃ§ her bir **.c** uzantÄ±lÄ± dosya iÃ§in ayrÄ± ayrÄ± Ã§alÄ±ÅŸtÄ±rÄ±lmaktadÄ±r.</br>
**.c** uzantÄ±lÄ± kaynak dosyalar ilk Ã¶nce **preprocessing** programÄ± tarafÄ±ndan iÃ§erdikleri Ã¶n iÅŸlemci komutlarÄ± iÅŸlenir ve **translation unit** dosyalarÄ± oluÅŸturulur.</br>
Ãœretilen **translation unit** dosyalarÄ±nÄ± **compiler** programÄ± alÄ±p iÅŸler ve **object** dosyalarÄ±nÄ± Ã¼retir.</br>
En son aÅŸamada **linker** program **object** dosyalarÄ±nÄ± alÄ±p farklÄ± dosyalarda kullanÄ±lmÄ±ÅŸ olan varlÄ±klarÄ± iliÅŸkilendirip baÄŸlama iÅŸlemini yapÄ±p tek bir Ã§alÄ±ÅŸtÄ±rÄ±labilir dosyayÄ± Ã¼retir(.exe vb. dosyalar).


## Preprocessor & Preprocessor Directives(Ã–n-iÅŸlemci ve Ã–n-iÅŸlemci BuyruklarÄ±) 

C ve C++ dillerinde diÄŸer bir Ã§ok dilden farklÄ± olarak **preprocessing** iÅŸleminin yapÄ±lmasÄ±dÄ±r.

âš ï¸ Ä°yi bir C ve C++ yazÄ±lÄ±mcÄ±sÄ± olmak iÃ§in Ã¶n-iÅŸlemci programÄ±n nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± ve Ã¶n-iÅŸlemci komutlarÄ±nÄ± iyi bilmek gerekmektedir.

Ã–n-iÅŸlemci program **.c** uzantÄ±lÄ± kaynak dosyalarÄ± alÄ±r iÅŸler ve **translation unit** dosyalarÄ±nÄ± oluÅŸturur.


KaÃ§ tane Ã¶n-iÅŸlemci komutunun olduÄŸu C dilinin standardÄ±nda belirtilmiÅŸtir, C dilindeki Ã¶n-iÅŸlemci komutlarÄ±nÄ±n aÅŸaÄŸÄ±daki gibidir;
1. `# (null directive)`: Bu komut sadece sÃ¼sleme, hizalama amaÃ§lÄ± olarak kullanÄ±lmaktadÄ±r baÅŸka bir gÃ¶revi yoktur.`
2. `#include`
3. `#define`
4. `#undef`
5. `#if`
6. `#else`
7. `#elif`
8. `#endif`
9. `#ifdef`
10. `#ifndef`
11. `#line`
12. `#error`
13. `#pragma`


â— Ã–n-iÅŸlemci komutlarÄ±nÄ±n hepsinin ortak Ã¶zelliÄŸi, `#` karakteriyle baÅŸlamasÄ± ve her bir Ã¶n-iÅŸlemci komutunun sonunda **new-line(yeni satÄ±r)** karakterinin olma zorunluluÄŸudur, burada Ã¶n-iÅŸlemci komutlarÄ±nÄ±n sonuna `;` token'Ä±nÄ±n eklenmemesine dikkat edilmelidir.


ğŸ‘‡ AÅŸaÄŸÄ±daki C kodunda  
```C
#include <stdion.h>

// AÅŸaÄŸÄ±daki Ã¶n-iÅŸlemci bildirimleri birbirinden farklÄ±dÄ±r, bu fark ';' token kullanÄ±mÄ±ndan kaynaklanÄ±yor.
#define SIZE1 100
#define SIZE2 100;
```

ğŸ‘‡ AÅŸaÄŸÄ±daki C kodunda 
```C
// AÅŸaÄŸÄ±daki Ã¶n-iÅŸlemci bildirimi geÃ§erli deÄŸildir, bunun nendeni her satÄ±rda tek bir Ã¶n-iÅŸlemci komutunun olmasÄ± gerekmesindendir.
int x ; #include <stdion.h>

```


ğŸ‘‡ AÅŸaÄŸÄ±daki C programÄ± derleme hatasÄ± verecektir, bunun nedeni **name lookup** iÅŸleminin en iÃ§ kapsamdan(stope) yukarÄ±ya doÄŸru yapÄ±lmasÄ±dÄ±r ve aÅŸaÄŸÄ±daki programda derleyici "printf" fonksiyonunu bulamaz.
```C

int main(void)
{
    printf("selam dunya!");
}

#include <stdion.h>
```



âš ï¸ Derleyicinin gÃ¶rdÃ¼ÄŸÃ¼ dosyada(translation unit) hiÃ§bir Ã¶n-iÅŸlemci komutu yer almaz Ã§Ã¼nkÃ¼ Ã¶n-iÅŸlemci program bu komutlarÄ± iÅŸledikten sonra siler.



âš ï¸ Preprocessing iÅŸleminden Ã¶nce yorum satÄ±rlarÄ± koddan Ã§Ä±kartÄ±lÄ±r(silinir) ardÄ±ndan Ã¶n-iÅŸlemci komutlarÄ± yÃ¼rÃ¼tÃ¼lÃ¼r ve **translation unit** dosyasÄ± Ã¼retilir, **translation unit** dosyasÄ±nda herhangi bir Ã¶n-iÅŸlemci komutu yeralmaz yani derleyici yorum satÄ±rlarÄ±nÄ± ve Ã¶n-iÅŸlemci komutunu gÃ¶rmez(yani ne olduklarÄ±nÄ± bilmez).


### `#include` Komutu 

**#include** komutu Ã¶n-iÅŸlemci programa ÅŸunu anlatÄ±r: "KullanÄ±lan **.h** uzantÄ±lÄ± dosyayÄ± bul ve kaynak dosyada ilgili yere oradaki kodlarÄ± yapÄ±ÅŸtÄ±r."

`#include <stdio.h>` ve `#include "nutility.h"` ÅŸeklinde kullanÄ±labilir, bu iki kullanÄ±m arasÄ±nda aÅŸaÄŸÄ±da aÃ§Ä±klandÄ±ÄŸÄ± gibi ufak bir fark vardÄ±r;
- `#include <stdio.h>` ÅŸeklindeki kullanÄ±mda dosya konumu bilinen(bu konum derleyiciye ve kullanÄ±lan Ide programa gÃ¶re deÄŸiÅŸebilir) **.h** dosyalarÄ± kullanÄ±lmak istendiÄŸinde tercih edilir. Bu durumdaki kullanÄ±m ile **.h** dosyalarÄ± ya standart **.h** dosyalarÄ±nÄ± eklerken ya da derleyicinin Ã¶zel olarak sunduÄŸu **.h** dosyalarÄ±nÄ± eklerken kullanÄ±lmalÄ±dÄ±r.
- `#include "nutility.h"` ÅŸeklindeki kullanÄ±mda Ã¶zel olarak yazÄ±lan **.h** dosyalar kullanÄ±lmak istendiÄŸinde kullanÄ±lÄ±r. Bu kullanÄ±mdaki **.h** dosyasÄ± ilk kullanÄ±ldÄ±ÄŸÄ± kaynak dosyanÄ±n(.c file) bulunduÄŸu dizinde aranmaktadÄ±r eÄŸer bu dizinde ilgili dosya bulunamazsa **default directory**'de dosya aranÄ±r.

â— Derleyicilerin kaynak dosyalarda `#include` ile kullanÄ±lan harici dosyalarÄ± arama dizinleri Ã¶zel olarak ayarlanabilir ya da kullanÄ±lan derleyiciye kaynak dosyalarÄ±n aranacaÄŸÄ± dizin komut satÄ±rÄ±ndan verilebilir, bu ÅŸekilde yazÄ±lan programlarda Ã¶zel dizin konumlarÄ±nda dosyalar saklanabilir.


âš ï¸ EÄŸer **include** komutuyla bir header olmayan dosya adÄ± kullanÄ±yorsanÄ±z(mesela `#include file_name.c` gibi bir kullanÄ±m) %99.99999 olasÄ±lÄ±kla yanlÄ±ÅŸ bir iÅŸlem yapÄ±yorsunuzdur. 


ğŸ‘‡ â— **#include** kullanÄ±mÄ±nÄ± daha iyi anlayabilmek iÃ§in aÅŸaÄŸÄ±daki program incelenebilir fakat Ã¼retimde bu ÅŸekilde kodlama yapÄ±lmamaktadÄ±r;
```C
#include <stdio.h>
#include "eren.h" // Bu dosyanÄ±n iÃ§eriÄŸi 'int main(' ÅŸeklindedir.

)
{
    printf("marhaba");  
}
```


â— ğŸ‘† YukarÄ±da program, ğŸ‘‡ aÅŸaÄŸÄ±daki program ile aynÄ±dÄ±r ve **sÃ¶zdizim hatasÄ±(syntax error)** yoktur;
```C
#include <stdio.h>
int main(

)
{
  
  printf("marhaba");  

}
```

â— Kaynak dosyalara(**.c** files) **#include** buyruÄŸu(komut) ile eklenen baÅŸlÄ±k dosyalarÄ± iÃ§erisinde de **#include** buyruklarÄ±(komut) olabilir ve bu birkaÃ§ seviyeye kadar devam edebilir, Ã¶n-iÅŸlemci programÄ± her seviyedeki **#include** buyruÄŸu(komut) iÃ§in aynÄ± iÅŸlemi tekrar edecektir.


Ders sonu ...
