# 35.Ders 17.05.2025 ğŸ•˜

Derse 13(09:01)-14(09:05)-16(09:23)-17(09:43)-15(10:45)-15(11:13)-15(12:25)-15(12:45) kiÅŸi katÄ±ldÄ±.
---

## Pointer To Pointer Devam


â—â—â— ProgramcÄ±lar baÅŸlangÄ±ÅŸ aÅŸamasÄ±nda **deÄŸiÅŸkenlerin tÃ¼rÃ¼(decleration type)** ve **ifadelerin tÃ¼rÃ¼(expression type)** kavramlarÄ±nÄ± birbirine karÄ±ÅŸtÄ±rÄ±yormuÅŸ ama bu terimler birbirlerinden farklÄ±dÄ±r ve farklarÄ± iyi bilinmelidir.

`int x = 10; int* ptr = &x;` burada `x` deÄŸiÅŸkeninn tÃ¼rÃ¼ `int` ve `ptr` deÄŸiÅŸkeninn tÃ¼rÃ¼ `int*` tÃ¼rÃ¼dÃ¼r.


ğŸ‘‡ AÅŸaÄŸÄ±daki sÃ¶zde kodda deÄŸiÅŸkenlerin tÃ¼rÃ¼nÃ¼n baÅŸka ifadelerin tÃ¼rÃ¼nÃ¼n baÅŸka olma durumu incelenebilir, **integral promotion** durumuna da deÄŸiniliyor 
```C

int x1; // 'x1' deÄŸiÅŸkeninin tÃ¼rÃ¼ 'int'
int* x2; // 'x2' deÄŸiÅŸkeninin tÃ¼rÃ¼ 'int*'
int** x3; // 'x3' deÄŸiÅŸkeninin tÃ¼rÃ¼ 'int**'
int x4[10]; // 'x4' deÄŸiÅŸkeninin tÃ¼rÃ¼ 'int[10]'

char c = 6; // 'c' deÄŸiÅŸkeninin tÃ¼rÃ¼ 'char'

+c; // '+c' ifadesinin tÃ¼rÃ¼ 'integral promotion' nedeniyle 'int', buradan da gÃ¶rÃ¼lÃ¼yor ki deÄŸiÅŸkenlerin tÃ¼rÃ¼ baÅŸka ifadelerin tÃ¼rÃ¼ baÅŸkadÄ±r.


int x = 10;
int* ptr = &x;

/*

'ptr' ifadesinin tÃ¼rÃ¼ 'int*'

'*ptr' ifadesinin tÃ¼rÃ¼ 'int'

*/
```


â—â—â— **Value Category**: C standardÄ±nda bu terim kullanÄ±lmasa da C++ standardÄ± bu terim kullanÄ±lÄ±yor ve ifadelerin **value category** deÄŸerlerinin ne olduÄŸu o ifadelerin hangi iÅŸlemlerde kullanÄ±labileceÄŸini belirliyor, bellekte bir yazÄ±lÄ±msal varlÄ±ÄŸa eriÅŸilebilmesini saÄŸlayacak olan ifadeler **L-value**, tam tersi bir nesneye eriÅŸim saÄŸlamayan ifadeler **R-value** ifadelerdir.
- **Adres operatÃ¶rÃ¼(`&`)** ile oluÅŸturulan tÃ¼m ifadeler **R-value** grubuna dahildir.
- TÃ¼m deÄŸiÅŸken adlarÄ±(identifier) **L-value** grubuna dahildir, Ã§Ã¼nkÃ¼ bellekte yer alan nesnelerdir.
- **Dereferencing(iÃ§erik) operatÃ¶rÃ¼(`*`)** ile oluÅŸturulan tÃ¼m ifadeler **L-value** grubuna dahildir.



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programda ifadelerin tÃ¼rleri ve **value category** deÄŸerlerinin ne olduÄŸu incelenebilir, buradaki bilgiler iyi bilinmelidir yoksa konularda ilerlenemeyecektir.
```C
#include <stdio.h>

int main(void)
{
    int x = 10;
    int* p = &x;
    int** ptr = &p;

    /*

    ifade   Type    Value
    x       int     L
    &x      int*    R
    p       int*    L
    *p      int     L
    &p      int**   R
    ptr     int**   L
    *ptr    int*    L
    **ptr   int     L
    &ptr    int***  R
    
    */
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program **pointer to pointer** deÄŸiÅŸkenlerin temel olarak nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 10;
    int y = 45;
    int* p = &x;
    int** ptr = &p;

    //*ptr = &y;
    **ptr = 99; // '*(*ptr)' ile denktir ve buradaki kod 'x' deÄŸiÅŸkeninin deÄŸerini '99' yapar. '**ptr' ifadesi sÃ¶zel olarak ÅŸuna denktir: 'ptr deÄŸiÅŸkeninin gÃ¶sterdiÄŸi nesne olan p nesnesinin gÃ¶sterdiÄŸi x nesnesi demektir.'
    
    printf("x = %d\n", x);
    ++**ptr; // 'x' deÄŸiÅŸkeninin deÄŸeri bir arttÄ±rÄ±lÄ±yor.
    printf("x = %d\n", x);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **double dereferencing** ya da **double indirection** olarak adlandÄ±rÄ±lan iÅŸlemin ne olduÄŸu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 10;
    int 7 = 45;
    int* p = &x;
    int** ptr = &p;

    // '**' operatÃ¶rÃ¼ ile iki defa bir nesnenin deÄŸerine eriÅŸme iÅŸlemine 'double-dereferencing' ya da 'double-indirection' deniliyor.
    **ptr = 99;
    
    printf("x = %d\n", x);
    ++**ptr;
    printf("x = %d\n", x);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **pointer to pinter** deÄŸiÅŸkenlerde bazÄ± kafa karÄ±ÅŸtÄ±rÄ±cÄ± durumlar incelenebilir, buradaki iÅŸlemler iyi anlaÅŸÄ±lmalÄ±dÄ±r ve anlaÅŸÄ±lmadan ilerlenmemelidir(ayrÄ±ca bu konuyla ilgili olarak internetten yeterli sayÄ±da soru bulup anlaÅŸÄ±larak Ã§Ã¶zÃ¼lmelidir)
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[] = { 1, 3, 5, 7, 9 };
    int* p = a;
    int** ptr = &p;

    print_array(a, 5);
    ++*ptr; // Buradaki ifade '++(*ptr)' ile aynÄ±dÄ±r ve burada '*ptr' ifadesi ile 'p' nesnesinin deÄŸeri '1' arttÄ±rÄ±lÄ±yor 'p' nesnesi bir pointer olduÄŸu iÃ§in pointer aritmetiÄŸi kurallarÄ± gereÄŸi gÃ¶sterdiÄŸi adres deÄŸeri bir 'int' tÃ¼rÃ¼ kadar Ã¶telenen adres deÄŸeri olacaktÄ±r ve bÃ¶ylece 'a' dizisinin 1 indisli elemanÄ±nÄ± iÅŸaret eder durumu gelecektir.
    ++**ptr; // Buradaki ifade '++(**ptr)' ile aynÄ±dÄ±r ve burada '**ptr' ifadesi ile 'p' nesnesinin gÃ¶sterdiÄŸi nesneye eriÅŸiliyor, bir Ã¶nceki kodda 'p' nesnesinin gÃ¶sterdiÄŸi nesne 'a' dizisinin 1 indisli elemanÄ± yapÄ±lmÄ±ÅŸtÄ± ve bu nesnenin deÄŸeri bir arttÄ±rÄ±lÄ±yor, 'a' dizisinin 1 indisli elemanÄ±nÄ±n tÃ¼rÃ¼ 'int' olduÄŸu iÃ§in bu deÄŸer bir arttÄ±rÄ±lacaktÄ±r, ilk deÄŸer '3' ve son deÄŸeri '4' olacaktÄ±r.
    print_array(a, 5);

    // C ve C++ dillerinde aÅŸaÄŸÄ±daki gibi karmaÅŸÄ±k bir ifade yazÄ±labiliyor, bu kÄ±smÄ±da '*&' alt ifadesinin birbirini nÃ¶tÃ¼rlediÄŸi anlaÅŸÄ±lmalÄ±dÄ±r.
    ++*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&**ptr;
    print_array(a, 5);
}
```


### Pointer To Pointer Ne Ä°ÅŸe Yarar 

**Pointer to pointer** ne iÅŸe yarar sorusunun kendisi gereksiz bir sorudur Ã§Ã¼nkÃ¼ pointer ne iÃ§in kullanÄ±lÄ±yorsa "**Pointer to pointer**" da o amaÃ§la kullanÄ±lÄ±yor.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `iswap` adÄ±ndaki `int*` tÃ¼rÃ¼nden iki nesnenin gÃ¶sterdiÄŸi adreslerdeki nesnelerin deÄŸerlerini takas eden fonksiyon incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

//  'iswap' adÄ± 'int swap' sÃ¶zcÃ¼klerinden gelmektedir.
// 'int*' tÃ¼rden iki pointer nesnenin gÃ¶sterdiÄŸi adreslerdeki nesnelerin deÄŸerlerini takas eden fonksiyon
void iswap(int* p1, int* p2)
{
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}

int main(void)
{
    int x = 13;
    int y = 23;

    printf("x = %d, y = %d\n", x, y);
    iswap(&x, &y);
    printf("x = %d, y = %d\n", x, y);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `foo` adÄ±nda kendisine `int*` tÃ¼rÃ¼nden gÃ¶stericinin iÅŸaret ettiÄŸi nesnenin deÄŸerini deÄŸiÅŸtiren fonksiyon incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

void foo(int* p)
{
    *p = 7623;
}

int main(void)
{
    int x = 10;

    printf("x = %d\n", x);
    foo(&x);
    printf("x = %d\n", x);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `foo` adÄ±nda kendisine `int**` tÃ¼rÃ¼nden bir gÃ¶stericiyi gÃ¶steren nesne iletilince o nesnenin gÃ¶sterdiÄŸi nesne adresi deÄŸerini global ad alanÄ±nda olan "g" deÄŸiÅŸkeninin adresi olarak deÄŸiÅŸtiren fonksiyon incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int g = 47;

void foo(int** p)
{
    *p = &g; // Burada 'p' parametresinin gÃ¶sterdiÄŸi nesnenin(ki o nesne 'int*' tÃ¼rÃ¼ndedir yani 'int' tÃ¼rÃ¼nden bir nesneyi gÃ¶steren bir pointer) deÄŸeri global 'g' nesnesinin adresi yapÄ±lÄ±yor.
}

int main(void)
{
    int x = 13;
    int* ptr = &x;
    
    printf("*ptr = %d\n", *ptr);
    foo(&ptr);
    printf("*ptr = %d\n", *ptr);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki pointer deÄŸiÅŸkenin deÄŸerlerinin(yani tuttuklarÄ± adres deÄŸerlerinin) nasÄ±l takas edildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a = 133;
    int b = 513;

    int* p1 = &a;
    int* p2 = &b;
    
    printf("*p1 = %d    *p2 = %d\n", *p1, *p2);

    // AÅŸaÄŸÄ±da pointer deÄŸiÅŸkenlerin deÄŸerleri takas edilmektedir, burada takas edilen pointer deÄŸiÅŸkenlerin tuttuÄŸu adres deÄŸerleridir.
    int* temp = p1;
    p1 = p2;
    p2 = temp;

    printf("*p1 = %d    *p2 = %d\n", *p1, *p2);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `pswap` adÄ±ndaki `int**` tÃ¼rÃ¼nden iki nesnenin deÄŸerlerini takas eden fonksiyon incelenebilir, `pswap` fonksiyonu kendisine gÃ¶nderilen `int` tÃ¼rÃ¼nden nesnelerin adreslerini tutan pointer nesnelerin adres deÄŸerlerini takas etmektedir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

void pswap(int** ptr1, int** ptr2)
{
    int** temp = *ptr1;
    *ptr1 = *ptr2;
    *ptr2 = temp;
}

int main(void)
{
    int a = 133;
    int b = 513;

    int* p1 = &a;
    int* p2 = &b;
    

    printf("*p1 = %d    *p2 = %d\n", *p1, *p2);

    pswap(&p1, &p2);

    printf("*p1 = %d    *p2 = %d\n", *p1, *p2);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "setptr" adÄ±ndaki `int**` tÃ¼rÃ¼nden bir pointer parametre alan ve aldÄ±ÄŸÄ± bu `int*` tÃ¼rÃ¼nden nesnenin adres deÄŸerini `NULL` olarak deÄŸiÅŸtiren fonksiyon incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

void setptr(int** p)
{
    //p = NULL; // Buradaki iÅŸlem ile sadece fonksiyonun kendi iÃ§inde var olan 'p' adÄ±ndaki parametre deÄŸiÅŸkeninin deÄŸeri 'NULL pointer' olarak deÄŸiÅŸtirilmiÅŸ oluyor.

    *p = NULL;
}

int main(void)
{
    int* ptr;

    setptr(&ptr);

    if(ptr == NULL)
        pritf("dogru\n");
    else
        pritf("yanlis\n");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program Ã§alÄ±ÅŸtÄ±rÄ±lmak iÃ§in yazÄ±lmamÄ±ÅŸtÄ±r sadece **pointer to pointer** deÄŸiÅŸkenlerin kullanÄ±mÄ±nÄ± iyi anlayabilmek iÃ§in bazÄ± bilgiler iÃ§in incelenmelidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

void foo(int);

void bar(int** p)
{
    *p; // '*p'ye atama yapÄ±lsa main fonksiyonundaki locak deÄŸiÅŸken olan 'ptr' deÄŸiÅŸkeninin deÄŸeri deÄŸiÅŸecektir.
    **p; // '**p' ye atama yapÄ±lsa main fonksiyonundaki locak deÄŸiÅŸken olan 'x' deÄŸiÅŸkeninin deÄŸeri deÄŸiÅŸecektir.
}

int main(void)
{
    int x = 5;
    int* ptr = &x;

    foo(ptr); // 'foo' fonksiyonu 'ptr'nin deÄŸerini deÄŸiÅŸtiremez ama 'foo' fonksiyonu 'ptr'nin gÃ¶sterdiÄŸi nesnenin(yani 'x' nesnesinin) deÄŸerini deÄŸiÅŸtirebilir.

    bar(&ptr); // 'bar' fonksiyonu 'ptr'nin deÄŸerini deÄŸiÅŸtirebilir ve aynÄ± zamanda 'ptr'nin gÃ¶sterdiÄŸi nesnenin deÄŸerini de deÄŸiÅŸtirebilir.
}
```



â—â—â— AÅŸaÄŸÄ±daki program bu dersin en zorlayÄ±cÄ± bilgilerini iÃ§eriyor, dikkatli incelenmelidir. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programdan bir dizinin hem en bÃ¼yÃ¼k hem de en kÃ¼Ã§Ã¼k elemanÄ±nÄ± geriye dÃ¶ndÃ¼ren fonksiyonun nasÄ±l yazÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 20

// 'get_array_min_max' fonksiyonu dÄ±ÅŸarÄ±dan alacaÄŸÄ± tam 
void get_array_min_max(const int* pa, size_t size, int** ptrmin, int** ptrmax)
{
    // Dizinin en kÃ¼Ã§Ã¼k elemanÄ±nÄ±n adresini *ptrmin deÄŸiÅŸkenine yaz.
    // Dizinin en bÃ¼yÃ¼k elemanÄ±nÄ±n adresini *ptrmax deÄŸiÅŸkenine yaz.
    *ptrmin = *ptrmax = (int*)pa;

    for(size_t i = 0; i < size; ++i){
        if(pa[i] < **ptrmin){
            *ptrmin = (int*)(pa + i);
            //*ptrmin = &pa[i];
        }
        else if(pa[i] > **ptrmax){
            *ptrmax = (int*)(pa + i);
            //*ptrmax = &pa[i];
        }
    }
}

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    int* pmin;
    int* pmax;

    get_array_min_max(ar, SIZE, &pmin, &pmax);

    printf("min = %d, indeks = %d\n", *pmin, pmin - ar);
    printf("max = %d, indeks = %d\n", *max, max - ar);

    swap(pmini, pmax);
    print_array(ar, SIZE);
}
```


>â”
> 
> Sorulan soru; 
> 
> GeÃ§en derslerde yazÄ±ÄŸÄ±mÄ±z fonksiyonlarÄ± da bÃ¶yle kullanabiliriz deÄŸil mi? 
> 
> void get_array_minmax(const int *pa, size_t size, int **ptrmin, int **ptrmax)
> {
>     *ptrmax = get_array_max(pa, size);
>     *ptrmin = get_array_min(pa, size);
> }
> 
> Cevap;
> 
> AÅŸaÄŸÄ±daki ilk C programÄ± bu soru Ã¼zerine yazÄ±lmÄ±ÅŸtÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `get_array_min_max` fonksiyonu iki ayrÄ± fonksiyonu kullanacak ÅŸekilde yazÄ±lmÄ±ÅŸtÄ±r, bu kullanÄ±m ile **reusability(yeniden kullanÄ±labilirlik)** kullanÄ±mÄ±nÄ±n gÃ¼zel bir misali gÃ¶rÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 10

int* get_array_max(const int* pa, size_t size)
{
    int* pmax = (int*)pa;

    for(size_t i = 0; i < size; ++i){
        if(pa[i] > *pmax){
            pmax = (int*)(pa + i);
        }
    }

    return pmax;
}

int* get_array_min(const int* pa, size_t size)
{
    int* pmin = (int*)pa;

    for(size_t i = 0; i < size; ++i){
        if(pa[i] < *pmax){
            pmin = (int*)(pa + i);
        }
    }

    return pmin;
}

void get_array_min_max(const int* pa, size_t size, int** ptrmin, int** ptrmax)
{
    // Dizinin en kÃ¼Ã§Ã¼k elemanÄ±nÄ±n adresini *ptrmin deÄŸiÅŸkenine yaz.
    // Dizinin en bÃ¼yÃ¼k elemanÄ±nÄ±n adresini *ptrmax deÄŸiÅŸkenine yaz.
    *ptrmin = get_array_min(pa, size);
    *ptrmax = get_array_max(pa, size);
}

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random();
    print_array(ar, SIZE);

    int* pmin;
    int* pmax;

    get_array_min_max(ar, SIZE, &pmin, &pmax);

    printf("min = %d, indeks = %d\n", *pmin, pmin - ar);
    printf("max = %d, indeks = %d\n", *max, max - ar);

    swap(pmini pmax);
    print_array(ar, SIZE);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda pointer dizisi Ã¼zerinde yapÄ±lan iÅŸlemler incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

// AÅŸaÄŸÄ±daki foo fonksiyonu 'int** ptr' parametresiyle dÄ±ÅŸarÄ±dan bir pointer dizisinin elemanÄ±nÄ±n ilk adresini alÄ±p iÅŸleyecek ÅŸekilde yazÄ±lmÄ±ÅŸtÄ±r.
void foo(int** ptr, int size)
{
    printf("foo' function called. => ");

    for(int i = 0; i < size; ++i){
        printf("%d ", *ptr[i]);
        ++*ptr[i]; // Burada dizinin 
    }
}

int main(void)
{
    int x = 10, y = 20, z = 30, t = 40;

    printf("%d %d %d %d", x, y, z, t);

    int* ptr_ary[4] = { &x, &y, &z, &t };
    foo(ptr_ary, 10);

    printf("%d %d %d %d", x, y, z, t);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `int*` ve `int**` parametre alan fonksiyonlara hangi tÃ¼rden deÄŸerlerin geÃ§ilebileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

void foo(int* ptr, int size);
void bar(int** ptr, int size);

int main(void)
{
    int a[5];
    foo(a, 5); // Buradaki statement derleyici tarafÄ±ndan 'array decay' iÅŸlemiyle 'foo(&a[0], 5);' olarak yorumlanacaktÄ±r.

    int* b[5];
    bar(b, 5); // Buradaki statement derleyici tarafÄ±ndan 'array decay' iÅŸlemiyle 'bar(&b[0], 5);' olarak yorumlanacaktÄ±r.
}
```

 

ğŸ‘‡ AÅŸaÄŸÄ±daki programda `int**` tÃ¼rÃ¼nden elemanlarÄ± olan dizi kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int x = 3, y = 5, z = 7, t = 9;

    printf("%d %d %d %d", x, y, z, t);

    int* px = &x;
    int* py = &y;
    int* pz = &z;
    int* pt = &t;

    int** ar[4] = { &px, &py, &pz, &pt, };

    for(int i = 0; i < size; ++i){
        ++**ar[i];
    }

    printf("%d %d %d %d", x, y, z, t);
}
``` 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `char*` tÃ¼rÃ¼nden elemanlarÄ± yazÄ± olan bir dizinin referansÄ±nÄ± bir fonksiyona geÃ§erek o dizinin elemanlarÄ±nÄ±n nasÄ±l standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderilebileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

void print_names(char** pa, size_t size)
{
    for(size_t i = 0; i < size; ++i){
        printf("%s ", pa[i]);
    }
    printf("\n\n");
}

int main(void)
{
    char* p[] = {  
        "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
        "hakki", "haldun", "halime", "haluk", "handan" "hande", "handesu", "hasan", "helin", "hikmet",
        "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
        "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata", // Burada iki yazÄ± arasÄ±nda olmasÄ± gereken ',' token'Ä± unutulmuÅŸtur.
    };

    for(size_t i = 0; i < asize(p); ++i){
        printf("%s ", p[i]);
    }

    printf("\n~~~~~~~~~~~~~~~~~~~~~\n");

    print_names(p, asize(p));
}
``` 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "sort_name" adlÄ± fonksiyon elemanlarÄ± `char*` tÃ¼rÃ¼nden yazÄ±lar olan bir pointer dizisindeki elemanlarÄ± "booble-sort" algoritmasÄ±yla sÄ±ralamaktadÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h> // YazÄ±larÄ± karÅŸÄ±laÅŸtÄ±rmak iÃ§in 'strcmp' fonksiyonunu kullanabilmek iÃ§in eklenen baÅŸlÄ±k dosyasÄ±.
#include "nutility.h"

void print_names(char** pa, size_t size)
{
    for(size_t i = 0; i < size; ++i){
        printf("%s", pa[i]);
    }
    printf("\n\n");
}

void sort_name(char** pa, size_t size)
{
    // 
    for(size_t i = 0; i < size - 1; ++i){
        for(size_t k = 0; k < size - 1; ++k){
            if(strcmp(p[k], p[k + i]) > 0){
                char* ptemp = p[k];
                p[k] = p[k + 1];
                p[k + 1] = ptemp;
            }
        }
    }
}

int main(void)
{
    const char* p[] = {  
        "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
        "hakki", "haldun", "halime", "haluk", "handan" "hande", "handesu", "hasan", "helin", "hikmet",
        "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
        "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata", // Burada iki yazÄ± arasÄ±nda olmasÄ± gereken ',' token'Ä± unutulmuÅŸtur.
    };

    print_names(p, asize(p));
    sort_name(p, asize(p));
    print_names(p, asize(p));

    /*
        'p' ifadesi ile '&p[0]' ifadesi birbirine denktir, bu ifadelerin denk olmasÄ±nÄ±n nedeni 'p' kullanÄ±lan Ã§oÄŸu yerde(bunun birkaÃ§ istisnasÄ± var) 'array decay conversion' uygulanmasÄ±dÄ±r!

    */
}
``` 

>â”
> 
> Sorulan soru; 
> 
> TÃ¼rleri farkli olsa da 
> p ile "refika" dizisinin adresleri sayisal olarak ayni mi?
> p array decay
> 
> Cevap;
> 
> Buradaki soruda sorulmak istenilen 'char' tÃ¼rÃ¼nden elemanlarÄ± olan dizi tÃ¼rlerinden birden fazlasÄ± kendi elemanÄ± olan bir deÄŸiÅŸkenin 



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programda yazÄ±larÄ± tutan dizilerle pointer deÄŸiÅŸken ve pointer ifadelerin kullanÄ±mlarÄ± incelenebilir, bu programdaki bilgiler Ã¶nemlidir ve iyi anlaÅŸÄ±lmalÄ±dÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

int main(void)
{
    // 'p' deÄŸiÅŸkeninin tÃ¼rÃ¼ 'char*[5]'tir. 'p' ifadesinin Ã§oÄŸu yerde 'array decay'den dolayÄ± '&p[0]' olarak yorumlanÄ±r ve bu ifadenin tÃ¼rÃ¼ de 'char**' tÃ¼rÃ¼dÃ¼r.
    char* p[] = { 
        "ozan", "fersen", "zerpin", "necati", "cavzen", "aypar" 
    };

    puts(p[0]); // Burada ekrana dizinin ilk char dizisini yazar.
    puts(&p[0]); // Buradaki kod hatalÄ±dÄ±r, 'ub' vardÄ±r Ã§Ã¼nkÃ¼ '&p[0]' demek 'p' dizisinin ilk elemanÄ±nÄ±n adresi demek ve o adreste 'string literal' bir varlÄ±ÄŸÄ±n ilk adresi deÄŸer olarak bulunuyor.
    
    puts(p); // Bu iÅŸlem 'ub' durumuna neden olur. 'p' dizi adÄ± olduÄŸu iÃ§in derleyici 'array decay' ile '&p[0]' olarak yorumlanacaktÄ±r, fakat 'p' deÄŸiÅŸkeni bir 'char*' tÃ¼rÃ¼nden elemanlarÄ± olan pointer dizi olduÄŸu iÃ§in '&p[0]' ifadesinin 'puts' fonksiyonuna geÃ§ilmesi tanÄ±msÄ±z davranÄ±ÅŸtÄ±r.
    puts(*p); // Bu kod legal ve geÃ§erlidir, standart Ã§Ä±ktÄ± akÄ±mÄ±na 'p' dizisinin ilk elemanÄ± olan yazÄ± gÃ¶nderilir.
}
```



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programda yazÄ±larÄ± tutan dizilerle ilgili **pointer to pointer** kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

void print_names(char** pa, size_t size)
{
    for(size_t i = 0; i < size - 1; ++i){
        printf("%c\n", *pa[i]); // Burada yazÄ± dizisinin her bir elemanÄ±nÄ±n ilk karakteri yazdÄ±rÄ±lÄ±r. 
        printf("%s\n", pa[i]); // Burada yazÄ± dizisinin her bir elemanÄ± yazdÄ±rÄ±lÄ±r.
    }

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ yukarÄ±daki dÃ¶ngÃ¼ ile aynÄ± verileri yazdÄ±rmaktadÄ±r.
    for(size_t i = 0; i < size - 1; ++i){
        putchar(*pa[i]); // Burada yazÄ± dizisinin her bir elemanÄ±nÄ±n ilk karakteri yazdÄ±rÄ±lÄ±r. 
        putchar('\n');
        puts(pa[i]); // Burada yazÄ± dizisinin her bir elemanÄ± yazdÄ±rÄ±lÄ±r.
    }
}

int main(void)
{
    char* p[] = { 
        "ozan", "furkan", "zeynep", "necati", "cavit", "ayhan" 
    };

    print_names(p, asize(p));
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.49-11.12 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bu derste Ã¶nceden yazÄ±lan bir yazÄ± dizisinin elemanlarÄ±nÄ± sÄ±ralayan fonksiyondaki takas iÅŸlemi yapan kÄ±sÄ±m `cswap` adÄ±nda ayrÄ± bir fonksiyona alÄ±nmÄ±ÅŸtÄ±r ve `print_names` adÄ±ndaki fonksiyon C dilinin idiomatic yapÄ±sÄ±nda yeniden yazÄ±lmÄ±ÅŸtÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

void print_names(char** pa, size_t size)
{
    while(size--)
        printf("%s ", *pa++);
    
    // YukarÄ±daki dÃ¶ngÃ¼nÃ¼n idiom kullanÄ±lmadan yazÄ±lmÄ±ÅŸ hali aÅŸaÄŸÄ±daki gibidir
    //while(size--){
    //    printf("%s ", *pa);
    //    pa++;
    //}
}

//void print_names_old(char** pa, size_t size)
//{
//    for(size_t i = 0; i < size; ++i){
//        printf("%s", pa[i]);
//    }
//    printf("\n");
//}

void cswap(char** p1, char** p2)
{
    char* ptemp = *p1*;
    *p1 = *p2;
    *p2 = ptemp;
}

void sort_name(char** pa, size_t size)
{
    for(size_t i = 0; i < size - 1; ++i){
        for(size_t k = 0; k < size - 1; ++k){
            if(strcmp(p[k], p[k + i]) > 0){
                //cswap(&p[k], &p[k + i]);
                cswap(p + k, p + k + i); // Buradaki kullanÄ±m yukarÄ±daki kullanÄ±mÄ±n pointer aritmetiÄŸi kullanÄ±lmÄ±ÅŸ halidir.
            }
        }
    }
}

int main(void)
{
    const char* p[] = {  
        "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
        "hakki", "haldun", "halime", "haluk", "handan" "hande", "handesu", "hasan", "helin", "hikmet",
        "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
        "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata", // Burada iki yazÄ± arasÄ±nda olmasÄ± gereken ',' token'Ä± unutulmuÅŸtur.
    };

    print_names(p, asize(p));
    sort_name(p, asize(p));
    print_names(p, asize(p));
}
``` 


### Pointer To Pointer And cost 


â—â—â— **const** anahtar sÃ¶zcÃ¼ÄŸÃ¼ neyden Ã¶nce gelirse **const** olan odur. 
- `int * const p = &x;` burada **const** anahtarÄ± `p` deÄŸiÅŸkeninden Ã¶nce geliyor ve bu bildirim **const pointer to int** olarak adlandÄ±rÄ±lÄ±r, bu durumda `p` pointer deÄŸiÅŸkeninin adres deÄŸeri deÄŸiÅŸtirilmesi **sÃ¶zdizim hatasÄ±na(syntax error)** neden olur ama `*p` ifadesine atama iÅŸlemi yapÄ±lÄ±rsa **sÃ¶zdizim hatasÄ±(syntax error)** olmaz.
- `int const * p = &x;` ya da `const int * p = &x;` burada **const** anahtarÄ± `*p` den Ã¶nce geliyor ve bu bildirim **pointer to const int** olarak adlandÄ±rÄ±lÄ±r. bu durumda `p` pointer deÄŸiÅŸkeninin adres deÄŸerinin deÄŸiÅŸtirilmesi **sÃ¶zdizim hatasÄ±(syntax error)** deÄŸildir ama `*p` ifadesine atama iÅŸlemi yapÄ±lÄ±rsa **sÃ¶zdizim hatasÄ±(syntax error)** olur.
- `const int * const p = &x;` ya da `int const * const p = &x;` birdiriminda hem `p` hem de `*p` ifadelerine deÄŸer atanmasÄ± **sÃ¶zdizim hatasÄ±(syntax error)** olacaktÄ±r.



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programda pointer deÄŸiÅŸkenlerin **const** bildirilmesi durumlarÄ± incelenebilir, buradaki bildirimleri anlamak Ã¶nemlidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

int main(void)
{
    int x = 19;
    int y = 37;
    int* p1 = &x;
    int* p2 = &y;

    int** ptr1 = &p1; 

    // AÅŸaÄŸÄ±daki atamalarÄ±n hiÃ§birinde sÃ¶zdizim hatasÄ±(syntax error) yoktur
    ptr1 = &p2; // Legal atama iÅŸlemi.
    *ptr1 = &y; // Legal atama iÅŸlemi.
    **ptr1 = 98; // Legal atama iÅŸlemi.


    int** const ptr2 = &p1; // Burada 'ptr2' pointer deÄŸiÅŸkeni 'const' bildiriliyor.

    ptr2 = &p2; // Bu atama iÅŸleminde sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.
    *ptr2 = &y; // Legal atama iÅŸlemi.
    **ptr2 = 98; // Legal atama iÅŸlemi.


    int* const * ptr3 = &p1;

    ptr3 = &p2; // Legal atama iÅŸlemi.
    *ptr3 = &y; // Bu atama iÅŸleminde sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.
    **ptr3 = 98; // Legal atama iÅŸlemi.


    int const ** ptr4 = &p1;

    ptr4 = &p2; // Legal atama iÅŸlemi.
    *ptr4 = &y; // Legal atama iÅŸlemi.
    **ptr4 = 98; // Bu atama iÅŸleminde sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.

    const int** ptr5 = &p1;

    ptr5 = &p2; // Legal atama iÅŸlemi.
    *ptr5 = &y; // Legal atama iÅŸlemi.
    **ptr5 = 98; // Bu atama iÅŸleminde sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.

    const int* const * const ptr6 = &p1;

    ptr6 = &p2; // Bu atama iÅŸleminde sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.
    *ptr6 = &y; // Bu atama iÅŸleminde sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.
    **ptr6 = 98; // Bu atama iÅŸleminde sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.

    const int* const * const ptr7 = &p1;

    ptr7 = &p2; // Bu atama iÅŸleminde sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.
    *ptr7 = &y; // Bu atama iÅŸleminde sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.
    **ptr7 = 98; // Bu atama iÅŸleminde sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.

    int const * const * const ptr8 = &p1;

    ptr8 = &p2; // Bu atama iÅŸleminde sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.
    *ptr8 = &y; // Bu atama iÅŸleminde sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.
    **ptr8 = 98; // Bu atama iÅŸleminde sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "sort_name" adlÄ± fonksiyon elemanlarÄ± `char*` tÃ¼rÃ¼nden yazÄ±lar olan bir pointer dizisindeki elemanlarÄ± "booble-sort" algoritmasÄ±yla sÄ±ralamaktadÄ±r, buradaki deÄŸiÅŸken bildirimlerinde **const** olmasÄ± gereken deÄŸiÅŸkenlerin bildirimlerine dikkat edilerek bildirimler yapÄ±lmÄ±ÅŸtÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h> // YazÄ±larÄ± karÅŸÄ±laÅŸtÄ±rmak iÃ§in 'strcmp' fonksiyonunu kullanabilmek iÃ§in eklenen baÅŸlÄ±k dosyasÄ±.
#include "nutility.h"

void print_names(char* const * pa, size_t size)
{
    pa[i] = NULL; // Bu bildirim sÃ¶zdizim hatasÄ±dÄ±r(syntax error), 'pa' dizisi elemanlarÄ± yazÄ± olan bir dizi olduÄŸu iÃ§in bu atamaya izin verilmemesi gerektiÄŸinden 'pa' parametresinin bildirimi buna uygun yapÄ±lmÄ±ÅŸtÄ±r.

    for(size_t i = 0; i < size; ++i){
        printf("%s", pa[i]);
    }
    printf("\n\n");
}

void cswap(char** p1, char** p2)
{
    char* ptemp = *p1*;
    *p1 = *p2;
    *p2 = ptemp;
}

void sort_name(char** pa, size_t size)
{
    // 
    for(size_t i = 0; i < size - 1; ++i){
        for(size_t k = 0; k < size - 1; ++k){
            if(strcmp(p[k], p[k + i]) > 0){
                char* ptemp = p[k];
                p[k] = p[k + 1];
                p[k + 1] = ptemp;
            }
        }
    }
}

int main(void)
{
    const char* p[] = {  
        "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
        "hakki", "haldun", "halime", "haluk", "handan" "hande", "handesu", "hasan", "helin", "hikmet",
        "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
        "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata", // Burada iki yazÄ± arasÄ±nda olmasÄ± gereken ',' token'Ä± unutulmuÅŸtur.
    };

    print_names(p, asize(p));
    sort_name(p, asize(p));
    print_names(p, asize(p));
}
``` 



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**Bir fonksiyonun parametresi dizi olamaz.**" cÃ¼mlesinde belirtilen ifadenin doÄŸruluÄŸu incelenebilir, aÅŸaÄŸÄ±daki programÄ± derleyip Ã§alÄ±ÅŸtÄ±rarak inceleme yap.
```C
#include <stdio.h>
#include <string.h>
#include "nutility.h"

// AÅŸaÄŸÄ±daki fonksiyon bildirimlerinin hepsi aynÄ±dÄ±r, C dilince diziler 'array-decay' iÅŸlemine tabi olacaÄŸÄ± iÃ§in bir fonksiyonun parametresi dizi olamaz.
void foo1(int* p);
void foo2(int p[]);
void foo3(int p[10]);

void foo(int p[10])
{
    printf("sizeof(a) = %zu", sizeof(a)); // Burada 'sizeof(a)' deÄŸeri fonksiyonun 'int p[10]' olarak bildirilen parametresinin tÃ¼rÃ¼nÃ¼ pointer olduÄŸu iÃ§in programÄ±n derleneceÄŸi donanÄ±mÄ±n adres kapasitesine uygun deÄŸeri ekrana yazacaktÄ±r.
}

int main(void)
{
    int a[10]  = { 0 };

    printf("sizeof(a) = %zu", sizeof(a));

    foo(a);
}
```



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**Bir fonksiyonun parametresi dizi olamaz.**" cÃ¼mlesinde belirtilen ifadenin doÄŸruluÄŸu incelenebilir
```C
#include <stdio.h>
#include <string.h>
#include "nutility.h"

// AÅŸaÄŸÄ±daki fonksiyon bildirimlerinin ikise de aynÄ±dÄ±r.
void foo1(int** p);
void foo2(int* p[]);


void foo(int p[])
{
    printf("sizeof(a) = %zu", sizeof(a));
}

int main(void)
{
    int a[10]  = { 0 };

    printf("sizeof(a) = %zu", sizeof(a));

    foo(a);
}
```

>â”
> 
> Sorulan soru; 
> 
> Ä°ki boyutlu diziyi adresiyle fonk.'a gectigimde (mesela p[8][8]) debugger davranisindan bi farklilik goruyorum. Bazen fonksiyon icinde debugger'la diziye bakinca dizinin sadece ilk row'unu goruyorum. Ama Bunun anlami nedir?
> 
> Cevap;
> 
> Bu soruya cevap verilmeyecek Ã§Ã¼nkÃ¼ sorulan soru **multi-dimensional arrays** konusuyla ilgili ve bu konu pointerlar ile ilgili olan zor baÅŸlÄ±klarÄ±n en sonuncu konusu.



âš ï¸ Biz aynÄ± zamanda C++ dilini Ã¶ÄŸreniyoruz, C++ dilinin iÃ§erisinde C kursunda anlatÄ±lanlar anlatÄ±lmÄ±yor ve C++ kursuna gelenlerin en az %70 oranÄ±nda C dilini iyi bildiÄŸi kabul ediliyormuÅŸ ve C++ dilinin konularÄ± ona gÃ¶re anlatÄ±lÄ±yor.


## void Pointers 

### `void` Type

â—â—â— C ve C++ dillerinde `void` bir tÃ¼rdÃ¼r(void is a type) ama bir deÄŸeri olmayan tÃ¼rdÃ¼r.

â—â—â— `void` bir deÄŸiÅŸkenin tÃ¼rÃ¼ olamaz ama `void` bir ifadenin tÃ¼rÃ¼ olabilir. C++ dilinde daha Ã¶nemli bir yeri vardÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda deÄŸiÅŸken tÃ¼rÃ¼ bildirimi gereken yerlerde `void` kullanÄ±lamayacaÄŸÄ± incelenebilir.
```C
int main(void)
{
    void x; // Burada bir deÄŸiÅŸkenin tÃ¼rÃ¼ 'void' olamayacaÄŸÄ± iÃ§in sÃ¶zdizim hatasÄ±(syntax error) oluÅŸacaktÄ±r.
    void ary[10]; // Bir dizinin elemanlarÄ±nÄ±n tÃ¼rÃ¼ 'void' olamayacaÄŸÄ± iÃ§in sÃ¶zdizim hatasÄ±(syntax error) oluÅŸacaktÄ±r.
}
```



`void` ifadeler aÅŸaÄŸÄ±daki gibi iki ÅŸekilde oluÅŸturulabilir;
- `void` fonksiyonlara yapÄ±lan Ã§aÄŸrÄ± ifadelerinin tÃ¼rÃ¼ `void` tÃ¼rÃ¼dÃ¼r.
- TÃ¼r dÃ¶nÃ¼ÅŸtÃ¼rme operatÃ¶rÃ¼ ile `void` tÃ¼rden ifadeler oluÅŸturulabilir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda geri dÃ¶nÃ¼ÅŸ deÄŸeri olmayan(yani void olan) bir donksiyona yapÄ±lan Ã§aÄŸrÄ± ifadesinin tÃ¼rÃ¼nÃ¼n ne olacaÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include <string.h>
#include "nutility.h"

void foo(int); // void function

int main(void)
{
    foo(12321); // Bu statement'taki 'foo(12321)' ifadesinin tÃ¼rÃ¼ 'void' tÃ¼rÃ¼dÃ¼r.
}
```


ğŸ§  Neden bir ifadeyi `void` yapma ihtiyacÄ± hissederiz;
- ğŸ‘‡ AÅŸaÄŸÄ±daki programda `(void)` tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼nÃ¼n kullanÄ±ldÄ±ÄŸÄ± bir durum incelnebilir.
```C
#include <stdio.h>
#include <string.h>
#include "nutility.h"

void foo();

int main(void)
{
    for(int i = 0; i < 10; ++i){
        printf("%d ", i);
        (void)getchar(); // Standart input'tan tek bir karakter okunuyor ama bu fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸerini 'discard' edildiÄŸini vurgulamak iÃ§in '(void)' tÃ¼r dÃ¶nÃ¼ÅŸtÃ¼rme operatÃ¶rÃ¼ kullanÄ±lÄ±yor.
    }
}
```



`void` tÃ¼rÃ¼ bir tÃ¼r gerektiren hiÃ§ bir ifadede kullanÄ±lamaz. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda yukarÄ±daki cÃ¼mleyle ilgili kullanÄ±mlar incelenebilir.
```C
#include <stdio.h>
#include <string.h>
#include "nutility.h"

void foo(int);

int main(void)
{
    int x = foo(9); // Fonksiyondan dÃ¶enn deÄŸer 'void' ve bu deÄŸer 'int' tÃ¼rÃ¼ne ilk deÄŸer olarak verilmek istendiÄŸi iÃ§in sÃ¶zdizim hatasÄ±(syntax error).

    // AÅŸaÄŸÄ±daki if deyiminin kullanÄ±lmasÄ± sÃ¶zdizim hatasÄ±dÄ±r(syntax error).  
    if(foo(21)){

    }
}
```



â—â—â— Derleyicilerin bakÄ±ÅŸ aÃ§Ä±sÄ±ndan tÃ¼rler iki Ã¶beÄŸe ayrÄ±lmaktadÄ±r, bu Ã¶bekler aÅŸaÄŸÄ±daki gibidir(bu konu detaylÄ± olarak bir ay sonra iÅŸlenecekmiÅŸ);
1. **Complate Type(Eksik olmayan, TamamlanmÄ±ÅŸ tÃ¼r)**
2. **Incomplate Type(TamamlanmamÄ±ÅŸ, Eksik olan tÃ¼r)**

â—â—â— Dilin kuralÄ± ÅŸudur: "**Incomplate**" tÃ¼rlerden deÄŸiÅŸken tanÄ±mlanamaz yani tanÄ±mlanan bir deÄŸiÅŸkenin tÃ¼rÃ¼ "**Incomplate Type**" olamaz. </br>
â—â—â— `void` tÃ¼rÃ¼ **incomplate** bir tÃ¼rdÃ¼r ama tek **incomplate** tÃ¼r `void` tÃ¼rÃ¼ deÄŸildir, ileride bu konu detaylÄ± iÅŸlenecekmiÅŸ.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda C++ dilinde legal bir kullanÄ±m iÃ§eren `baz` fonksiyonu incelenebilir ama ne iÃ§in kullanÄ±ldÄ±ÄŸÄ±na deÄŸinilmedi, kÄ±saca bir deÄŸinildi.
```Cpp
#include <stdio.h>
#include <string.h>
#include "nutility.h"

// AÅŸaÄŸÄ±daki fonksiyon tanÄ±mÄ± hatalÄ±dÄ±r Ã§Ã¼nkÃ¼ geri dÃ¶nÃ¼ÅŸ deÄŸeri olmayan bir fonksiyondan deÄŸer dÃ¶ndÃ¼rÃ¼lmeye Ã§alÄ±ÅŸÄ±lÄ±yor, bu C ve C++ dilinde hatalÄ±dÄ±r.
void foo(void)
{
    return 1;
}

void bar(void);

void baz()
{
    return bar(); // C++'da legal, C'de illegal.
}
```



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programda `void` tÃ¼rÃ¼nÃ¼n fonksiyon bildirimlerinde iki farklÄ± kullanÄ±mÄ± incelenebilir. </br>
C dilinin ilk zamanlarÄ±nda `void` tÃ¼rÃ¼ yoktu bu nedenden dolayÄ± fonksiyon bildirimlerinde parametre olmadÄ±ÄŸÄ±nda boÅŸ bÄ±rakÄ±lÄ±yordu ve fonksiyon Ã§aÄŸrÄ±larÄ±nÄ±n doÄŸru yapÄ±lma sorumluluÄŸu programcÄ±ya bÄ±rakÄ±lÄ±yordu.
```C

// AÅŸaÄŸÄ±daki iki farklÄ± fonksiyon bildirimi aldÄ±ÄŸÄ± parametre ve geri dÃ¶nÃ¼ÅŸ deÄŸeri aÃ§Ä±sÄ±ndan C++ dili iÃ§in aynÄ± anlama gelirken C dili iÃ§in aynÄ± anlama gelmemektedir.
void foo(); // Buradaki bildirim C dilinde geriye doÄŸru uyumluluktan dolayÄ± 'foo' fonksiyonunun parametre deÄŸiÅŸkeni konusunda bilgi vermiyorum anlamÄ±na geliyor ve burada C dili iÃ§in 'implicit int(gizli int)' vardÄ±r.
void bar(void);

int main(void)
{
    foo(1, 3, 44); // Bu fonksiyon Ã§aÄŸrÄ±sÄ±nda C derleyicisi uyarÄ± vermez ama C++ derleyicisi uyarÄ± verir.

    bar(3, 5); // Burada C ve C++ diline derleyici uyarÄ± verecektir.
}
```


### void Pointer Type(`void*` TÃ¼rÃ¼) 

â—â—â—AÅŸaÄŸÄ±daki bilgiler Ã¶nemlidir;
- `void` tÃ¼rÃ¼ ile `void*` birbirinden faklÄ±dÄ±r, `void*` tÃ¼rÃ¼nden bir deÄŸiÅŸken tanÄ±mlanabilir, `void*` tÃ¼rÃ¼ bir **object pointer** tÃ¼rÃ¼dÃ¼r. </br>
- `void*` pointer tÃ¼rÃ¼ herhangi bir tÃ¼rden deÄŸiÅŸkenin adresini deÄŸer olarak alabilir, kÄ±saca ne tÃ¼r adres olursan ol gel diyor ğŸ˜Š.
- `void*` pointer `*` ve `&` operatÃ¶rlerinin operandÄ± olamaz. </br>
- `void*` pointer tÃ¼rÃ¼nden nesneler ile poiner aritmetiÄŸi yapÄ±lamaz. </br>
- `sizeof` operatÃ¶rÃ¼nÃ¼n operandÄ± sadece **complate type** olabilir bu nedenle de `void` tÃ¼rÃ¼ `sizeof` operatÃ¶rÃ¼nÃ¼n operandÄ± olamaz.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda farklÄ± pointer tÃ¼rlerinin bildirimlerinin yapÄ±ldÄ±ÄŸÄ± gibi `void` tÃ¼rÃ¼nden de pointer deÄŸiÅŸken bildirimi yapÄ±labileceÄŸi gÃ¶rÃ¼lebilir.
```C
#include <stdio.h>

int main(void)
{
    void* vptr; // 'vptr' deÄŸiÅŸkeninin tÃ¼rÃ¼ 'void*' tÃ¼rÃ¼dÃ¼r.
    int* iptr; // 'iptr' deÄŸiÅŸkeninin tÃ¼rÃ¼ 'int*' tÃ¼rÃ¼dÃ¼r.
    double* dptr; // 'dptr' deÄŸiÅŸkeninin tÃ¼rÃ¼ 'double*' tÃ¼rÃ¼dÃ¼r.
}
```


â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programda `sizeof` operatÃ¶rÃ¼nÃ¼n operandÄ±nÄ±n `void` tÃ¼rÃ¼ olamayacaÄŸÄ± esasen `sizeof` operatÃ¶rÃ¼nÃ¼n operandÄ±nÄ±n herhangi bir **incomplate type(tamamlanmamÄ±ÅŸ, eksik olan tÃ¼r)** olamaz ve farklÄ± pointer tÃ¼rlerinin byte deÄŸerlerinin ne olduÄŸu incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    //size_t sz1 = sizeof(void); // Burada sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.

    printf("sizeof(int*) = %zu\n", sizeof(int*));
    printf("sizeof(double*) = %zu\n", sizeof(double*));
    printf("sizeof(double****) = %zu\n", sizeof(double****));
    printf("sizeof(void*) = %zu\n", sizeof(void*));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir pointer deÄŸiÅŸkenin kendi gÃ¶stermesi gereken tÃ¼r dÄ±ÅŸÄ±nda bir tÃ¼rÃ¼n adres deÄŸerini almasÄ±nÄ±n yanlÄ±ÅŸ olduÄŸu durum incelenebilir. 
```C
#include <stdio.h>

int main(void)
{
    int x = 10;
    double* p = &x; // C++ dilinde sÃ¶zdizim hatasÄ±dÄ±r(syntax error), C dilinde derleyiciler uyarÄ± bildirimi yaparlar.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `void*` tÃ¼rÃ¼nÃ¼n farklÄ± deÄŸerleri alabileceÄŸi incelenebilir.
```C
#include <stdio.h>

// AÅŸaÄŸÄ±daki 'func' fonksiyonu herhangi bir tÃ¼rden bir deÄŸiÅŸken alabilir, bu gibi deÄŸiÅŸkenlere 'generic function' denilmektedir.
void func(void*);

int main(void)
{
    int x = 10;
    double d = 3.4; 
    char str[] = "eren";

    void* vptr;

    // `void*` tÃ¼rÃ¼nden bir deÄŸiÅŸken her tÃ¼rlÃ¼ adres deÄŸerini tutabilir.
    vptr = &x;
    vptr = &d;
    vptr = str;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan `void*` tÃ¼rÃ¼nden nesnelerin `*` ve `&` operatÃ¶rlerinin operandÄ± olamaz, `void*` tÃ¼rÃ¼nden nesneler ile poiner aritmetiÄŸi yapÄ±lamaz kurallarÄ± incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 10;
    double d = 3.4;

    void* vp = &x;

    *vp; // Burada sÃ¶zdizim hatasÄ±(syntax error) vardÄ±r.
    vp + 3; // Burada sÃ¶zdizim hatasÄ±(syntax error) vardÄ±r.


    int ary[10] = { 0 };
    void* vp1 = a + 8;
    void* vp2 = a + 3;

    vp1 - vp2; // Buradaki pointer aritmetiÄŸi iÅŸlemi sÃ¶zdizim hatasÄ±dÄ±r(syntax error) Ã§Ã¼nkÃ¼ 'void*' tÃ¼rden deÄŸiÅŸkenlerle pointer aritmetiÄŸi yapÄ±lamaz.
}
```



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programda `void*` tÃ¼rÃ¼nÃ¼n adres tÃ¼rÃ¼ tuttuÄŸu incelenebilir ama `void*` tÃ¼rÃ¼nden deÄŸiÅŸkenler ne tuttuklarÄ±nÄ± bilmez, tutulan tÃ¼rÃ¼ anca programÄ± yazan **_bilinÃ§li bir varlÄ±k_** bilebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 23;
    void* vptr = &x;
    
    printf("&x = &p\n", &x);
    printf("vptr = &p\n", vptr);
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.13-12.24 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***



â—â—â— `void*` tÃ¼rÃ¼yle ilgili C ve C++ dillerindeki ortak ve farklÄ± kurallar iyi bilinmelidir;
- C ve C++ dillerinde herhangi bir adres tÃ¼rÃ¼ `void*` tÃ¼rÃ¼ne Ã¶rtÃ¼lÃ¼ olarak dÃ¶nÃ¼ÅŸebilir yani konunun baÅŸÄ±nda belirtildiÄŸi gibi `void*` tÃ¼rden bir deÄŸiÅŸkene herhengi bir tÃ¼rden nesnenin adresi aÃ§Ä±k ÅŸekilde tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapmadan atanabilir.
- `void*` tÃ¼rÃ¼nden herhangi bir adres tÃ¼rÃ¼ne Ã¶rtÃ¼lÃ¼ tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ C dilinde vardÄ±r ama C++ dilinde yoktur, yapÄ±ldÄ±ÄŸÄ±nda **sÃ¶zdizim hatasÄ±dÄ±r(syntax error)**.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `void*` tÃ¼rÃ¼nden herhangi bir adres tÃ¼rÃ¼ne Ã¶rtÃ¼lÃ¼ tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼nÃ¼n C ve C++ dillerinde nasÄ±l olduÄŸu incelenebilir.
```C
#include <stdio.h>

// AÅŸaÄŸÄ±daki 'foo' fonksiyonu dÄ±ÅŸarÄ±dan gelecek 'vptr' parametresinin tÃ¼rÃ¼ bilmez, bu tÃ¼rÃ¼ sadece bu fonksiyona Ã§aÄŸrÄ± yapan bilebilir. (!bu bilgi Ã¶nemli!)
void foo(void* vptr)
{
    // Some code here.
}

int main(void)
{
    int x = 10;
    void* vptr = &x;

    int* iptr = vptr; // Bu atama iÅŸlemi C dilinde legal'dir ve kullanÄ±lmaktadÄ±r ama C++ dilinde legal deÄŸildir(legal olmasÄ± iÃ§in tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapÄ±lmasÄ± gerekir).

    printf("%d\n", *iptr);
}
```


>â”
> 
> Sorulan soru; 
> 
> Pointer kullanan bir fonksiyona void* ptr ile arguman gondersek, fonksiyon icinde turunu bilmeden mesela icerde int* turune cast edip uzerinde islem yapmak mantikli mi?
> 
> Cevap;
> 
> HayÄ±r, bununla ilgili bilgiler ÅŸimdi gÃ¶rÃ¼lecek



ğŸ“Œ Åu ana kadar `void*` tÃ¼rÃ¼ne ait **sÃ¶zdizimi(syntax)** anlatÄ±ldÄ±, ne iÅŸe yarÄ±yor sorusunun cevabÄ±na ÅŸimdi cevap verilmeye baÅŸlanacak, bundan sonrasÄ± Ã§ok daha Ã¶nemli!

â—â—â— C dilinde bir pointer tÃ¼rÃ¼nden baÅŸka bir pointer tÃ¼rÃ¼ne Ã¶rtÃ¼lÃ¼ olarak tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapmak(mesela `int*` tÃ¼rÃ¼nden `double*` tÃ¼rÃ¼ne atama yapmak) yanlÄ±ÅŸ bir iÅŸlemdir ama C dilinde bu tÃ¼r bir iÅŸlem legaldir(sÃ¶zdizim hatasÄ±na neden olmaz) ama yapÄ±lmamalÄ±dÄ±r.


### Generic Functions 

**Generic programlama paradigmasÄ±** programlama dillerinin geneli iÃ§in bir terimdir, C++ dilinin en gÃ¼Ã§lÃ¼ olduÄŸu alan **generic programlama** denilebilir.

C++ dilinin **sÃ¶zdiziminin(syntax)** yarÄ±dan fazlasÄ± **Generic programlama** yaklaÅŸÄ±mÄ±yla ilgilidir.

**Generic programlama paradigmasÄ±** tÃ¼rden baÄŸÄ±msÄ±z olarak kodlama yapayÄ± ifade eder ve her programlama dilinin bir ya da daha fazla **generic programlama** yÃ¶ntemi olabilir. 

Ã–yle bir fonksiyon ki birden fazla farklÄ± tÃ¼r iÃ§in kullanÄ±labiliyor, iÅŸte bÃ¶yle fonksiyonlara **Generic Function** deniliyor.

TÃ¼rden baÄŸÄ±msÄ±z fonksiyon yazmak farklÄ± farklÄ± araÃ§larla yapÄ±labilir, kursun ilerleyen saatlerinde bunun iÃ§in C dilinde nasÄ±l araÃ§lar var anlatÄ±lacaktÄ±r. 

â—â—â— `void*` tÃ¼rÃ¼ genellikle **generic function** larda kullanÄ±lan bir tÃ¼rdÃ¼r, bir fonksiyonun birden fazla tÃ¼re hizmet vermesi isteniyorsa(birden fazla farklÄ± tÃ¼rden argÃ¼manlarla Ã§aÄŸÄ±rÄ±labilmesi isteniyorsa) o fonksiyonun bir ya da daha fazla argÃ¼manÄ± `void*` tÃ¼rÃ¼nden olmalÄ±dÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda tÃ¼rden baÄŸÄ±msÄ±z olarak kendisine gÃ¶nderilen aynÄ± tÃ¼rden iki tÃ¼rÃ¼ takas edecek `gswap` fonksiyonunun nasÄ±l yazÄ±ldÄ±ÄŸÄ± incelenebilir, bu takas iÅŸlemini yapacak olan fonksiyon iki tane taks edilecek `void*` tÃ¼rÃ¼nden parametre almalÄ± ve takas edilecek tÃ¼rÃ¼n byte boyutu bilgisini almalÄ± ve bu bilgileri kullanarak tÃ¼rÃ¼ bilinmeyen bu nesnelerin deÄŸerleri byte byte takes edilerek takas iÅŸlemi yapÄ±labilir.
```C
#include <stdio.h>
#include "nutility.h"

// 'gswap' adÄ± 'Generic Swap' sÃ¶zcÃ¼klerinden gelmektedir.
// AÅŸaÄŸÄ±daki 'gswap' fonksiyonu herhangi bir tÃ¼r iÃ§in takas iÅŸlemi yapmaktadÄ±r.
// 'gswap' fonksiyonu ile sadece aynÄ± tÃ¼rden nesneler takas edilmelidir.
// vp1  : Takas edilecek ilk nesnenin adresi.
// vp2  : Takas edilecek ikinci nesnenin adresi.
// sz   : KaÃ§ byte alan takas edileceÄŸi bilgisi.
void gswap(void* vp1, void* vp2, size_t sz)
{
    char* p1 = (char*)vp1; // '(char*)' tÃ¼r dÃ¶nÃ¼ÅŸtÃ¼rme operatÃ¶rÃ¼ ile yapÄ±lan tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ iÅŸlermi hem kodu okuyana hem de derleyiciye aÃ§Ä±k ÅŸekilde bildirilmiÅŸ olacaktÄ±r.
    char* p2 = (char*)vp2;

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼nÃ¼n koÅŸul ifadesinde idiomatik yapÄ± kullanÄ±lmÄ±ÅŸtÄ±r ama dÃ¶ngÃ¼ gÃ¶vdesinde idiomatik yapÄ±lar kullanÄ±lmamÄ±ÅŸtÄ±r.
    //while(sz--){
    //    char temp = *p1;
    //    *p1 = *p2;
    //    *p2 = temp;
    //    ++p1;
    //    ++p2;
    //}

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼nÃ¼n koÅŸul ifadesinde ve gÃ¶vdesinde idiomatik yapÄ±lar kullanÄ±lmÄ±ÅŸtÄ±r.
    while(sz--){
        char temp = *p1;
        *p1++ = *p2;
        *p2++ = temp;
    }
}

int main(void)
{
    int x = 3423, y = 5532;

    printf("x = %d, y = %d", x, y);
    gswap(&x, &y, sizeof x);
    printf("x = %d, y = %d", x, y);

    double d1 = 43.543543;
    double d2 = 13.543543;

    printf("d1 = %f, d2 = %f", d1, d2);
    gswap(&d1, &d2, sizeof d1);
    printf("d1 = %f, d2 = %f", d1, d2);

    int ary1[] = { 1, 3, 5, 7, 9, };
    int ary2[] = { 9, 3, 2, 6, 8, };

    print_array(ary1, 5);
    print_array(ary2, 5);
    gswap(&ary1, &ary2, sizeof ary2);
    print_array(ary2, 5);
}
```



Generic takas iÅŸlemini yapan `gswap` fonksiyonunu "nutility.h" dosyasÄ±na alÄ±nmasÄ± iÅŸlemi;

âœï¸ "nutility" dosyalarÄ±na `gswap` fonksiyonu dahil edildi, bu `gswap` fonksiyonunu ileride sÄ±kÃ§a kullanacaÄŸÄ±z.
```C
// 'nutility.h' dosyasÄ±na aÅŸaÄŸÄ±daki 'fuction decleration' eklenmiÅŸtir.

void gswap(void* vp1, void* vp2, size_t sz);

```


```C
// 'nutility.c' dosyasÄ±na aÅŸaÄŸÄ±daki 'fuction defination' eklenmiÅŸtir.

// 'gswap' adÄ± 'Generic Swap' sÃ¶zcÃ¼klerinden gelmektedir.
// AÅŸaÄŸÄ±daki 'gswap' fonksiyonu herhangi bir tÃ¼r iÃ§in takas iÅŸlemi yapmaktadÄ±r.
// 'gswap' fonksiyonu ile sadece aynÄ± tÃ¼rden nesneler takas edilmelidir.
// vp1  : Takas edilecek ilk nesnenin adresi.
// vp2  : Takas edilecek ikinci nesnenin adresi.
// sz   : KaÃ§ byte alan takas edileceÄŸi bilgisi.
void gswap(void* vp1, void* vp2, size_t sz)
{
    char* p1 = (char*)vp1; // '(char*)' tÃ¼r dÃ¶nÃ¼ÅŸtÃ¼rme operatÃ¶rÃ¼ ile yapÄ±lan tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ iÅŸlermi hem kodu okuyana hem de derleyiciye aÃ§Ä±k ÅŸekilde bildirilmiÅŸ olacaktÄ±r.
    char* p2 = (char*)vp2;

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼nÃ¼n koÅŸul ifadesinde idiomatik yapÄ± kullanÄ±lmÄ±ÅŸtÄ±r ama dÃ¶ngÃ¼ gÃ¶vdesinde idiomatik yapÄ±lar kullanÄ±lmamÄ±ÅŸtÄ±r.
    //while(sz--){
    //    char temp = *p1;
    //    *p1 = *p2;
    //    *p2 = temp;
    //    ++p1;
    //    ++p2;
    //}

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼nÃ¼n koÅŸul ifadesinde ve gÃ¶vdesinde idiomatik yapÄ±lar kullanÄ±lmÄ±ÅŸtÄ±r.
    while(sz--){
        char temp = *p1;
        *p1++ = *p2;
        *p2++ = temp;
    }
}
```



YukarÄ±da yazÄ±lmÄ±ÅŸ olan `gswap` fonksiyonuyla ilgili bazÄ± sorularÄ±n ve cevaplarÄ±nÄ±n ne olduÄŸunu inceleyelim;
1. `gswap` fonksiyonunun takas edilecek nesneleri tutan parametrelerinin tÃ¼rÃ¼ `char*` olamaz mÄ±ydÄ±?
    - `gswap` fonksiyonunun bildirimi `void gswap(char* vp1, char* vp2, size_t sz)` olsaydÄ±, bu fonksiyonun bildirimine bakÄ±ldÄ±ÄŸÄ±nda bu fonksiyonun **generic function** olduÄŸu anlaÅŸÄ±lmazdÄ±.
    - `gswap` fonksiyonunun bildirimi `void gswap(char* vp1, char* vp2, size_t sz)` olsaydÄ±, bu fonksiyona `char*` tÃ¼rÃ¼ dÄ±ÅŸÄ±ndaki tÃ¼rler ile Ã§aÄŸrÄ± yapÄ±lacaÄŸÄ± zaman fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±lan yerde tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapÄ±lmasÄ± gerekecekti.
2. `gswap` fonksiyonunun takas eteceÄŸi kendisine parametre olarak gelecek olan nesnelerin takas edilmesi iÅŸlemi `char*` tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸÃ¼m yapÄ±lmadan yapÄ±labilir mi?
    - HayÄ±r yapÄ±lamaz Ã§Ã¼nkÃ¼ `vp1` ve `vp2` parametre deÄŸiÅŸkenlerinin tÃ¼rÃ¼ belli olmalÄ±ÄŸÄ± iÃ§in bu pointer deÄŸiÅŸkenlerin gÃ¶sterdiÄŸi nesnelere eriÅŸilemez.



â—â—â— C standardÄ± ÅŸunu aÃ§Ä±kÃ§a belirtiyor, herhangi bir adres tÃ¼rÃ¼nden `char*` tÃ¼rÃ¼ne tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapÄ±labilir, bu iÅŸlem bir istisnadÄ±r zaten bu istisna Ã¼zerine C dilinde "**Generic Programing**" yaklaÅŸÄ±mÄ± inÅŸa ediliyor.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda farklÄ± tÃ¼rlerden `char*` tÃ¼rÃ¼ne tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapÄ±lÄ±p, bu pointer Ã¼zerinden nasÄ±l o nesnenin deÄŸerinin deÄŸiÅŸtirilebildiÄŸi incelenebilir ve bu iÅŸlem hem legal hem de mantÄ±ken doÄŸru kullanÄ±mÄ± olan bir yaklaÅŸÄ±mdÄ±r.
```C
#include <stdio.h>

int main(void)
{
    int x = 1212414;
    char* p = (char*)&x; // Buradaki tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ legaldir ve burada bir 'ub' yoktur, 

    for(size_t i = 0; i < sizeof(int); ++i){
        p[i] = 0;
    }

    printf("x = %d\n", x);


    double y = 21421.56435;
    p = (char*)&y; // Buradaki tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ legaldir ve burada bir 'ub' yoktur, 

    for(size_t i = 0; i < sizeof(double); ++i){
        p[i] = 0;
    }

    printf("y = %d\n", y);
}
```

âš ï¸ Bir sonraki dersin Ã¶nemli bir kÄ±smÄ±nda "**void Pointers**" konusu devam edecek ondan sonra da **Function Pointers** konusuna geÃ§ilecek.


Ders sonu ...
