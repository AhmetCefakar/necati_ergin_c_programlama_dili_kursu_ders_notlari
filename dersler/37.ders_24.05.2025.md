# 37.Ders 24.05.2025 🕘

Derse 12(09:01)-13(09:04)-14(09:08)-15(09:16)-16(09:20)-14(09:38)-15(09:47)-16(10:08)-17(10:52)-17(11:39)-18(11:48)-18(12:00)-17(12:30) kişi katıldı.
---


## Function Pointers

C ve C++ gibi programlama dillerinin en güçlü araçlarından biri bir fonksiyona bir fonksiyonun gönderilebiliyor olmasıdır. </br>
Bu mekanizmaya "**Callback**" deniyor ve bir fonksiyonun başka bir fonksiyona gönderdiği fonksiyonlara "**Callback Function**" deniliyor. </br>
Pointer'lar **object pointers** ve **function pointers** olarak ikiye ayrılıyor.

C dilinin en önemli araçlarından biri fonksiyonların adresleri ile yapılabilen işlemlerdir, fonksiyonların adresleri **function pointer** türünden değişkenlerde tutulabiliyor.

Fonksiyon adresleri nasıl bir ifade, farklı parametrik yapıdaki fonksiyonların adresleri farklı türdendir.
- `int foo(int, int);` fonksiyonunun türü `int (int, int)` ve adresinin türü `int (*)(int, int)`.
- `int bar(double, int, long);` fonksiyonunun türü `int (double, int, long)` ve adresinin türü `int (*)(double, int, long)`.


👇 Aşağıdaki programda bir **function pointer** türünden değişken nasıl bildirilir ve kullanılır incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

int foo(int, int);
int bar(int, int);
int baz(int, int);

int main(void)
{
    int (*fp)(int, int) = &foo; // 'fp' adındaki 'int (*)(int, int)' türündeki bir 'function pointer' değişkene 'foo' fonksiyonunun adresiyle ilk değer veriliyor.

    fp = &bar;

    fp = &baz;
}
```



👇 Aşağıdaki programda **array to pointer conversion** işleminin nasıl olduğu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

int foo(int, int);
int bar(int, int);
int baz(int, int);

int main(void)
{
    int ar[10] = { 0 };

    int* ptr = ar; // Burada 'ar' dizisi 'array to pointer conversion' ile dizinin ilk elemanının adresine dönüşüm yapılır(yani derleyici 'ar' ifadesini '&ar[0]' ifadesine çeviriyor).
    // int* ptr = &ar[0]; // Buradaki statement ile yukarıdaki statement denktir.
}
```



**Function to Pointer Conversion(Fonksiyondan Fonksiyon Adresine Dönüşüm)**:  Bir ifade içinde fonksiyon adı kullanılırsa fonksiyon adı örtülü olarak fonksiyonun adresi türüne dönüştürülür.



👇 Aşağıdaki programda **function to pointer conversion** işleminin nasıl olduğu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

int foo(int, int);
int bar(int, int);
int baz(int, int);

int main(void)
{
    // Aşağıdaki iki fonksiyon göstericisi değişkenin ilk değer verme sözdizimi(syntax) birbirine denktir.
    int (*fp)(int) = &foo;
    //int (*fp)(int) = foo;

    // Aşağıdaki iki atama işlemi de birbirine denktir.
    fp = &bar;
    fp = bar;

    // Aşağıdaki iki atama işlemi de birbirine denktir
    fp = &baz;
    fp = baz;
}
```


>❔
> 
> Sorulan soru; 
> 
> Bir degiskenin adresinde degisken tipine gore 1 byte, 4 byte, 8 byte degeri bulunuyordu. Bir fonk. adresinde ne boyutta ne tutuluyor?
> 
> Cevap;
> 
> **Object pointers** değişkenler çalışacakları donanım mimarisine göre hangi türden değişkenin ares değerini tutuyor olursa olsun hep aynı byte değerine sahiptir, 32 bit'lik donanımlarda 4-byte ve 64 bit'lik donanımlarda 8-byte.
>
> Fakat **funciton pointers** değişkenler ile **object pointers** değişkenler aynı byte'lık alan kaplamak zorunda değildir. **Object pointers** değişkenler 4-byte iken **funciton pointers** değişkenler 8-byte yer kaplayabilir. 



👇 Aşağıdaki programda bir **funciton pointers** değişkenin bellekte kapladığı alanın nasıl öğrenildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

int foo(int, int);
int bar(int, int);
int baz(int, int);

int main(void)
{
    printf("sizeof(&foo) = %zu\n", sizeof(&foo));
}
```


>❔
> 
> Sorulan soru; 
> 
> Fonksiyonun geri dönüş değeri ya da parametre değişkenleri değiştirildiğinde de yine **funciton pointer** boyutu aynı kalır mı?
> 
> Cevap;
> 
> Evet ayını kalır, **funciton pointer** değişkenlerin kapladığı byte alanı, fonksiyonun geri dönüş değeri ya da kaç tane parametresinin olduğuyla ilgili değildir. Yani hangi fonksiyon olursa olsun o fonksiyonun adresi aynı büyüklükte byte alanında tutulacaktır.



❗❗❗ Bir dil ne kadar düşük seviyeli olursa olsun en nihayetinde bir soyutlamadır ve o programlama dilini kullanan programcıyı belirli seviyelerde donanımdan soyutlar. 
- **Function pointer** değişkenleri ya da **fonksiyon adresleri** şöyle düşünülmelidir: Fonksiyonların derlenmiş kodu çalışma zamanında bir yer kaplamaktadır yani bir fonksiyonun derlenmiş kodu demek o fonksiyon çağırıldığında yürütülecek makine komutları demektir. 
- Bir fonksiyonun programın çalışma zamanında çağırılması için fonksiyonun makine komutlarının bellekte bir yere yüklenmesi gerekiyor, işte fonksiyonun adresi o fonksiyon çağırıldığında çalıştırılacak olan makine komutlarını içeren bellek adresidir.


### Fonksiyon Çağrı Operatörü(Function Call Operator) 

Fonksiyon Çağrı Operatörünün operandı bir fonksiyonun fonksiyon adresidir. </br>
Fonksiyon Çağrı Operatörünün operandı bir fonksiyon adı olmak zorunda değildir.

❗ Fonksiyon Çağrısı bir operatör marifetiyle yapılıyor, bir fonksiyon adı fonksiyon çağrı operatörünün(`()` operatörü) operandı yapıldığında derleyici programın akışını o fonksiyonun kodunun çalıştırmasına yönlendiren bir kod oluşturuyor, fonksiyon çağrıları bu şekilde yapılıyor. Gerçekte fonksiyon çağrı operatörünün operandı bir fonksiyon adresidir, `FONKSİYON_ADI()` ya da `FONKSİYON_ADRESİ()` şeklinde yapılan bir fonksiyon çağrıları aynı anlama geliyor. Fonksiyon çağrı operatörünün operandının bir fonksiyon adı olması gerekmiyor, fonksiyon adresi olan herhengi bir ifade olabilir. O zaman bir **function pointer** değişkenin değeri bir fonksiyon adresi olduğuna göre fonksiyon çağrı operatörünün operandı bir **function pointer variable** da olabilir.



👇 Aşağıdaki programda kursun başından beri kullanılan fonksiyon çağırma sözdizimi(syntax) incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int foo(int x)
{
    printf("foo(int x) called x = %d\n", x);

    return x * x;
}

int main(void)
{
    int i = foo(3); // Kursun başından beri bir fonksiyonu çağırmak için kullanılan yöntem bu şekildeydi.

    printf("i = %d\n", x);
}
```



👇 Aşağıdaki programda bir **function pointer** üzerinden nasıl fonksiyon çağrısı yapıldığı görülebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int foo(int x)
{
    printf("foo(int x) called x = %d\n", x);

    return x * x;
}

int main(void)
{
    int (*fp)(int) = &foo;

    int x = fp(5); // Burada 'fp' adındaki 'function pointer' üzerinden nasıl fonksiyon çağrısı yapılacağı görülebilir.

    printf("x = %d\n", x);
}
```



👇 Aşağıdaki programda fonksiyon adreslerinin türü aynı olan(bu programda adres türleri `void (*)(void)` olan fonksiyonlar) fonksiyonların tek bir **function pointer** değişken üzerinden nasıl çağırılabildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

void foo1(void)
{
    printf("foo1 called!\n");
}

void foo2(void)
{
    printf("foo2 called!\n");
}

void foo3(void)
{
    printf("foo3 called!\n");
}

void foo4(void)
{
    printf("foo4 called!\n");
}


int main(void)
{
    void (*fp)(void) = &foo1;

    fp(); // Burada 'foo1' fonksiyonu çağırılacaktır.

    fp = &foo2;
    fp(); // Burada 'foo2' fonksiyonu çağırılacaktır.


    fp = &foo3;
    fp(); // Burada 'foo3' fonksiyonu çağırılacaktır.


    fp = &foo4;
    fp(); // Burada 'foo4' fonksiyonu çağırılacaktır.
}
```

>❔
> 
> Sorulan soru; 
> 
> fp' yi tanimlarken void (*fp) pointer kullanmaniz bu fonksiyonlarin geri donus degerlerinin void olmasindan dolayi mi, yoksa bu bir generic void* pointer mi?
> 
> 



👇 Aşağıdaki programda bir fonksiyonun davranışının o fonksiyona çağrı yapan kodun nasıl belirleyebileceği incelenebilir. `foo` fonksiyonu dışarıdan fonksiyon adresi alıyor ve bu da `foo` fonksiyonuna çağrı yapan kodun gönderdiği fonksiyon adresine göre `foo` fonksiyonuna farklı işlemler yaptırabileceği anlamına geliyor.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

void foo1(void)
{
    printf("foo1 called!\n");
}

void foo2(void)
{
    printf("foo2 called!\n");
}

void foo3(void)
{
    printf("foo3 called!\n");
}

void foo4(void)
{
    printf("foo4 called!\n");
}

// Aşağıdaki 'foo' adlı fonksiyon parametre olarak bir fonksiyonun adresi alıyor.
void foo(void (*fp)(void))
{
    printf("foo called!\n");
    printf("foo is calling a function that is sent\n");
    fp(); // 'fp' fonksiyon adresi değeri üzerinden fonksiyon çağrısı yapılıyor.
    // some code here...
}

int main(void)
{
    foo(&foo1);
    printf("\n");

    foo(&foo2);
    printf("\n");

    foo(&foo3);
    printf("\n");

    foo(&foo4);
    printf("\n");
}
```



👇 Aşağıdaki programda **function pointer** değişkenlerin en temel olarak kullanıldığı yöntem incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>

int func(int c)
{
    for(int i = 0; i < 128; ++i){
        if(isupper(i)){
            printf("%c", i);
        }
    }
    primtf("\n");

    for(int i = 0; i < 128; ++i){
        if(islower(i)){
            printf("%c", i);
        }
    }
    primtf("\n");

    for(int i = 0; i < 128; ++i){
        if(isdigit(i)){
            printf("%c", i);
        }
    }
    primtf("\n");

    printf("~~~~~~~~~~~~~~~~~\n");
}

// Aşağıdaki 'print_chars' fonksiyonu dışarıdan 'int (*)(int)' türünden fonksiyon adresi almaktadır ve ardından ASCII karakterlerinden gönderilen adresteki test fonksiyonuna göre mantıksal true değer dönen karakterleri standar çıktı akımına göndermektedir.
void print_chars(int (*fp)(int)){
    for(int i = 0; i < 128; ++i){
        if(fp(i)){
            printf("%c", i);
        }
    }
    primtf("\n");
}

int main(void)
{
    print_chars(&isupper);
    print_chars(&islower);
    print_chars(&isdigit);
    print_chars(&isalnum);
    print_chars(&ispunct);
}
```



👇 Aşağıdaki programda fonksiyon adresi alan bir fonksiyonun en sık kullanıldığı senaryo incelenebilir, bu kullanım gerek gömülü sistem programlama alanında gerek sistem programlama alanında gerekse de uygulama programları geliştirmede sıkça kullanılmaktadır.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>

void print_chars(const char* p, int (*fp)(int)){

    printf("%s\n", p);
    for(int i = 0; i < 128 ; ++i){
        if(fp(i)){
            printf("%c", i);
        }
    }
    primtf("\n");
}

int main(void)
{
    print_chars("isupper ", &isupper);
    print_chars("islower ", &islower);
    print_chars("isdigit ", &isdigit);
    print_chars("isalnum ", &isalnum);
    print_chars("ispunct ", &ispunct);
}
```

Generik programlama yaparken en sık kullanılan yöntemlerde biri **function pointer** kullanılmasıdır, **function pointer** kullanımı ile bir fonksiyonun çağırdığı fonksiyon(lar) aynı fonksiyonun çağrılarında farklı yapılabilir.


>❔
> 
> Sorulan soru; 
> 
> switch statement int param aliyordu fonk adresi de alabiliyor mu hocam?
> 
> Cevap;
> 
> Soru yanluş sorulmuş, switch statement **parameter** almaz bir fonksiyon **parameter** alır, switch statement **expression(ifade)** alır, bir switch statement'ın alacağı ifade **function pointer** olamaz.



👇 Aşağıdaki programda bir fonksiyonun hangi bicimlerde çağrılabileceği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>

void foo(void)
{
    printf("foo() function called!\n");
}

int main(void)
{
    // Bir fonksiyon aşağıdaki gibi farklı şekillerde çağrılabilir;
    foo(); // 'foo' fonksiyonuna çağrı yapılıyor.
    (&foo)(); // 'foo' fonksiyonuna çağrı yapılıyor. Burada '&foo' ifadesinin öncelik parantezine alınmasının nedeni fonksiyon çağrı operatörünün önceliğinin adres operatöründen('&' operatörü) yüksek olmasıdır.
    (*foo)(); // 

    void(*fptr)(void) = &foo;
    fptr(); // 'foo' fonksiyonuna çağrı yapılıyor.
    (*fptr)(); // 'foo' fonksiyonuna çağrı yapılıyor. Burada '*fptr' ifadesinin öncelik parantezine alınmasının nedeni fonksiyon çağrı operatörünün önceliğinin dereferencing operatöründen('*' operatörü) yüksek olmasıdır.
}
```



👇 Aşağıdaki programda bir fonksiyonun adresi(yani **function pointer**) 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>

void foo(void)
{
    printf("foo() function called!\n");
}

int main(void)
{
    void(*fptr)(void) = &foo;
    fptr();
    (*foo)(); // Bu şekilde fonksiyon çağrısı yapılıyorsa programcının doğrudan fonkisyon adı üzerinden değil de bir fonksiyonun pointer'ı üzerinden fonksiyon çağrısının yapıldğı vurgulanmış olur.
    (&foo)();
}
```


"(*foo)();" ve "(&foo)();" 



👇 Aşağıdaki programda bir fonkisyonun çağrısının **function pointer** üzerinden yapıldığını vurgulamak için nasıl fonksiyon çağrısı yapılabileceği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>

void foo(int (*fp)(int))
{
    int x = fp(4); // 'Function pointer' adı üzerinden fonksiyon çağrısının nasıl yapılabileceği incelenebilir.
    int y = (*fp)(4); // Burada fonksiyon göstericisi üzerinden fonksiyon çağrısının yapıldığı vurgulanmaktadır.
}

int main(void)
{

}
```


>❔
> 
> Sorulan soru; 
> 
> Degiskenlerin adreslerini fonksiyonlara gonderdigimizde degerlerine erisip degistirebiliyorduk. fonk. pointer gonderdigimizde de fonk.un kullandigi degerlere ulasip degerlerini degistirebiliyor muyuz? 
> Bunun argumanlarina ulasabilir miyiz?
> 
> Cevap;
> 
> Bir **function pointer** nesne üzerinden ne o göstericide tutulan fonksiyonun değerlerine erişilebilir işlem yapılabilir ne de gösterilen fonksiyonun argümanlarına erişilip bir değişiklik yapılabilir. Sadece adresi bilinen bir fonksiyona çağrı yapılabilir.
>
> 👇 Aşağıdaki programda `foo` fonksiyonu dışarıdan alacağı `fp` parametresini sadece adresi gönderilen fonksiyona çağrı yapmak için kullanabilir, bu anlaşılmalıdır.
> ```C
> #define _CRT_SECURE_NO_WARNINGS
> 
> #include <stdio.h>
> #include <ctype.h>
> 
> void foo(int (*fp)(int))
> {
>     int x = fp(4);
>     int y = (*fp)(4);
> }
> 
> int main(void)
> {
>     int x = 19;
>     int* ptr = &x;
> 
>     *ptr = 2343423; // 'object pointer' değişkenlerin adresleri üzerinden o adresteki nesnelerin değerleri değiştirilebilir.
> }
> ```



👇 Aşağıdaki programda **function pointer**'larla ilgili karmaşık kullanımlar incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>
#include <stirng.h>

void foo(const char*, const char*);
void bar(const char*, const char*);
void baz(const char*, const char*);

void f1(int (*p1)(const char*, const char*)); // 'f1' fonksiyonu dışarıdan 'int (*)(const char*, const char*)' türünde tek bir parametre almaktadır.
void f2(int (*p1)(const char*, const char*), int (*p2)(const char*, const char*)); // 'f2' fonksiyonu dışarıdan 'int (*)(const char*, const char*)' türünde iki adet parametre almaktadır.

// C dilinin sözdiziminde(syntax) geriye 'int (*)(const char*, const char*)' türünden fonksiyon adresi döndüren 'f3' adında bir fonksiyon aşağıdaki gibi tanımlanmaktadır.
int (*f3(void)) (const char*, const char*)
{
    return &foo;
}

// C dilinin sözdiziminde(syntax) geriye 'int (*)(const char*, const char*)' türünden fonksiyon adresi döndüren ve 'int (*)(const char*, const char*)' bir parametre alan bir fonksiyon aşağıdaki gibi tanımlanmaktadır.
int (*f4(int (*fp)(const char*, const char*)))(const char*, const char*)
{
    return &fp;
}

int main(void)
{
    int (*fp)(const char*, const char*) = &strcmp; // Burada bildirilen ve ilk değer atanan 'fp' adlı fonksiyon pointer değişkeni 'int (*)(const char*, const char*)' türünden fonksiyonların adreslerini alabilir.
    int (**fptr)(const char*, const char*) = &fp; // Burada bildirilen ve ilk değer atanan 'fptr' adlı değişken bir 'object pointer'dır. 'fptr' göstericisi 'int (*)(const char*, const char*)' türünden bir fonksiyonun adresini tutmaktadır.

    // '*fptr' demek 'fp' demektir! 

    int (*ar[4])(const char*, const char*) = { &foo, &bar, &baz, &strcmp }; // Funciton pointer değerler tutan 'ar' adındaki 4 elemanlı dizi değişkeninin bildirilip ilk değer verilmesi işlemi.s
    //int (*ar[])(const char*, const char*) = { &foo, &bar, &baz, &strcmp }; // Funciton pointer tutan 'ar' adındaki 4 elemanlı dizi değişkeninin bildirilip ilk değer verilmesi işlemi.s
}
```



👇 Aşağıdaki programda `typedef` bildirimi ile karmaşık fonksiyon göstericisi değişkenlerin nasıl sade olarak yazılabildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>
#include <stirng.h>

typedef int(*Fcmp)(const char*, const char*); // Burada 'Fcmp' adında 'int (*)(const char*, const char*)' türünü temsil edecek bir 'tür eş ad' bildirimi yapılmıştır.

void foo(const char*, const char*);
void bar(const char*, const char*);
void baz(const char*, const char*);

//void f1(int (*p1)(const char*, const char*));
void f1(Fcmp p1);

//void f2(int (*p1)(const char*, const char*), int (*p2)(const char*, const char*));
void f2(Fcmp p1, Fcmp p2);

// int (*f3(void)) (const char*, const char*)
Fcmp f3()
{
    return &foo;
}

// int (*f4(int (*fp)(const char*, const char*)))(const char*, const char*)
Fcmp f4(Fcmp f)
{
    return &f;
}

int main(void)
{
    //int (*fp)(const char*, const char*) = &strcmp;
    Fcmp fp = &strcmp;
    
    //int (**fptr)(const char*, const char*) = &fp;
    Fcmp* fptr = &fp;

    //int (*ar[4])(const char*, const char*) = { &foo, &bar, &baz, &strcmp }; // Funciton pointer tutan 'ar' adındaki 4 elemanlı dizi.
    //int (*ar[])(const char*, const char*) = { &foo, &bar, &baz, &strcmp }; // Funciton pointer tutan 'ar' adındaki 4 elemanlı dizi.
    Fcmp 
}
```



👇 Aşağıdaki programda **booble sort** algoritmasıyla sıralama işlemi yapan `sort` adında bir fonksiyonun **gerçekleştiriminin(implementation)** nasıl yapıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>
#include "nutility.h"

// Aşağıdaki 'booble sort' algoritmasıyla sıralama işlemi yapan fonksiyonda sıralama kriteri sabittir. Kriteri dışarıdan fonksiyon olarak alan C dilinin standardında olan 'qsort' fonksiyonu vardır, biz de 'qsort' fonksiyonu gibi sıralama yöntemini dışarıdan alan sıralama fonksiyonu yazabiliriz.
void sort(int* p, int size)
{
    for(int i = 0; i < size - 1; ++i){
        for(int k = 0; k < size - 1 - i; ++k){
            if(p[k] > p[k + 1]){
                swap(p + k, p + k + 1);
            }
        }
    }
}

int main(void)
{
    
}
```



👇 Aşağıdaki programda C dilinin standardında olan $O(n) lon(n)$ algoritma karmaşıklığındaki generic `qsort` fonksiyonunun bir benzeri oaln $O(n^2)$ algoritma karmaşıklığındaki generic `gbsort` fonksiyonu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>
#include "nutility.h"

#define SIZE 100

// "Generic Booble Sort" fonksiyonu aşağıdaki gibidir.
// vpa      : Sıralama yapılacak dizinin adresi.
// size     : Dizinin eleman sayısı değeri.
// sz       : Dizinin tek bir elemanının kaç byte yer kapladığı bilgisi.
// fpcomp   : Sıralama kriteri işleminde çağrılacak fonksiyon pointer türünden değişken.
void gbsort(void* vpa, size_t size, size_t sz, int (*fpcomp)(const void *, const void *))
{
    char* pa = (char*)vpa;

    for(size_t i = 0; i < size - 1; ++i){
        for(size_t k = 0; k < size - 1 - i; ++k){
            if(fpcomp(pa + k * sz, pa + (k + 1) * sz) > 0){
                gswap(pa + k * sz, pa + (k + 1) * sz, sz);
            }
        }
    }
}

// "int compara" fonksiyonu aşağıdaki gibidir.
int icmp(const void* vp1, const void* vp2)
{
    if(*(const int*)vp1 > *(const int*)vp2){
        return 1;
    }
    else if(*(const int*)vp1 < *(const int*)vp2){
        return -1;
    }

    return 0;
}

// "double compara" fonksiyonu aşağıdaki gibidir.
int dcmp(const void* vp1, const void* vp2)
{
    if(*(const double*)vp1 > *(const double*)vp2){
        return 1;
    }
    else if(*(const double*)vp1 < *(const double*)vp2){
        return -1;
    }

    return 0;
}

int main(void)
{
    int a[SIZE];
    
    randomize();
    set_array_random(a, SIZE);
    print_array(a, SIZE);

    // Aşağıdaki üç 'gbsort' fonksiyon çağrısı aynı anlama gelmektedir.
    gbsort(a, SIZE, sizeof(int), &icmp);
    //gbsort(a, SIZE, sizeof(*a), &icmp);
    //gbsort(a, SIZE, sizeof(a[0]), &icmp);

    print_array(a, SIZE);

    double ar[] = { 1.1, 34.5, 2.4, 5.4, 31.6, 7.9, 9.1 };
    gbsort(ar, asize(ar), sizeof(*ar), &dcmp);
    
    for(size_t i = 0; i < sizeof(ar); ++i){
        printf("%f", ar[i]);
    }
}
```


### `qsort` Fonksiyonu 

Bu fonksiyon `stdlib.h` başlık dosyasında bulunuyor, bu kütüphene biraz garip, bir çok değişik alanda hizmet veren fonksiyonlar bu başlık dosyasında bulunuyor. </br>
`stdlib.h` başlık dosyasında birden fazla farklı alanla ilgili fonksiyonlar bulunuyor ve genel bir destek kütüphanesi olarak kullanılıyor.


🧭 `stdlib.h` başlık dosyasında bulunan bazı fonksiyonlar aşağıdaki gibidir;
- `exit` fonksiyonu programı sonlandırmaktadır.
- `abort` fonksiyonu programı sonlandırmaktadır.
- `rand` fonksiyonu rastgele sayı üretimiyle ilgili olarak kullanılmaktadır.
- `srand` fonksiyonu rastgele sayı üretimiyle ilgili olarak kullanılmaktadır. 
- `atoi` fonksiyonu sayılar ve yazılar arasında dönüşüm yapmak için kullanılır.
- `atof` fonksiyonu sayılar ve yazılar arasında dönüşüm yapmak için kullanılır.
- `malloc` fonksiyonu dinamik bellek yönetiminde kullanılıyor.
- `calloc` fonksiyonu dinamik bellek yönetiminde kullanılıyor.
- `realloc` fonksiyonu dinamik bellek yönetiminde kullanılıyor.
- `free` fonksiyonu dinamik bellek yönetiminde kullanılıyor.   
- `qsort` fonksiyonu genel olarak sıralama yapmak için kullanılmaktadır.



👇 Aşağıdaki programda `qsort` fonksiyonunun bildirimi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>

void qsort(void* vpa, size_t size, size_t sz, int (*fp)(const void *, const void *));

int main(void)
{

}
```



👇 Aşağıdaki programda `qsort` fonksiyonuna çağrı yapılarak `int` türünden elemanları olan bir dizinin nasıl küçükten büyüğe doğru sıralanabileceği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include "nutility.h"

#define SIZE 100

// Küçükten büyüğe doğru sıralama yapmak için kullanılan fonksiyon
int icmp(const void* vp1, const void* vp2)
{
    if(*(const int*)vp1 > *(const int*)vp2){
        return 1;
    }
    else if(*(const int*)vp1 < *(const int*)vp2){
        return -1;
    }

    return 0;
}

int main(void)
{
    int a[SIZE];
    
    randomize();
    set_array_random(a, SIZE);
    print_array(a, SIZE);

    qsort(a, SIZE, sizeof(int), &icmp);
    print_array(a, SIZE);
}
```



👇 Aşağıdaki programda `qsort` fonksiyonuna çağrı yapılarak `int` türünden elemanları olan bir dizinin nasıl büyükten küçüğe doğru sıralanabileceği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

#define SIZE 100

// Büyükten küçüğe doğru sıralama yapılması için kullanılan fonksiyon
int icmp(const void* vp1, const void* vp2)
{
    if(*(const int*)vp1 < *(const int*)vp2){
        return 1;
    }
    else if(*(const int*)vp1 > *(const int*)vp2){
        return -1;
    }

    return 0;
}

int main(void)
{
    int a[SIZE];
    
    randomize();
    set_array_random(a, SIZE);
    print_array(a, SIZE);

    qsort(a, SIZE, sizeof(int), &icmp);
    print_array(a, SIZE);
}
```



👇 Aşağıdaki programda `qsort` fonksiyonuna çağrı yapılarak `int` türünden elemanları olan bir dizinin nasıl küçükten büyüğe doğru sıralanabileceği incelenebilir ama `icmp` fonksiyonunda işaretli tam sayılarda taşma oluşabilme durumu var bu da "**ub**" durumuna neden olacaktır.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include "nutility.h"

#define SIZE 100

// Küçükten büyüğe doğru sıralama yapılması için kullanılan fonksiyon ama burada işaretli tam sayılarda taşma olabilir.
// Mesela 'vp1' değişkeninin değeri '2,147,483,647' ve 'vp2' değişkeninin değeri '-2,147,483,648' ise yapılacak çıkarma işlemi taşmaya neden olacaktır.
int icmp(const void* vp1, const void* vp2)
{
    return *(const int*)vp1 - *(const int*)vp2;
}

int main(void)
{
    int a[SIZE];
    
    randomize();
    set_array_random(a, SIZE);
    print_array(a, SIZE);

    qsort(a, SIZE, sizeof(int), &icmp);
    print_array(a, SIZE);
}
```



👇 Aşağıdaki programda türden bağımsız olarak `gprint_array` adlı bir fonksiyonun nasıl yazıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

#define SIZE 10

int gprint_array(const void* vp, size_t size, size_t sz, void (*fprint)(const void*))
{
    for(size_t i = 0; i < size; ++i){
        fprint((const char *)vp + i *sz);
    }
    putchar('\n');
}

void myprint(const void* p)
{
    printf("%p \n", *(const int*)p);
}

int main(void)
{
    int a[SIZE];
    
    randomize();
    set_array_random(a, SIZE);
    gprint_array(a, SIZE, sizeof(int), &myprint);
}
```


***
==================================================

✦✦✦✦✦ 11.05-11.26 birinci ara verildi. ✦✦✦✦✦

==================================================
***

### `binary` Fonksiyonu 

Sıralanmmış bir dizide bir değeri arayan `stdlib.h` başlık dosyasında bulunan generic bir fonksiyondur. </br>
Sıralanmış bir dizide arama yapmak için kullanılmaktadır.


👇 Aşağıdaki programda `bsearch` fonksiyonu kullanılarak sıralı bir dizide bir değerin nasıl aranabileceği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

#define SIZE 200

// Küçükten büyüğe doğru sıralama yapılması için kullanılan fonksiyon ama burada işaretli tam sayılarda taşma olabilir.
int icmp(const void* vp1, const void* vp2)
{
    return 
        *(const int*)vp1 > *(const int*)vp2 ? 1 :
        *(const int*)vp1 < *(const int*)vp2 ? -1 : 0;
}

int main(void)
{
    int a[SIZE];
    
    randomize();
    set_array_random(a, SIZE);
    print_array(a, SIZE);

    qsort(a, SIZE, sizeof(*a), &icmp); // Burada 'qsort(a, SIZE, sizeof(*a), icmp);' olarak ta fonksiyon çağrısı yapılabilirdi, bu durumda 'icmp' fonksiyonu adı örtülü olarak adrese dönüştürülürdü.
    print_array(a, SIZE);

    int key;
    printf("aramacak degeri giriniz: ");
    scanf("%d", &key);

    int* p = (int*)bsearch(&key, a, SIZE, sizeof(*a), &icmp); 

    if(p != NULL){
        printf("bulundu %d index = %d \n", *p, p - a);
    }
    else{
        printf("bulunamadi\n");
    }
}
```

⚡ Şu ana kadar bir fonksiyonun adresini parametre olarak alan ve generic olan iki tane standart C fonksiyonu öğrendik, bunlar `qsort` ve `bsearch` fonksiyonları.



📖 Ödev-1:
- 👇 Aşağıdaki soru C mülakatlarında sorulan aslında zor olmayan ama çözülürken biraz zorlanılan bir soru.
- Elemanları `char *` türünden olan bir diziyi `qsort` fonksiyonunu kullanarak sıralayınız(burada `qsort` fonksiyonuna gönderilecek olan callback fonksiyonun doğru yazılıp yazılamadığı sınanmaktadır). 
- Bu işlemi yaparken dizideki yazılar küçükten büyüğe doğru sıralanmalıdır.
- Yazacağınız callback fonksiyonda `strcmp` fonksiyonunu çağırabilirsiniz.
- Yazılacak programda tür uyumsuzluğu ya da tek bir uyarı iletisi olmamalıdır.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

#define SIZE 200

int main(void)
{
    char* p[] = {
        "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
        "hakki", "haldun", "halime", "haluk", "handan", "hande", "handesu", "hasan", "helin", "hikmet",
        "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
        "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata",
    };

    for(size_t i = 0; asize(p); ++i){
        printf("%s \n", p[i]);
    }
    
    // Burada dizinin sıralanması işlemleri yapılıyor.
    //for(size_t i = 0; asize(p) - 1; ++i){
    //    for(size_t k = 0; asize(k) - 1 - i; ++k){
    //        if(strcmp(p[k], p[k + 1]) > 0){
    //            char* temp = p[k];
    //            p[k] = p[k + 1];
    //            p[k + 1] = temp;
    //        }
    //    }
    //}

    // qsort ile diziyi sıralayınız ... (yazılar küçükten büyüğe sıralayınız)
    // yazacağınız callback fonksiyonda 'strcmp' fonksiyonunu çağırabilirsiniz.
    // tür uyumsuzluğu ya da tek bir uyarı iletisi olmamalı. 

    (void)getchar();

    for(size_t i = 0; asize(p); ++i){
        printf("%s \n", p[i]);
    }
}
```



👇 Aşağıdaki programda fonksiyon bildirimlerinde olduğu gibi fonksiyon pointer'larında da parametre parantezinin içini boş bırakmakla parametre parantezinin içinde `void` yazmanın farklı olduğu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

void bom(); // Burada fonksiyonun parametreleri hakkında bilgi verilmemiş, C dilinde 'implicit int' uygulanacaktır.
void foo(void);
void bar(int);
void baz(double, double);

int main(void)
{
    // Buradaki 'fp1' fonksiyon göstericisinin bildirimi 'void (*)()' türünden bir fonksiyonu gösterecek şekilde yapılmıştır. 
    // Bu fonksiyon göstericisi parametre parantezinin içinin boş bırakılması fonksiyon parametresi olmayan bir fonksiyonun parametresini tuttuğu anlamına gelmiyor.
    // 'fp1' fonksiyon göstericisi herhangi bir parametrik yapıda(herhangi sayıda herhangi türde parametrelere sahip) olan fonksiyonların adreslerini tutabilir. 
    void (*fp1)(); 
    
    // Buradaki 'fp2' fonksiyon göstericisinin bildirimi 'void (*)(void)' türünden bir fonksiyonu gösterecek şekilde yapılmıştır.
    void (*fp2)(void) = &foo; 
    
    fp2 = &bar; // Buradaki atama işlemi doğru değildir.

    // Aşağıdaki 'fp1' pointer değişkene yapılan atamaların hepsi legaldir, bunun nedeni 'fp1' göstericisinin göstereceği fonksiyonların parametrik yapısıyla ilgili bilgi verilmemiş olmasıdır.
    fp1 = &foo;
    fp1 = &bar;
    fp1 = &baz;
}
```



👇 Aşağıdaki programda bir karakter test fonksiyonunun adresini döndüren `get_test_func` adlı fonksiyonun nasıl tanımlandığı incelenebilir, bu fonksiyonun geri dönüş türü `int (*)(int)` şeklinde olan bir fonksiyon adresidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include "nutility.h"

// Aşağıdaki 'get_test_func' fonksiyonu geriye 'int (*)(int)' türünü döndürmektedir.
int (*get_test_func(void))(int)
{
    return &isupper;
}

int main(void)
{
    int (*fp)(int) = get_test_func();

    if(fp('A'))
        printf("evet dogru\n");
}
```



👇 Aşağıdaki programda geriye bir test fonksiyonunun adresini döndüren bir fonksiyona yapılan çağrıdan geriye dönen fonksiyon adresi kullanılarak nasıl fonksiyon çağrısı yapıldığı incelenebilir. Biraz kafa karıştırıcı gelebilir, mantığını görünce zihninde basitleşecektir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "nutility.h"

// Aşağıdaki 'get_test_func' fonksiyonu geriye 'int (*)(int)' türünü döndürmektedir.
int (*get_test_func(void))(int)
{
    return &isupper;
}

int main(void)
{
    // Aşağıdaki gibi bir kullanım legal ve kullanışlıdır. Burada 'get_test_func()' fonksiyon çağrısı geriye fonksiyon adresi döndürdüğü için o fonksiyon adresi üzerinden yeni bir fonksiyon çağrısı yapılıyor.
    if(get_test_func()('A')){
        printf("evet dogru\n");
    }
}
```



👇 Aşağıdaki programda `typedef` bildirimi kullanılarak nasıl, bir fonksiyondan geriye döndürülen **funciton pointer** değerin daha sade olarak yazılabileceği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "nutility.h"

typedef int (*Fptest)(int); // 'int (*)(int)' türünde bildirilen 'Fptest' değişkeni.

// Aşağıdaki 'get_test_func' fonksiyonu geriye 'int (*)(int)' türünü döndürmektedir.
Fptest get_test_func(void)
{
    return &isupper;
}

int main(void)
{
    Fptest fp = get_test_func();

    // Aşağıdaki gibi bir kullanım legal ve kullanışlıdır.
    if(fp('D')
        printf("evet dogru\n");
    else
        printf("hayir dogru degil\n");
}
```

## Function Pointers Arrays 


Elemanları "**Function Pointer**" olan dizilere "**Function Pointer Array**" deniliyor. </br>
"**Function Pointer Array**" nadir kullanılan bir araç değildir, üretim ortamında sıklıkla kullanılmaktadır ve iyi bilinmelidir.


👇 Aşağıdaki programda `fpa` adındaki **function pointer array** değişkenin nasıl tanımlandığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "nutility.h"

int f1(int x) { return x + 1; }
int f2(int x) { return x + 2; }
int f3(int x) { return x + 3; }
int f4(int x) { return x + 4; }
int f5(int x) { return x + 5; }

int main(void)
{
    int (*fpa[5])(int) = { &f1, &f2, &f3, &f4, &f5 };
    // int (*fpa[5])(int) = { f1, f2, f3, f4, f5 }; // Buradaki gibi bir tanımlama da yapılabilir, bunun nedeni fonksiyon adlarının fonksiyon adresine dönüştürülmesidir.

    int val = fpa[3](20); // Burada ilk defa '[]' operatöründen sonra '()' operatörünün kullanımını görmüş oluyoruz. Burada 'fpa' dizisinin 3 indisli elemanı olan fonksiyona '20' değeriyle fonksiyon çağrısı yapılmaktadır.

    printf("val = %d\n", val);
}
```


❗❗❗ **Function pointer array** değişkenler sıklıkla "**Jump Table**" yapılarında kullanılmaktadır. </br>
**Lookup Table**: Bir veri sonucunu yeniden hesaplamak yerine sabit zamanda almak için kullanılır. Mesela faktoriyel değerlerini bir kere hesaplayıt bir **lookup table** içinde saklayabiliriz. </br>
**Jump Table**: Sabit zamanda farklı kod bloklarına atlayabilmek için fonksiyon adreslerini ya da etiketleri(label) tutmak için kullanılır.



👇 Aşağıdaki programda **Function pointer array**'in **Jump Table** olarak kullanılarak kullanıcıdan alınan iki `int` değerin istenilen işleme sokulup sonucunun standart çıktıya gönderilmesi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "nutility.h"

int sum(int x, int y) { return x + y}
int subtract(int x, int y) { return x - y}
int multiply(int x, int y) { return x * y}
int division(int x, int y) { return x / y}
int mod(int x, int y) { return x % y}

typedef int (*op_type)(int, int); 

int main(void)
{
    int x, y;

    printf("iki tam sayi girin:");
    scanf("%d%d", &x, &y);

    printf("islemi saciniz;\n");
    printf("[1] toplama\n",
        "[2] cikarma\n",
        "[3] carpma\n",
        "[4] bolme\n",
        "[5] mod\n");

    int option;
    scanf("%d", &option);

    op_type f_ar[] = { &sum, &subtract, &multiply, &division, &mod }; // 'f_ar' adındaki 'Lookup Table' olarak kullanılacak olan 'function pointer array' değişkenin bildirilmesi ve ilk değer verilmesi işlemi.

    printf("%d\n", f_ar[option - 1](x, y));
}
```


***
==================================================

✦✦✦✦✦ 12.20-12.32 ikinci ara verildi. ✦✦✦✦✦

==================================================
***


### **Function Pointer Array** Değişkenler Hangi Temalarda Kullanılıyor

**Function Pointer Array** yapıları aşağıdaki durumlarda kullanılabilir;
1. Bazı fonksiyonların adreslerini tutup gerekli olduğunda o fonksiyonlardan birine programın akışını yönlendirmek için **jump table** olarak kullanılır.
2. Bir işlemin farklı farklı basamaklarını gerçekleştiren fonksiyonlar var ve bu fonksiyonların arka arkaya çağırılması gerekiyor, bunu yapmak için bir döngü kurulduktan sonra "**function pointer array**" elemanı olan tüm fonksiyonlara sırasıyla çağrı yapılabilir.



👇 Aşağıdaki programda "**function pointer array**" bir değişkenin elemanları olan tüm fonksiyonlara nasıl sırayla çağrı yapıldığı incelenebilir, buradaki program 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "nutility.h"

int sum(int x, int y) { return x + y}
int subtract(int x, int y) { return x - y}
int multiply(int x, int y) { return x * y}
int division(int x, int y) { return x / y}
int mod(int x, int y) { return x % y}

typedef int (*op_type)(int, int); 

int main(void)
{
    int x, y;

    printf("iki tam sayi girin:");
    scanf("%d%d", &x, &y);

    const op_type f_ar[] = { &sum, &subtract, &multiply, &division, &mod };

    for(size_t i = 0; i < asize(f_ar);++i){
        printf("%d\n", f_ar[i](x, y));
    }
}
```



**Mapping**: İki tane farklı varlığı birbirine eşleme işlemine verilen addır, **mapping** yapmanın en kolay yolu iki tane dizi oluşturmak ve o iki diziyi birbiriyle ilişkilendirmektir. C++ dilinin standart kütüphenesinde **mapping** terimi sıklıkla karşımıza çıkacaktır.



👇 Aşağıdaki programda "**function pointer array**" bir değişkenin elemanları olan tüm fonksiyonlara nasıl sırayla çağrı yapıldığı ve bu çağrılarda **mapping** kullanıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "nutility.h"

int sum(int x, int y) { return x + y}
int subtract(int x, int y) { return x - y}
int multiply(int x, int y) { return x * y}
int division(int x, int y) { return x / y}
int mod(int x, int y) { return x % y}

typedef int (*op_type)(int, int); 

int main(void)
{
    int x, y;

    printf("iki tam sayi girin:");
    scanf("%d%d", &x, &y);

    // Aşağıdaki 'f_ar' ve 'ops' dizileri birbirine 'map' edilmiştir yani ilişkilendirilmiştir.
    const op_type f_ar[]    = { &sum,      &subtract, &multiply, &division, &mod };
    const char* const ops[] = { "toplama", "cikarma", "carpma",  "bolme",   "mod" };

    for(size_t i = 0; i < asize(f_ar);++i){
        printf("%s  %d\n", ops[i], f_ar[i](x, y));
    }
}
```



👇 Aşağıdaki programda kullanılan yapı C mülakatlarında sıklıkla sorulmaktadır.</br>
👇 Aşağıdaki programda **jump table** ve **mapping** yapısı kullanılarak nasıl C standardında olan test fonkiyonlarına çağrı yapılabildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "nutility.h"

typedef int (*fptest)(int);

int main()
{
    int ch;
    char fname_entry[20];

    // Aşağıdaki 'fp_ar' ve 'fnames' dizileri birbirine 'map' edilmiştir yani ilişkilendirilmiştir. 'fp_ar' değişkeni 'jump table' özelliktedir.
    const fptest fp_ar[] = { &isupper, &islower, &isalpha, &isdigit, &isalnum, &isxdigit, &ispunct, &isspace, &isblank, &isprint, &isgraph, &iscntrl };
    const char* const fnames[] = { "isupper", "islower", "isalpha", "isdigit", "isalnum", "isxdigit", "ispunct", "isspace", "isblank", "isprint", "isgraph", "iscntrl" };

    printf("bir karakter girin: ");
    ch = getchar();

    printf("hangi test fonkisyonu cagirilsin: ");
    scanf("%s", fname_entry);

    int i;

    for(i = 0; i < asize(fnames); ++i){
        if(!strcmp(fnames[i], fname_entry)){
            break;
        }
    }

    if(i == asize(fnames)){
        printf("istedigin fonksiyon bulunamadi!\n");
    }
    else if(fp_ar[i](ch)){
        printf("%c karakter icin %s testi sonucu dogru\n", ch, fname_entry);
    }
    else{
        printf("%c karakter icin %s testi sonucu yanlis\n", ch, fname_entry);
    }
}
```


>❔
> 
> Sorulan soru; 
> 
> Mapping kullanmadan kullanicidan aldigimiz "isupper" yazisini map kullanmadan, baska bir sekilde kodumuzda ayni isimle func call'a convert etme sansimiz var midir acaba?
> 
> Cevap;
> 
> Hayır bu şekilde bir işlem yapılamaz, bu durumda elde olacak şey yazı adresidir, yazı adresi başka fonksiyon adresi başkadır, en fazla dışarıdan alınan yazı adresi bir mapping ile fonksiyon adresine dönüştürülerek bir şeyler yapılabilir.



👇 Aşağıdaki programda fonksiyon adreslerini tutan bir dizinin oyunlarda en sık kullanım yaklaşımlarından biri olan bazı işlemlerin yapılmasının nasıl **function pointer array** ile yapılabildiği incelenebilir, buradaki program yarım kaldı.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "nutility.h"

// Aşağıdaki fonksiyonlar animasyonlara bağlı da olabilir.
void play(void) { printf("kedi oynuyor") }
void meow(void) { printf("kedi miyavliyor") }
void jump(void) { printf("kedi zipliyor") }
void eat(void) { printf("kedi mama yiyor") }
void sleep(void) { printf("kedi uyuyor") }

typedef void (*cat_action)(void);

int main()
{
    cat_action ct_act[] = { &play, &meow, &jump, &eat, &sleep};
}
```


Ders sonu ...
