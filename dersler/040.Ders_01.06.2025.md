# 40.Ders 01.06.2025 ğŸ•˜

Derse 6(09:01)-10(09:07)-11(09:21)-11(10:03)-13(10:12)-14(10:30)-15(11:01)-13(11:25)-15(11:35)-14(12:01) kiÅŸi katÄ±ldÄ±.
---


âš ï¸ `scanf`, `sscanf` fonksiyonlarÄ±nÄ± tam olarak anlamak iÃ§in ilave derse ihtiyaÃ§ var, bu fonksiyonlarÄ±n formatlama Ã¶zellikleri tamamen anlatÄ±lmadÄ±. Mesela **scanset** nedir nasÄ±l kullanÄ±lÄ±r, formatlama dÃ¶nÃ¼ÅŸtÃ¼rÃ¼cÃ¼lerinin tam listesi ve bir Ã§ok detay bilgiye deÄŸinilmedi.


## `snprintf` Fonksiyonu

`snprintf` fonksiyonunun `sprintf` fonksiyonundan tek farkÄ± bir tane fazladan parametreye sahip olmasÄ±, bu fazladan parametre en fazla yazÄ±labilecek karakter sayÄ±sÄ±nÄ± ifade etmektedir ve bu ÅŸekilde dizi taÅŸma sorunu oluÅŸmamaktadÄ±r. 


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `sprintf` ve `snprintf` fonksiyonlarÄ±nÄ±n farklÄ± gÃ¶rÃ¼lebilir.
```C
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int x = 5, y = 2432;
    char buffer[10];

    sprintf(buffer, "necati%d%d", x, y); // Burada 'buffer' dizisine yazÄ±lacak veri 11 karakter ve bir de '\0' dizi sonu karakteri olacaÄŸÄ± iÃ§in toplamda 12 karakter olacak ama diziyi taÅŸÄ±rdÄ±ÄŸÄ± iÃ§in 'ub' durumuna neden olur.
    puts(buffer);

    snprintf(buffer, 10, "necati%d%d", x, y); // Burada ikinci parametre dizinin boyutu olduÄŸu iÃ§in dizi taÅŸmasÄ± sorunu olmayacak.
    puts(buffer);
}
```


## Process SonlandÄ±ran Fonksiyonlar 

ProgramlarÄ±n Ã§alÄ±ÅŸma anÄ±ndaki hallerine **process** deilmektedir.

`stdlib.h` baÅŸlÄ±k dosyasÄ±nda bulunan `exit`, `atexit`, `abort` fonksityonlarÄ± Ã§alÄ±ÅŸan programÄ± sonlandÄ±rmak iÃ§in kullanÄ±lÄ±r.


### `exit` Fonksiyonu

Ã‡alÄ±ÅŸan C programlarÄ±nÄ± sonlandÄ±rmak iÃ§in `exit` fonksiyonu kullanÄ±labilir. </br>
Ã‡alÄ±ÅŸan C programlarÄ± sonlandÄ±klarÄ±nda geriye bir tane tam sayÄ± deÄŸer dÃ¶ndÃ¼rÃ¼r, bu tam sayÄ± deÄŸer **zero/non-zero** olarak yorumlanÄ±r, geriye dÃ¶nen deÄŸer **zero** ise programÄ±n Ã§alÄ±ÅŸmasÄ±nÄ±n baÅŸarÄ±lÄ± olduÄŸu ve geriye dÃ¶nen deÄŸer **non-zero** ise programÄ±n Ã§alÄ±ÅŸmasÄ±nÄ±n baÅŸarÄ±sÄ±z olduÄŸu anlaÅŸÄ±lÄ±r. </br>
Ã‡alÄ±ÅŸan bir yazÄ±lÄ±msal yapÄ±nÄ±n **Zero/non-zero** deÄŸer dÃ¶ndÃ¼rmesine gÃ¶re iÅŸlemin baÅŸarÄ±lÄ±/baÅŸarÄ±sÄ±z olduÄŸunun anlaÅŸÄ±lmasÄ± yaklaÅŸÄ±mÄ± C diline Ã¶zgÃ¼ deÄŸildir, bir Ã§ok yazÄ±lÄ±m dilinde kullanÄ±lmaktadÄ±r, baÅŸarÄ±lÄ±lÄ±k durumunun tek bir hali varken baÅŸarÄ±sÄ±zlÄ±ÄŸÄ±n birden Ã§ok hali vardÄ±r ve bu nedenden dolayÄ± da **non-zero** deÄŸerler hatalÄ± olarak youmlanmÄ±ÅŸtÄ±r, dÃ¶nÃ¼len deÄŸere gÃ¶re de hatanÄ±n tÃ¼rÃ¼ tanÄ±mlanabilir.


â—â—â— Derleyici `main` fonksiyonunda kullanÄ±lan `return` statement'Ä± `exit` fonksiyonuna Ã§aÄŸrÄ± yapan koda dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r, `return 0;` deyimi `exit(0);` deyimine, `return 234;` deyimi `exit(234);` deyimine derleyici tarafÄ±ndan dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `exit` fonksiyonu ile programÄ±n sonlandÄ±rÄ±lÄ±ÅŸÄ± incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    printf("merhaba dunya\n");
    exit(EXIT_FAILURE); // 'EXIT_FAILURE' identifier'Ä± bir 'object-like makro' ve genellikle derleyiciler '1' deÄŸerine eÅŸitlemektedir ve bu satÄ±rdaki statement ÅŸuna denktir 'exit(1);'.
    printf("elveda dunya\n");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `exit` ve `return` ile yazÄ±lan kod satÄ±rlarÄ± aynÄ± iÅŸi yapmaktadÄ±r ama bir process'i sonlandÄ±rÄ±rken Ã§oÄŸu zaman baÅŸka iÅŸler yapÄ±lmak istenecektir, bu durumlarÄ± sonraki programlarda inceleyebiliriz.
```C
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    printf("merhaba dunya\n");
    exit(643);

    return 643;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **call-chane** olarak adlandÄ±rÄ±lan fonksiyon Ã§aÄŸÄ±rma zincirinin kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>


void f4(void)
{
    printf("f4 calismaya basladi!\n");
    printf("f4 calismasi bitti!\n");    
}

void f3(void)
{
    printf("f3 calismaya basladi!\n");
    f4();
    printf("f3 calismasi bitti!\n");    
}

void f2(void)
{
    printf("f2 calismaya basladi!\n");
    f3();
    printf("f2 calismasi bitti!\n");    
}

void f1(void)
{
    printf("f1 calismaya basladi!\n");
    f2();
    printf("f1 calismasi bitti!\n");    
}


int main(void)
{
    printf("main calismaya basladi!\n");
    f1();
    printf("main calismasi bitti!\n");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **call-chane** olarak adlandÄ±rÄ±lan fonksiyon Ã§aÄŸÄ±rma zincirinin bir nedenden dolayÄ± programÄ±n `exit` ile nasÄ±l sonlandÄ±rÄ±labileceÄŸini anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>


void f4(void)
{
    printf("f4 calismaya basladi!\n");
    
    if(1){
        printf("f4 isini yapamadi.");
        exit(EXIT_FAILURE);
    }

    printf("f4 calismasi bitti!\n");    
}

void f3(void)
{
    printf("f3 calismaya basladi!\n");
    f4();
    printf("f3 calismasi bitti!\n");    
}

void f2(void)
{
    printf("f2 calismaya basladi!\n");
    f3();
    printf("f2 calismasi bitti!\n");    
}

void f1(void)
{
    printf("f1 calismaya basladi!\n");
    f2();
    printf("f1 calismasi bitti!\n");    
}


int main(void)
{
    printf("main calismaya basladi!\n");
    f1();
    printf("main calismasi bitti!\n");
}
```


â—â—â— `exit` fonksiyonu process'i hemen sonlandÄ±rmÄ±yor, bazÄ± garantiler vererek sonlandÄ±rÄ±yor. `exit` fonksiyonu ile Ã§alÄ±ÅŸan program "**Normal Termination**" olarak sonlandÄ±rÄ±lÄ±yor ve bir de `abort` fonksiyonu ile Ã§alÄ±ÅŸan program "**Abnormal Termination**" olarak sonlandÄ±rÄ±lÄ±yor. </br>
`exit` fonksiyonunun verdiÄŸi garantiler aÅŸaÄŸÄ±daki gibidir;
- AÃ§Ä±k olan dosyalar kapatÄ±lmadan Ã¶nce dosyalarÄ±n buffer'larÄ±nÄ±n dosyaya yazÄ±lmasÄ± garantisi(bu konuyu dosya iÅŸlemlerinde gÃ¶receÄŸiz, henÃ¼z gÃ¶rmedik).
- AsÄ±l Ã¶nemli olan garanti ise, daha Ã¶nceden process sonlanmadan Ã¶nce belirli sÄ±rayla caÄŸÄ±rÄ±lmasÄ± istenildiÄŸi bildirilen bazÄ± fonksiyonlara Ã§aÄŸrÄ± yapÄ±ldÄ±ktan sonra Ã§alÄ±ÅŸan programÄ±n sonlandÄ±rÄ±lmasÄ± garantisidir, Ã§aÄŸrÄ±lacak fonksiyonlarÄ±n neler olduÄŸu `atexit` fonksiyonu ile belirlenmektedir.


### `atexit` Fonksiyonu 

â—â—â— `exit` fonksiyonu kendisine Ã§aÄŸrÄ± yapÄ±ldÄ±ÄŸÄ±nda process'i sonlandÄ±racaktÄ±r ama `atexit` fonksiyonu kullanarak Ã§aÄŸÄ±rÄ±lmasÄ± istenilen fonksiyonlar belirtilmiÅŸse, sÄ±rasÄ±yla o fonksiyonlar Ã§aÄŸÄ±rÄ±ldÄ±ktan(Ã§aÄŸÄ±rma iÅŸlemi stack veri yapÄ±sÄ±na gÃ¶re yapÄ±lmaktadÄ±r) sonra process sonlandÄ±rÄ±lacaktÄ±r.

â—â—â— `atexit` fonksiyonu yazÄ±lmÄ±ÅŸ programÄ±n ihtiyaÃ§larÄ±na gÃ¶re(mesela ) process `exit` fonksiyonu ile sonlanmadan Ã¶nce Ã§aÄŸrÄ± yapÄ±lmasÄ± istenilen fonksiyonlarÄ±n son kaydedilenden ilk kaydedilene doÄŸru Ã§aÄŸrÄ±lmasÄ± iÃ§in kullanÄ±lmaktadÄ±r.

â—â—â— Bir Ã§ok program Ã§alÄ±ÅŸtÄ±ÄŸÄ± donanÄ±m Ã¼zerinde bazÄ± kaynaklar kullanÄ±r ve bu kaynaklarÄ± program sonlanmadan Ã¶nce geri iade etmesi gerekiyor bunu yapabilmek iÃ§in `atexit` ve `exit` fonksiyonu birlikte kullanÄ±lmaktadÄ±r. </br>
Peki bu yapÄ± nasÄ±l Ã§alÄ±ÅŸÄ±yor diye dÃ¼ÅŸÃ¼nÃ¼lÃ¼rse, bu tÃ¼r temalarda global bir **function pointer array** kullanÄ±lÄ±yor, `atexit` fonksiyonuna Ã§aÄŸrÄ± yapÄ±ldÄ±ÄŸÄ±nda geÃ§ilen fonksiyon adresi bir **function pointer array**'de tutuluyor `exit` fonksiyonuna Ã§aÄŸrÄ± yapÄ±ldÄ±ÄŸÄ±nda process sonlandÄ±rÄ±lmadan Ã¶nce o **function pointer array**'de tutulan fonksiyonlara Ã§aÄŸrÄ± yapÄ±lÄ±yor, bu Ã¶nemli bir garanti.

âš ï¸ `atexit` fonksiyonuna aynÄ± fonksiyon adresiyle birden fazla defa Ã§aÄŸrÄ± yapÄ±labilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `atexit` fonksiyonu kullanÄ±ldÄ±ktan sonra `exit` fonksiyonu ile process'in nasÄ±l sonlandÄ±rÄ±ldÄ±ÄŸÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>

void f1(void) { printf("f1 cagirildi\n"); }
void f2(void) { printf("f2 cagirildi\n"); }
void f3(void) { printf("f3 cagirildi\n"); }
void f4(void) { printf("f4 cagirildi\n"); }

int main(void)
{
    atexit(f1);

    // some code here ...

    atexit(f2);

    // some code here ...

    atexit(f3);

    // some code here ...

    atexit(f4);

    // some code here ...

    printf("merhaba dunya!\n");

    exit(EXIT_FAILURE);
}
```


>â”
> 
> SorduÄŸum soru?
> 
> "return 0;" olduÄŸunda derleyici nasÄ±l bir kod  Ã¼retiyor yani bu durumda program hangi fonksiyon Ã§aÄŸrÄ±sÄ±yla sonlandÄ±rÄ±lÄ±yor, "return 1;"e benzer olarak baÅŸka bir fonksiyona Ã§aÄŸrÄ± yapÄ±lÄ±yor mu?
> Her durumda 'exit' fonksiyonu ile process sonlandÄ±rÄ±lÄ±yor o zaman, teÅŸekkÃ¼rler.
> 
> Cevap;
> 
> Gayet basit `exit(EXIT_SUCESS);` ya da `exit(0);` ile process sonlandÄ±rÄ±lÄ±yor. </br>
> Bir process'in doÄŸal yolla sonlandÄ±rÄ±lmasÄ± her durumda `exit` fonksiyonuna yapÄ±lan Ã§aÄŸrÄ± ile oluyor.


### `abort` Fonksiyonu 

Bu fonksiyon Ã§aÄŸrÄ±lÄ±r Ã§aÄŸrÄ±lmaz program sonlandÄ±rÄ±lacaktÄ±r ve bu fonksiyon Ã§alÄ±ÅŸan programÄ± sonlandÄ±rÄ±rken hiÃ§bir garanti vermemektedir, bu biÃ§imdeki Ã§alÄ±ÅŸan programÄ±n sonlandÄ±rÄ±lÄ±ÅŸÄ±na **Abnormal Termination** deniliyor. </br>
Bu fonksiyon bazÄ± Ã¶zel durumlarda programlarÄ±n hemen sonlandÄ±rÄ±lmasÄ± gerektiÄŸinde kullanÄ±lÄ±r ve bu fonksiyon standart hata akÄ±mÄ±na veri yazacaktÄ±r. </br>
`abort` Fonksiyonu hata akÄ±ylama iÅŸlemlerinde sorunlu durumlarÄ± tespit iÃ§in kullanÄ±labiliyor.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda **call-chane** olarak adlandÄ±rÄ±lan fonksiyon Ã§aÄŸÄ±rma zincirinin bir nedenden dolayÄ± programÄ±n `abort` ile nasÄ±l sonlandÄ±rÄ±labileceÄŸini anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>

void f4(void)
{
    printf("f4 calismaya basladi!\n");
    abort(); // ProgramÄ±n hemen sonlandÄ±rÄ±lmsÄ± iÃ§in kullanÄ±lÄ±yor.
    printf("f4 calismasi bitti!\n");    
}

void f3(void)
{
    printf("f3 calismaya basladi!\n");
    f4();
    printf("f3 calismasi bitti!\n");    
}

void f2(void)
{
    printf("f2 calismaya basladi!\n");
    f3();
    printf("f2 calismasi bitti!\n");    
}

void f1(void)
{
    printf("f1 calismaya basladi!\n");
    f2();
    printf("f1 calismasi bitti!\n");    
}

int main(void)
{
    printf("main calismaya basladi!\n");
    f1();
    printf("main calismasi bitti!\n");
}
```


## Dynamic Memory Managament 

ProgramlamanÄ±n Ã¶nemli araÃ§larÄ±ndan biri olan bir konudur. </br>
Nesnelerin hayata baÅŸladÄ±ÄŸÄ± bir zamansal nokta var bir de hayatÄ±nÄ±n bittiÄŸi zamansal nokta var(bu duruma daha geniÅŸ bir terim olarak "**Life Spent**" denilmektedir).

**Dynamic Life Time(Dinamik Ã¶mÃ¼r)**: Herhangi bir noktada Herhangibir nesnenin hayatÄ±na baÅŸlamasÄ± ve programcÄ±nÄ±n istediÄŸi bir noktada o nesnenin Ã¶mrÃ¼nÃ¼n sonlanmasÄ±nÄ± ifade eden Ã¶mÃ¼r kavramÄ±dÄ±r. ProgramÄ±n Ã§alÄ±ÅŸmasÄ± sÄ±rasÄ±nda herhangi bir noktada herhangi bir fonksiyonun iÃ§inde bir deÄŸiÅŸkenin hayata baÅŸlamasÄ± ve yine programcÄ±nÄ±n istediÄŸi bir noktadadeÄŸiÅŸkenin hayatÄ±nÄ±n bitmesine **Dynamic life time(Dinamik Ã¶mÃ¼r)** denilmektedir, yani ne bir kapsam(scope) ile sÄ±nÄ±rlÄ± bir Ã¶mÃ¼r ne de program sonlandÄ±ÄŸÄ±nda biten bir Ã¶mÃ¼r.



ğŸ§  **Dynamic life time(Dinamik Ã¶mÃ¼r)** ile **dynamic memory managament(dinamik bellek yÃ¶netimi)** konularÄ±nÄ± birbirine karÄ±ÅŸtÄ±rmak sÄ±k karÅŸÄ±laÅŸÄ±lan bir durumdur.

â—â—â— **Dinamik Ã¶mÃ¼rlÃ¼** nesneler iÃ§in **memory allocation** iÅŸleminin yapÄ±lmasÄ± yani **nesnelerin(object)** ihtiyacÄ± olan bellek alanÄ±nÄ±n elde edilmesi iÅŸlemine ve bu bellek alanÄ± kullanÄ±ldÄ±ktan sonra sisteme geri verilmesi sÃ¼reÃ§lerine **dynamic memory managament(dinamik bellek yÃ¶netimi)** deniliyor.

**Dinamik Ã¶mre(dynamic life time)** sahip nesnelerin bellekte yer alacaÄŸÄ± konum iÅŸletim sisteminin sistem fonksiyonlarÄ± kullanÄ±larak elde edilmektedir, bellekten yer ayÄ±rma iÅŸlemine fiil olarak **Allocate Memory** ve adlaÅŸtÄ±rÄ±lmÄ±ÅŸ hali olarak **Memory Allocation** denilmektedir.


â—â—â— C dilinde **Heap** ve C++ dilinde **Free Storage** olarak adlandÄ±rÄ±lan bellek alanÄ±nda(bellek segmenti) **dinamik Ã¶mÃ¼rlÃ¼** deÄŸiÅŸkenler tutulmaktadÄ±r.


â—â—â— C standardÄ± donanÄ±mla ilgilenmez sadece bir soyut makine Ã¼zerinde C programÄ±nÄ±n nasÄ±l Ã§alÄ±ÅŸacaÄŸÄ±ndan bahseder(ilgilenir), C programÄ±nÄ±n hangi donanÄ±m ya da iÅŸletim sistemi Ã¼zerinde Ã§alÄ±ÅŸacaÄŸÄ±yla C standardÄ± ilgilenmez.
- C programÄ±nÄ±n Ã¼zerinde Ã§alÄ±ÅŸacaÄŸÄ± zahiri donanÄ±ma **C Abstract Machine** deniliyor.
- C++ programÄ±nÄ±n Ã¼zerinde Ã§alÄ±ÅŸacaÄŸÄ± zahiri donanÄ±ma **C++ Abstract Machine** deniliyor.

â—â—â— Bir dilin standardÄ± kurallarÄ± belirtir, saÄŸlanmasÄ± gereken koÅŸullarÄ± belirtir ve oluÅŸmasÄ± gereken sonuÃ§larÄ± belirtir. C standardÄ±nda "**Stack**" ya da "**Heap**" diye bir terim geÃ§memektedir, bu terimler iÅŸletim sistemiyle ilgili terimlerdir, ayrÄ±ca bir C programÄ±nÄ±n bir iÅŸletim sistemi Ã¼zerinde Ã§alÄ±ÅŸmasÄ± gibi bir zorunluluk yoktur.



âš ï¸ Kursun bu anÄ±na kadar **dinamik Ã¶mÃ¼rlÃ¼** nesnelere hiÃ§ deÄŸinilmedi, bu derle birlikte **dinamik Ã¶mÃ¼rlÃ¼** nesnelerle tanÄ±ÅŸacaÄŸÄ±z.

â—â—â— **Dinamik Ã¶mÃ¼rlÃ¼** nesnelerin maliyeti **otomatic Ã¶mÃ¼rlÃ¼** nesnelerin maliyetinden Ã§ok daha yÃ¼ksektir. </br>
âš ï¸ Verim kritik bir uygulamada **otomatic Ã¶mÃ¼rlÃ¼** nesnelerin kullanÄ±lmasÄ± yerine **dinamik Ã¶mÃ¼rlÃ¼** nesnelerin kullanÄ±lmasÄ± programÄ±n Ã§alÄ±ÅŸma anÄ±ndaki iÅŸlem maliyetini kat ve kat arttÄ±racaktÄ±r. </br>
â—â—â— **Otomatic Ã¶mÃ¼rlÃ¼** nesneler iÃ§in bellekte ayrÄ±lan alanÄ±n geri verilmesi iÃ§in programcÄ±nÄ±n bir iÅŸlem yapmasÄ±na gerek yok fakat **dinamik Ã¶mÃ¼rlÃ¼** nesnelerin hayatÄ±nÄ±n bitirilmesi programcÄ±nÄ±n sorumluluÄŸundadÄ±r, bu yÃ¶nÃ¼yle **dinamik Ã¶mÃ¼rlÃ¼** nesneleri doÄŸru ÅŸekilde kullanabilmek Ã¶nemlidir. </br>
â—â—â— **Garbage Collection** sÃ¼recini yÃ¶neten yapÄ±ya **Garbage Collector** denilmektedir. **Garbage Collection** aracÄ± olan bir programlama dilinin Ã§alÄ±ÅŸma maliyeti yÃ¼ksektir bu nedenle bu yapÄ±ya sahip diller genellikle verim kritik domain'lerde kullanÄ±lmaz. **Garbage Collector** aracÄ± olan dillerde prpgramÄ±n iÃ§ine gÃ¶mÃ¼lÃ¼ olarak gelen ayrÄ± bir **threed** Ã¼zerinde Ã§alÄ±ÅŸan yapÄ± belirli sÃ¼relerde artÄ±k referans edilmeyen **dinamik Ã¶mÃ¼rlÃ¼** nesnelerin hayatlarÄ±nÄ± sonlandÄ±rmaktadÄ±r. </br>
C ve C++ dillerinde **Garbage Collection** sÃ¼reci iÃ§in hazÄ±r bir araÃ§ yoktur(istenirse yazÄ±labilir tabi).

ğŸ§  C#, Java gibi diller programcÄ±nÄ±n Ã¼retkenliÄŸini yÃ¼ksek tutma Ã¼zerine tasarlanmÄ±ÅŸken, C ve C++ gibi diller sistem kaynaklarÄ±nÄ±n verimli kullanÄ±lmasÄ± Ã¼zerine tasarlanmÄ±ÅŸ dillerdir.

âš ï¸ **Dinamik Ã¶mÃ¼rlÃ¼** nesneleri kullanmak ayrÄ±lan sistem kaynaklarÄ±nÄ±n geri iade edilmesinin programcÄ±ya bÄ±rakÄ±lmasÄ±ndan dolayÄ± programcÄ± aÃ§Ä±sÄ±ndan daha zordur ve maliyeti **otomatik Ã¶mÃ¼rlÃ¼** nesneleri kullanmaya gÃ¶re daha maliyetlidir.



**Memory Leak**: Bellekten yer ayrÄ±lmÄ±ÅŸ **dinamik Ã¶mÃ¼rlÃ¼** nesnelerin bellek alanlarÄ±nÄ±n geri verilmemesine verilen addÄ±r, bu durumda geri iade edilmeyen bellek alanlarÄ± baÅŸka iÅŸler iÃ§in kullanÄ±lamaz.

**Dangling  Pointer**: **Dinamik Ã¶mÃ¼rlÃ¼** nesnelerin kullanÄ±ldÄ±ÄŸÄ± durumlarda Ã¶mrÃ¼ bitmiÅŸ olan **dinamik Ã¶mÃ¼rlÃ¼** nesnelere eriÅŸilmeye Ã§alÄ±ÅŸÄ±lmasÄ± durumudur.


**Otomatic storage duration** nesnelerle ilgili en kritik hata geriye gÃ¶sterici dÃ¶ndÃ¼ren bir fonksiyondan **otomatic Ã¶mÃ¼rlÃ¼** bir nesnenin adresinin dÃ¶ndÃ¼rÃ¼lmesidir(ki bu durum o nesneye dereference iÅŸlemi yapÄ±ldÄ±ÄŸÄ±nda **ub** durumuna neden olur). </br>
**Dynamic storage duration** nesneleri kullanÄ±rken oluÅŸabilecek sorunlar daha fazladÄ±r.



â—â—â— Ã–yle durumlar var ki ne **otomatic** Ã¶mÃ¼rlÃ¼ nesne ne de **static** Ã¶mÃ¼rlÃ¼ nesne iÅŸimizi gÃ¶rmeyecektir, bu durumlarda mecburen **dinamik Ã¶mÃ¼rlÃ¼** nesneleri kullanmak gerekiyor;
- Ã‡alÄ±ÅŸan programda bir diziye(array) ihtiyacÄ±mÄ±z var ama dizinin boyutsaunun programÄ±n Ã§alÄ±ÅŸma zamanÄ±nda belli olduÄŸu durumlarda **dinamik Ã¶mÃ¼rlÃ¼** nesnelerin kullanÄ±lmasÄ± gerekecektir.
- Bazen bir nesnenin tÃ¼rÃ¼nÃ¼n bile Ã§alÄ±ÅŸma zamanÄ±nda belirlendiÄŸi durumlar vardÄ±r, bu gibi durumlarda bellekten ayrÄ±lmasÄ± gereken alanÄ±n geniÅŸliÄŸini belirlemek iÃ§in **dinamik Ã¶mÃ¼rlÃ¼** nesnelerin kullanÄ±lmasÄ± gerekecektir.
- Veri yapÄ±larÄ±nÄ± kullanÄ±rken kullanÄ±lan veri yapÄ±sÄ±nÄ±n bellek ihtiyacÄ± deÄŸiÅŸken boyutlu olduÄŸunda **dinamik Ã¶mÃ¼rlÃ¼** nesnelerin kullanÄ±lmasÄ± gerekecektir. Mesela "**Linked List Data Structor**" veri yapÄ±sÄ±nda dÃ¼ÄŸÃ¼m sayÄ±sÄ± deÄŸiÅŸken olacaktÄ±r, bu gibi deÄŸiÅŸken boyutlu bellek alanlarÄ± gerekli olduÄŸunda **dynamic storage duration** nesneleri kullanÄ±rÄ±z.


â—â—â— Neden **dynamic storage duration** nesneleri kullanÄ±rÄ±z diye sorulursa;
- Bunun nedeni Ã§oÄŸu zaman mecburiyettir, yapÄ±lmak istenilen iÅŸlemi baÅŸka bir araÃ§ ile yapamadÄ±ÄŸÄ±mÄ±z iÃ§in **dinamik Ã¶mÃ¼rlÃ¼** nesneleri kullanÄ±rÄ±z.
- Bazen de Ã§oÄŸunlukla iÅŸletim sisteminin parametrelerine baÄŸlÄ±(bazen ise donanÄ±ma baÄŸlÄ±) olarak **otomatic Ã¶mÃ¼rlÃ¼** nesnelere ayrÄ±lan bellek alanÄ±nÄ±n(**Stack**), **dinamik Ã¶mÃ¼rlÃ¼** nesnelere ayrÄ±lan bellek alanÄ±ndan(**Heap**) daha kÃ¼Ã§Ã¼k olmasÄ± ve oluÅŸturulmak istenilen nesne iÃ§in **otomatik Ã¶mÃ¼rlÃ¼** bir nesnenin kullanÄ±lamÄ±yor olmasÄ±dÄ±r.



Kursun baÅŸÄ±nda neden standart C kÃ¼tÃ¼khanesi ve fonksiyonlarÄ± oluduÄŸuyla ilgili bilgi verilmiÅŸti;
1. Ortak arayÃ¼z oluÅŸturmak.
2. HazÄ±r kullanÄ±labilir varlÄ±klarÄ±n olmasÄ±.
3. YazÄ±lmÄ±ÅŸ programlarÄ±n taÅŸÄ±nabilir olmasÄ±nÄ±n saÄŸlanmasÄ±. Mesela iÅŸletim sisteminin sistem fonksiyonlarÄ±nÄ±n kullanÄ±lmasÄ± gerektiÄŸi yerlerde(I/O iÅŸlemleri vb.) o Ã§aÄŸrÄ±larÄ± yazÄ±lmÄ±ÅŸ C programÄ±ndan yapmak yerine bu sorumluluk C dilinin fonksiyonlarÄ±na devredilebilir.



â—â—â— TaÅŸÄ±nabilirlik bir yere kadar Ã§Ã¼nkÃ¼ standart C fonksiyonlarÄ± iÅŸletim sistemine bir baÄŸÄ±mlÄ±lÄ±k varsa o noktada bir soyutlama yapÄ±yorlar fakat bazÄ± iÅŸlemlerin standart C fonksiyonu olarak karÅŸÄ±lÄ±ÄŸÄ± yok, C programÄ±nÄ±n ne olduÄŸuna ve ne iÅŸ yaptÄ±ÄŸÄ±na baÄŸlÄ± olarak bazÄ± durmlarda iÅŸletim sisteminin sistem fonksiyonlarÄ±nÄ± doÄŸrudan Ã§aÄŸÄ±rmak gerekebilir. </br>
Her ÅŸeyi sadece standart C fonksiyonlarÄ±na Ã§aÄŸrÄ± yaparak mÃ¼mkÃ¼n mÃ¼ dÃ¼ye dÃ¼ÅŸÃ¼nÃ¼ldÃ¼ÄŸÃ¼nde, belirli programlar iÃ§in iÃ§in mÃ¼mkÃ¼n ama belirli programlar iÃ§in bu mÃ¼mkÃ¼n deÄŸildir. </br>
**Dynamic memory managament(dinamik bellek yÃ¶netimi)** iÅŸlemlerinin tamamÄ±na yakÄ±nÄ± Ã§ok Ã¶zel bir durum olmadÄ±ÄŸÄ± mÃ¼ddetÃ§e standart C fonksiyonlarÄ±yla yapÄ±labilir.

âš ï¸ **Dynamic memory managament(dinamik bellek yÃ¶netimi)** konusu 4-6 saat ya da biraz daha fazla vakit alacak bir konu!

â—â—â— Dinamik bellek yÃ¶netimi ile ilgili kullanÄ±lan fonksiyonlar `stdlib.h` baÅŸlÄ±k dosyasÄ±nda bulunmaktadÄ±r, ve bunlar aÅŸaÄŸÄ±daki gibidir;
- `malloc`: Bu fonksiyonun adÄ± "**Memory Allocation**" sÃ¶zcÃ¼klerinden gelmektedir. Bu fonksiyon ile kullanÄ±labilir bellek bloÄŸunun ayrÄ±lÄ±r ve bu bloÄŸun baÅŸlangÄ±Ã§ adresi geriye dÃ¶ndÃ¼rÃ¼lÃ¼r. AyrÄ±lan bellek alanÄ± temizlenmeden(**indeterminate value**) verilmektedir.
- `calloc`: Bu fonksiyonun adÄ± "**Memory Celar Allocation**" sÃ¶zcÃ¼klerinden gelmektedir. `calloc`un `malloc`tan iki farkÄ± vardÄ±r,`calloc` tahsis edilen bellek bloÄŸundaki tÃ¼m verinin bitlerini "0" yapar. `calloc` eÅŸittir `malloc` + `memset`. `calloc` kÄ±saca cleared `malloc` olarak nitelendirilebilir.
- `realloc`: Bu fonksiyonun adÄ± "**Memory ReAllocation**" sÃ¶zcÃ¼klerinden gelmektedir. Daha Ã¶nce edinilmiÅŸ belllek alanÄ±nÄ±n arttÄ±rÄ±lÄ±p azaltÄ±lmasÄ± iÃ§in kullanÄ±lan bir fonksiyondur, Ã¶nceden edinilmiÅŸ bir bellek alanÄ±nÄ± bÃ¼yÃ¼tÃ¼p/kÃ¼Ã§Ã¼ltmek iÃ§in kullanÄ±lan bir fonksiyondur.
- `free`: EdinilmiÅŸ bellek bloklarÄ±nÄ±n tamamÄ±nÄ± geri vermek iÃ§in kullanÄ±lÄ±r.

â—â—â— YukarÄ±da aÃ§Ä±klanan dinamik bellek yÃ¶netimi iÃ§in kullanÄ±lan dÃ¶rt farklÄ± fonksiyonun kullanÄ±mÄ± genellikle ÅŸu ÅŸekildedir: Dinamik bellek alanÄ±na ihtiyaÃ§ duyulduÄŸunda `malloc` ya da `calloc` fonksiyonu ile bellek edin, programÄ±n Ã§alÄ±ÅŸma zamanÄ±nda bellek ihtiyacÄ±nÄ±n deÄŸiÅŸmesi gerektiÄŸinde `realloc` fonksiyonunu kullan, ayrÄ±lmÄ±ÅŸ tÃ¼m belleÄŸi geri vermek iÃ§in `free` fonksiyonunu kullan.

ğŸ§  Bir process bir iÅŸletim sisteminde hayata geldiÄŸinde iÅŸletim sisteminin o process'e ayÄ±rdÄ±ÄŸÄ± bir "**Heap**" ya da "**Free Store**" olarak adlandÄ±rÄ±lan alanÄ± vardÄ±r, **dynamic memory managament(dinamik bellek yÃ¶netimi)** process'e ayrÄ±lan "**Heap**" alanÄ±nÄ± ihtiyaca gÃ¶re kullanÄ±p yÃ¶netmeyi ifade eden bir kavramdÄ±r.



Burada C kursundan sonra ne yapÄ±labileceÄŸiyle ilgili bazÄ± konularla ilgili konuÅŸuluyor.


hocam iÅŸim olduÄŸu iÃ§in geÃ§ girmek zorunda kaldÄ±m. C++ kursu iÃ§in ne dediniz, eÄŸer dersi bÃ¶lÃ¼yorsam kayÄ±t dan dinlerim

Undefined Behaviour burada Ã¶ÄŸrendim hocam :)

Bende ondan geldim. Bir Ã¶ÄŸrenciniz sizi tavsiye etti. BaÅŸka yerden Ã¶ÄŸrenme sÄ±fÄ±rdan Ã¶ÄŸretir dedi. HaklÄ±ymÄ±ÅŸ :)

C++ ben game development iÃ§in kullanmak istiyorum o yÃ¼zden sizden almak istiyorum oop ve generic paradigmalarÄ±nÄ± Ã¶ÄŸrenmek istiyorum

Kendi domain'im ile ilgili sorularÄ±m olacaktÄ± hocam onu Ã¶zel den size sorsam olur mu, bura dan vakit kaybettirmemek iÃ§in.

teamviewer pure C pozisyonu acmis mesela

Ben bu kursu zaten c++ iÃ§in alÄ±yorum

Bu kursta nasÄ±l Ã¶ÄŸrenmem gerektiÄŸini de Ã¶ÄŸrendim hocam 4 yÄ±llÄ±k bil mÃ¼h mezunuyum ub burada duydum.

Oyun MotorlarÄ±,Ekran KartlarÄ±,Databaselerde,HTFiÅŸemlerinde bir Ã§ok alanda ve bir Ã§ok standard var

hocam dogrudan C++ ye gecince C deki bazi ileri konular unutulacak gibi geliyor, ya da sindirilemeyecek gibi, yanlis mi dÃ¼sÃ¼nÃ¼yorum acaba

Hocam c++ c with classes mantÄ±ÄŸÄ±ndan artÄ±k Ã§ok uzak deÄŸil mi hocam ? C++ kursunda oop ve generic gÃ¶receÄŸiz deÄŸil mi hocam?

hocam, konulara bir tÄ±k hÄ±zlÄ± giderek bir ders sadece sektÃ¶rler Ã¼zerine bilgi verseniz mÃ¼kemmel olur.

AnladÄ±ÄŸÄ±m kadarÄ±yla ÅŸirketler bir projede gerekliliÄŸe gÃ¶re bir standart belirleyip ona gÃ¶re c++ yazÄ±lÄ±yor

ÅŸirketler istiyor hocam iÅŸ ilanlarÄ±nda Ã§oÄŸu ilan da var hem C ve C++ hem de rust isteyenler var, Ã§ok fgarip gelmiÅŸti

Rust yerine Objective-c kullansak daha iyi deÄŸil mi oda gÃ¼venli bir programlama dili diye biliyorum


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 11.04-11.24 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


Bir process iÃ§in iÅŸletim sisteminin ayÄ±rdÄ±ÄŸÄ± **Heap** alanÄ± sÄ±nÄ±rlÄ± bir alandÄ±r, bu alan iÅŸletim sisteminde bazÄ± ayarlarÄ± deÄŸiÅŸtirilerek arttÄ±rÄ±labilir. </br>
Dinamik bellek edinmek iÃ§in kullanÄ±lan `malloc`, `calloc`, `realloc` fonksiyonlarÄ±nÄ±n her zaman baÅŸarÄ±lÄ± olacaÄŸÄ±nÄ±n kesinliÄŸi yoktur.


### `malloc` Fonksiyonu 

`malloc` fonksiyonu sadece bellek alanÄ± ayrÄ±lmasÄ±ndan sorumludur, ayrÄ±lan alanda ne tutulacaÄŸÄ±yla ilgilenmez, ayrÄ±ca ayrÄ±lan bellekteki alanlar **indeterminate value(garbage value)** durumundadÄ±r. </br>
`void* malloc(size_t n);` olarak bir **bildirimi(definition)** vardÄ±r, `malloc` fonksiyonu iÅŸlem baÅŸarlÄ± olursa geriye ayrÄ±lan bellek adresinin baÅŸlangÄ±cÄ±nÄ± dÃ¶ndÃ¼rÃ¼r, eÄŸer iÅŸlem baÅŸarÄ±lÄ± olamazsa geriye **NULL pointer** dÃ¶ndÃ¼rÃ¼lecektir. </br>
`malloc` fonksiyonuna geÃ§ilen argÃ¼man, ayrÄ±lmasÄ± istenilen bellek bloÄŸunun byte bÃ¼yÃ¼klÃ¼ÄŸÃ¼dÃ¼r. </br>
`malloc` fonksiyonuna yapÄ±lan Ã§aÄŸrÄ±larÄ±n baÅŸarÄ±lÄ± olma garantisi yoktur, istenildiÄŸi kadar bellek alanÄ± ayrÄ±lamazsa geriye `NULL` pointer dÃ¶necektir, baÅŸarÄ±sÄ±z durumlarÄ± dikkate alarak kod yazmak gerekiyor.


>â”
> 
> Sorulan soru; 
> 
> malloc sonucta kÃ¼tÃ¼phane fonksiyonu isletim sisteminden talepte bulunmak icin system fonk mu cagiriliyor. dogrudan sys func da cagirabilir miyiz benzer isler icin?
> 
> Cevap;
> 
> Evet kesinlikle, doÄŸrudan sistem fonksiyonu Ã§aÄŸrÄ±labilir ama o zaman taÅŸÄ±nabilirlik kaybedilir. </br>
> Standart bir fonksiyon karÅŸÄ±lÄ±ÄŸÄ± olmayan iÅŸlemlerde iÅŸletim sisteminin sistem fonksiyonlarÄ±na Ã§aÄŸrÄ± yapÄ±lmasÄ± mantÄ±klÄ± olur ama diÄŸer durumlarda bu iÅŸlem mantÄ±klÄ± olmayacaktÄ±r.


>â”
> 
> Sorulan Soru?
> 
> Sistem func nedir? c de ne kadar ve nerede kullanilir bunlara deginecek miyiz?
> 
> Cevap;
> 
> Bir derste deÄŸinilebilir ama daha Ã§ok ileri C ve sistem programlama konusuna giriyor. </br>
> Ama bir derste Windows iÅŸletim sisteminin bazÄ± sistem fonksiyonlarÄ±ndan bahsedilebilir. </br>
> Mesela GUI konusunda bir pencere oluÅŸturmak istediÄŸimizde bunu C ya da C++ dillerinin standart bir fonksiyonuyla yapma olanaÄŸÄ± yoktur ama bunu Windows API ya da Linux sisetem Ã§aÄŸrÄ±larÄ±yla yapabiliriz.


>â”
> 
> Sorulan Soru?
> 
> malloc olumsuz dÃ¶ndÃ¼gÃ¼nde ve ben dolu bir bellegi bosaltmazsam, sistem ub'ye girecek diye dÃ¼sÃ¼nÃ¼rÃ¼m , bu dogru degil mi?
> 
> Cevap;
> 
> DoÄŸru deÄŸil, `malloc` fonksiyonunun baÅŸarÄ±sÄ±z olmasÄ± **ub** deÄŸildir.


>â”
> 
> Sorulan Soru?
> 
> Geri vermeyince sistem Ã§Ã¶ker diyor yapay zeka, Ã§Ã¶kme nasÄ±l oluyor?
> 
> Cevap;
> 
> AyrÄ±lan bellek bloklarÄ±nÄ±n geri verilmemesi doÄŸrudan programÄ±n Ã§Ã¶kmesine neden olmaz, sadece bazÄ± Ã¶zel durumlarda programÄ±n Ã§Ã¶kmesi meydana gelebilir. </br>
> YZ'lara sorulan sorulardaki eksikliklerden dolayÄ± yanlÄ±ÅŸ cevap verebilir ya da soru Ã§ok karmaÅŸÄ±ksa da tam doÄŸru cevap veremeyebilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `malloc` fonksiyonu kullanÄ±larak programÄ±n Ã§alÄ±ÅŸma zamanÄ±nda deÄŸiÅŸken sayÄ±da elemanÄ± olan bir dizinin nasÄ±l oluÅŸturulduÄŸu incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    size_t n;
    printf("dizinin boyutu ne olsun: ");
    scanf("%zu", &n);

    //int* p = malloc(n * sizeof(int)); // C++ dilinde bu kullanÄ±m sÃ¶zdizim hatasÄ±dÄ±r(syntax error) Ã§Ã¼nkÃ¼ 'void*' tÃ¼rÃ¼nden 'int*' tÃ¼rÃ¼ne atama yapÄ±lÄ±yor.
    int* p = (int*)malloc(n * sizeof(int)); // Kodun daha net anlaÅŸÄ±labilmesi iÃ§in bu ÅŸekilde kullanÄ±lmasÄ± doÄŸru olacaktÄ±r. 

    // 'p == NULL' yazmak yerine '!p' ÅŸeklinde bir kullanÄ±m idiomatic olarak daha Ã§ok tercih edilmektedir.
    if(!p){
        printf("bellek yetersiz!\n");
        exit(EXIT_FAILURE);
    }

    set_array_random(p, n);
    print_array(p, n);

    free(p);
}
```


â—â—â— `malloc` fonksiyonu baÅŸarÄ±lÄ± olmasÄ± demek bu fonksiyonun bellekte ayÄ±rdÄ±ÄŸÄ± bellek bloÄŸunun tek parÃ§a olarak sÄ±ralÄ± olmasÄ± demektir. `malloc` fonksiyonunun ayÄ±rdÄ±ÄŸÄ± bellek bloklarÄ± parÃ§alÄ± olamaz, ayrÄ±lan bellek bloÄŸunun **yekpare(continuous)** olmasÄ± zorunludur.

`malloc` fonksiyonu ayÄ±rdÄ±ÄŸÄ± bellek bloÄŸunu **indeterminate value** ile vermektedir.

â—â—â— Arka arkaya `malloc` Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ±nda bellekte ayrÄ±lan alanlarÄ±n ardÄ±ÅŸÄ±k olma garantisi yoktur, bu bilgi Ã¶nemlidir.



ğŸ‘‡ AÅŸaÄŸÄ±daki program `malloc` fonksiyonu ard arda kullanÄ±ldÄ±ÄŸÄ±nda ayrÄ±lan bellek alanlarÄ±nÄ±n ardÄ±ÅŸÄ±k olmayabileceÄŸini gÃ¶rebilmek iÃ§in yazÄ±lmÄ±ÅŸtÄ±r.
```C
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int* p1 = malloc(n * sizeof(16));
    printf("adres = %p\n", p1);

    int* p2 = malloc(n * sizeof(16));  
    printf("adres = %p\n", p2);
}
```


>â”
> 
> Sorulan Soru?
> 
> Konu ile alakasÄ±z ama ÅŸunu soracaktÄ±m garbage value neye gÃ¶re deÄŸer Ã¼retiyor?
> rand() fonksiyonu gibi tohum deÄŸeri yok ama neye gÃ¶re Ã¼retiyor?
> 
> Cevap;
> 
> Bellek bloklarÄ±nda Ã¶nceki kullanÄ±mdan kaynaklanan deÄŸerlerin kalmasÄ±na ve bu deÄŸerlerde deÄŸiÅŸkenlere ilgili bellek bloÄŸunun iliÅŸkilendirilip kullanÄ±lmasÄ±na "indeterminate value" deniliyor.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda kullanÄ±lan **if statement**'ta **Unix/Linux** tarzÄ± yazÄ±lmÄ±ÅŸtÄ±r ama C++ dilinde bir nesneyi ilk deper vermeden bildirmek ve bir **if statement**'ta deÄŸerini atamak Ã§ok tercih edilen bir kodlama yaklaÅŸÄ±mÄ± deÄŸildir.
```C
#include <stdio.h>
#include <stdlib.h>,
#include "nutility.h"

int main(void)
{
    size_t n;
    printf("dizinin boyutu ne olsun: ");
    scanf("%zu", &n);
    int* p;

    // AÅŸaÄŸÄ±daki '=' operatÃ¶rÃ¼nÃ¼n Ã¼rettiÄŸi deÄŸerin nesneye atanan deÄŸre olmasÄ±ndan yararlanÄ±lmasÄ± C dilinde en Ã§ok kullanÄ±lan idiomacit kullanÄ±mlardan biridir.
    if((p = (int*)malloc(n * sizeof(int))) == NULL){
        printf("bellek yetersiz!\n");
        exit(EXIT_FAILURE);
    }

    set_array_random(p, n);
    print_array(p, n);

    free(p);
}
```



**Function wrapper**: Bir fonksiyonu doÄŸrudan Ã§aÄŸÄ±rmak yerine o fonksiyonu Ã§aÄŸÄ±ran bir fonksiyon tanÄ±mlamak tercih edilitorsa bu tÃ¼r fonksiyonlar iÃ§in yapÄ±lan tanÄ±mlamadÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `malloc` Ã§aÄŸrÄ±sÄ±nÄ±n yapÄ±lacaÄŸÄ± kod parÃ§asÄ± `checked_alloc` adÄ±nda bir fonksiyona alÄ±nÄ±yor ve bu ÅŸekilde `malloc` fonksiyonu baÅŸka bir fonksiyon tarafÄ±ndan sarmalanmÄ±ÅŸ oluyor.
```C
#include <stdio.h>
#include <stdlib.h>,
#include "nutility.h"

// AÅŸaÄŸÄ±daki fonksiyon bir 'function wrapper'dÄ±r.
void* checked_alloc(size_t n)
{
    void* p = malloc(n);

    if((!p){
        printf("cannot allocate memory!\n");
        exit(EXIT_FAILURE);
    }

    return p;
}

int main(void)
{
    size_t n;
    printf("dizinin boyutu ne olsun: ");
    scanf("%zu", &n);

    int* p = (int*)checked_alloc(n * sizeof(int));

    set_array_random(p, n);
    print_array(p, n);

    free(p);
}
```



âš ï¸ MÃ¼lakatlarda yazÄ±lmasÄ± istenilen programlarda en Ã§ok kod tekrarÄ± yapÄ±lÄ±p yapÄ±lmadÄ±ÄŸÄ±na bakÄ±lmaktadÄ±r, buna dikkat etmek gerekiyor.


"**Augmentation**" terimini daha detaylÄ± yaz!



C dilinde **varsayÄ±lan argÃ¼man(default argument)** aracÄ± yok, **function wrapper** kullanarak varmÄ±ÅŸ gibi kullanÄ±labilir. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda **function wrapper** ile nasÄ±l **varsayÄ±lan argÃ¼man(default argument)** Ã¶zelliÄŸi varmÄ±ÅŸ gibi kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>,
#include "nutility.h"

void foo(int x, int y, int z);

void call_foo(int x)
{
    foo(x, 0, 0);
}

int main(void)
{

}
```



ğŸ§  Unix/Linux sistemlerde standart olan fonksiyonlara **Posix Function** deniliyormuÅŸ, bu kavram da ayrÄ± bir derste detaylandÄ±rÄ±labilir.

ğŸ§  `itoa` adÄ± geÃ§en bir fonksiyon standart bir fonksiyon deÄŸildir ama bir Ã§ok C derleyicisinde bu isimde fonksiyon bulunmaktadÄ±r, adÄ± "**Int to Alphabeth**" sÃ¶zcÃ¼klerinden gelmektedir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Microsoft C derleyicisinde bulunan standart olmayan `_itoa` fonksiyonunun kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>,
#include "nutility.h"
#include <string.h>

int main(void)
{
    char buf1[100];
    char buf2[100];
    int x = 287342;

    _itoa(x, buf1, 2); // Ä°lk parametreye 'int' deÄŸiÅŸkenin adresi, ikinci parametreye yazÄ±nÄ±n adresi, Ã¼Ã§Ã¼ncÃ¼ parametreye sayÄ± tabanÄ± deÄŸeri geÃ§iliyor.
    _itoa(x, buf2, 16); // 

    puts(buf1);
    puts(buf2);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **function wrapper** kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>,
#include "nutility.h"
#include <string.h>

// 'mitoa' fonksiyonu sadece 10 sayÄ± tabanÄ± iÃ§in sayÄ±yÄ± yazÄ±ya dÃ¶nÃ¼ÅŸtÃ¼rme iÅŸlemi yapmaktadÄ±r, bunun iÃ§in bu fonksiyonda 'function wrapper' tekniÄŸi kullanÄ±lmÄ±ÅŸtÄ±r.
// pbuf : yazÄ±nÄ±n adresi.
// val  : yazÄ±ya Ã§evrilmek istenilen 'int' tÃ¼rÃ¼nden deÄŸiÅŸken.
char* mitoa(char* pbuf, int val)
{
    return _itoa(val, pbuf, 10);
}

int main(void)
{
    char buf[100];
    int x = 287342;

    mitoa(buf, x);

    puts(buf);
}
```



â—â—â— **Memory Leak** programÄ±n Ã§alÄ±ÅŸma sÃ¼resi boyunca programÄ± ilgilendiren bir kavramdÄ±r, process sonlandÄ±ÄŸÄ±nda ayrÄ±lan bellek alanlarÄ± zaten iade edilmiÅŸ oluyor.


ğŸ§  **Valgrind ProgramÄ±**: C dilinde **dynamic memory managament(dinamik bellek yÃ¶netimi)** iÅŸlemlerinde oluÅŸabilecek olan **memory leak** hatalarÄ±nÄ± yakalamak iÃ§in kullanÄ±lmaktadÄ±r.


ğŸ§  ProgramlarÄ±n Ã¶mrÃ¼ boyunca tutulacak bellek bloklarÄ± olduÄŸunda bile program sonlanmadan Ã¶nce `free` fonksiyonu ile bu bellek bloÄŸunun iade edilmesi iyi bir programlama alÄ±ÅŸkanlÄ±ÄŸÄ±dÄ±r, bu ÅŸekilde kodu okuyana programÄ±n Ã¶mrÃ¼ boyunca tutulacak olan bellek bloÄŸunun bilinÃ§li olarak ayrÄ±ldÄ±ÄŸÄ± bilgisi verilmiÅŸ olur. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda yukarÄ±daki durumun Ã§ok sade bir kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>,
#include "nutility.h"
#include <string.h>

int main()
{
    char* p = malloc(20000);
    
    free(); // Burada kodu okuyana main baÅŸÄ±nda ayrÄ±lan bellek bloÄŸunun bilinÃ§li olarak ayrÄ±ldÄ±ÄŸÄ± bilgisi verilmiÅŸ olur.
    return 0;
}
```


>â”
> 
> Sorulan soru; 
> 
> Global de yapabilir miyiz bu tanÄ±mÄ±? </br>
> Anladim, amacim ptr yi baska dosyalarin  kullanimina erisimine sunmakti. ptr global tanimlayip main icinde malloc ile atama yapamaz miyiz
> 
> Cevap;
> 
> HayÄ±r, bu C dilindeki **sÃ¶zdizimiyle(syntax)** ilgili bir durumdur. </br>
> C dilinde **static** Ã¶mÃ¼rlÃ¼ deÄŸiÅŸkenlere ilk deÄŸer veren ifadenin **constant expression** olmasÄ± gerekiyor yoksa **sÃ¶zdizim hatasÄ±(syntax error)** oluÅŸacaktÄ±r. </br>
> C dilinde fonksiyon Ã§aÄŸrÄ± ifadedeleri **constant expression** olamÄ±yor. </br>
> Ä°ster `malloc` fonksiyonu olsun ister herhangi bir baÅŸka fonksiyon olsun, C dilinde bir fonksiyona yapÄ±lan Ã§aÄŸrÄ± ifadesi **constant expression** deÄŸildir. C de **static** Ã¶mÃ¼rlÃ¼ deÄŸiÅŸkenlere sabit ifadesiyle ilk deÄŸer vermek mecburidir ama C++ dili bÃ¶yle bir kÄ±sÄ±tlama yok.
> 
> 
> ğŸ‘‡ AÅŸaÄŸÄ±daki programda **static** Ã¶mÃ¼rlÃ¼ deÄŸiÅŸkenlere **constant expression** dÄ±ÅŸÄ±nda ilk deÄŸer verildiÄŸinde **sÃ¶zdizim hatasÄ±(syntax error)** oluÅŸtuÄŸu incelenebilir, anlamak iÃ§in programÄ± derlemek gerekebilir. </br>
> [YZ aracÄ±nÄ±n aÅŸaÄŸÄ±daki programÄ± aÃ§Ä±klamasÄ± incelenebilir](https://chatgpt.com/share/68486f65-99bc-800a-93e0-d53a1e29efe1)
> ```C
> int foo(int);
> 
> int x = 10; // 'x' static Ã¶mÃ¼rlÃ¼ deÄŸiÅŸkeni yaÅŸamÄ±na '10' sabit deÄŸeriyle baÅŸlÄ±yor.
> int y = x + 3; // Burada 'y' static Ã¶mÃ¼rlÃ¼ deÄŸiÅŸkeninin yaÅŸamÄ±na sabit ifade olmayan 'x + 3' ile baÅŸlatÄ±lmasÄ±ndan dolayÄ± sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.
> int z = foo(x); // Burada 'z' static Ã¶mÃ¼rlÃ¼ deÄŸiÅŸkeninin yaÅŸamÄ±na sabit ifade olmayan 'foo(x)' ile baÅŸlatÄ±lmasÄ±ndan dolayÄ± sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.
> 
> int main()
> {
>     
> }
> ```
> 
> 
> ğŸ‘‡ AÅŸaÄŸÄ±daki program Ã§alÄ±ÅŸtÄ±rÄ±larak **file scope** alanÄ±nda fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±lamadÄ±ÄŸÄ± incelenebilir. </br>
> [YZ aracÄ±nÄ±n aÅŸaÄŸÄ±daki programÄ± aÃ§Ä±klamasÄ± incelenebilir](https://chatgpt.com/share/68487396-3ed4-800a-a7cc-b9f5d2230d8d)
> ```C
> #include <stdio.h>
> #include <stdlib.h>
> 
> int foo(int x)
> {
>     printf("called foo!\n");
> 	  exit(EXIT_SUCCESS);
> 
> 	  return x * 2;
> }
> 
> 
> int x = 10;
> 
> foo(x); // Buradaki gibi bir statement yazÄ±ldÄ±ÄŸÄ±nda bu geÃ§erli bir statement olmayacaktÄ±r, C derleyicisi uyarÄ± verebilir ya da bu statement'Ä± dikkate almadan derleme iÅŸlemini yapabilir. C standardÄ±nda 'file scope'ta sadece declaration(bildirim) ya da  definition(tanÄ±mlama) olabileceÄŸi belirtilmektedir, fonksiyon Ã§aÄŸrÄ±sÄ± 'file scope'ta yapÄ±lamaz.
> 
> int main(void)
> {
>     printf("called main!\n");
> }
> ```
> 
> 
> ğŸ‘‡ AÅŸaÄŸÄ±daki programda C++ dilinde programÄ±n `main` fonksiyonundan baÅŸlamak zorunda olmadÄ±ÄŸÄ± gÃ¶rÃ¼lebilir ama C dili bu programÄ± global alandaki `int g = foo();` **deyiminden(statement)** dolayÄ± Ã§alÄ±ÅŸtÄ±rmayacaktÄ±r.
> ```Cpp
> int foo();
> 
> int g = foo();
> 
> 
> int main(void)
> {
>     printf("main called!");
> }
> 
> int foo()
> {
>     printf("foo called!");
>     return 1;
> }
> ```
> 
> C dilinde bir deÄŸiÅŸkenin aynÄ± projedeki baÅŸka bir kaynak dosya tarafÄ±ndan kullanÄ±lmasÄ± isteniyorsa Ã¶zel olarak `extern` bildirime ihtiyaÃ§ vardÄ±r. Bu dersin konusu olmadÄ±ÄŸÄ± iÃ§in detaya girilmemiÅŸtir.


â—â—â— C dilinde program `main` fonksiyonundan baÅŸlamak zorundadÄ±r ama C++ dilinde program Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda `main` fonksiyonundan Ã¶nce baÅŸka fonksiyonlar Ã§alÄ±ÅŸabilir.


### `free` Fonksiyonu 

âš ï¸ `free` fonksiyonu daha basit olmasÄ±na raÄŸmen bu fonkisyonunun kullanÄ±mÄ±nda yapÄ±lan hatalar `malloc` fonksiyonunun kullanÄ±mÄ±nda yapÄ±lan hatalardan daha fazladÄ±r.

`free` fonksiyonunun prototipi `void free(void*);` ÅŸeklindedir. `free` fonksiyonu ile yapÄ±lan iÅŸlem **free the memory block** ya da **deallocate** olarak adlandÄ±rÄ±lmaktadÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `malloc` fonksiyonu ile alÄ±nan bellek bloÄŸunun nasÄ±l `free` fonksiyonuyla geri verildiÄŸi gÃ¶rÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>,
#include "nutility.h"

int main(void)
{
    size_t n;
    printf("dizinin boyutu ne olsun: ");
    scanf("%zu", &n);
    int* p;

    // AÅŸaÄŸÄ±daki '=' operatÃ¶rÃ¼nÃ¼n Ã¼rettiÄŸi deÄŸerden yararlanÄ±lmasÄ± C dilinde en Ã§ok kullanÄ±lan idiomacit kullanÄ±mlardan biridir.
    if((p = (int*)malloc(n * sizeof(int))) == NULL){
        printf("bellek yetersiz!\n");
        exit(EXIT_FAILURE);
    }

    set_array_random(p, n);
    print_array(p, n);

    free(p); // Bu fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±ldÄ±ktan sonra 'p' gÃ¶stericisine eriÅŸilmek istenmesi 'dangling pointer' hatasÄ±na neden olacaktÄ±r.

    // Bu noktadan sonra 'p' gÃ¶stericisine 'dangling pointer' denilmektedir ve 
}
```


>â”
> 
> SorduÄŸum soru; 
> 
> Bir process'in edindiÄŸi bellek bloklarÄ±nÄ±n nereleri olduÄŸu bilgisi iÅŸletim sisteminde mi tutuluyor(nasÄ±l tutuluyor), iÅŸletim sistemi olmayan microcontroller'lar Ã¼zerinde Ã§alÄ±ÅŸacak C programlarÄ±nda bellek tahsisi iÅŸlemleri nasÄ±l iÅŸliyordu, kÄ±saca bilgi paylaÅŸabilir misiniz?
> 
> Cevap;
> 
> Bir sonraki derste cevap verilebileceÄŸi belirtildi, aÃ§Ä±klamasÄ±nÄ±n uzun sÃ¼receÄŸi iÃ§in.


#### `free` Fonksiyonunun KullanÄ±mÄ±nda SÄ±k YapÄ±lan Hatalar 


1. `free` fonksiyonuna yapÄ±lan Ã§aÄŸrÄ±nÄ±n tanÄ±msÄ±z davranÄ±ÅŸ olmamasÄ± iÃ§in `free` fonksiyonuna gÃ¶nderilen adresin `malloc`, `calloc`, `realloc` fonkisyonlarÄ±yla edinilen bellek bloÄŸunun adresi olmasÄ± gerekir, bunun dÄ±ÅŸÄ±nda adres geÃ§ilirse tek bir istisna dÄ±ÅŸÄ±nda **ub** durumuna neden olacaktÄ±r.

    ğŸ‘‡ AÅŸaÄŸÄ±daki programda `malloc`, `calloc`, `realloc` fonkisyonlarÄ±yla elde edilmemiÅŸ bir adresin `free` fonksiyonuna argÃ¼man olarak geÃ§ilmesinin **ub** durumuna neden olduÄŸu incelenebilir.
    ```C
    #include <stdio.h>
    #include <stdlib.h>,
    #include "nutility.h"

    int main(void)
    {
        char str[100] = "";

        char* p1 = str;
        char* p2 = (char*)malloc(1000);

        free(p1); // Buradaki fonksiyon Ã§aÄŸrÄ±sÄ± 'ub' durumuna neden olur. Derleyiciler burada uyarÄ± iletisi da veremeyecektir Ã§Ã¼nkÃ¼ buradaki sorun run-time sorunudur.
    }
    ```

2. `malloc`, `calloc`, `realloc` fonkisyonlarÄ±yla elde edilmemiÅŸ bellek alanlarÄ±nÄ±n bir kÄ±smÄ±nÄ± iade etmek iÃ§in `free` fonksiyonuna Ã§aÄŸrÄ± yapmak tanÄ±msÄ±z davranÄ±ÅŸtÄ±r.

    ğŸ‘‡ AÅŸaÄŸÄ±daki programda `malloc` fonksiyonu ile elde edilmiÅŸ olan bellek bloÄŸunun sadece yarÄ±sÄ±nÄ±n iade edilmesi iÃ§in `free` fonksiyonuna Ã§aÄŸrÄ± yapÄ±lmasÄ±ndan dolayÄ± **ub** durumu oluÅŸacaÄŸÄ± gÃ¶rÃ¼lmelidir.
    ```C
    #include <stdio.h>
    #include <stdlib.h>,
    #include "nutility.h"

    int main(void)
    {
        char* ptr = (char*)malloc(1000);

        free(ptr + 500); // Buradaki fonksiyon Ã§aÄŸrÄ±sÄ± 'ub'dir. 'malloc' ya da 'calloc' ile ayrÄ±lan bellek alanlarÄ±nÄ±n bir kÄ±smÄ±nÄ± iade etmek iÃ§in Ã§aÄŸrÄ± yapÄ±lmamalÄ±dÄ±r.
    }
    ```

3. En sÄ±k yapÄ±lan hatalardan biri olarak `free` fonksiyonuyla iade edilen belleÄŸi gÃ¶steren bir nesnenin(bu nesnelere **dangling pointer** deniliyor) kullanÄ±lmasÄ±dÄ±r. 

    ğŸ‘‡ AÅŸaÄŸÄ±daki programda **dangling pointer** kullanÄ±lmasÄ±nÄ±n **ub** durumuna neden olduÄŸu incelenebilir.
    ```C
    #include <stdio.h>
    #include <stdlib.h>,
    #include "nutility.h"

    int main(void)
    {
        size_t n;
        printf("dizinin boyutu ne olsun: ");
        scanf("%zu", &n);
        int* p;

        // AÅŸaÄŸÄ±daki '=' operatÃ¶rÃ¼nÃ¼n Ã¼rettiÄŸi deÄŸerden yararlanÄ±lmasÄ± C dilinde en Ã§ok kullanÄ±lan idiomacit kullanÄ±mlardan biridir.
        if((p = (int*)malloc(n * sizeof(int))) == NULL){
            printf("bellek yetersiz!\n");
            exit(EXIT_FAILURE);
        }

        set_array_random(p, n);
        print_array(p, n);

        free(p); // Bu fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±ldÄ±ktan sonra 'p' gÃ¶stericisine eriÅŸilmek istenmesi 'dangling pointer' olacaktÄ±r.

        print_array(p, n); // 'dangling pointer' durumundan dolayÄ± 'ub'dir.
    }
    ```


Ders sonu ...
