# 59.Ek Ders
---


## C99 StandardÄ±yla Dile Eklenen Ã–zellikler Devam

### Inline Functions

Bu konuyu iyi anlayabilmek iÃ§in ilk Ã¶nce **Inline Extension** tavramÄ±nÄ± bilmek ve **makro** kullanÄ±mÄ±nÄ± bilmek gerekiyor. </br>
**Inline Extension** derleyicilerin uyguladÄ±ÄŸÄ± **iyileÅŸtirme(optimization)** yÃ¶ntemidir. **Inline Extension** bir fonksiyon Ã§aÄŸrÄ±sÄ±nda derleyici Ã§aÄŸÄ±rÄ±lan fonksiyonun tanÄ±mÄ±nÄ± gÃ¶rÃ¼yor ve **linker** programÄ±n baÄŸlamasÄ± iÃ§in object koda bir referans ad yazmak yerine doÄŸrudan fonksiyonun derlenmiÅŸ kodunu yani o fonksiyonun yaptÄ±ÄŸÄ± iÅŸi yapacak makine komutlarÄ±nÄ± fonksiyon Ã§aÄŸrÄ±sÄ±nÄ±n olduÄŸu yere yerleÅŸtiriyor. </br>
Derleyicilerin **Inline Extension** uygulamasÄ±nÄ±n nedeni daha hÄ±zlÄ± Ã§alÄ±ÅŸan kod Ã¼retmektir. Fonksiyon olarak baÄŸlandÄ±ÄŸÄ±nda fonksiyona giriÅŸ ve fonksiyondan Ã§Ä±kÄ±ÅŸ kodlarÄ±nÄ±n maliyeti de koda eklenir, **Inline Extension** uygulandÄ±ÄŸÄ±nda bu maliyet koda eklenmez. </br>
Kodun verimliliÄŸini en fazla etkileyen **iyileÅŸtirme(optimization)** yÃ¶ntemlerinden biri **Inline Extension** yÃ¶ntemidir. </br>
**Inline Extension** uygulanma biÃ§imi derleyicilerin **anahtarlarÄ±yla(switch)** ayarlanabiliyor(yap, yapma, agrasif olarak yap vb.).


ğŸ‘‡ AÅŸaÄŸÄ±daki sÃ¶zde kodda **Inline Extension** iÅŸlemiyle ilgili bilgi alÄ±nabilir.
```Text

expr statement;
expr statement;
foo(x, y); // Derleyici burada fonksiyonun tanÄ±mÄ±nÄ± gÃ¶rebiliyorsa bazÄ± iyileÅŸtirmeleri yapabilir ama gÃ¶remiyorsa yapamaz. Burada fonksiyon Ã§aÄŸrÄ±sÄ± yapmak yerine fonksiyonun kodu doÄŸrudan kullanÄ±lsa derleyicinin yapabileceÄŸi iyileÅŸtirme imkanÄ± geniÅŸleyecektir.
expr statement;
expr statement;
```


ğŸ§­ Derleyicilerin **Inline Extension** yapabilmesi iÃ§in saÄŸlanmasÄ± gereken koÅŸullar aÅŸaÄŸÄ±daki gibidir;
1. Derelyicinin Ã§aÄŸÄ±rÄ±lan fonksiyonun tanÄ±mÄ±nÄ± gÃ¶rmesi gerekyor.
2. Derelyicinin sÃ¶zkonusu fonksiyon Ã§aÄŸrÄ±sÄ± iÃ§in **Inline Extension** yapabilecek kabiliyette olmasÄ± gerekiyor, her derleyici aynÄ± deÄŸildir ve her derleyicinin yeteneÄŸi aynÄ± olmadÄ±ÄŸÄ± iÃ§in.
3. Derelyicinin **Inline Extension** yapÄ±p yapmaya karar vermesi gerekiyor, fonksiyonun kodu Ã§ok bÃ¼yÃ¼kse **Inline Extension** yapmak doÄŸru olmayabilir.
4. Derelyicinin **anahtarlarÄ±nÄ±n(switch)** **Inline Extension** yapabilmeye izin veriyor olmasÄ± gerekiyor.


C99 diliyle birlikte C diline C++ dilinde zaten varolan `inline` anahtar sÃ¶zcÃ¼ÄŸÃ¼ eklendi, bu anahtar sÃ¶zcÃ¼ÄŸÃ¼ C99 ile dil eklenen diÄŸer anahtar sÃ¶zcÃ¼klerin adlarÄ±nÄ±n `_` ve bÃ¼yÃ¼k harfle baÅŸlamasÄ±ndan farklÄ± olarak tÃ¼m harfleri kÃ¼Ã§Ã¼ktÃ¼r. </br>
`inline` anahtar sÃ¶zcÃ¼ÄŸÃ¼ iÃ§in dile **function specifier** adÄ±nda yeni bir kategori eklendi. </br>
`inline` anahtar sÃ¶zcÃ¼ÄŸÃ¼ bir fonksiyonun tanÄ±mÄ±nda geri dÃ¶nÃ¼ÅŸ deÄŸerinin Ã¶ncesinde kullanÄ±lÄ±yor, bÃ¶ylece derleyiciden ilgili fonksiyonun **Inline Extension** iÅŸlemine tabi tutulmasÄ± iÃ§in rica edildiÄŸi anlamÄ±na geliyor, derleyici sonuÃ§ta **Inline Extension** yapÄ±p yapmamaya kendisi karar veriyor.
Bir fonkisyon `inline` anahtar sÃ¶zcÃ¼ÄŸÃ¼ olmadan tanÄ±mlandÄ±ÄŸÄ±nda bile derleyici **Inline Extension** yapabilir. </br>
Bir fonkisyon `inline` anahtar sÃ¶zcÃ¼ÄŸÃ¼ ile tanÄ±mlandÄ±ÄŸÄ±nda bile derleyici **Inline Extension** yapmayabilir.


ğŸ‘‡ AÅŸaÄŸÄ±daki program parÅŸasÄ±nda `inline` fonksiyon kullanÄ±mÄ±na dair bazÄ± bilgiler edinilebilir. `inline` fonksiyonlar Ã¼Ã§ farklÄ± biÃ§imde tanÄ±mlanabiliyor bu Ã¼Ã§ farklÄ± tanÄ±mlama yÃ¶ntemini iyi bilmek gerekiyor.
```C
// 'inlinetest.h' baÅŸlÄ±k dosyasÄ± iÃ§eriÄŸi

// ...

// 'func1' fonksiyonun tanÄ±mÄ±nÄ±n burada yapÄ±lmasÄ± doÄŸru olmaz Ã§Ã¼nkÃ¼ bu baÅŸlÄ±k dosyasÄ±nÄ± birden fazla kaynak dosya 'include' ederse o zaman 'link' aÅŸamasÄ±nda sorun oluÅŸur. 
// C++ dilinde 'One Defination Rule' denilen terim yazÄ±lÄ±msal terimlerin sadece bir tane tanÄ±mÄ± olabileceÄŸini belirtir, C dili bunu aÃ§Ä±kÃ§a sÃ¶ylemese de C dilinde de bu geÃ§erlidir.
int func1(int x, int y)
{
    return x * y +7;
}


// C dilinde bir 'inline' fonkisyon Ã¼Ã§ farklÄ± biÃ§imde bulunabilir.

// 'func2' fonksiyonun tanÄ±mÄ±nÄ±n burada yapÄ±lmasÄ± doÄŸrudur, 
inline int func2(int x, int y)
{
    return x * y + 6;
}


// 'func3' fonksiyonun tanÄ±mÄ±nÄ±n burada yapÄ±lmasÄ± doÄŸrudur, 
static inline int func3(int x, int y)
{
    return x * y - 7;
}



// 'func4' fonksiyonun tanÄ±mÄ±nÄ±n burada yapÄ±lmasÄ± doÄŸrudur, 
extern inline int func4(int x, int y)
{
    return x * y + 9;
}


// ...
```



Bir `inline` fonksiyona Ã§aÄŸrÄ± yapÄ±ldÄ±ÄŸÄ±nda derleyiciler bir Ã§ok incelemeyi yapmaktadÄ±r(mesela derleyici bir `inline` fonksiyona yapÄ±lan Ã§aÄŸrÄ± ile o `inline` fonksiyonun parametre sayÄ±sÄ± ve uyumunu sÄ±namaktadÄ±r) ama makrolar bÃ¶yle deÄŸildir doÄŸrudan ilgili makro kodu Ã¶niÅŸlemci program yerdeÄŸiÅŸtirme iÅŸlemine tabi tutar. </br>
**Function like makro** kullanÄ±mÄ±na gÃ¶re `inline` fonksiyon kullanÄ±mÄ± gÃ¼venlik aÃ§Ä±sÄ±ndan daha iyidir.



`inline` fonksiyonlarÄ±n farklÄ± tanÄ±mlarÄ± arasÄ±ndaki farklar;


ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki farklÄ± dosya iÃ§eriÄŸi gÃ¶sterilmiÅŸtir, burada `inline` olarak tanÄ±mÄ± bir baÅŸlÄ±k dosyasÄ±nda yapÄ±lan bir fonksiyonun adresinin kullanÄ±mÄ±nÄ±n derleyicinin **Inline Extension** yapÄ±p yapmamasÄ±na gÃ¶re deÄŸiÅŸeceÄŸi durum bilgisi incelenebilir.
```C
/* 'inlinetest.h' dosya baÅŸÄ± */

// 'inlinetest.h' baÅŸlÄ±k dosyasÄ± iÃ§eriÄŸi

// EÄŸer sadece aÅŸaÄŸÄ±daki gibi 'foo' fonksiyonu tanÄ±mlanÄ±yorsa tÃ¼m 'foo' fonksiyon Ã§aÄŸrÄ±larÄ±nÄ±n derleyici tarafÄ±ndan 'inline extension' iÅŸlemine tabi tutulmasÄ± gerekecek ya da projeyi oluÅŸturan bu modÃ¼lde ya da baÅŸka bir modÃ¼lde 'foo' adÄ±nda bir fonksiyon tanÄ±mÄ± olmasÄ± gerekiyor.
// 'inline' olan 'foo' fonksiyonunun iÃ§eriÄŸiyle 'inline' olmayan 'foo' fonksiyonunun iÃ§eriÄŸi aynÄ± olmak zorunda deÄŸil.
inline int foo(int x, int y)
{
    return x * y +7;
}


/* 'inlinetest.h' dosya sonu */



/* 'main.c' dosya baÅŸÄ± */

int main(void)
{
    // EÄŸer derleyici 'inline extension' yapmazsa 'inlinetest.h' baÅŸlÄ±k dosyasÄ±ndaki 'foo' fonksiyon tanÄ±mÄ± '&foo' ile eÅŸleÅŸecek durumda olmayacaktÄ±r.
    // Derleyici 'inline extension' yapmadÄ±ÄŸÄ±nda 'foo' fonksiyonunu 'external' olarak baÅŸka bir modÃ¼lde tanÄ±mlanmÄ±ÅŸ bir fonksiyon olarak varsayacaktÄ±r.
    int (*fp)(int, int) = &foo; 
}

/* 'main.c' dosya sonu */
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda en Ã§ok kullanÄ±lan **Inline Extension** yapÄ±sÄ± olan `inline` anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼ `static` anahtar sÃ¶zcÃ¼ÄŸÃ¼yle birlikte kullanmaktÄ±r, bu durumda **Inline Extension** yapÄ±labiliyorsa yapÄ±lacak yapÄ±lamazsa her modÃ¼lde ayrÄ± bir `internal` fonksiyon olmasÄ± gerekecektir.
```C
/* 'inlinetest.h' dosya baÅŸÄ± */

// 'inlinetest.h' baÅŸlÄ±k dosyasÄ± iÃ§eriÄŸi

// 'foo' fonkisyonu 'inline extension' uygulanmadÄ±ÄŸÄ±nda Ã¼retilecek olan 'object' koda yazÄ±lmayacaktÄ±r.
static inline int foo(int x, int y)
{
    return x * y +7;
}


/* 'inlinetest.h' dosya sonu */



/* 'main.c' dosya baÅŸÄ± */

int main(void)
{
    int (*fp)(int, int) = &foo; 
}

/* 'main.c' dosya sonu */
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda 
```C
/* 'inlinetest.h' dosya baÅŸÄ± */

// 'inlinetest.h' baÅŸlÄ±k dosyasÄ± iÃ§eriÄŸi

// 'foo' fonkisyonu 'inline extension' uygulanmadÄ±ÄŸÄ±nda bu fonksiyonun bulunduÄŸu baÅŸlÄ±k dosyasÄ± koduna dahil eden tÃ¼m kaynak dosyalarda bu fonksiyonun 'external' olarak tanÄ±mÄ±nÄ±n olmasÄ± gerekiyor.
extern inline int foo(int x, int y)
{
    return x * y +7;
}


/* 'inlinetest.h' dosya sonu */



/* 'main.c' dosya baÅŸÄ± */

int main(void)
{
    int (*fp)(int, int) = &foo; 
}

/* 'main.c' dosya sonu */
```



ğŸ§  **Inline Function**'lar kodu kÃ¼Ã§Ã¼k olan ve **function-like makro**'larÄ±n yerine kullanÄ±labilecek yapÄ±lardÄ±r, kimse kodu bÃ¼yÃ¼k olan fonksiyonlarÄ± **Inline Function** olarak kullanmaz.


C++ dilinde `inline` anahtar sÃ¶zcÃ¼ÄŸÃ¼ daha farklÄ± kullanÄ±lÄ±yor, C++ dilinde bir fonksiyon `inline` anahtar sÃ¶zcÃ¼ÄŸÃ¼yle tanÄ±mlandÄ±ÄŸÄ±nda bu fonksiyon sÄ±radan bir fonksiyon gibi ele alÄ±nÄ±r. </br> 
Bir derleyici `inline` olarak bildirilen bir fonksiyonu **inline extension** uyguladÄ±ÄŸÄ±nda kullanÄ±r ama uygulanmadÄ±ÄŸÄ±nda da diÄŸer fonksiyon tanÄ±mlarÄ± gbi ele alÄ±r ve bir `inline` fonksiyon `external` olarak bildirilmediÄŸi sÃ¼rece baÅŸka modÃ¼llerde tanÄ±mÄ±nÄ±n yapÄ±lmÄ±ÅŸ olmasÄ± gerekmemektedir. </br>
C++ dilindeki kurallar daha tutarlÄ±, bazÄ± derleyiciler **Inline Function** kullanÄ±mÄ±na dair kurallarÄ± C standardÄ±ndaki gibi deÄŸil de C++ standardÄ±ndaki gibi gerÃ§ekleÅŸtirmiÅŸ olabilir.


### Variadic Macros 

C99 standardÄ±yla dile makro'larÄ±n da **vaiadic** olabilme Ã¶zelliÄŸi getirilmiÅŸtir. </br>
Variadic Macro'larda da yine elipsis(`...`) yoken'Ä± kullanÄ±lmaktadÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **variadic macro** kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

#define eprintf(...)   fprintf(stderr, __VA_ARGS__) // 'Variadic macro' bildirimi


int main()
{
    int a = 5, b = 78;
    double dval = 24.64;

    eprintf("error : a = %d  b = %d  dval = %f\n", a, b, dval);
    // fprintf(stderr ,"error : a = %d  b = %d  dval = %f\n", a, b, dval); // Ã–niÅŸlemci program yukarÄ±daki 'variadic macro'yu bÃ¶yle aÃ§acaktÄ±r. 
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **variadic macro** kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

#define printlist(...)  puts(#__VA_ARGS__)   // 'Variadic macro' bildirimi


int main()
{
    printlist();
    // puts(""); // Ã–niÅŸlemci program yukarÄ±daki 'variadic macro'yu bÃ¶yle aÃ§acaktÄ±r.


    printlist(mete, atilla, timur);
    // puts("mete, atilla, timur"); // Ã–niÅŸlemci program yukarÄ±daki 'variadic macro'yu bÃ¶yle aÃ§acaktÄ±r.


    printlist(mete, "atilla", "timur");
    // puts("mete, \"atilla\", \"timur\""); // Ã–niÅŸlemci program yukarÄ±daki 'variadic macro'yu bÃ¶yle aÃ§acaktÄ±r.
}
```


### `//` BiÃ§iminde Tek SatÄ±rlÄ±k Yorum SatÄ±rlarÄ± Kullanabilme 

Tek satÄ±rlÄ±k yorum satÄ±rlarÄ± C dilinin C99 standardÄ±yla birlikte dile eklenmiÅŸtir, tabi derleyiciler bu Ã¶zelliÄŸi extension olarak sunabiliyordu.


### `for` DÃ¶ngÃ¼sÃ¼ Deyiminde DeÄŸiÅŸken TanÄ±mlayabilme 

`for` statement expression'Ä±nda sÄ±klÄ±kla kullanÄ±lan sayaÃ§ deÄŸiÅŸkeninin tanÄ±mlanabilmesi C99 ile dile eklenmiÅŸtir, tabi derleyiciler bu Ã¶zelliÄŸi extension olarak sunabiliyordu.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `for` statement'a C99 ile getirilen kullanÄ±m yeniliÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    // AÅŸaÄŸÄ±daki for statement'Ä±n sahip olduÄŸu expression bÃ¶lÃ¼mÃ¼nde 'i' deÄŸiÅŸkeninin tanÄ±mlanabilmesi C99 ile dile eklenmiÅŸtir.
    for(int i = 0; i < 10; ++i){
        printf("i = %d", i);
    }

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ kodunda C diline Ã¶zgÃ¼ ilginÃ§ bir durum incelenebilir.
    for(int i = 0; i < 10; ++i){
        int i = 99; // Burada dÃ¶ngÃ¼nÃ¼n 'i' deÄŸiÅŸkeni gizlenmektedir(nam hiding). Bu tanÄ±mlama C dilinde geÃ§erli(legal), C++ dilinde geÃ§erli deÄŸildir(illegal).
        printf("i = %d\n", i); // On defa 'i = 99\n' standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderilir.
    }
}
```


### Executable statement KullanÄ±mÄ±ndan Sonra DeÄŸiÅŸken TanÄ±mlayabilme 

**Executable statement** kullandÄ±ktan sonra deÄŸiÅŸken bildirimi yapabilme Ã¶zelliÄŸi C99 standardÄ±yla dile eklenmiÅŸtir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda dile C99 ile getirilen deÄŸiÅŸken bildirimi Ã¶zelliÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    printf("some string\n");
    int x = 7; // Bu kod C89'da sÃ¶zdizim hatasÄ±dÄ±r ama C99 ve sonrasÄ±nda legal'dir.
}
```



### Implicity Function Decleration KullanÄ±mÄ± Dilden KaldÄ±rÄ±ldÄ± 

**Implicity Function Decleration** kullanÄ±mÄ±nÄ±n C99 standardÄ±yla birlikte dilden kaldÄ±rÄ±ldÄ±.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda C99 ile dilden kaldÄ±rÄ±lan kaldÄ±rÄ±lan **Implicity Function Decleration** kullanÄ±mÄ±nÄ±n ne olduÄŸu gÃ¶rÃ¼lebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = foo(13); // Buradaki 'foo' fonksiyonunun bildirimi yapÄ±lmamÄ±ÅŸ olsa da dil sanki 'int foo();' bildirimi yapÄ±lmÄ±ÅŸ gibi davranÄ±yordu(yani bu durumda sÃ¶zdizim hatasÄ± vermiyordu) ama C99 ile bu dilden kaldÄ±rÄ±ldÄ±.
}
```

### Implicity `int` KullanÄ±mÄ± Dilden KaldÄ±rÄ±ldÄ± 

**Implicity `int`** kullanÄ±mÄ±nÄ±n C99 standardÄ±yla birlikte dilden kaldÄ±rÄ±ldÄ±.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda C99 ile dilden kaldÄ±rÄ±lan kaldÄ±rÄ±lan **Implicity `int`** kullanÄ±mÄ±nÄ±n ne olduÄŸu gÃ¶rÃ¼lebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

// C99 Ã¶ncesinde aÅŸaÄŸÄ±daki gibi fonksiyon bildirimleri legaldi, varsayÄ±lan dÃ¶nÃ¼ÅŸ tÃ¼rÃ¼ 'int' tÃ¼rÃ¼ kabulediliyordu.
foo(void); // C89'da fonksiyon bildirimi 'int foo(void);' biÃ§iminde kabuledilir.

bar(void)  // C89'da fonksiyon bildirimi 'int bar(void);' biÃ§iminde kabuledilir.
{

}
```



### Designated Initialisers Ã–zelliÄŸi 

**Designated Initialisers** ile dizilerde(arrays), yapÄ±larda(structs) ve birliklerde(unions) herhangi bir ya da birkaÃ§ elemanÄ±n baÅŸlangÄ±Ã§ deÄŸerinin belirlenmesinin kolayca yapÄ±labilmesi ve ilk deÄŸer verilmeyenlerin "0", "NULL" vb. deÄŸerler olur.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda C99 ile dile eklenen **Designated Initialisers** Ã¶zelliÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


typedef struct {
    int a, b, c;
    int ary[3];
    char str[20];
} Data;


int main(void)
{
    int ary[] = { [3] = 7, [2] = -3 }; // Bir dizide 'designated initialisers' aracÄ±nÄ±n kullanÄ±mÄ± bu biÃ§imdedir. Buradaki dizinin elemanlarÄ±na verilen ilk deÄŸerler 'constant expression(sabit ifadesi)' olmak zorundadÄ±r.

    // AÅŸaÄŸÄ±da 'designated initialisers' aracÄ±nÄ±n kullanÄ±mÄ± ile bir yapÄ±ya nasÄ±l ilk deÄŸer verildiÄŸi incelenebilir. 
    Data date01 = {
        .b = 21524,
        .ary = { 2, 7 },
        .str = "atilla"
    };
}
```


### C Dilinde Olan Dizilerin FonksiyonlarÄ±n ArgÃ¼manÄ± OlmasÄ± DurumlarÄ±ndaki BazÄ± Ä°lginÃ§ KullanÄ±mlar 

`void foo(int x[]);`, `void foo(int x[11]);` fonksiyon bildirimlerinde fonksiyonlarÄ±n parametresinin tÃ¼rÃ¼ `int*` olacaktÄ±r, bu Ã¶zellik C dilinde ilk baÅŸtan beri mevcuttur. </br>
`void foo(const int x[]);` fonksiyon bildirimi `void foo(const int x*);` olarak deÄŸerlendirilir. </br>
`void foo(int x[const]);` fonksiyon bildirimi `void foo(int * const x);` olarak deÄŸerlendirilir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda sadece C diline Ã¶zgÃ¼ olan bir fonksiyonda dizi argÃ¼manÄ± kullanÄ±mÄ± incelenebilir.
```C
void foo(int x[const])
{
    *x = 45; // legal
    ++x; // illegal
}

int main(void)
{


}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda C99 ile dile eklenen dizi tÃ¼rÃ¼nÃ¼n fonksiyon argÃ¼manÄ± olarak geÃ§ilmesiyle ilgili durum incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


// AÅŸaÄŸÄ±daki fonksiyonun parametresinin 'int p[static 10]' olmasÄ± 'en az 10 elemana sahip bir dizinin adresinin argÃ¼man olarak beklendiÄŸi anlamÄ±na gelmektedir' anlamÄ±na gelmektedir.
void func(const int p[static 10])
{    
    for(int i = 0; i < 10; ++i){
        printf("%d ", p[i]);
    }
    printf("\n");
}

int main(void)
{
    int ary1[5] = { 3, 5, 78, 2, 8 };
    int ary2[20] = { 3, 5, 78, 2, 8 };

    funct(ary1); // Burada 'func' fonksiyonuna on elemandan kÃ¼Ã§Ã¼k bir dizinin adresinin geÃ§ilmesi 'ub'ye neden olabilir, derleyici burada uyarÄ± iletisi verecektir(ya da bu Ã¶zellik desteklenmeye de bilir ve sÃ¶zdÃ¼zÃ¼m hatasÄ± oluÅŸur, Ã§ok kullanÄ±lan bir Ã¶zellik deÄŸil).
    funct(ary2); 
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 20.36-20.37 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


## Ã–nceden Ä°ncelenmeyen BazÄ± Ã–zenmli Standart C FonksiyonlarÄ± 


### `fropen` Fonkiyonu 

Bu fonksiyonun bildirimi `stdio.h` dosyasÄ±nda bulunmaktadÄ±r. Bu fonksiyonun adÄ± "**file re open**" sÃ¶zcÃ¼klerinden elde edilmiÅŸtir. </br>
Bu fonksiyonun prototipi `FILE* fropen(const char* pname, const char* pmode, FILE*);` biÃ§imindedir. Bu fonkisyon Ã¼Ã§Ã¼ncÃ¼ parametresine geÃ§ilen **file handle**'Ä±n iliÅŸkili olduÄŸu dosyayÄ± kapatÄ±r ve o **file handle**'Ä± `pname` adÄ±nda `pmode` olarak aÃ§Ä±lmÄ±ÅŸ dosyanÄ±n **file handle**'Ä± olarak geri verir, fonksiyon iÅŸini yapamadÄ±ÄŸÄ±nda geriye `NULL pointer` dÃ¶ndÃ¼rÃ¼lÃ¼r. </br>
Bu fonksiyon genellikle standart giriÅŸ ya da Ã§Ä±kÄ±ÅŸ akÄ±mÄ±nÄ± yÃ¶nlendirmek iÃ§in kullanÄ±lÄ±r, bir iÅŸletim sisteminin komut satÄ±rÄ±ndan giriÅŸ veya Ã§Ä±kÄ±ÅŸ akÄ±mlarÄ±nÄ±n yÃ¶nlendirmesinin yapÄ±lmasÄ±nÄ±n yerine bu yÃ¶nlendirmenin koddan yapÄ±lmasÄ± iÃ§in kullanÄ±lan bir fonksiyondur.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    puts("standart output directive to console.\n");

    FILE* f = freopen("out.txt", "w", stdout);

    if(!f){
        printf("%p %p\n", f, stdout);
    }
    else{
        printf("basarisiz.\n");
    }

    if(freopen("neco.txt", "w", stdout) == NULL){
        perror("freopen failed!\n");
        return 1;
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `freopen` fonksiyonu ile standart Ã§Ä±ktÄ± akÄ±mÄ±nÄ±n koddan nasÄ±l bir dosyaya yÃ¶nlendirilebileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    puts("standart output directive to console.\n");

    if(freopen("neco.txt", "w", stdout) == NULL){
        perror("freopen failed!\n");
        return 1;
    }

    puts("necati ergin\n");
    printf("mete uluhakan");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `freopen` fonksiyonu ile standart Ã§Ä±ktÄ± akÄ±mÄ±nÄ±n koddan nasÄ±l bir dosyaya yÃ¶nlendirilebileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    puts("standart output directive to console.\n");

    if(freopen("neco.txt", "w", stdout) == NULL){
        perror("freopen failed!\n");
        return 1;
    }

    for(int i = 0; i < 10; ++i){
        printf("%d\n", i);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `freopen` fonksiyonu ile standart Ã§Ä±ktÄ± akÄ±mÄ±nÄ±n koddan nasÄ±l bir dosyaya yÃ¶nlendirilebileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    puts("standart output directive to console.\n");

    FILE* = freopen("out.txt", "w", stdout);

    if(!f){
        perror("freopen failed!\n");
        return 1;
    }

    for(int c = 'A'; c < 'Z'; ++c){
        putchar(c);
    }

    fclose(f);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `freopen` fonksiyonu ile standart giriÅŸ akÄ±mÄ±nÄ±n kod tarafÄ±ndan nasÄ±l bir dosyadan okunabileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    puts("standart output directive to console.\n");

    if(!freopen("out.txt", "r", stdin)){
        fprintf(stderr, "yonlendirme yapilamadi!\n");
        return 1;
    }
    
    int c;

    while((c == getchar()) != '\n'){
        putchar(c);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `freopen` fonksiyonu ile standart giriÅŸ akÄ±mÄ±nÄ±n kod tarafÄ±ndan nasÄ±l bir dosyadan okunabileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    puts("standart output directive to console.\n");

    if(!freopen("out.txt", "r", stdin)){
        fprintf(stderr, "yonlendirme yapilamadi!\n");
        return 1;
    }
    
    int c;

    while((c == getchar()) != '\n'){
        putchar(c);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `freopen` fonksiyonu ile standart giriÅŸ akÄ±mÄ±nÄ±n kod tarafÄ±ndan `scanf` fonksiyonu ile nasÄ±l bir dosyadan okunabileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    puts("standart output directive to console.\n");

    if(!freopen("out.txt", "r", stdin)){
        fprintf(stderr, "yonlendirme yapilamadi!\n");
        return 1;
    }
    
    char str[256];
    int x, y;
    double dval;

    int n = scanf("%s%d%d%lf", str, &x, &y, &dval);

    if(n == 4){
        puts(str);
        printf("x = %d y = %d dval = %f\n", x, y, dval);
    }
}
```


### `mktime` Fonksiyonu 

Bu fonksiyonun bildirimi `time.h` dosyasÄ±nda bulunmaktadÄ±r. Bu fonksiyonun adÄ± "**make time**" sÃ¶zcÃ¼klerinden elde edilmiÅŸtir. </br>
Bu fonksiyonun prototipi `time_t mktime(struct tm*);` biÃ§imindedir. Bu fonksiyon `localtime` fonksiyonun yaptÄ±ÄŸÄ± iÅŸlemin tersini yapmaktadÄ±r, bu fonksiyon `struct tm` tÃ¼rÃ¼nÃ¼ `time_t` tÃ¼rÃ¼ne Ã§evirmek iÃ§in kullanÄ±lÄ±r.
`mktime` fonksiyonu kendisine geÃ§ilen `struct tm` tÃ¼rÃ¼ndeki nesnenin Ã¼yelerinin deÄŸerlerini inceleyip yanlÄ±ÅŸlÄ±k varsa dÃ¼zeltir, mesela ayÄ±n gÃ¼nÃ¼ 31'den bÃ¼yÃ¼kse fazladan gÃ¼nÃ¼ aya ekler ve ayÄ±n gÃ¼nÃ¼ Ã¼yesinin deÄŸerini deÄŸiÅŸtiri vb.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `mktime` fonksiyonunun kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <time.h>

int main(void)
{
    // n gÃ¼n Ã¶ncesinin tarihini yazdÄ±rmak istiyoruz diyelim.
    int n;

    printf("kac gun oncesi: ");
    scanf("%d", &n);

    //&(time_t) {time(NULL)} // compound literal kullanÄ±mÄ±.
    struct tm tm = *localtime(& (time_t) { time(NULL) });

    printf("today is: %s", asctime(&tm));
    tm.tm_mday -= n;
    
    mktime(&tm); // 'mktime' 'struct tm' nesnesini normalize edecektir.

    printf("%d days ago was : %s", asctime(&tm));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `mktime` fonksiyonunun kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <time.h>

const char* const days[] = { "Pazar", "Pazartesi", "Sali", "Carsamba", "Persembe", "Cuma", "Cumartesi", };


int main(void)
{
    struct tm tm = {
        .tm_year = 2013 - 1900,
        tm.tm_mon = 0, // Ocak
        tm.tm_mday = 17,
        tm.tm_isdst = -1 // GÃ¼n iÃ§Ä±ÄŸÄ± tasarruf modunda olma/olmama durumunu kod kendi tespit edecektir.
    };

    time_t sec = mktime(&tm);
    struct tm* p = localtime(&sec);

    printf("%s\n", days[p->tm_wday]);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `mktime` fonksiyonunun kullanÄ±mÄ± ile iki adres farkÄ±nÄ±n alÄ±nÄ±ÅŸÄ± incelenebilir(yazÄ±lan program iki tarih farkÄ±nÄ± doÄŸru hesaplayamÄ±yor).
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <time.h>


int main(void)
{
    struct tm tm = {
        .tm_year = 1999 - 1900,
        .tm_mon = 7, // 
        .tm_mday = 17,
        .tm_hour = 3,
        .tm_min = 2,
        .tm_isdst = -1 // GÃ¼n iÃ§Ä±ÄŸÄ± tasarruf modunda olma/olmama durumunu kod kendi tespit edecektir.
    };
    
    time_t now;
    time(&now);
    time_t earthquake = mktime(&tm);
    time_t result = (time_t)difftime(now, earthquake);
    
    struct tm* p = now - earthquake;

    printf("depremden sonra %d yil %d ay %d gun %d saat %d dakika %d saniye gecti.\n", p->tm_year + 1900, p->tm_mon + 1, p->tm_day, p->tm_hour, p->tm_min, p->tm_sec);
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 21.28-21.41 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `mktime` fonksiyonunun kullanÄ±mÄ± ile bulunulan yÄ±lda ÅŸu ana kadar kaÃ§ saniye geÃ§tiÄŸi bilgisinin hesaplanÄ±ÅŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <time.h>


int main(void)
{
    time_t now = time(NULL);
    struct tm tm = *localtime(&now);

    tm.tm_mon = 0;
    tm.tm_mday = 1;
    tm.tm_hour = 0;
    tm.tm_min = 0;
    tm.tm_sec = 0;
    tm.tm_isdst = -1;

    mktime(&tm);

    double seconds = difftime(now - mktime(&tm));

    printf("%.f saniye\n", seconds);
}
```


### `mktime`, `difftime`, `strftime` FonksiyonlarÄ± 

`ctime` fonksiyonu `time_t` nesnesinin adresini alÄ±yor ve geriye bir static Ã¶mÃ¼rlÃ¼ bir dizi adresi(bir yazÄ±nÄ±n adresi) dÃ¶ndÃ¼rÃ¼r, bu dÃ¶nen yazÄ±yÄ± deÄŸiÅŸtiremiyoruz yazÄ± Ã¶nceen belirlenmiÅŸ bir formattadÄ±r. </br>
`asctime` fonksiyonu `struct tm` nesnesinin adresini alÄ±yor ve geriye bir static Ã¶mÃ¼rlÃ¼ bir dizi adresi(bir yazÄ±nÄ±n adresi) dÃ¶ndÃ¼rÃ¼r, bu dÃ¶nen yazÄ±yÄ± deÄŸiÅŸtiremiyoruz yazÄ± Ã¶nceen belirlenmiÅŸ bir formattadÄ±r. </br>
`strftime` fonksiyonu yukarÄ±daki iki fonksiyona gÃ¶re daha karmaÅŸÄ±ktÄ±r, bu fonksiyon bir tarih bilgisini istenilen formatta yazdÄ±rmak iÃ§in kullanÄ±lmaktadÄ±r. </br>



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `asctime` fonksiyonunun kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <time.h>


int main(void)
{
    struct tm* p = localtime(&(time_t) { time(NULL) });
    
    printf("%s", asctime(p)); // Burada ÅŸimdinin tarihi yazdÄ±rÄ±lÄ±yor.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strftime` fonksiyonunun kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <time.h>


int main(void)
{
    char str[256];
    struct tm* p = localtime(&(time_t) { time(NULL) });
    
    printf("%s", asctime(p)); // Burada ÅŸimdinin tarihi yazdÄ±rÄ±lÄ±yor.
    strftime(str, 256, "%a %b %d %H:%M:%S %Y", p); // Burada ÅŸimdinin tarihini istediÄŸimiz bir formatta yazdÄ±rÄ±yoruz.
    printf("%s\n", str);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strftime` fonksiyonunun TÃ¼rkÃ§e diliyle kullanÄ±mÄ± incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <time.h>
#include <locale.h>


int main(void)
{
    // AÅŸaÄŸÄ±daki kod bloÄŸunda kullanÄ±lan dil TÃ¼rkÃ§e olarak deÄŸiÅŸtiriliyor.
    if(!setlocal(LC_ALL, "turkish")) {
        printf("local degistirildi.\n");
        return 1;
    }

    char str[256];
    struct tm* p = localtime(&(time_t) { time(NULL) });

    printf("%s", asctime(p)); // Burada ÅŸimdinin tarihi yazdÄ±rÄ±lÄ±yor.
    strftime(str, 256, "%a %b %d %H:%M:%S %Y", p); // Burada ÅŸimdinin tarihini istediÄŸimiz bir formatta TÃ¼rkÃ§e olarak yazdÄ±rÄ±yoruz.
    printf("%s\n", str);
}
```

ğŸ“Œ `time.h` baÅŸlÄ±k dosyasÄ±ndaki ÅŸu `mktime`, `difftime`, `strftime` fonksiyonlarÄ±n tekrarÄ±nÄ± yapmÄ±ÅŸ olduk.


## Ã‡evresel DeÄŸiÅŸkenler(Environment Variables) 

Bu Ã§evresel deÄŸiÅŸkenler iÅŸletim sistemi altÄ±nda koÅŸan programlarda process'lere Ã¶zgÃ¼ anahtar-deÄŸer Ã§iftleridir. </br>
Anahtar-deÄŸer Ã§iftleri her ikisi de yazÄ±(string) tÃ¼rÃ¼nden olan verilerdir. </br> 
Ä°ÅŸletim sistemi bir process Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda o process'in bellek alanÄ±nda bu Ã§evresel deÄŸiÅŸkenleri de tutar ve bu Ã§evresel deÄŸiÅŸkenler program iÃ§inde kullanÄ±labilir. </br>
Ä°ÅŸletim sisteminin `PATH`, `USER` gibi kendi tanÄ±mladÄ±ÄŸÄ± Ã§evresel deÄŸiÅŸkenler var, biz de kendi Ã§evresel deÄŸiÅŸkenlerimizi oluÅŸturabiliriz ve bu deÄŸerleri elde edip gÃ¼ncelleyebiliriz. </br>
Ä°ÅŸletim sistem sistemleri(Windows, IOS, GNU/Linux vb.) anahtar-deÄŸer Ã§iftlerini bir veri yapÄ±sÄ±nda tutar, anahtar-deÄŸer Ã§iftleri Windows sisteminde bÃ¼yÃ¼k-kÃ¼Ã§Ã¼k harf duyarlÄ± deÄŸil ama diÄŸer iÅŸletim sistemlerinde bÃ¼yÃ¼k-kÃ¼Ã§Ã¼k harf duyarlÄ±dÄ±r.

`stdlib.h` baÅŸlÄ±k soayasÄ±nda bulunan `getenv` fonksiyonu var, bu fonksiyonun adÄ± "**get environment**" sÃ¶zcÃ¼klerinin kÄ±saltmasÄ±ndan gelmektedir. </br>
Bir Ã§evresel deÄŸiÅŸkene(bir anahtara) karÅŸÄ±lÄ±k gelen deÄŸeri elde etmek iÃ§in `getenv` fonksiyonuna Ã§aÄŸrÄ± yapÄ±lÄ±r. </br>
`getenv` fonksiyonun bildiirmi `char* getenv(const char* p);` biÃ§imindedir, fonksiyon Ã§aÄŸrÄ±sÄ± sonrasÄ±nda geriye **NULL pinter** dÃ¶ndÃ¼rÃ¼rse iÅŸlem baÅŸarÄ±sÄ±z dÃ¶nmezse iÅŸlem baÅŸarÄ±lÄ± anlamÄ±na gelmektedir.</br>
 


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `getenv` ile `PATH` ortam deÄŸiÅŸkeninin okunup bir dosyaya yazdÄ±rÄ±lÄ±ÄŸÄ± incelenebilir.
```C

#include <stdlib.h>
#include <stdio.h>

int main(void)
{
    const char* p = getenv("PATH");

    if(p == NULL) {
        fprintf(strerr, "hata ...\n");
        return 1;
    }

    FILE* f = fopen("out.txt", "w");
    if(!f) {
        fprintf(strerr, "dosya olusturulamadi.\n");
        return 2;
    }

    fputs(p, f); // Dosyaya yazdÄ±rma Ã§aÄŸrÄ±sÄ± yapÄ±lÄ±yor.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `getenv` ile `USER_NAME` ortam deÄŸiÅŸkeninin okunup bir dosyaya yazdÄ±rÄ±lÄ±ÄŸÄ± incelenebilir, ama `USER_NAME` ortam deÄŸiÅŸkeni ilgili iÅŸletim sisteminde yoksa hata da oluÅŸabilir.
```C
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
    const char* p = getenv("USER_NAME");

    if(p == NULL) {
        fprintf(strerr, "hata ...\n");
        return 1;
    }

    FILE* f = fopen("out.txt", "w");
    if(!f) {
        fprintf(strerr, "dosya olusturulamadi.\n");
        return 2;
    }

    fputs(p, f); // Dosyaya yazdÄ±rma Ã§aÄŸrÄ±sÄ± yapÄ±lÄ±yor.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda programÄ±n `main` fonksiyonu ile nasÄ±l tÃ¼m ortam deÄŸiÅŸkenlerinin okunup yazdÄ±rÄ±labileceÄŸi incelenebilir.
```C
#include <stdlib.h>
#include <stdio.h>

int main(int argc, char** argv, char** env)
{
    int i = 0;

    while(env[i] != NULL) {
        printf("[%2d]  %s\n", i + 1, env[i]);
        ++i;
    }
}
```



ğŸ“Œ `getenv` fonksiyonu esasÄ±nda iÅŸletim sisteminin bir fonksiyonunu Ã§aÄŸÄ±rmaktadÄ±r, **Posix** standardÄ±na uyan **Unix** tÃ¼revi sistemlerde de ortam deÄŸiÅŸkenlerini okumak iÃ§in kullanÄ±lan fonksiyonun adÄ± **getenv**.

ğŸ“Œ Maalesef bir ortam deÄŸiÅŸkeninin deÄŸerini deÄŸiÅŸtirmek iÃ§in kullanÄ±labilecek standart bir C fonksiyonu yok, bu iÅŸlemi yapabilmek iÃ§in kullanÄ±lan iÅŸletim sisteminin saÄŸladÄ±ÄŸÄ± bir fonksiyonun kullanÄ±lmasÄ± gerekiyor, bu iÅŸlem iÃ§in tam bir kod taÅŸÄ±nabilirliÄŸini saÄŸlayan standart bir C fonksiyonu buunmuyor.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir dizide tutulan tÃ¼m ortam deÄŸiÅŸkenlerinin nasÄ±l yazdÄ±rÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    const char* const p_env[] = {
        "PATH", "OS", "COMPUTERNAME", "USERNAME", "SYSTEMROOT", "HOMEDRIVE", "HOMEPATH",
    };

    const char* penv_str;

    for (size_t i = 0; i < sizeof(p_env) / sizeof(*p_env); ++i) {
        if ((penv_str = getenv(p_env[i])) != NULL)
            printf("%-16s = %s\n\n", p_env[i], getenv(p_env[i]));
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir dizide tutulan tÃ¼m ortam deÄŸiÅŸkenlerinden bazÄ±larÄ±nÄ±n nasÄ±l deÄŸiÅŸtirilip yazdÄ±rÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    ; // Windows sistemi iÃ§in ortam deiÅŸkeni 
    if(_putenv("TestEnv=test_value01")) {
        printf("basarisiz.\n");
        return 1;
    }
    else {
        printf("basarili.\n");
    }

    printf("~~~~~~~~~~~~~~~~");
    
    const char* p;

    if((p = getenv("TestEnv")) != NULL) {
        printf("%s\n", p);
    }
}
```

## Pointer HatalarÄ± 

Pointer hatalarÄ± C programlarÄ±nda en Ã§ok yapÄ±lan hatalardÄ±r. </br>
C dili iÃ§in yapÄ±lan mÃ¼lakaylarda en Ã§ok sorulan soru Ã§eÅŸitlerinden biri bir C programÄ±nÄ±n gÃ¶sterilip bu programda bir **ub** ya da bir hata var mÄ± yok mu tespit edilmesinin istenmesidir, genellikle pointer hatalarÄ± bulunur bu programlarda. </br>
Bu baÅŸlÄ±k altÄ±nda en basitinden en karmaÅŸÄ±ÄŸÄ±na doÄŸru pointer hatalarÄ±nÄ± inceleyeceÄŸiz. </br>
C mÃ¼lakatlarÄ±nda farklÄ± kategorilerde basitten zora doÄŸru sorular sorulmaktadÄ±r, en basit sorulara yanlÄ±ÅŸ cevap verildiÄŸinde daha zor sorularÄ± da sormaya gerek kalmÄ±yor.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda en basit pointer hatalarÄ±ndan biri incelenebilir. </br>
C mÃ¼lakatlarÄ±nda sorulmaktadÄ±r.
```C

int main(void)
{
    int* ptr; // Buradaki 'ptr' deÄŸiÅŸkeni Ã§Ã¶p deÄŸerdedir(indeterminant value), bu tÃ¼r gÃ¶stericilere standart olmayan biÃ§imde 'wild pointer' da denilebiliyor.

    *ptr = 243; // Buradaki atama iÅŸlemi 'ptr' deÄŸiÅŸkeni Ã§Ã¶p deÄŸerde olduÄŸu iÃ§in 'ub'dir.
}
``` 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda en basit pointer hatalarÄ±ndan biri incelenebilir. </br>
C mÃ¼lakatlarÄ±nda sorulmaktadÄ±r.
```C

int main(void)
{
    int x = 10; // Buradaki 'x' deÄŸiÅŸkeni 'int' tÃ¼rÃ¼ndendir.

    int* p1, p2; // Buradaki 'p1' 'int*' tÃ¼rÃ¼nden ama 'p2' 'int' tÃ¼rÃ¼ndendir.

    p1 = &x;
    p2 = p1; // Buradaki atama iÅŸleminde 'int*' tÃ¼rÃ¼nden 'int' tÃ¼rÃ¼ne atama yapÄ±lacaktÄ±r, bu atama iÅŸlemi legal olsa da doÄŸru deÄŸildir.
}
``` 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda en basit pointer hatalarÄ±ndan biri incelenebilir. </br>
C mÃ¼lakatlarÄ±nda sorulmaktadÄ±r.
```C

#define IPTR    int *

int main(void)
{
    int x = 10; // Buradaki 'x' deÄŸiÅŸkeni 'int' tÃ¼rÃ¼ndendir.
    int x = 17; 

    // AÅŸaÄŸÄ±daki iki kod satÄ±rÄ±nda hata yoktur.
    IPTR p11 = &x;
    IPTR p12 = p1;

    IPTR p21, p22; // Buradaki 'p21' 'int*' tÃ¼rÃ¼nden ama 'p22' 'int' tÃ¼rÃ¼ndendir.

    p21 = &x;
    p22 = p21; // Buradaki atama iÅŸleminde 'int*' tÃ¼rÃ¼nden 'int' tÃ¼rÃ¼ne atama yapÄ±lacaktÄ±r, bu atama iÅŸlemi legal olsa da doÄŸru deÄŸildir.
}
``` 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `typedef` ile bildirilen deÄŸiÅŸkenin kullanÄ±mÄ±ndaki durum iyi anlaÅŸÄ±lmalÄ±dÄ±r. </br>
C mÃ¼lakatlarÄ±nda sorulmaktadÄ±r.
```C

typedef int* IPTR;

int main(void)
{
    int x = 10; // Buradaki 'x' deÄŸiÅŸkeni 'int' tÃ¼rÃ¼ndendir.
    int x = 17; 

    IPTR p1, p2; // Buradaki 'p1' ve 'p2' deÄŸiÅŸkenlerinin tÃ¼rÃ¼ 'int*' tÃ¼rÃ¼nden olacaktÄ±r.

    p1 = &x;
    p2 = p1; // Buradaki atama iÅŸleminde 'int*' tÃ¼rÃ¼nden 'int*' tÃ¼rÃ¼ne atama yapÄ±lacaktÄ±r, bu atama iÅŸleminde bir yanlÄ±ÅŸlÄ±k yoktur.
}
``` 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `typedef` ile `const` kullanÄ±mÄ±ndaki Ã¶nemli bir bilgi incelenebilir. </br>
C mÃ¼lakatlarÄ±nda sorulmaktadÄ±r.
```C

typedef int* IPTR;

int main(void)
{
    int x = 10;
    int y = 23;

    const IPTR p = &x; // Buradaki statement'Ä± derleyici 'const int* p = &x;' olarak yorumlamaz, derleyici 'int * const p = &x;' olarak ilgili statement'Ä± yorumlar.

    *p = 12312; // Buradaki atama iÅŸlemi legal ve doÄŸrudur.

    p = &y; // Buradaki atama iÅŸlemi sÃ¶zdizim hatasÄ±dÄ±r.
}
``` 


Ders sonu ...
