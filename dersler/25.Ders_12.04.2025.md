# 25.Ders 12.04.2025 ğŸ•˜

Derse 10(09:01)-15(10:17)-13(11:01)-10(12:31)-10(12:45)-8(13:03) kiÅŸi katÄ±ldÄ±.
---

Pointer konusundan Ã¶nceki son ders belki bu gÃ¼n de pointer konusuna geÃ§ilebilir, pointer konusuna geÃ§ildiÄŸinde kursun ikinci kÄ±smÄ±na geÃ§ilmiÅŸ olacaktÄ±r.


## Strings in C Continue(C dilinde YazÄ±lar Devam)


ğŸ§  YazÄ±larla Ã§alÄ±ÅŸÄ±lÄ±rken Null karakter sabitinin(`'\0'`) yazÄ±nÄ±n sonunu kontrol etmke iÃ§in kullanÄ±lmasÄ± genel bir yaklaÅŸÄ±mdÄ±r, bu ÅŸekilde kodu okuyana daha anlaÅŸÄ±lÄ±r olarak **NTBS(Null Terminated Byte Stream)** bir yazÄ±nÄ±n sonunuyla ilgili bir iÅŸlem yapÄ±ldÄ±ÄŸÄ± belirtilmiÅŸ olacaktÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda tek tek karakterler(C dilinde karakter sabitleri `int` tÃ¼rÃ¼ndendir) ile nasÄ±l bir karakter dizisi oluÅŸturulup kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    char str[] = { 'C', 'a', 'n', 'e', 'r', '\0' };

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼de 'str' dizisinin sonunu belirten 'null character' olduÄŸu iÃ§in 'ub' yoktur.
    for(int i = 0; str[i] != '\0'; ++i){
        putchar(str[i]);
    }
}
```



`%zu` kullanÄ±mÄ± `size_t` tÃ¼rÃ¼nden bir deÄŸeri standart output'a yazdÄ±rmak iÃ§in dile taÅŸÄ±nabilirlik amaÃ§lÄ± eklenen bir "**conversion specifier**"dÄ±r, buna detaylÄ± deÄŸinilmemiÅŸtir.


ğŸ‘‡ AÅŸaÄŸÄ±daki program C dilinde yazÄ± dizilerine ilk deÄŸer verme **sÃ¶zdizimiyle(syntax)** ilgili bilgi edinilebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    // AÅŸaÄŸÄ±daki iki farklÄ± dizi tanÄ±mÄ± da aynÄ± kullanÄ±ma karÅŸÄ±lÄ±k geliyor ve derleyici dizinin son elemanÄ±nÄ± 0 olacak eÅŸkilde dÃ¼zenlemektedir.
    char str[] = "yazi";
    char str2[5] = "yazi";

    printf("str2 dizisinin boyutu: %zu\n", asize(str2));

    for(int i = 0; str[i] != '\0'; ++i){
        putchar(str[i]);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program C ve C++ dillerinde yazÄ±larÄ±n tanÄ±mlanmasÄ±ndaki bir farklÄ±lÄ±ÄŸÄ± analmak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    // AÅŸaÄŸÄ±daki kullanÄ±m C dilinde geÃ§erli bir kullanÄ±mdÄ±r ama C++ dilinde sÃ¶zdizim hatasÄ±dÄ±r(syntax error).
    char str[4] = "yazi";

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ 'str' dizisinin son karakteri '\0' olmadÄ±ÄŸÄ± iÃ§in tanÄ±msÄ±z davranÄ±ÅŸtÄ±r.
    for(int i = 0; str[i] != '\0'; ++i){
        putchar(str[i]);
    }
}
```



Dizinin sonunda null karakter olmayan durumlar;

1. Otomatik Ã¶mÃ¼rlÃ¼ dizi tanÄ±mÄ± yapÄ±ldÄ±ÄŸÄ±nda deÄŸer atanmayan dizi elemanlarÄ± **Ã§Ã¶p deÄŸer(indeterminate value)** alacaktÄ±r, bu durumda dizinin son elemanÄ±nda `'\0'` deÄŸeri yoktur.

    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include "nutility.h"

    int main(void)
    {
        char str[10]; // Burada otomatik Ã¶mÃ¼rlÃ¼ dizi tanÄ±mÄ± yapÄ±lÄ±yor, dizi elemanlarÄ±nÄ±n 0 deÄŸeriyle yaÅŸamÄ±na baÅŸlama garantisi yoktur.

        str[0] = 'N';
        str[1] = 'U';
        str[2] = 'R';

        // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ 'str' dizisinin son karakteri '\0' olmadÄ±ÄŸÄ± iÃ§in tanÄ±msÄ±z davranÄ±ÅŸtÄ±r.
        for(int i = 0; str[i] != '\0'; ++i)
            putchar(str[i]);
    }
    ```


2. Dizi tanÄ±mÄ± tek tek karakterler verilerek yapÄ±ldÄ±ÄŸÄ±nda `'\0'` karakteri dizi sonuna eklenmeyecektir.

    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include "nutility.h"

    int main(void)
    {
        char str[] = { 'a', 'l', 'p' };

        // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ 'str' dizisinin son karakteri '\0' olmadÄ±ÄŸÄ± iÃ§in tanÄ±msÄ±z davranÄ±ÅŸtÄ±r.
        for(int i = 0; str[i] != '\0'; ++i)
            putchar(str[i]);
    }
    ```


3. Dizi tanÄ±mÄ± dizi boyutu belirtilerek dizideki tÃ¼m elemanlar tek tek verildiÄŸi tanÄ±mlama ÅŸeklinde dizi sonunu belirten `'\0'` karakteri verilmediÄŸinde dizi sonunda `'\0'` karakteri olmadÄ±ÄŸÄ± iÃ§in tanÄ±msÄ±z davranÄ±ÅŸa neden olabilecek bir durum oluÅŸur.
    
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include "nutility.h"

    int main(void)
    {
        char str[3] = { 'a', 'l', 'p' }; // Burada 'char str[4] = { 'a', 'l', 'p' };' ÅŸeklinde bir kod olsaydÄ± son karakterin deÄŸeri '0' olacaktÄ±r.

        // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ 'str' dizisinin son karakteri '\0' olmadÄ±ÄŸÄ± iÃ§in tanÄ±msÄ±z davranÄ±ÅŸtÄ±r.
        for(int i = 0; str[i] != '\0'; ++i)
            putchar(str[i]);
    }
    ```


4. Dizi tanÄ±mÄ± dizinin eleman sayÄ±sÄ± belirtilerek deÄŸeri bir yazÄ± olarak Ã§ift tÄ±rnaklar arasÄ±nda verildiÄŸinde ama karakter uzunluÄŸu dizi ile aynÄ± olduÄŸu durumlarda dizi sonunu belirten `'\0'` karakteri eklenmemiÅŸ olacaktÄ±r.
    
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include "nutility.h"

    char str[10];

    int main(void)
    {
        char str[4] = "KAYA";

        // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ 'str' dizisinin son karakteri '\0' olmadÄ±ÄŸÄ± iÃ§in tanÄ±msÄ±z davranÄ±ÅŸtÄ±r.
        for(int i = 0; str[i] != '\0'; ++i)
            putchar(str[i]);
    }
    ```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir yazÄ±nÄ±n son karatterinin nasÄ±l deÄŸiÅŸtirilebildiÄŸi incelenebilir. YazÄ± tutacak bir diziye ilk deÄŸer Ã§ift tÄ±rnaklar arasÄ±nda atandÄ±ÄŸÄ±nda deÄŸer atanmayÄ±p boÅŸta kalan dizi elemanlarÄ±nÄ±n deÄŸerleri `'\0'` olacaktÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    char str[10] = "KAYA"; // Bu bildirimde dizinin eleman deÄŸeri verilmeyen elemanlarÄ±nÄ±n deÄŸerleri '0' olarak atanacaktÄ±r.

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ 'str' dizisinin 4. indeksinden sonraki elemanlarÄ± '\0' olduÄŸu iÃ§in tanÄ±msÄ±z davranÄ±ÅŸ yoktur.
    for(int i = 0; str[i] != '\0'; ++i)
        putchar(str[i]);

    putchar('\n');

    str[4] = '!';

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ 'str' dizisinin 4. indeksinden sonraki elemanlarÄ± '\0' olduÄŸu iÃ§in tanÄ±msÄ±z davranÄ±ÅŸ yoktur.
    for(int i = 0; str[i] != '\0'; ++i)
        putchar(str[i]);
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir karakter dizisine ait elemanlarÄ±n `'\0'` karakteri iÃ§ermediÄŸinde bunun "ub" durumuna neden olduÄŸu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    char str[5] = "KAYA";

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ 'str' dizisinin 4. indeksinden sonraki elemanlarÄ± '\0' olduÄŸu iÃ§in tanÄ±msÄ±z davranÄ±ÅŸ yoktur.
    for(int i = 0; str[i] != '\0'; ++i)
        putchar(str[i]);

    putchar('\n');

    str[4] = '!';

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ 'str' dizisinin son karakteri '\0' olmadÄ±ÄŸÄ± iÃ§in tanÄ±msÄ±z davranÄ±ÅŸtÄ±r.
    for(int i = 0; str[i] != '\0'; ++i)
        putchar(str[i]);
}
```



Bir yazÄ±yÄ± bir standart C fonksiyonu ile standart Ã§Ä±kÄ±ÅŸ  akÄ±mÄ±na gÃ¶nderebilir miyiz diye sorulursa, evet bunu yapmanÄ±n iki yolu vardÄ±r. 
- ğŸ‘‡ AÅŸaÄŸÄ±daki programda yukarÄ±da aÃ§Ä±klanan kullanÄ±m yÃ¶ntemi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    char name[] =  "Name";
    char surname[] =  "Surname";

    printf("%s", name);
    printf("%s", surname);

    // Array decay(array to pointer conversion) kuralÄ± uygulanÄ±yor.
    printf("%s %s\n", name);
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda tek seferde karakter dizisi ve tam sayÄ± deÄŸiÅŸkeninin nasÄ±l tek seferde yazdÄ±rÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    char name[] = "Name";
    char surname[] = "Surname";
    int age = 10;

    printf("%s %s is %d years old\n", name, surname, age);
}
```


â— `puts` fonksiyonu **variadic(deÄŸiÅŸken sayÄ±da argÃ¼man alabilen)** fonksiyon deÄŸildir sadece tek bir pointer deÄŸer almaktadÄ±r, bu fonksiya geÃ§ilecek argÃ¼man standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderilmek istenilen yazÄ± olmalÄ±dÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `puts` fonksiyonunun kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    char name[] = "Name Surname";

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼de 'putchar' fonksiyonunu kullanarak karakter dizisi aynÄ± 'printf' fonksiyonunda olduÄŸu gibi standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderlmektedir.
    for(int i = 0; name[i] != '\0'; ++i)
        putchar(name[i]);
    putchar('\n');

    puts(name); // Bu fonksiyon sonuna new-line karakteri ekler.

    printf("Necati\n");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program `scanf` fonksiyonu ile nasÄ±l standart giriÅŸten bir yazÄ± alÄ±nacaÄŸÄ± incelenebilir. Fakat bu ÅŸekilde sadece boÅŸluk karakter iÃ§ermeyen yazÄ±lar diziye alÄ±nabilir. `scanf` fonksiyonu boÅŸluk karakterlerini yazÄ± ayÄ±rÄ±cÄ± olarak kabul etmektedir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 100

int main(void)
{
    char str[SIZE];

    printf("adinizi bahsediniz: ");
    scanf("%s", str); // Bu fonksiyon ile boÅŸluklardan oluÅŸan bir yazÄ±yÄ± dizi deÄŸiÅŸkenine alamayÄ±z.

    printf("adiniz: (%s)\n", str);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program `scanf` fonksiyonu boÅŸluk karakterlerini yazÄ± ayÄ±rÄ±cÄ± olarak kabul etme Ã¶zelliÄŸinden yayarlanarak nasÄ±l ad soyad verileirnin alÄ±nabileceÄŸini anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 100

int main(void)
{
    char name[SIZE];
    char surname[SIZE];
    int birth_year;

    printf("adinizi soyadÄ±nÄ±zÄ± ve dogum yilinizi vakfediniz: ");
    scanf("%s%s%d", name, surname, &birth_year);

    printf("%s %s kisisi %d yilinda dogmustur.\n", name, surname, &birth_year);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program yazÄ± giriÅŸlerinde dizinin boyutundan baha bÃ¼yÃ¼k bir deÄŸerin `scanf` fonksiyonu ile birlikte girilmek istenirse run-time hatasÄ± alÄ±ndÄ±ÄŸÄ± durumunu gÃ¶rmek iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 10

int main(void)
{
    char name[SIZE];

    printf("adinizi deyiniz: ");
    scanf("%s", name); // girilen yazÄ± 10 karakterden fazla olursa Ã§alÄ±ÅŸma zamanÄ± hatasÄ± alÄ±nÄ±r, 9 karakterden bÃ¼yÃ¼k olursa son karakter 0 olmazsa 'ub' durumu oluÅŸturulabilir.

    printf("%s iyi bir ad\n", name);
}
```



`char` tÃ¼rden bir diziye alÄ±nacak yazÄ±yÄ± boÅŸluk karakterlerle(**whitespace**) birlikte nasÄ±l alabiliriz, bunun birden fazla yolu vardÄ±r, bunlar; 
1. `scanf`'i **scanset** Ã¶zelliÄŸiyle birlikte kullanmak(**scanset** Ã¶zelliÄŸinin detaylÄ± incelendiÄŸi bir ders olacak, ÅŸu anda detayÄ±na deÄŸinilmiyor).
    
    ğŸ‘‡ `scanf`'i **scanset** Ã¶zelliÄŸiyle birlikte kullanarak nasÄ±l boÅŸluk karakteri iÃ§eren yazÄ±larÄ±n bir karakter dizi deÄŸiÅŸkenine alÄ±nabileceÄŸi incelenebilir.
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include "nutility.h"

    #define SIZE 100

    int main(void)
    {
        char name[SIZE];

        printf("adÄ±nÄ±zÄ± giriniz: ");
        scanf("%s[ ]", name);

        printf("%s iyi bir ad\n", name);
    }
    ```


2. `gets` fonksiyonu kullanÄ±labilir, `gets` fonksiyonunun adÄ± "**Get Strings**" adÄ±ndan tÃ¼retilmiÅŸtir.

    `gets` fonksiyonunu kullanmak, bu fonksiyon **C99** standardÄ±ndan sonra dilin standardÄ±nda kaldÄ±rÄ±labilir durumuna alÄ±nmÄ±ÅŸtÄ±r(**deprecated, deprecate, deprecation**) sonrasÄ±nda da C11 standardÄ±yla dilden Ã§Ä±kartÄ±lmÄ±ÅŸtÄ±r.
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include "nutility.h"

    #define SIZE 100

    int main(void)
    {
        char name[SIZE];

        printf("adinizi giriniz: ");
        gets(name); // Bu fonksiyon C11 ile dilden kaldÄ±rÄ±ldÄ±ÄŸÄ± iÃ§in kullanÄ±lmasÄ± doÄŸru olmayacaktÄ±r.

        printf("ad: (%s)\n", name);
    }
    ```


3. `gets_s` fonksiyonu kullanÄ±labilir, bu fonksiyon eskiden dilde olan `gets` fonksiyonunun gÃ¼venli halidir. 

    "**_s**" ile biten fonksiyonlar **C11** standardÄ±nda dile eklendi ama "**optional**" olarak dilin standardÄ±na eklendi, bu da bu fonksiyonlarÄ±n eklenip eklenmemesinin derleyicileri yazanlara bÄ±rakÄ±lmasÄ± anlamÄ±na geliyor.

    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include "nutility.h"

    #define SIZE 100

    int main(void)
    {
        char name[SIZE];

        printf("adinizi giriniz: ");
        gets_s(name, SIZE); // 'gets_s' fonksiyonu 

        printf("ad: (%s)\n", name); // Burada kullanÄ±cÄ±nÄ±n girdiÄŸi yazÄ±yÄ± girilen boÅŸluklarla birlikte gÃ¶rÃ¼lebilmesi iÃ§in parantezlele birlikte yazdÄ±rÄ±lÄ±yor. 
    }
    ```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir dizinin eleman sayÄ±sÄ±nÄ± belirten ifadenin C dilinin standardÄ±nda bir **constant** olmasÄ± gerektiÄŸi durum incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 100

int main(void)
{
    int size = 90; // Buradaki 'size' deÄŸiÅŸkeni C dilinde constant olarak kabul edilmemektedir, hatta C dilinde 'const int size = 90;' ÅŸeklinde bildirilse bile constant olarak kabul edilmemektedir.

    int ary[size]; // C dilinde burada sÃ¶zdizim hatasÄ±(syntax error) vardÄ±r, dizi boyutu sadece constant ifadeler ile bildirilebilir ama derleyicileri 'VLA' derleyici eklentisiyle bu kullanÄ±ma izin verebilir.

    for(int i = 0; i < size; ++i){
        ary[i] = i;
    }

    for(int i = 0; i < size; ++i){
        printf("%d \n", ary[i]);
    }
}
```



**VLA(Variable Length Array)(DeÄŸiÅŸken uzunluklu dizi)**: Bu **C99** ile dilin standardÄ±na eklendi, **C11** ile dilin standardÄ±nda optional hale getirildi. YukarÄ±da paylaÅŸÄ±lan programdaki bir dizinin eleman sayÄ±sÄ± deÄŸerinin const olmayan ifadeler ile bildirilebilmesi iÅŸlemine **VLA** deniliyor ve her C derleyici bunu desteklemeyebilir.


>â”
> 
> Sorulan soru; 
> 
> AlakasÄ±z olacak ama _s oop tabanlÄ± dillerde de deÄŸiÅŸkenlerin private olduÄŸunu kodda belirtmek iÃ§in yazÄ±lÄ±yor mu?
> 
> Cevap;
> 
> Bir `fonksiyon_adi()` **_s** ile bitirmek bir dilin kullandÄ±ÄŸÄ± **convension** olabilir ama bu ÅŸekilde uygulanan kullanÄ±mlar bir dilin **sÃ¶zdizim(syntax)** kuralÄ± deÄŸildir, mesela for dÃ¼ngsÃ¼nde dÃ¶ngÃ¼ sayacÄ± i, j, k deÄŸiÅŸken adlarÄ±yla tutulmasÄ± bir **convension**'dÄ±r, herkes bÃ¶yle yapÄ±yor sen de bÃ¶yle yap durumlarÄ± **convension** olarak adlandÄ±rÄ±lÄ±r.



âœï¸ Standar input'tan alÄ±nacak yazÄ±larda boÅŸluk karakterlerini de alacak ÅŸekilde bir fonksiyonun kendi kÃ¼tÃ¼phenemize eklenmesi.
```c
// 'nutility.h' dosyasÄ±na aÅŸaÄŸÄ±daki 'fuction decleration' eklemesini yapÄ±yoruz.

void sgets(char* p);
```

```C
// 'nutility.c' dosyasÄ±na aÅŸaÄŸÄ±daki 'fuction definition' eklemesini yapÄ±yoruz.

// p : 'Standart Input'tan yapÄ±lan giriÅŸi 'null character'i gÃ¶rene kadar okuyup okunan karakterlerin yazÄ±lacaÄŸÄ± elemanlarÄ± 'char' tÃ¼rÃ¼nden olan dizinin baÅŸlangÄ±Ã§ adresi deÄŸeri.
void sgets(char* p)
{
    int ch;
    int idx = 0;

    while((ch = getchar()) != '\n'){
        p[idx++] = (char)ch; // Burada int tÃ¼rÃ¼nden char tÃ¼rÃ¼ne atama yapÄ±ldÄ±ÄŸÄ± iÃ§in bu ÅŸekilde tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼nÃ¼n bilinÃ§li olarak yapÄ±ldÄ±ÄŸÄ± belirtiliyor.
    }
    p[idx] = '\0'; // Burada yazÄ±nÄ±n son karakteri 'null character' yapÄ±lÄ±yor.
}
```


â—`getchar()` fonksiyonu standart giriÅŸ akÄ±mÄ±ndan tek bir karakter okumak iÃ§in kullanÄ±lÄ±yor.


ğŸ‘‡ AÅŸaÄŸÄ±daki program kendi kÃ¼tÃ¼phanemize eklediÄŸimiz `sgets` fonksiyonu kullanÄ±larak **standart input**'tan gelen girdileri boÅŸluk karakterleri de dahil olarak  nasÄ±l okunabileceÄŸini gÃ¶rmek iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 100

int main(void)
{
    char name[SIZE];

    printf("adinizi giriniz: ");
    sgets(name);    

    printf("ad: (%s)\n", name);
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.30-10.53 birinci ve ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


ğŸ“Œ BugÃ¼nkÃ¼ derste yazÄ±labildiÄŸi kadar yazÄ±larla ilgili kodlar yazÄ±lacak yarÄ±n da kursun daha zor olan ikinci yarÄ±sÄ± pointer konusuyla baÅŸlayacaktÄ±r, derlere canlÄ± katÄ±lÄ±mÄ±n yarÄ±ndan itibaren Ã¶nemli olduÄŸu belirtildi.


ğŸ‘‡ AÅŸaÄŸÄ±daki program yazÄ±nÄ±n uzunluÄŸunu hesaplayan programdÄ±r. Bu program dizi sonu olan 0 deÄŸerini gÃ¶rene kadar diziyi gezecek ve dizi uzunluÄŸunu tutacak bir deÄŸiÅŸkeni arttÄ±rarak ve en son bu deÄŸer dizi uzunluÄŸunu tespit etmiÅŸ olacaktÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 100

int main(void)
{
    char str[SIZE];

    printf("bir yazi giriniz: ");
    sgets(str);

    int len = 0;

    for(int i = 0; str[i] != '\0' ; ++i){
        ++len;
    }

    printf("uzunluk: %d\n", len);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program yazÄ±nÄ±n uzunluÄŸunu hesaplayan programÄ±n C dilinin idiomatic ÅŸekilde nasÄ±l alÄ±nabileceÄŸini analmak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 100

int main(void)
{
    char str[SIZE];

    printf("bir yazi giriniz: ");
    sgets(str);

    int len;

    for(len = 0; str[len] != '\0' ; ++len)
        ; // null statement

    printf("uzunluk: %d\n", len);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program yazÄ±nÄ±n uzunluÄŸunu hesaplayan programÄ±n `while` ile yazÄ±lmÄ±ÅŸ halidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 100

int main(void)
{
    char str[SIZE];

    printf("bir yazi giriniz: ");
    sgets(str);

    int len = 0;

    while(str[len] != '\0')
        ++len;

    printf("uzunluk: %d\n", len);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program yazÄ±nÄ±n uzunluÄŸunu hesaplayan programÄ±n `while` ile C dilinin idiomatic ÅŸekilde nasÄ±l yazÄ±labileceÄŸini analmak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 100

int main(void)
{
    char str[SIZE];

    printf("bir yazi giriniz: ");
    sgets(str);

    int len = 0;

    while(str[len++] != '\0')
        ; // null statement
    --len; // Buradaki iÅŸlem 'while' ifadesindeki en son dizinin boyutundan bir fazla 

    printf("uzunluk: %d\n", len);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program yazÄ±yÄ± tersten yazdÄ±ran iÅŸlemi yapmaktadÄ±r. Ä°lk Ã¶nce dizinin uzunluÄŸu tespit edilir ardÄ±ndan dizinin ilk ve en son elemanlarÄ± dizinin ortasÄ±na gelinceye kadar deÄŸiÅŸtirilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 100

int main(void)
{
    char str[SIZE];

    printf("bir yazi giriniz: ");
    sgets(str);

    puts(str);

    int i;

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ dizi boyutunu Ã¶ÄŸrenmek iÃ§in kullanÄ±lÄ±yor.
    for(i = 0; str[i] != '\0'; ++i)
        ; // null statement

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ diziyi tersten yazdÄ±rmaktadÄ±r.
    for(--i; i >= 0; --i)
        putchar(str[i]);

    putchar('\n');
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program diziyi ters Ã§evirme iÅŸlemi yapmaktadÄ±r. Bu algoritma basittir ve mÃ¼lakatlarda da sÄ±klÄ±kla sorulmaktadÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 100

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile dizinin ters Ã§evrilmesini saÄŸlamaktadÄ±r.
    for(int i = 0; i < SIZE / 2; ++i){
        int temp = ar[i];
        ar[i] = ar[ SIZE - 1 - i];
        ar[ SIZE - 1 - i] = temp;
    }

    print_array(ar, SIZE);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program yazÄ±yÄ± ters Ã§evirme iÅŸlemi yapmaktadÄ±r. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 100

int main(void)
{
    char str[SIZE];

    printf("bir yazi giriniz: ");
    sgets(str);
    printf("(%s)\n", str);

    int len = 0;

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile yazÄ±nÄ±n uzunluÄŸu tespit ediliyor, karakter dizisinin son elemanÄ± 'null character' olduÄŸu iÃ§in bu karakter 'len' deÄŸiÅŸkenine dahil edilmiyor.
    while(str[len])
        ++len;

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile dizinin ters Ã§evrilmesi saÄŸlamaktadÄ±r.
    for(int i = 0; i < len / 2; ++i){
        char temp = str[i];
        str[i] = str[ SIZE - 1 - i];
        str[ SIZE - 1 - i] = temp;
    }

    printf("(%s)\n", str);
}
```


>â”
> 
> Sorulan soru; 
> 
> while iÃ§inde `str[++len]` yazsak ve `++len` satÄ±rÄ±ndan kurtulsak, olur mu?
> 
> Cevap;
> 
> ğŸ‘‡ AÅŸaÄŸÄ±daki program yazÄ±yÄ± ters Ã§evirme iÅŸlemi yapmaktadÄ±r. 
> ```C
> #define _CRT_SECURE_NO_WARNINGS
> 
> #include <stdio.h>
> #include "nutility.h"
> 
> #define SIZE 100
> 
> int main(void)
> {
>     char str[SIZE];
> 
>     printf("bir yazi giriniz: ");
>     sgets(str);
>     printf("(%s)\n", str);
> 
>     int len = 0;
> 
>     // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile dizinin uzunluÄŸu tespit ediliyor ama girilen yazÄ± boÅŸ yazÄ± ise sorun oluÅŸacaktÄ±r.
>     // EÄŸer 'str' dizisi boÅŸ ise dizi uzunluÄŸu 0 ve dizide tek eleman olarak '\0' karakteri olacaktÄ±r, bu da dizinin uzunluÄŸunun aÅŸÄ±lmasÄ±na ve 'ub' durumuna neden olacaktÄ±r.
>     while(str[++len] != '\0')
>         ; // null statement
> 
>     // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile dizinin ters Ã§evrilmesi saÄŸlanÄ±yor.
>     for(int i = 0; i < len / 2; ++i){
>         char temp = str[i];
>         str[i] = str[ SIZE - 1 - i];
>         str[ SIZE - 1 - i] = temp;
>     }
> 
>     printf("(%s)\n", str);
> }


â—â—â— Bir yazÄ± **boÅŸ yazÄ±(empty string, null string)** ise geÃ§erli bir yazÄ±dÄ±r. UzunluÄŸu 0 olan bir yazÄ±dÄ±r, yazÄ±lar Ã¼stÃ¼nde iÅŸlem yapan kodlarÄ±n boÅŸ yazÄ±lar Ã¼stÃ¼nde de doÄŸru Ã§alÄ±ÅŸmasÄ± beklenir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki gibi **bir yazÄ± boÅŸ yazÄ±(empty string, null string)** da olabilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 100

int main(void)
{
    char str[SIZE];

    printf("bir yazi giriniz: ");
    sgets(str);
    printf("(%s)\n", str);

    int len = 0;

    // Burada yazÄ± boÅŸ yazÄ±ysa dizi taÅŸmasÄ± durumundan dolayÄ± 'ub' oluÅŸacaktÄ±r. Bu ÅŸekilde yazmaktansa aÅŸaÄŸÄ±daki yorumdaki gibi yazÄ±lÄ±rsa bu sorun gÃ¼zel ÅŸekilde Ã§Ã¶zÃ¼lmÃ¼ÅŸ olur.
    while(str[++len] != '\0') 
        ; // null statement

    // BoÅŸ dizilerde oluÅŸabilecek olan dizinin uzunluÄŸunun aÅŸÄ±lmasÄ± sorununu aÅŸaÄŸÄ±daki gibi Ã§Ã¶zebiliriz.
    //if(str[0] != '\0')
    //    while(str[++len] != '\0')
    //        ; // null statement

    for(int i = 0; i < len / 2; ++i){
        char temp = str[i];
        str[i] = str[ SIZE - 1 - i];
        str[ SIZE - 1 - i] = temp;
    }

    printf("(%s)\n", str);
}
```


>â”
> 
> SorduÄŸum soru;
> 
> "while(str[0] != '\0' && str[++len] != '\0')" bÃ¶yle yazÄ±labilir mi?
> 
> Cevap;
> 
> BÃ¶yle yazÄ±lmamalÄ± Ã§Ã¼nkÃ¼ gereksiz yere kod karmaÅŸÄ±klaÅŸmÄ±ÅŸ olur, bunun yerine aÅŸaÄŸÄ±daki gibi yazÄ±labilir.
> 
> ```C
> // Burada yazÄ± boÅŸ yazÄ±ysa dizi taÅŸmasÄ± durumundan dolayÄ± 'ub' oluÅŸacaktÄ±r. Bu ÅŸekilde yazmaktansa aÅŸaÄŸÄ±daki yorumdaki gibi yazÄ±lÄ±rsa bu sorun gÃ¼zel ÅŸekilde Ã§Ã¶zÃ¼lmÃ¼ÅŸ olur.
> while(str[++len] != '\0') 
>     ; // null statement
> 
> // BoÅŸ dizilerde oluÅŸabilecek olan dizinin uzunluÄŸunun aÅŸÄ±lmasÄ± sorununu aÅŸaÄŸÄ±daki gibi Ã§Ã¶zebiliriz.
> //if(str[0] != '\0')
> //    while(str[++len] != '\0')
> //        ; // null statement
> ```



ğŸ§  Palindrom sayÄ±, cÃ¼mle vb.: Sondan baÅŸa doÄŸru ve baÅŸtan sona doÄŸru yazÄ±lÄ±ÅŸÄ± aynÄ± olan yazÄ±lardÄ±r. Mesela "_Ana, Naci dede ne dedi Canan'a?_", "_At, sahibi gibi hasta_", "_Tras neden sart_", "_kalas yok kutuk koy salak_", "_en iyi mese bese mi yine_", "_Madam, I'm Adam_", "_Para hazÄ±r ama RÄ±za harap!_", "_A man, a plan, a canal: Panama_" cÃ¼mleleri palindrom cÃ¼mlelerdir, bu cÃ¼mlelerdeki yazÄ± karakterleri dÄ±ÅŸÄ±ndaki karakterler gÃ¶rmezden gelinmektedir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda palindrom yazÄ±larÄ±n ayrÄ± bir dizi kullanÄ±larak nasÄ±l tespit edilebildiÄŸini anlamak iÃ§in incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <ctype.h> // 'isalpha(), toupper()' gibi karakterler Ã¼zerinde iÅŸlem yapan fonksiyonlar bu kÃ¼tÃ¼phenede bulunmaktadÄ±r.

#define SIZE 100

int main(void)
{
    char str[SIZE];

    printf("bir yazi giriniz: ");
    sgets(str);
    printf("(%s)\n", str);

    char temp[SIZE];
    int len = 0;

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼de, girilen yazÄ±nÄ±n alfabe karakterleri olmayan hali 'temp' dizisine alÄ±nÄ±yor. 
    for(int i = 0; str[i] != '\0'; ++i)
        if(isalpha(str[i]))
            temp[len++] = str[i];
    
    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ eÄŸer 'break;' ile sonlanmÄ±yorsa yazÄ±nÄ±n palindrom olduÄŸu anlamÄ±na gelecektir.
    int i;
    for(i = 0; i < len / 2; ++i){
        if(toupper(temp[i] != toupper(temp[len - 1 - i])))
            break;
    }

    if(i < len / 2){
        printf("palindrom degil\n"); // break ile dÃ¶ngÃ¼den Ã§Ä±kÄ±ldÄ±ÄŸÄ± durum.
    }
    else{
        printf("palindrom"); // 'i < len / 2' kÄ±smÄ±na girmeden dÃ¶ngÃ¼den Ã§Ä±kÄ±ldÄ±ÄŸÄ± iÃ§in bu palindrom yazÄ±dÄ±r.
    }
}
```



â—AÅŸaÄŸÄ±daki Ã¶devi yaparak bir Ã§ok programda kullanÄ±lan bir teknik Ã¶ÄŸrenilecektir ve bu sorunun Ã§Ã¶zÃ¼mÃ¼nde kullanÄ±lan teknik, mÃ¼lakatlarda sorulan bir Ã§ok sorunun Ã§Ã¶zÃ¼mÃ¼nde kullanÄ±lmaktadÄ±r.
- ğŸ“– Ã–dev-1: ğŸ‘† YukarÄ±daki program girilen yazÄ±nÄ±n palindrom olup olmadÄ±ÄŸÄ±nÄ± tespit etmektedir. Ä°kinci bir dizi kullanmadan ve `str` dizisindeki yazÄ± deÄŸiÅŸmeyecek ÅŸekilde bu programÄ± yeniden yazÄ±nÄ±z.
- ğŸ§­ Ä°picu: Girilen yazÄ±nÄ±n ilk ve son elemanlarÄ±nÄ±n indeks deÄŸerleri birer deÄŸiÅŸkende tutulacak ve alfabetik karakterler dÄ±ÅŸÄ±ndaki karakterler karÅŸÄ±laÅŸtÄ±rmaya tabi tutulmayacak ÅŸekilde iki indeksteki dizi deÄŸerleri karÅŸÄ±laÅŸtÄ±rÄ±larak ilerlenmesi gerekiyor, tÃ¼m karÅŸÄ±laÅŸtÄ±rmalar eÅŸit Ã§Ä±karsa en son indeks deÄŸerleri aralarÄ±nda bir fark olacak duruma geliyorsa bu girilen yazÄ±nÄ±n palindrom olduÄŸu anlamÄ±na geliyor.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 11.50-12.00 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***

## Dizilerle Ä°ligli Verilen BazÄ± Ã–devlerin Ã‡Ã¶zÃ¼mleri


 23. derteki "_ğŸ“– Ã–dev-1: Bir dizide arama iÅŸleminde algoritmayÄ± '3 * SIZE' yerine '2 * SIZE' iÅŸlem ile yapÄ±nÄ±z._" cevabÄ± aÅŸaÄŸÄ±daki gibidir;
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 20

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    int key;
    printf("aranacak degeri giriniz: ");
    scanf("%d", &key);

    // Bu Ã§Ã¶zÃ¼mdeki dÃ¶ngÃ¼de 'i < SIZE', 'ar[i] == key' ve '++i' bir iÅŸlemdir ve bu dÃ¶ngÃ¼de '3 * SIZE' adet iÅŸlem yapÄ±lÄ±yor, bizden '2 * SIZE' adet iÅŸlemle aynÄ± dÃ¶ngÃ¼nÃ¼n yazÄ±lmasÄ± isteniyor.
    int i;
    for(i = 0; i < SIZE; ++i){
        if(ar[i] == key){
            break;
        }
    }

    if(i == SIZE)
        printf("bulunamadi.\n");
    else
        printf("bulundu, dizinin %d indisli elemani.\n", i);
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda 23. derteki "_ğŸ“– Ã–dev-1_" Ã§Ã¶zÃ¼mÃ¼ incelenebilir;
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 20

int main(void)
{
    int ar[SIZE + 1];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    int key;
    printf("aranacak degeri giriniz: ");
    scanf("%d", &key);

    ar[SIZE] = key; // AranÄ±lan deÄŸer dizinin en son elemanÄ± olarak ekleniyor.
    int i;
    for(i = 0; ar[i] != key; ++i)
        ; // null statement
    
    if(i == SIZE)
        printf("bulunamadi.\n");
    else
        printf("bulundu, dizinin %d indisli elemani.\n", i);
}
```


 24. dersteki "_ğŸ“– Ã¶dev-2_" cevabÄ± aÅŸaÄŸÄ±daki gibidir ve algoritma karmaÅŸÄ±klÄ±ÄŸÄ± $O(n^2)$ seviyesindedir. Soruda dizinin sadece **eÅŸsiz(unique)** elemanlarÄ±nÄ±n standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderilmesi isteniyor.

Mesela aÅŸaÄŸÄ±daki gibi bir tam sayÄ± dizisi iÃ§in Ã§Ä±ktÄ±nÄ±n nasÄ±l olacaÄŸÄ± bir altÄ±nda yer almaktadÄ±r;
- 10 6 1 4 19 7 18 12 16 10 9 4 14 1 15 13 6 12 0 8
- 19 7 18 16 9 14 15 13 0 8


ğŸ‘‡ AÅŸaÄŸÄ±daki programda 24. derteki "_ğŸ“– Ã–dev-2_" Ã§Ã¶zÃ¼mÃ¼ incelenebilir, buradaki program bu soru iÃ§in yazÄ±labilecek en doÄŸru yollardan biriyle yazÄ±lmÄ±ÅŸtÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <ctype.h> // 'isalpha(), toupper()' gibi karakterler Ã¼zerinde iÅŸlem yapan fonksiyonlar bu kÃ¼tÃ¼phenede bulunmaktadÄ±r.
#include <stdlib.h>

#define SIZE 20

int main(void)
{
    int ar[SIZE];

    randomize();

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼de dizinin elemanlarÄ± [0-19] aralÄ±ÄŸÄ±nda bir deÄŸer alacak ÅŸekilde atanmaktadÄ±r.
    for(int i = 0; i < SIZE; ++i)
        ar[i] = rand() % 20;

    print_array(ar, SIZE);

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼de dizi elemanlarÄ± geziliyor ve bir elemanÄ±n eÅŸsiz olup olmadÄ±ÄŸÄ± tespit ediliyor.
    int k;
    for(int i = 0; i < SIZE; ++i){
        for(k = 0; k < SIZE; ++k){
            // AÅŸaÄŸÄ±daki ÅŸart doÄŸru olduÄŸunda ilgili dizi elemanÄ±nÄ±n dizide eÅŸsiz olmadÄ±ÄŸÄ± anlaÅŸÄ±lmaktadÄ±r ve dÃ¶ngÃ¼ sonlandÄ±rÄ±lmaktadÄ±r.
            if(i != k && ar[i] == ar[k]){
                break;
            }
        }

        // EÄŸer 'k' deÄŸeri dizi eleman sayÄ±sÄ±na eÅŸit ise bu durum ilgili dizi elemanÄ±nÄ±n dizide eÅŸsiz olduÄŸu anlamÄ±na geliyor.
        if(k == SIZE)
            printf("%3d ", ar[i]);
    }
}
```



ğŸ‘† YukarÄ±daki soruda eÅŸsiz olan elemanlarÄ±n sÄ±ralÄ± olarak bulunmasÄ± ÅŸartÄ± olmasaydÄ± soru aÅŸaÄŸÄ±daki gibi $O(n)$ karmaÅŸÄ±klÄ±kta Ã§Ã¶zÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <stdlib.h>

#define SIZE 20

int main(void)
{
    int ar[SIZE];

    randomize();

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼de dizinin elemanlarÄ± [0-19] aralÄ±ÄŸÄ±nda bir deÄŸer alacak ÅŸekilde atanmaktadÄ±r.
    for(int i = 0; i < SIZE; ++i)
        ar[i] = rand() % 20;

    print_array(ar, SIZE);

    int counts[SIZE] = { 0 };

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼de 'counts' dizisinin indislerine karÅŸÄ±lÄ±k gelen elemanlarÄ±n 'ar' dizisinde kaÃ§ defa geÃ§tiÄŸi bilgisi belirlenmektedir.
    for(int i = 0; i < SIZE; ++i)
        ++counts[ar[i]];

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼de 'counts' dizisinin sadece tek eleman iÃ§eren indeks deÄŸerleri yazdÄ±rÄ±lmaktadÄ±r, bu yÃ¶ntemde eÅŸsiz elemanlar yazdÄ±rÄ±lmaktadÄ±r ama sÄ±ra bilgisi kaybolmaktadÄ±r.
    for(int i = 0; i < SIZE; ++i)
        if(counts[i] == 1)
            printf("%3d ", i);
}
```


## Strings in C Continue(C dilinde YazÄ±lar Devam) 


ğŸ‘‡ AÅŸaÄŸÄ±daki programda girilen bir yazÄ±daki bir karakterin sayÄ±sÄ±nÄ±n bÃ¼yÃ¼k-kÃ¼Ã§Ã¼k harf duyarlÄ± ve duyarsÄ±z olarak nasÄ±l bulunabileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <ctype.h> // 'isalpha(), toupper()' gibi karakterler Ã¼zerinde iÅŸlem yapan fonksiyonlar bu kÃ¼tÃ¼phenede bulunmaktadÄ±r.

#define SIZE 200

int main(void)
{
    char str[SIZE];

    printf("bir yazi giriniz: ");
    sgets(str);
    printf("(%s)\n", str);

    int c;

    // BÃ¼yÃ¼k-kÃ¼Ã§Ã¼k harf duyarlÄ± olarak karakterin sayÄ±lmasÄ± iÅŸlemi
    printf("case-censitive olarak sayilacak karakteri giriniz: ");
    c = getchar();
    int cnt = 0;

    for(int i = 0; str[i] != '\0'; ++i){
        if(str[i] == c){
            ++cnt;
        }
    }

    printf("%d tane %c karakter var.\n", cnt, c);


    // BÃ¼yÃ¼k-kÃ¼Ã§Ã¼k harf duyarsÄ±z olarak karakterin sayÄ±lmasÄ± iÅŸlemi
    printf("case-incensitive olarak sayilacak karakteri giriniz: ");
    c = getchar();
    cnt = 0;

    for(int i = 0; str[i] != '\0'; ++i){
        if(toupper(str[i]) == toupper(c)){ 
            ++cnt;
        }
    }

    printf("%d tane %c karakter var.\n", cnt, c);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program girilen bir yazÄ±daki harflarin deÄŸer ve adedini hesaplayÄ±p standart Ã§Ä±ktÄ±ya vermektedir.
- AÅŸaÄŸÄ±daki gibi alfabetik karakterler ile yazÄ±lacak olan programlarda kullanÄ±lan karakter kodlamasÄ±nÄ±n ne olduÄŸu Ã¶nemlidir.
- **ASCII** karakter kodlamasÄ±nda harf karakterlerinin kodlarÄ± sÄ±ralÄ± durumdadÄ±r ve aÅŸaÄŸÄ±daki programda bu Ã¶zellikten faydalanÄ±lmaktadÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <ctype.h> // 'isalpha(), toupper()' gibi karakterler Ã¼zerinde iÅŸlem yapan fonksiyonlar bu kÃ¼tÃ¼phenede bulunmaktadÄ±r.

#define SIZE 200

int main(void)
{
    char str[SIZE];

    printf("bir yazi giriniz: ");
    sgets(str);
    printf("(%s)\n", str);

    int cnts[26] = { 0 }; // Ä°ngiliz alfabesinde 26 karakter olduÄŸu iÃ§in 26 elemanlÄ± bir dizi bildiriliyor.

    for(int i = 0; str[i] != '\0'; ++i){
        if(isalpha(str[i])){
            ++cnts[toupper(str[i])  - 'A']; // Burada yazÄ±daki alfabetik karakter bÃ¼yÃ¼k harfe Ã§evrilip 'A' karakterinden Ã§Ä±kartÄ±lÄ±yor, bu ÅŸekilde 'cnts' dizisinin hangi indisinin deÄŸerinin arttÄ±rÄ±lacaÄŸÄ± belirleniyor.
        }
    }

    for(int i = 0; i < 26; ++i){
        if(cnts[i] != 0){
            printf("%c   %d\n", i + 'A', cnts[i]); // "i + 'A'" ifadesi ile 'cnts' dizisinin ilgili indisinin hangi harfe karÅŸÄ±lÄ±k geldiÄŸi belirleniyor.
        }
    }
}
```



ğŸ“– Ã–dev-2: AÅŸaÄŸÄ±daki programda Ã¶yle bir kod yazÄ±lmasÄ± gerekiyor ki girdi olarak alÄ±nan iki sÃ¶zcÃ¼ÄŸÃ¼n yerleri deÄŸiÅŸtirilerek yazdÄ±rÄ±lacak, girilen sÃ¶zcÃ¼kler farklÄ± uzunlukta olabilir. Bu iÅŸlemi yaparken ayrÄ± bir dizi kullanÄ±lmayacak.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <ctype.h>

#define SIZE 200

int main(void)
{
    char str[SIZE];

    printf("aralarÄ±nda bir boÅŸluk karakteri ile iki sozcuk giriniz: ");
    sgets(str);
    printf("(%s)\n", str);

}
```



**Remove Copy**: Bir yazÄ±yÄ± copyalarken bir karakteri ya da yazÄ±yÄ± kaynak yazÄ±dan silerek yapÄ±lan kopyalama yÃ¶ntemine verilen addÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**remove copy**" algoritmasÄ±nÄ±n tek bir karakter iÃ§in gerÃ§ekleÅŸtiriminin nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <ctype.h>

#define SIZE 200

int main(void)
{
    char str1[SIZE];
    char str2[SIZE];

    printf("bir yazi giriniz: ");
    sgets(str1);

    printf("silinecek karakter: ");
    int ch = getchar();
    
    printf("(%s)\n", str1);

    int write_idx = 0;

    for(int i = 0; str1[i] != '\0'; ++i){
        // if(toupper(str1[i]) != toupper(ch))
        if(str1[i] != ch)
            str2[write_idx++] = str1[i];
    }
    str2[write_idx] = '\0'; // Buradaki iÅŸlem 'str2' yazÄ± dizisinin son karakterinin 0 olmasÄ± iÃ§in yazÄ±lmÄ±ÅŸtÄ±r.

    printf("(%s)\n", str2);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**remove a character from an array**" algoritmasÄ±nÄ±n gerÃ§ekleÅŸtiriminin nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <ctype.h>

#define SIZE 200

int main(void)
{
    char str[SIZE];

    printf("bir yazi giriniz: ");
    sgets(str);

    printf("silinecek karakter: ");
    int ch = getchar();

    printf("(%s)\n", str);

    int write_idx = 0;
    for(int i = 0; str[i] != '\0'; ++i)
        if(str[i] != ch)
            str[write_idx++] = str[i];
    
    str[write_idx] = '\0';

    printf("(%s)\n", str);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program bir yazÄ±dan rakam karakterlerini silecek bir programÄ±n nasÄ±l yazÄ±labileceÄŸini anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <ctype.h>

#define SIZE 200

int main(void)
{
    char str[SIZE];

    printf("bir yazi giriniz: ");
    sgets(str);

    printf("(%s)\n", str);

    int write_idx = 0;
    for(int i = 0; str[i] != '\0'; ++i)
        if(!isdigit(str[i]))
            str[write_idx++] = str[i];
    
    str[write_idx] = '\0';
}
```



â—â—â—ğŸ‘‡ AÅŸaÄŸÄ±daki programda girilen bir yazÄ±daki sÃ¶zcÃ¼klerin sayÄ±sÄ±nÄ± bulun bir programÄ±n nasÄ±l yazÄ±labileceÄŸi incelenebilir. 
- MÃ¼lakatlarda buna benzer 10-15 farklÄ± soru sorulabilir, bu tÃ¼r sorular "**flag variables(bayrak deÄŸiÅŸkenler)**" kullanÄ±larak Ã§Ã¶zÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <ctype.h>

#define SIZE 200

#define OUTWORD 0
#define INWORD 1

int main(void)
{
    char str[SIZE];

    printf("bir yazi giriniz: ");
    sgets(str);
    printf("girilen yazi: (%s)\n", str);

    int word_flag = OUTWORD;
    int word_count = 0;

    for(int i = 0; str[i] != '\0'; ++i){
        if(isspace(str[i]))
            word_flag = OUTWORD;
        else if(word_flag == OUTWORD){
            ++word_count;
            word_flag = INWORD;
        }
    }
    
    printf("girilen yazida toplamda %d sÃ¶zcÃ¼k vardir.", word_count);
}
```


Ders sonu ...
