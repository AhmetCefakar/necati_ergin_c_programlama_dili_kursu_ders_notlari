# 24.Ders 06.04.2025 ğŸ•˜

Derse 14(09:01)-16(09:31)-15(10:13)-16(10:45)-15(11:58)-15(12:00)-15(12:45) kiÅŸi katÄ±ldÄ±.
---


ğŸ§  Ã–nceki derste dizilerle ilgili yazÄ±lan fonksiyonlarÄ± doÄŸrudan main fonksiyonu iÃ§erisine yazÄ±yorduk bu da bizim bu fonksiyonlarÄ± genelleÅŸtirmediÄŸimiz anlamÄ±na geliyor, fonksiyonlarÄ± "**tekrar kullanÄ±labilir(re-useable)**" olarak yazmalÄ±yÄ±z. Dizilerle ilgili yazdÄ±ÄŸÄ±mÄ±z kodlarÄ± "utility.c, utility.h" dosyalarÄ± gibi dosyalara alabilmek iÃ§in pointer konusunu bilmek gerekiyor.

âš ï¸ C dilinde sorulan sorularÄ± yapay zekalardan ya da internetten bakmadan Ã§Ã¶zmeye Ã§alÄ±ÅŸmak gerekiyor, eÄŸer Ã§Ã¶zÃ¼m Ã¼retilemezse yardÄ±m alÄ±nabilir. YazÄ±lan C programlarÄ± ile yazÄ±lÄ±m geliÅŸtirebilme becerileri ilerlemektedir.


## Diziler Konusuna Devam



ğŸ“– Ã–dev-1: Bir dizideki tam sayÄ±larÄ±n ekrana her satÄ±rda dizi elemanÄ±nÄ±n deÄŸeri kadar yÄ±ldÄ±z basÄ±lmasÄ±nÄ± saÄŸlayan program mevcuttur, bu ÅŸeklin yan yatÄ±rÄ±lmÄ±ÅŸ olarak gÃ¶rÃ¼necek ÅŸekilde yazÄ±nÄ±z.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

#define SIZE 20

int main(void)
{
    int ar[SIZE];

    randomize();

    for(int i = 0; i < SIZE; ++i){
        ar[i] = rand() % 20 + 1;
        printf("%d", ar[i]);
    }
    print_array("\n\n");

    for(int i = 0; i < SIZE; ++i){
        for(int j = 0; j < ar[i]; ++j){
            putchar('*');
        }
        print_array("\n");
    }
}
```

ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**ğŸ“– Ã–dev-1**" cevabÄ± incelenebilir. Algoritma karmaÅŸÄ±klÄ±ÄŸÄ± $O(n^2)$.
```C
// Version-1
#include  <stdio.h>

int main(void)
{
    int ary[] = { 2, 4, 7, 3, 17, 13, 7, 3, 5, 15, 15, 14, 6, 11, 3, 9 };

    for (int i = 0; i < sizeof(ary) / sizeof(ary[0]); ++i) {
        for (int j = 0; j < ary[i]; ++j) {
            printf("*");
        }
        printf("\n");
    }

    printf("\n---------------------------------------------------\n");

    int max_val = ary[0];

    for (int i = 1; i < sizeof(ary) / sizeof(ary[0]); ++i) {
        if (ary[i] > max_val) {
            max_val = ary[i];
        }
    }

    for (int i = 0; i < max_val; ++i) {
        for (int j = 0; j < sizeof(ary) / sizeof(ary[0]); ++j) {
            if (ary[j] >= max_val - i) {
                printf("* ");
            }
            else {
                printf("  ");
            }
        }

        printf("\n");
    }

    printf("\n---------------------------------------------------\n");

    return 0;
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**ğŸ“– Ã–dev-1**" cevabÄ± incelenebilir. Algoritma karmaÅŸÄ±klÄ±ÄŸÄ± $O(n^2)$.
```C
// Version-2
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

#define SIZE 20

int main(void)
{
    int ary[SIZE];

    randomize();

    for (int i = 0; i < SIZE; ++i) {
        ary[i] = rand() % 20 + 1;
        printf("%d", ary[i]);
    }
    printf("\n---------------------------------------------------\n\n");

    for (int i = 0; i < SIZE; ++i) {
        for (int j = 0; j < ary[i]; ++j) {
            putchar('*');
        }
        printf("\n");
    }
    printf("\n---------------------------------------------------\n\n");


    int max_val = ary[0];

    for (int i = 1; i < sizeof(ary) / sizeof(ary[0]); ++i) {
        if (ary[i] > max_val) {
            max_val = ary[i];
        }
    }

    for (int i = 0; i < max_val; ++i) {
        for (int j = 0; j < sizeof(ary) / sizeof(ary[0]); ++j) {
            if (ary[j] >= max_val - i) {
                printf("* ");
            }
            else {
                printf("  ");
            }
        }

        printf("\n");
    }
}
```



ğŸ“– Ã¶dev-2: AÅŸaÄŸÄ±daki dizinin elemanlarÄ± 0-20 aralÄ±ÄŸÄ±nda. AÅŸaÄŸÄ±daki program dizideki **unique(eÅŸsiz)** elemanlarÄ±n sÄ±rayla ekrana yazdÄ±rÄ±lmasÄ± isteniyor.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

#define SIZE 20

int main(void)
{
    int ar[SIZE];

    randomize();

    for(int i = 0; i < SIZE; ++i){
        ar[i] = rand() % 20;
        printf("%d", ar[i]);
    }
    print_array("\n---------------------------------------------------\n\n");
}
```

**Standart Sapma(Standard Deviation)**: Ortalamadan sapmanÄ±n Ã¶lÃ§Ã¼sÃ¼dÃ¼r. **Standart Sapma** ne kadar dÃ¼ÅŸÃ¼kse ortalamada yÄ±ÄŸÄ±lma o kadar fazladÄ±r, **Standart Sapma** ne kadar yÃ¼ksekse ortalamadan o derece daÄŸÄ±tÄ±k olma durumu mevcuttur. 


ğŸ‘‡ AÅŸaÄŸÄ±daki programda yapÄ±lacak olan **standart sapma** hesaplamasÄ± iÅŸlemi ÅŸu ÅŸekilde yapÄ±lmalÄ±dÄ±r: Dizinin her bir elemanÄ±nÄ±n dizi ortalamasÄ±ndan farklarÄ±nÄ±n karelerinin toplamÄ± hesaplayÄ±p(dizi ortalamasÄ± "m" ise $ (ar[0] - m)^2 + (ar[1] - m)^2 + ... + (ar[n - 1] - m)^2$) bu toplamÄ± dizinin eleman sayÄ±sÄ±ndan bir kÃ¼Ã§Ã¼k olan tam sayÄ±ya bÃ¶l ve tÃ¼m bu matematiksel iÅŸlemin karekÃ¶kÃ¼nÃ¼ al.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"
#include <math.h>

#define SIZE 20

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    int ar_sum = 0;

    for(int i = 0; i < SIZE; ++i){
        ar_sum += ar[i];
    }

    double mean = (double)ar_sum / SIZE;
    double sum_square = 0.;

    for(int i = 0; i < SIZE; ++i){
        sum_square += (ar[i] - mean) * (ar[i] - mean);
    }
    
    double std_dev = sqrt(sum_square / (SIZE - 1)); // KarekÃ¶k alma iÅŸlemi

    printf("std_dev: %f\n", std_dev);
}
```


## Sorting and Sorting Algorithm(SÄ±ralama ve SÄ±ralama AlgiritmalarÄ±) 

âš ï¸ Bir sÄ±ralama algoritmasÄ± ve sÄ±ralama kuralÄ±(kriteri) birbirinden ayrÄ± kavramlardÄ±r ama yeni Ã¶ÄŸrenenler bu iki ÅŸeyi aynÄ± zannedip tongaya dÃ¼ÅŸÃ¼yorlarmÄ±ÅŸ.

SÄ±ralama iÅŸlemi bir karÅŸÄ±laÅŸtÄ±rma kriterine gÃ¶re dizinin elemanlarÄ±nÄ± konumlandÄ±rmak olarak tanÄ±mlanabilir.

Mesela sÄ±ralama kuralÄ±(kriteri) ÅŸu ÅŸekilde olabilir: Tekler baÅŸta Ã§iftler sonda, tekler kendi iÃ§inde kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe sÄ±ralÄ± ve Ã§iftler kendi iÃ§inde kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe sÄ±ralÄ±.

â—SÄ±ralama algoritmalarÄ± genellikle $O(n)$, $O(n^2)$, $O(n Logn)$ karmaÅŸÄ±klÄ±ÄŸÄ±nda olur.


ğŸ§­ SÄ±ralama algoritmalarÄ± big-0 notasyonu dÄ±ÅŸÄ±nda **best case**, **worst case**, **avarage case** olarak ta nitelendirilebiliyor.
- **Best case**: En iyi durum.
- **Worst case**: En kÃ¶tÃ¼ durum.
- **Avarage case**: Ortalama durum.


ğŸ§­ AÅŸaÄŸÄ±dakiler bazÄ± sÄ±ralama algoritmalarÄ± dizilmiÅŸtir;
- Linear sort
- Bouble sort
- Selaction sort
- Insertion sort
- Binary sort
- Quick sort
- Merge sort
- Radix sort
- Shell sort
- Heap sort
- Intro sort


â—Åu ana kadar algoritma karmaÅŸÄ±klÄ±ÄŸÄ±nÄ± sadece hesaplamaya baÄŸlÄ± olan karmaÅŸÄ±klÄ±k(**Computational Complexity** ya da **Time Complexity**) olarak inceledik yani veri yapÄ±sÄ±ndaki eleman sayÄ±sÄ±nÄ±n artmasÄ±yla yapÄ±lacak iÅŸlemlerin artmasÄ± arasÄ±ndaki iliÅŸkiyi betimlemek iÃ§in kullanÄ±lan bir yÃ¶ntemdir. </br>
Bunun dÄ±ÅŸÄ±nda algoritmalarÄ±n kullandÄ±klarÄ± bellek alanÄ± aÃ§Ä±sÄ±ndan da bir karmaÅŸÄ±klÄ±ÄŸÄ± vardÄ±r, bu karmaÅŸÄ±klÄ±ÄŸa **Space Complexity** denilmektedir.

**In-Place Algorithm**: **Bouble sort** gibi algoritmalar Ã§alÄ±ÅŸabilmesi iÃ§in ilave bir bellek alanÄ±na ihtiyaÃ§ duymazlar, bu tÃ¼rden ilave bellek ihtiyacÄ± olmayan algoritmalar **in-place** olarak nitelendirilmektedir.


**Stable(kararlÄ±)/Anstable(kararsÄ±z) Algorithm**: SÄ±ralamadan Ã¶nce sÄ±ralama kriterine gÃ¶re aynÄ± deÄŸerde olan kayÄ±tlar(burada "mete" kayÄ±tlarÄ±) sÄ±ralama iÅŸleminden sonra izafi konumlarÄ±nÄ± korudular mÄ± diye sorarsak buradaki incelenen misalde cevabÄ±n hayÄ±r olduÄŸu gÃ¶rÃ¼lÃ¼r bÃ¶yle algoritmalara **Anstable(kararsÄ±z) Algorithm** denilmektedir, sÄ±ralamadan sonra aynÄ± deÄŸere sahip kayÄ±tlarÄ±n birbirlerine gÃ¶re izafi konumlarÄ±nÄ± koruyan algoritmalara **Stable(kararlÄ±) Algorithm** denilmektedir.

ğŸ‘‡ AÅŸaÄŸÄ±daki listedeki adlarÄ± alfabetik olarak kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe sÄ±ralayalÄ±m, sÄ±ralamadaki "mete" kayÄ±tlarÄ±nÄ±n birbirlerine gÃ¶re izafi konumlarÄ± korunmadÄ±ÄŸÄ± iÃ§in bu sÄ±ralama **Anstable(kararsÄ±z) Algorithm** olarak nitelendirilecektir;

ğŸ“Œ SÄ±ralama Ã¶ncesi liste;
-  mete       19
- hasan       23
-  mete       26
- ayse        25
- veli        13
-  mete       40
- suleyman    15
-  mete       14

ğŸ“Œ SÄ±ralama sonrasÄ± liste;
- ayse        25
- hasan       23
- mete       14
- mete       19
- mete       26
- mete       40
- suleyman    15
- veli        13


â— BazÄ± durumlarda kullanÄ±lan sÄ±ralama algoritmasÄ±nÄ±n **Stable(kararlÄ±)/Anstable(kararsÄ±z)** olmasÄ± Ã¶nemli olabilir, buna gÃ¶re kullanÄ±lacak olan sÄ±ralama algoritmasÄ± belirlenmelidir.

â— Mesela elimizde 100.000 elemandan oluÅŸan bir ad ve yaÅŸ bilgisinden oluÅŸan bir dizi var, eÄŸer ilk baÅŸta bu dizinin elemanlarÄ±nÄ± yaÅŸa gÃ¶re kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe dizmiÅŸsek ardÄ±ndan da alfabetik olarak kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe dizmek istiyorsan bu durumda alfabetik olarak sÄ±ralama yaparken yaÅŸa gÃ¶re yapÄ±lan sÄ±ralamada aynÄ± adlÄ± kayÄ±tlarÄ±n birbirlerine gÃ¶re izafi sÄ±ralamalarÄ±nÄ±n deÄŸiÅŸmemesini isteriz, iÅŸte bu gibi durumlarda kullanÄ±lan sÄ±ralama algoritmalarÄ±nÄ±n **Stable(kararlÄ±)** olmasÄ±nÄ± isteriz.


### Bubble Sort Algorithm 


ğŸ§­ Baloncuk sÄ±ralama yÃ¶nteminde kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe sÄ±ralama yapÄ±lacaksa algoritma ÅŸu ÅŸekilde olacaktÄ±r;
1. Dizinin ilk elemanÄ±ndan baÅŸlanarak sÄ±rasÄ±yla dizinin o elemanÄ±ndan sonraki tÃ¼m elemanlarÄ±yla karÅŸÄ±laÅŸtÄ±rma yapÄ±lÄ±r(bu da iÃ§ iÃ§e iki dÃ¶ngÃ¼ kullanÄ±lmasÄ± gerektiÄŸi anlamÄ±na geliyor).
2. Ä°lgili adÄ±mda karÅŸÄ±laÅŸtÄ±rÄ±lan eleman kendinden sonraki elemanla karÅŸÄ±laÅŸtÄ±rÄ±lÄ±r eÄŸer daha bÃ¼yÃ¼kse o elemanlar yer deÄŸiÅŸtirilir.
3. Her adÄ±mda karÅŸÄ±laÅŸtÄ±rma yapÄ±lmasÄ± gereken eleman sayÄ±sÄ± iÃ§ dÃ¶ngÃ¼ iÃ§in `size -1 - i` kadar olacaktÄ±r, bunun nedeni her adÄ±mda en bÃ¼yÃ¼k elemanÄ±n zaten en sona taÅŸÄ±nmasÄ±dÄ±r, mesela ilk adÄ±mda dizideki en bÃ¼yÃ¼k eleman en sona taÅŸÄ±nmÄ±ÅŸ olacak, ikinci adÄ±mda ikinci en bÃ¼yÃ¼k eleman en sondan bir Ã¶nceki dizi indisine taÅŸÄ±nmÄ±ÅŸ olacak, bu iÅŸlemler bu ÅŸekilde sÃ¼rer gider, zaten bu nedenle "baloncuk sÄ±ralama" olarak adlandÄ±rÄ±lmaktadÄ±r.


ğŸ“Œ AÅŸaÄŸÄ±da baloncuk sÄ±ralama yÃ¶ntemiyle sÄ±ralama iÅŸleminin nasÄ±l yapÄ±ldÄ±ÄŸÄ± gÃ¶rÃ¼lebilir;
- 820 982 933 639 400 282 175 472 796 203 => Dizinin ilk durumu ve iÃ§ iÃ§e iki dÃ¶ngÃ¼nÃ¼n sadece en iÃ§teki dÃ¶ngÃ¼nÃ¼n ilk adÄ±mÄ± sonlandÄ±ÄŸÄ± durum iÃ§in dizinin son durumu, tÃ¼m sÄ±ralama adÄ±mlarÄ± yazÄ±lmamÄ±ÅŸtÄ±r.
- 820 933 982 639 400 282 175 472 796 203 => Ä°Ã§ iÃ§e iki dÃ¶ngÃ¼nÃ¼n sadece en iÃ§teki dÃ¶ngÃ¼nÃ¼n ikinci adÄ±mÄ± sonlandÄ±ÄŸÄ± durum iÃ§in dizinin son durumu.
- 820 933 639 982 400 282 175 472 796 203 => Ä°Ã§ iÃ§e iki dÃ¶ngÃ¼nÃ¼n sadece en iÃ§teki dÃ¶ngÃ¼nÃ¼n Ã¼Ã§Ã¼ncÃ¼ adÄ±mÄ± sonlandÄ±ÄŸÄ± durum iÃ§in dizinin son durumu.
- 820 933 639 400 982 282 175 472 796 203 => Ä°Ã§ iÃ§e iki dÃ¶ngÃ¼nÃ¼n sadece en iÃ§teki dÃ¶ngÃ¼nÃ¼n dÃ¶rdÃ¼ncÃ¼ adÄ±mÄ± sonlandÄ±ÄŸÄ± durum iÃ§in dizinin son durumu.
- 820 933 639 400 282 982 175 472 796 203 => Ä°Ã§ iÃ§e iki dÃ¶ngÃ¼nÃ¼n sadece en iÃ§teki dÃ¶ngÃ¼nÃ¼n beÅŸinci adÄ±mÄ± sonlandÄ±ÄŸÄ± durum iÃ§in dizinin son durumu.
- 820 933 639 400 282 175 982 472 796 203 => Ä°Ã§ iÃ§e iki dÃ¶ngÃ¼nÃ¼n sadece en iÃ§teki dÃ¶ngÃ¼nÃ¼n altÄ±ncÄ± adÄ±mÄ± sonlandÄ±ÄŸÄ± durum iÃ§in dizinin son durumu.
- 820 933 639 400 282 175 472 982 796 203 => Ä°Ã§ iÃ§e iki dÃ¶ngÃ¼nÃ¼n sadece en iÃ§teki dÃ¶ngÃ¼nÃ¼n yedinci adÄ±mÄ± sonlandÄ±ÄŸÄ± durum iÃ§in dizinin son durumu.
- 820 933 639 400 282 175 472 796 982 203 => Ä°Ã§ iÃ§e iki dÃ¶ngÃ¼nÃ¼n sadece en iÃ§teki dÃ¶ngÃ¼nÃ¼n sekizinci adÄ±mÄ± sonlandÄ±ÄŸÄ± durum iÃ§in dizinin son durumu.
- 820 933 639 400 282 175 472 796 203 982 => Ä°Ã§ iÃ§e iki dÃ¶ngÃ¼nÃ¼n sadece en iÃ§teki dÃ¶ngÃ¼nÃ¼n dokuzuncu adÄ±mÄ± sonlandÄ±ÄŸÄ± durum iÃ§in dizinin son durumu.
- Buradan sonra en dÄ±ÅŸtaki dÃ¶ngÃ¼nÃ¼n sonraki adÄ±mÄ±na geÃ§ilir ve yukarÄ±daki iÅŸlemler yeniden tekrar edilir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**Bubble Sort Algorithm**" gerÃ§ekleÅŸtirimi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"
#include <math.h>

#define SIZE 20

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    int ar_sum = 0;

    for(int i = 0; i < SIZE - 1; ++i){
        for(int j = 0; j < SIZE - 1 - i; ++j){
            if(ar[j] > ar[j + 1]){ // Buradaki 'if statement' iÃ§indeki ifade sÄ±ralama ÅŸartÄ±dÄ±r ve bu ÅŸartÄ± deÄŸiÅŸtirerek sÄ±ralama yÃ¶ntemini deÄŸiÅŸtirebiliriz.
                int temp = ar[j];
                ar[j] = ar[j + 1];
                ar[j + 1] = temp;
            }
        }
    }
    
    print_array(ar, SIZE);
}
```



â—â—â— If parantezi iÃ§ine Ã¶yle bir ifade yazÄ±nÄ±z ki karÅŸÄ±laÅŸtÄ±rma(sÄ±ralama) ÅŸÃ¶yle yapÄ±lsÄ±n;
- Tekler baÅŸta Ã§iftler sonda, tekler kendi iÃ§inde kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe sÄ±ralÄ± ve Ã§iftler kendi iÃ§inde kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe sÄ±ralÄ± olsun.
- ğŸ‘‡ AÅŸaÄŸÄ±daki program yukarÄ±daki aÃ§Ä±klamaya gÃ¶re sÄ±ralama iÅŸlemini yapmaktadÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"
#include <math.h>

#define SIZE 20

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    int ar_sum = 0;

    for(int i = 0; i < SIZE - 1; ++i){
        for(int j = 0; j < SIZE - 1 - i; ++j){
            if(
                (ar[j] % 2 == 0 && ar[j + 1] % 2) || // Bu ÅŸart ile biri tek diÄŸeri Ã§ift olan dizi elemanlarÄ±nÄ±n takasedilmesi saÄŸlanÄ±r ve bu ÅŸekilde tekler bir tarafta Ã§iftler diÄŸer tarafta toplanmÄ±ÅŸ olur.
                (ar[j] % 2 == ar[j + 1] % 2 && ar[j] > ar[j + 1]) // Bu ÅŸart ile sadece tek ya da Ã§ift olan dizi elemanlarÄ±nÄ±n eÄŸer dÃ¼ÅŸÃ¼k indisli dizi elemananÄ± bÃ¼yÃ¼k indisli dizi elemanÄ±ndan bÃ¼yÃ¼kse takas edilmesi saÄŸlanÄ±r.
            ){
                int temp = ar[j];
                ar[j] = ar[j + 1];
                ar[j + 1] = temp;
            }
        }
    }
    
    print_array(ar, SIZE);
}
```


â—â—â— YukarÄ±da yazÄ±lmÄ±ÅŸ olan sÄ±ralama algoritmasÄ±nÄ±n sÄ±ralama ÅŸartÄ±nÄ± deÄŸiÅŸtirerek istenildiÄŸi ÅŸekilde sÄ±ralam yapÄ±lmasÄ± saÄŸlanabiliyor, ileride(pointer konusunu iÅŸledikten sonra) buradaki sÄ±ralama ÅŸartÄ±nÄ± fonksiyona dÄ±ÅŸarÄ±lan baÅŸka bir fonksiyonun adresinin gÃ¶nderilmesiyle nasÄ±l parametrik yapÄ±labileceÄŸini gÃ¶receÄŸiz.


â—â—â— $O(n^2)$ ve $O(n logn)$ karmaÅŸÄ±klÄ±ktaki algoritmalarÄ±n Ã§alÄ±ÅŸma zamanlarÄ± n deÄŸerleri arttÄ±kÃ§a belirgin hale gelmektedir, daha yÃ¼ksek karmaÅŸÄ±klÄ±k seviyesindeki algoritmalar daha uzun sÃ¼rede Ã§alÄ±ÅŸacaktÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki program $O(n^2)$ karmaÅŸÄ±klÄ±ktaki algoritmanÄ±n eleman sayÄ±sÄ± artarken ne kadar sÃ¼rede tamamlanacaÄŸÄ± incelenebilir(2020'li yÄ±llarÄ±n ortalama bir bilgisayarÄ± iÃ§in ama burada donanÄ±m Ã¶nemli deÄŸil algoritma Ã¶nemli).
- Dizinin eleman sayÄ±sÄ± 10000 ise algoritma yaklaÅŸÄ±k "**0.067000 saniye**" sÃ¼rede tamamlanacaktÄ±r.
- Dizinin eleman sayÄ±sÄ± 100000 ise algoritma yaklaÅŸÄ±k "**9.879000 saniye**" sÃ¼rede tamamlanacaktÄ±r.
- Dizinin eleman sayÄ±sÄ± 200000 ise algoritma yaklaÅŸÄ±k "**41.168000 saniye**" sÃ¼rede tamamlanacaktÄ±r.
- Dizinin eleman sayÄ±sÄ± 2000000 ise algoritma yaklaÅŸÄ±k "**4100 saniye(68 dakika)**" sÃ¼rede tamamlanacaktÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"
#include <time.h>

#define SIZE 20

int main(void)
{
    int ar[SIZE];

    randomize();

    int* ar = (int*)malloc(SIZE * sizeof(int)); 
    if(ar == NULL){
        printf("bellek yetersiz\n");
        return 1;
    }

    set_array_random(ar, SIZE);
    //print_array(ar, SIZE);

    printf("siralama basliyor.\n");
    clock_t start = clock();

    for(int i = 0; i < SIZE - 1; ++i){
        for(int j = 0; j < SIZE - 1 - i; ++j){
            if(ar[j] > ar[j + 1]){
                int temp = ar[j];
                ar[j] = ar[j + 1];
                ar[j + 1] = temp;
            }
        }
    }

    clock_t end = clock();

    printf("siralama bitti. dizi boyutu %d, siralama %f saniye\n", SIZE, (double)(end - start) / CLOCKS_PER_SEC);
    (void)getchar();

    print_array(ar, SIZE);
    free(ar);
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki program $O(n^2)$ karmaÅŸÄ±klÄ±ktaki **boble sort** yerine $O(n logn)$ karmaÅŸÄ±klÄ±ktaki **quick sort** algoritmasÄ± kullanÄ±lmÄ±ÅŸ halidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"
#include <time.h>

#define SIZE 20

// 'icmp' adÄ± 'Int Compare' sÃ¶zcÃ¼klerinin kÄ±saltmasÄ±ndan gelmektedir.
// Bu fonksiyon sÄ±ralama algoritmasÄ±na gÃ¶nderilecek olan sÄ±ralama ÅŸartÄ±nÄ± gerÃ§ekleÅŸtirecek olan fonksiyondur.
int icmp(const void* vp1, const void* vp2)
{
    return *(const int*)vp1 - *(const int*)vp2;
}

int main(void)
{
    int ar[SIZE];

    randomize();

    int* ar = (int*)malloc(SIZE * sizeof(SIZE)); 
    if(ar == NULL){
        printf("bellek yetersiz\n");
        return 1;
    }

    set_array_random(ar, SIZE);
    //print_array(ar, SIZE);

    printf("siralama basliyor.\n");
    clock_t start = clock();

    /*
    for(int i = 0; i < SIZE - 1; ++i){
        for(int j = 0; j < SIZE - 1 - i; ++j){
            if(ar[j] > ar[j + 1]){
                int temp = ar[j];
                ar[j] = ar[j + 1];
                ar[j + 1] = temp;
            }
        }
    }
    */

    qsort(ar, SIZE, sizeof(int), icmp); // 'qsort' fonksiyonu 'stdlib.h' baÅŸlÄ±k dosyasÄ±nda bildirilmiÅŸ olan C'nin standart fonksiyonudur.

    clock_t end = clock();

    printf("dizi boyutu %d, siralama %f saniye\n", SIZE, (double)(end - start) / CLOCKS_PER_SEC);
    (void)getchar();

    print_array(ar, SIZE);
    free(ar);
}
```


### Selection Sort Algorithms 

Bu algoritmanÄ±n da zaman karmaÅŸÄ±klÄ±ÄŸÄ± $O(n^2)$ seviyesindedir.

ğŸ§­ **selection sort** yÃ¶nteminde kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe sÄ±ralama yapÄ±lacaksa algoritma ÅŸu ÅŸekilde Ã§alÄ±ÅŸmaktadÄ±r;
1. Dizinin ilk elemanÄ±ndan baÅŸlanarak sÄ±rasÄ±yla dizinin o elemanÄ±ndan sonraki tÃ¼m elemanlarÄ± iÃ§indeki en kÃ¼Ã§Ã¼n elemanÄ±n index deÄŸeri tespit edilir.
2. Ä°lgili adÄ±mdaki dizi elemanÄ±yla tespit edilen en kÃ¼Ã§Ã¼k eleman ile karÅŸÄ±laÅŸtÄ±rma yapÄ±lÄ±r eÄŸer ilgili adÄ±mdaki dizi elemanÄ±ndan kÃ¼Ã§Ã¼kse takas iÅŸlemi yapÄ±lÄ±r.
3. Her adÄ±mda karÅŸÄ±laÅŸtÄ±rma yapÄ±lmasÄ± gereken eleman sayÄ±sÄ± iÃ§ dÃ¶ngÃ¼ iÃ§in "size -1 - i" kadar olacaktÄ±r, bunun nedeni her adÄ±mda en kÃ¼Ã§Ã¼k elemanÄ±n zaten en baÅŸa taÅŸÄ±nmasÄ±dÄ±r, mesela ilk adÄ±mda dizideki en kÃ¼Ã§Ã¼k eleman en baÅŸa taÅŸÄ±nmÄ±ÅŸ olacaktÄ±r, ikinci adÄ±mda ikinci en kÃ¼Ã§Ã¼k eleman en baÅŸtan bir sonraki dizi indisine taÅŸÄ±nmÄ±ÅŸ olacak, bu iÅŸlemler bu ÅŸekilde sÃ¼rer gider.


ğŸ“Œ AÅŸaÄŸÄ±da **selection sort** yÃ¶ntemiyle sÄ±ralama iÅŸleminin nasÄ±l yapÄ±ldÄ±ÄŸÄ± gÃ¶rÃ¼lebilir;
- 729 274 376 55 615 265 30 258 183 490 => Dizinin ilk durumu.
- 30 274 376 55 615 265 729 258 183 490 => Ä°Ã§ iÃ§e iki dÃ¶ngÃ¼nÃ¼n ilk adÄ±mÄ± sonlandÄ±ÄŸÄ± durum iÃ§in dizinin son durumu.
- 30 55 376 274 615 265 729 258 183 490 => Ä°Ã§ iÃ§e iki dÃ¶ngÃ¼nÃ¼n ikinci adÄ±mÄ± sonlandÄ±ÄŸÄ± durum iÃ§in dizinin son durumu.
- 30 55 183 274 615 265 729 258 376 490 => Ä°Ã§ iÃ§e iki dÃ¶ngÃ¼nÃ¼n Ã¼Ã§Ã¼ncÃ¼ adÄ±mÄ± sonlandÄ±ÄŸÄ± durum iÃ§in dizinin son durumu.
- 30 55 183 258 615 265 729 274 376 490 => Ä°Ã§ iÃ§e iki dÃ¶ngÃ¼nÃ¼n dÃ¶rdÃ¼ncÃ¼ adÄ±mÄ± sonlandÄ±ÄŸÄ± durum iÃ§in dizinin son durumu.
- 30 55 183 258 265 615 729 274 376 490 => Ä°Ã§ iÃ§e iki dÃ¶ngÃ¼nÃ¼n beÅŸinci adÄ±mÄ± sonlandÄ±ÄŸÄ± durum iÃ§in dizinin son durumu.
- 30 55 183 258 265 274 729 615 376 490 => Ä°Ã§ iÃ§e iki dÃ¶ngÃ¼nÃ¼n altÄ±ncÄ± adÄ±mÄ± sonlandÄ±ÄŸÄ± durum iÃ§in dizinin son durumu.
- 30 55 183 258 265 274 376 615 729 490 => Ä°Ã§ iÃ§e iki dÃ¶ngÃ¼nÃ¼n yedinci adÄ±mÄ± sonlandÄ±ÄŸÄ± durum iÃ§in dizinin son durumu.
- 30 55 183 258 265 274 376 490 729 615 => Ä°Ã§ iÃ§e iki dÃ¶ngÃ¼nÃ¼n sekizinci adÄ±mÄ± sonlandÄ±ÄŸÄ± durum iÃ§in dizinin son durumu.
- 30 55 183 258 265 274 376 490 615 729 => Ä°Ã§ iÃ§e iki dÃ¶ngÃ¼nÃ¼n dokuzuncu adÄ±mÄ± sonlandÄ±ÄŸÄ± durum iÃ§in dizinin son durumu.

ğŸ‘‡ AÅŸaÄŸÄ±daki program $O(n^2)$ karmaÅŸÄ±klÄ±ktaki **selection sort** algoritmasÄ±nÄ± gerÃ§ekleÅŸtirmesi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"
#include <math.h>

#define SIZE 20

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    int ar_sum = 0;

    for(int i = 0; i < SIZE - 1; ++i){
        // En kÃ¼Ã§Ã¼k elemanÄ±n indeksinin tespitedilmesi
        int min_index = i;

        for(int j = j + 1; j < SIZE; ++j){
            if(ar[j] > ar[min_index]){
                min_index = j;
            }
        }

        if(min_index != i){
            int temp = ar[i];
            ar[i] = ar[min_index];
            ar[min_index] = temp;
        }
    }
    
    print_array(ar, SIZE);
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.46-11.08 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***

## Searching and Searching Algorithms(Arama ve Arama AlgoritmalarÄ±) 

### Binary Search Algorithm


SÄ±ralÄ± dizilerde yapÄ±lacak arama iÅŸlemlerinde **binary Search** adlÄ± algoritma kullanÄ±labilir. </br>
**Binary Search** algoritmasÄ± aÅŸaÄŸÄ±daki gibi Ã§alÄ±ÅŸÄ±r;
- Ä°lk Ã¶nce dizinin ortasÄ±ndaki elemana bakÄ±lÄ±r aranÄ±lan deÄŸerin hangi tarafta olduÄŸuna gÃ¶re dizinin diÄŸer yarÄ±sÄ±na bakÄ±lmaz ve karÅŸÄ±laÅŸtÄ±rma yapÄ±lacak olan dizi eleman sayÄ±sÄ± algoritmanÄ±n her adÄ±mÄ±nda yarÄ±ya inmiÅŸ olur.
- Her adÄ±mda yukarÄ±daki gibi arama yapÄ±lacak olan dizinin elemanlarÄ±nÄ±n ortanca elemanÄ±nÄ±n aranÄ±lan deÄŸere gÃ¶re bÃ¼yÃ¼k, kÃ¼Ã§Ã¼k olmasÄ±na gÃ¶re dizinin hangi aralÄ±ÄŸÄ±na bakÄ±lacaÄŸÄ± tespit edilir ve en sonunda aranÄ±lan deÄŸer eÄŸer dizide varsa bulunur yoksa aranÄ±lan deÄŸerin dizide olmadÄ±ÄŸÄ±ndan emin olunmuÅŸ olur.
- **Binary Search** algoritmasÄ± gerÃ§ekleÅŸtirilirken dizinin en en bÃ¼yÃ¼k ve en kÃ¼Ã§Ã¼k deÄŸerinin indeks deÄŸeri deÄŸiÅŸkenlerde tutulur ve yukarÄ±da aÃ§Ä±klanan her adÄ±mda bu aralÄ±k daraltÄ±larak aranÄ±lan deÄŸer bulunmaya Ã§alÄ±ÅŸÄ±lÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda $O(logn)$ karmaÅŸÄ±klÄ±ktaki **binary Search** algoritmasÄ±nÄ±n gerÃ§ekleÅŸtirimi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"
#include <math.h>

#define SIZE 20


int icmp(const void* vp1, const void* vp2)
{
    return *(const int*)vp1 - *(const int*)vp2;
}

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    qsort(ar, SIZE, sizeof(int), icmp); // 'qsort' fonksiyonu C'nin standart kÃ¼tÃ¼phane fonksiyonudur.
    print_array(ar, SIZE);

    int key;
    printf("aranacak degeri giriniz: ");
    scanf("%d", &key);

    int idx_first = 0;
    int idx_last = SIZE - 1;
    int idx_mid = 0;

    int count = 0; // Bu deÄŸeri lagoritmanÄ±n zaman karmaÅŸÄ±klÄ±ÄŸÄ±nÄ±n 'O(logn)' olduÄŸunu anlamak iÃ§in kullanÄ±yoruz, algoritmaya dahil bir deÄŸiÅŸken deÄŸildir.

    while(idx_first <= idx_last){
        idx_mid = (idx_first + idx_last) / 2;

        if(ar[idx_mid] == key) // Bu durumda aranÄ±lan deÄŸer bulunmuÅŸ olur.
            break;

        if(ar[idx_mid] > key)  // Bu durumda aranÄ±lan deÄŸer bulunamadÄ± ama aranÄ±lan deÄŸerin ortanca deÄŸerden kÃ¼Ã§Ã¼k olduÄŸu anlaÅŸÄ±lÄ±r.
            idx_last = idx_mid - 1; // Burada son indeks ortanca indeksten bir Ã¶nceki indekse alÄ±nÄ±yor.
        else
            idx_first = idx_mid + 1; // Burada ilk indeks ortanca indeksten bir sonraki indekse alÄ±nÄ±yor.
    }

    if(idx_first > idx_last){
        printf("bulunamadÄ±.\n");
    }
    else{
        printf("bulundu, dizinin %d indisli elemani.\n", idx_mid);
    }

    printf("%d elemanli dizide %d adimda aranilan deger icin islem tamamalandi.\n", SIZE, count);
}
```

ğŸ“Œ AlgoritmalarÄ±n **zaman karmaÅŸÄ±klÄ±klarÄ±(calculator complexity)** aÅŸaÄŸÄ±daki gibi olabilir(aradaki deÄŸerler gÃ¶sterilmiyor);
- $O(1)$
- $O(log)$
- $O(n)$
- $O(nlogn)$
- $O(n^2)$



MÃ¼lakatlarda sorulan gÃ¼zel bir soru ama ÅŸu andaki bilgimizle soruyu Ã§Ã¶zemeyebiliriz.
- â”ÃœÃ§ dizinin her birinden birer adet toplamda Ã¼Ã§ indeks deÄŸeri bulunacan ve indekslerdeki dizi elemanlarÄ±nÄ±n toplamÄ± girdi(input) olarak verilen deÄŸere eÅŸit olacak ÅŸekilde bir durum mevcut mu bulan bu durum yoksa bulunamadÄ± diye Ã§Ä±ktÄ± Ã¼reten bir program yazÄ±nÄ±z?
- ğŸ“– Ã–dev-3: Bu konuda sorulabilecek soru ÅŸudur: YukarÄ±da aÃ§Ä±klanan algoritmayÄ± $O(n^3)$ karmaÅŸÄ±klÄ±ktan daha dÃ¼ÅŸÃ¼k karmaÅŸÄ±klÄ±k seviyesinde Ã§Ã¶zebilecek bir algoritma ile gerÅŸekleÅŸtiriniz. Bu algoritma eÄŸer $O(n^2 * logn)$ karmaÅŸÄ±klÄ±kta Ã§Ã¶zÃ¼lebilirse istenilen saÄŸlanmÄ±ÅŸ olur.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"
#include <time.h>

#define SIZE 1500

int main(void)
{
    int a1[SIZE];
    int a2[SIZE];
    int a3[SIZE];

    int val;
    printf("aranacak degeri giriniz: ");
    scanf("%d", &val);

    randomize();
    set_array_random(a1, SIZE);
    print_array(a1, SIZE);

    set_array_random(a2, SIZE);
    print_array(a2, SIZE);

    set_array_random(a3, SIZE);
    print_array(a3, SIZE);

    for(int i = 0; i < SIZE; ++i){
        for(int j = 0; j < SIZE; ++j){
            for(int k = 0; k < SIZE; ++k){
                if(a1[i] + a2[j] + a3[k] == val){
                    printf("tespit edilen indeks degerleri: %d, %d, %d\n", i, j, k);
                    return 0;
                }
            }
        }
    }

    printf("istenilen sartlari saglayan durum tespit edilemedi.\n");
    return 1;
}
```


**Sub Array(Subsquance)**: Bir dizinin sÄ±ralÄ± n adet elemanÄ±nÄ±n oluÅŸturacaÄŸÄ± diziye verilen addÄ±r, bu durumda dizinin kendisi ya da tek bir elemanÄ± da bir **subsquance** oluÅŸturacaktÄ±r.

**Maximum Subsquance Problem**: Ä°Ã§erisinde en az bir adet negatif deÄŸer olan bir dizideki n elemanlÄ± alt dizinin elemanlarÄ±nÄ±n toplamÄ±nÄ±n en bÃ¼yÃ¼k olduÄŸu dizinin belirlenmesi problemine verilen addÄ±r. 



ğŸ“– Ã–dev-4: **Maximum Sub Array(Maximum Subsquance)** iÅŸlemini yapacak olan algoritmanÄ±n zaman karmaÅŸÄ±klÄ±ÄŸÄ± $O(n)$ olarak yazÄ±labiliyor ve bu algoritmayÄ± yazÄ±nÄ±z(aÅŸÄŸÄ±daki "ar[SIZE]" dizisi Ã¶zelinde test iÅŸlemi yapÄ±lmalÄ±dÄ±r). 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"
#include <time.h>

#define SIZE 1000

int main(void)
{
    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile rastgele sayÄ± Ã¼retilebilir
    //randomize();
    //for(int i = 0; i < SIZE; ++i){
    //    if(i && i % 20 == 0)
    //        printf("\n");
    //    printf("%d, ", (rand() % 2 ? 1 : -1) * (rand() % 10000));
    //}

    int ar[SIZE] = {
        -3818, 7277, -5116, -1233, 259, -2731, -6153, 5436, 410, 2644,
        -3415, -3632, -4076, 3857, -2641, -7184, -7326, 159, 914, 369,
        -7894, -1036, 9549, 1294, 5087, -5822, 5926, 517, -616, 6796,
        -4567, 2919, 3926, -1523, 8237, -4524, -2910, -2450, -8904, 7021,
        -6811, -3598, 1502, -5544, 2990, -2191, 6920, 9696, 1849, 9697,
        -7348, 7370, 3492, -7189, 2994, -5041, 840, 7341, 3927, 6387,
        2790, 9683, 5612, 4786, 8913, 3554, -2784, 2276, 4639, -4315,
        -402, 5779, -3085, -6194, 2952, 2110, -3960, -2223, -827, 693,
        -3588, 8045, 7817, 7841, -6473, -670, -5681, 1050, -9041, -5381,
        -5371, -4239, -5563, 6075, -1485, -4082, -3931, -363, 1686, 5753,
    };
}
```


### Merge Algorithm



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **merge** algoritmasÄ± yazÄ±lmÄ±ÅŸtÄ±r, bu algoritmasÄ±nÄ±n zaman karmaÅŸÄ±klÄ±ÄŸÄ± $O(n)$ seviyesindedir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"
#include <time.h>

#define SIZE 10

int icmp(const void* vp1, const void* vp2)
{
    return *(const int*)vp1 - *(const int*)vp2;
}

int main(void)
{
    int a[SIZE];
    int b[SIZE];
    int c[SIZE * 2] = {0};

    randomize();
    set_array_random(a, SIZE);
    set_array_random(b, SIZE);

    qsort(a, SIZE, sezeof(int), icmp);
    qsort(b, SIZE, sezeof(int), icmp);

    print_array(a, SIZE);
    print_array(b, SIZE);

    int idx_a = 0;
    int idx_b = 0;

    for(int i = 0; i < 2 * SIZE; ++i){
        if(idx_a == SIZE){
            c[i] = b[idx_b++]; // AÅŸaÄŸÄ±daki iki satÄ±r yerine tek satÄ±rda yazÄ±ldÄ±.
            //c[i] = b[idx_b];
            //++idx_b;  
        }
        else if(idx_b == SIZE){
            c[i] = a[idx_a++];
        }
        else if(a[idx_a] < b[idx_b]){
            c[i] = a[idx_a++];
        }
        else{
            c[i] = b[idx_b++];
        }
    }

    print_array(c, 2 * SIZE);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda belirli bir sabit sayÄ±daki dizinin belirli bir aralÄ±kta alabileceÄŸi tam sayÄ± deÄŸerlerinin adetlerinin nasÄ±l hesaplanabileceÄŸi incelenebilir.
- â— Buradaki programda kullanÄ±lan algoritma tekniÄŸi, yazÄ±lÄ±m mÃ¼lakatlarÄ±nda sorulan bazÄ± algoritma sorularÄ±nÄ±n Ã§Ã¶zÃ¼mÃ¼nde kullanÄ±labilecek bir tekniktir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"
#include <math.h>

#define SIZE 1000
#define RANGE_SIZE 20

int main(void)
{
    int a[SIZE];

    randomize();

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼de 'a' dizisinin elemanlarÄ±na [0-19] kapalÄ± aralÄ±ÄŸÄ±nda rastgele deÄŸer atama iÅŸlemini yapÄ±lmaktadÄ±r.
    for(int i = 0; i < SIZE; ++i){
        a[i] = rand() % RANGE_SIZE;
    }

    int cnts[RANGE_SIZE] = { 0 };

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼de 'a' dizisinin eleman sayÄ±sÄ± kadar dÃ¶nÃ¼lerek, 'a' dizisinin [0-19] kapalÄ± aralÄ±ÄŸÄ±nda olan deÄŸlerinin kaÃ§ar adet olduÄŸu bilgisi 'cnts' dizisine alÄ±nÄ±yor.
    for(int i = 0; i < SIZE; ++i){
        ++cnts[a[i]];
    }
    
    for(int i = 0; i < RANGE_SIZE; ++i){
        printf("%d deÄŸerinden %d tane var.\n", i , cnts[i]);
    }
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.05-12.15 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


### Ducth flag problem(Hollanda bayraÄŸÄ± problemi)

**Ducth flag problem(Hollanda bayraÄŸÄ± problemi)**: Bir dizi var bu dizede sadece Ã¼Ã§ farklÄ± deÄŸer mevcut ama dizinin eleman sayÄ±sÄ± herhangi bir bÃ¼yÃ¼klÃ¼kte olabilir. Bu dizi Ã¼zerinde tek bir defa dolaÅŸÄ±lacak, ilave bellek alanÄ± kullanmak yok ve bu dÃ¶ngÃ¼nÃ¼n sÄ±ralanmasÄ± saÄŸlanmasÄ± isteniyor.

ğŸ“– Ã–dev-5: **Ducth flag algorithm** gerÃ§ekleÅŸtiren bir C programÄ± yazÄ±nÄ±z.


## Strings in C (C dilinde YazÄ±lar) 

C dilinde "**string**" adÄ±nda bir tÃ¼r yoktur, C dilinde yazÄ±lar dizilerde tutulur, genel olarak "`char`" tÃ¼rÃ¼nden dizilerde tutuluyor.

> â”
> Bir dizinin elemanlarÄ±nÄ±n `char` tÃ¼rÃ¼nde tutmaktan daha az yer kaplayacak ÅŸekilde nasÄ±l bir kullanÄ±m olabilir? 
> 
> Cevap;
>
> Bir tam sayÄ±nÄ±n bitlerinde veri tutulabilir. EÄŸer tutulacak olan deÄŸerler [0-15] arasÄ±ndaysa bu bilgiyi 4 bitlik alanda(1 limbil), [0-7] arasÄ±ndaysa bu bilgiyi 3 bitlik alanda, [0-3] arasÄ±ndaysa bu bilgiyi 2 bitlik alanda, [0-1] arasÄ±ndaysa bu bilgiyi 1 bitlik alanda tutulabilir. 
> Bu ÅŸekilde bir kullanÄ±m sadece bellek kÄ±sÄ±tÄ± olan donanÄ±mlar Ã¼zerinde Ã§alÄ±ÅŸÄ±lÄ±rken tercihedilmelidir.
> Bu ÅŸekilde bir kullanÄ±mlarda ilgili tam sayÄ±nÄ±n bitlerine deÄŸer yazarken ya da okurken bit seviyesinde iÅŸlem yapmak gerekeceÄŸi unutulmamalÄ±dÄ±r.


ğŸ§  C dilinde `string` adÄ±nda bir tÃ¼r yoktur ama `struct` tÃ¼rÃ¼nden bir kullanÄ±cÄ± tanÄ±mlÄ± tÃ¼r oluÅŸturularak diÄŸer dillerde olan `string` tÃ¼rÃ¼ gibi Ã§alÄ±ÅŸacak olan bir tÃ¼r oluÅŸtutulabilir.


**NTBS(Null Terminated Byte Stream)**: YazÄ± deÄŸerleri tutmak iÃ§in son elemanÄ± **null character** olan dizi kullanÄ±m yÃ¶ntemine verilen addÄ±r. Mesela `int str[4]; str[0] = 'E'; str[1] = 'C'; str[2] = 'A'; str[3] = '\0';` buradaki "str" dizisi **NTBS** olarak tutulan bir dizidir.

**Null character**: TÃ¼m karakter kodlamalarÄ±nda tam sayÄ± olarak "0" deÄŸerine karÅŸÄ±lÄ±k geldiÄŸi kesin olan karakterdir ve karakter sabiti `'\0'` olarak gÃ¶sterilir.

â— Karakter sabitleri C dilinde `int`, C++ dilinde `char` tÃ¼rÃ¼ndedir.

ğŸ‘‡ AÅŸaÄŸÄ±daki programda `'\0'` ve `'0'` karakterlerinin tam sayÄ± deÄŸerlerinin ne olduÄŸu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    printf("%d\n", '\0');
    printf("%d\n", '0');
    printf("%d\n", 0);
}
```


â— VarsayÄ±lan olarak C dilinde yazÄ±larÄ±n sonunda **null karakter** olduÄŸu kabul edilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki program C dilindeki `char` dizilerinin yazÄ± sonlandÄ±rma karakteri ile nasÄ±l bir baÄŸlantÄ±sÄ± olduÄŸunu anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    char str[20] = "yazÄ±lan yazÄ±";

    for(int i = 0; str[i] != '\0'; ++i){
        putchar(str[i]);
    }

    // Dizi sonu aÅŸaÄŸÄ±daki gibi de yazÄ±labilir ama bÃ¶yle yazmak kodu okuyanÄ± ÅŸaÅŸÄ±rtabilir ve bÃ¶yle kullanÄ±lmamalÄ±dÄ±r.
    for(int i = 0; str[i] != 0; ++i){
        putchar(str[i]);
    }

    // Dizi sonu aÅŸaÄŸÄ±daki gibi de yazÄ±labilir ama bÃ¶yle yazmak kodu okuyanÄ± ÅŸaÅŸÄ±rtabilir ve bÃ¶yle kullanÄ±lmamalÄ±dÄ±r.
    for(int i = 0; str[i]; ++i){
            putchar(str[i]);
    }
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir karakter dizisinin son karakterini ifade eden `'\n'` karakterinin dizinin farklÄ± bir indeksine atanmasÄ± ile nasÄ±l dizinin tuttuÄŸu yazÄ± kÄ±saltÄ±labiliyor bu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    char str[20] = "yazÄ±lan yazÄ±";

    str[5] = '\0';

    for(int i = 0; str[i] != '\0'; ++i){
        putchar(str[i]);
    }
}
```



â— **Null Stream**:  Bir dizide tutulan yazÄ±larÄ±n uzunluÄŸu 0 karakterli olabilir, bu tÃ¼rden dizilere **null stream** denmektedir. 


**Inditormenet Value(Garbage Value)**: Ã‡Ã¶p deÄŸer olarak tanÄ±mlanan, bir deÄŸiÅŸkenin bir kapsam(scope) iÃ§erisinde **otomatic storage duration** olarak tanÄ±mlandÄ±ÄŸÄ± durumlarda ilk deÄŸer verilmediÄŸinde bu deÄŸiÅŸkenler kendilerine hafÄ±zadan ayrÄ±lan yerdeki bitleri olduÄŸu gibi alÄ±rlar iÅŸte bu durumda deÄŸiÅŸken hayatÄ±na Ã§Ã¶p deÄŸer ile baÅŸlamÄ±ÅŸ olacaktÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda tanÄ±msÄ±z davranÄ±ÅŸ vardÄ±r Ã§Ã¼nkÃ¼ **otomatic Ã¶mÃ¼rlÃ¼** deÄŸiÅŸkenlere ilk deÄŸer verilmediÄŸinde dizinin elemanlarÄ± **Ã§Ã¶p deÄŸerde** alÄ±yor. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    char str[20];

    str[0] = 'C';
    str[1] = 'A';
    str[2] = 'N';

    for(int i = 0; str[i] != '\0'; ++i){
        putchar(str[i]);
    }
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda tanÄ±msÄ±z davranÄ±ÅŸ yoktur.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    char str[20];

    str[0] = 'C';
    str[1] = 'A';
    str[2] = 'N';
    str[3] = '\0';

    for(int i = 0; str[i] != '\0'; ++i){
        putchar(str[i]);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda tanÄ±msÄ±z davranÄ±ÅŸ yoktur. Global deÄŸiÅŸkenler **static storage duration** Ã¶zelliÄŸine sahip ve bu tÃ¼r deÄŸiÅŸkenlere ilk deÄŸer verilmese bile baÅŸlangÄ±Ã§ deÄŸerleri 0 deÄŸeriyle baÅŸlayacaktÄ±r. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

char str[20];

int main(void)
{
    str[0] = 'C';
    str[1] = 'A';
    str[2] = 'N';

    for(int i = 0; str[i] != '\0'; ++i){
        putchar(str[i]);
    }
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda tanÄ±msÄ±z davranÄ±ÅŸ yoktur Ã§Ã¼nkÃ¼ **static** deÄŸiÅŸkenler ilk deÄŸer atanmadÄ±ÄŸÄ±nda Ã¶mÃ¼rlerine 0 deÄŸeriyle baÅŸlar.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    static char str[20];

    str[0] = 'C';
    str[1] = 'A';
    str[2] = 'N';

    for(int i = 0; str[i] != '\0'; ++i){
        putchar(str[i]);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program yazÄ± tutan bir diziye deÄŸer atama iÅŸleminin atama operatÃ¶rÃ¼ ile neden yapÄ±lamayacaÄŸÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    char str[20];

    // str = "yazi"; // Burada sÃ¶zdizim hatasÄ±(syntax error) olacaktÄ±r Ã§Ã¼nkÃ¼ dizi adlarÄ± atama operatÃ¶rÃ¼nÃ¼n sol operandÄ± olamaz bunun nedeni de C dilinin standardÄ±nÄ±n kuralÄ±ndan dolayÄ± bir ifadede kullanÄ±lan dizi adlarÄ±nÄ±n dizinin ilk elemanÄ±nÄ±n adresine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼ÅŸ iÅŸlemidir.
    // &str[0] = "yazi"; // Buradaki statement ile 'str = "yazi";' bu statement aynÄ±dÄ±r.
}
```


â—â—â— **NTBS** olarak yazÄ± tutan bir dizideki yazÄ±yÄ± deÄŸiÅŸtirmek iÃ§in ya da bir yazÄ±yÄ± bir diziye yerleÅŸtirmek iÃ§in atama operatÃ¶rÃ¼nÃ¼ C dilinin standardÄ±nda olan **array decey** kuralÄ±ndan dolayÄ± kullanamÄ±yoruz. Ama deÄŸer atama iÅŸlemi ile ilk deÄŸer verme iÅŸlemi birbirinden farklÄ± olduÄŸunu unutmamak gerekiyor.



ğŸ‘‡ AÅŸaÄŸÄ±daki program **ub** yoktur Ã§Ã¼nkÃ¼ diziler tanÄ±mlanÄ±rken bir kaÃ§ elemanÄ±nÄ±n deÄŸerleri verildiÄŸinde tÃ¼m elemanlarÄ±nÄ±n deÄŸerleri verilmese bile deÄŸer verilmeyen elemanlar dizi deÄŸiÅŸkeninin Ã¶mÃ¼r tÃ¼rÃ¼nden baÄŸÄ±msÄ±z olarak 0 olarak hayatlarÄ±na baÅŸlayacaktÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    char str[20] = { 'm', 'e', 't', 'i', 'n' };

    for(int i = 0; str[i] != '\0'; ++i){
        putchar(str[i]);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program **ub** vardÄ±r Ã§Ã¼nkÃ¼ diziler tanÄ±mlanÄ±rken dizinin eleman sayÄ±sÄ± verilmezse ya da dizinin eleman sayÄ±sÄ± ile aynÄ± adette ilk deÄŸer verilip **null character** iÃ§in yer bÄ±rakÄ±lmazsa dizinin sonunu tutacak eleman olmayacaÄŸÄ± iÃ§in **ub** oluÅŸacaktÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    char str[] = { 'm', 'e', 't', 'i', 'n' };

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼de 'str' dizisinin sonunu belirten 'null character' olmadÄ±ÄŸÄ± iÃ§in 'ub' durumu olaÅŸacaktÄ±r.
    for(int i = 0; str[i] != '\0'; ++i){
        putchar(str[i]);
    }

    char str2[5] = { 'm', 'e', 't', 'i', 'n' };

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼de 'str2' dizisinin sonunu belirten 'null character' olmadÄ±ÄŸÄ± iÃ§in 'ub' durumu olaÅŸacaktÄ±r.
    for(int i = 0; str2[i] != '\0'; ++i){
        putchar(str2[i]);
    }    
}
```

>â”
> 
> Sorulan soru; 
> 
> Dizinin sonunda null karakterin olmama durumu nasÄ±l oluyor hocam bir Ã¶rneÄŸi var mÄ±?
> 
> Cevap;
> 
> Bir karakter dizisi sonunda null karakter olmadan tanÄ±mlanÄ±labilir burada bir sorun oluÅŸmaz ama bu karakter dizisinin kullanÄ±ldÄ±ÄŸÄ± yerde bu durum dikkate alÄ±nmadan iÅŸlem yapÄ±lÄ±rsa o zaman **ub** durumu oluÅŸacaktÄ±r, bu detayÄ± bilmek bazÄ± durumlarda Ã¶nemli olabilir.


Ders sonu ...
