# 21.Ders 22.03.2025 ğŸ•˜

Derse 14(09:01)-21(09:14)-21(10:01)-22(11:12)-18(12:04)-17(12:28)17(12:56) kiÅŸi katÄ±ldÄ±.
---


## Kendi BaÅŸlÄ±k DosyamÄ±zÄ± OluÅŸturalÄ±m


ğŸ‘‡ AÅŸaÄŸÄ±daki programda **Multiple Include Guards(Header Include Guards)** iÅŸleminin Ã¼Ã§ farklÄ± ÅŸekilde nasÄ±l yapÄ±labileceÄŸi gÃ¶rÃ¼lebilir. Necati Ergin standart yÃ¶ntemin kullanÄ±lmasÄ±nÄ± tavsiye ediyor.
```C

// AÅŸaÄŸÄ±da ilk yÃ¶ntem gÃ¶rÃ¼lebilir(Bu standart yÃ¶ntemdir).
#ifndef NUTULITY_H

#define NUTULITY_H

// Codes ...

#endif


// AÅŸaÄŸÄ±da ikinci yÃ¶ntem gÃ¶rÃ¼lebilir(Bu standart yÃ¶ntemdir).
#if !defined NUTULITY_H

#define NUTULITY_H

// Codes ...

#endif


// AÅŸaÄŸÄ±da Ã¼Ã§Ã¼ncÃ¼ yÃ¶ntem gÃ¶rÃ¼lebilir(Bu standart yÃ¶ntem deÄŸildir, her derleyici bunu desteklemeyebilir).
#pragma once

```




```C
// 'nutility.h' dosyasÄ± aÅŸaÄŸÄ±daki gibidir.

#ifndef NUTULITY_H

#define NUTULITY_H

// 

#endif

```


>â”
> 
> Sorulan soru; 
> 
> Makrolarin scope'u tum dosyalari kapsiyor muydu?
> 
> Cevap;
> 
> Makrolar iÃ§in **scope(kapsam)** teriminin bir anlamÄ± yoktur.
> 
> Makrolar scope tanÄ±mazlar.
> 
> Soru ÅŸu ÅŸekilde yorumlanabilir: Bir **.c(source file)** dosyasÄ±na eklenen **.h** dosyalarÄ±nÄ± preprocessor programÄ± Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda head dosyasÄ±ndaki kodlarÄ± kopyalayÄ±p kaynak dosyada tanÄ±mlanan yere yapÄ±ÅŸtÄ±rÄ±r bÃ¶yle olunca kullanÄ±lma sÄ±rasÄ±na gÃ¶re head dosya iÃ§erikleri kaynak dosyaya alÄ±nmÄ±ÅŸ olur.


ğŸ“Œ Kursun ilerleyen derleri iÃ§in aynÄ± fonksiyonlarÄ± sÃ¼rekli yeniden yazmaktansa fonksiyonlarÄ±n bir kere yazÄ±lÄ±p ardÄ±ndan sÃ¼rekli ilgili kaynak dosyadan kullanÄ±labilmesi iÃ§in **nutility.c** ve **nutility.h** dosyalarÄ±nÄ±n oluÅŸturulma iÅŸlemi gerÃ§ekleÅŸtirildi.

**.h** dosyalarÄ±na **multiple inclusion guard** saÄŸlamak iÃ§in Ã¶nceden Ã¶ÄŸrenilen varsayÄ±lan yaklaÅŸÄ±mÄ± kullanalÄ±m.

**Client(MÃ¼ÅŸteri)**: MÃ¼ÅŸteri demektir ve **.h** dosyalarÄ±na yazÄ±lan her ÅŸey **mÃ¼ÅŸteriyi(client)** ilgilendirir, buradaki **mÃ¼ÅŸteri(client)** kaynak kodu kullanan yazÄ±lÄ±mcÄ±lardÄ±r.
- Hizmet sunan, veren, saÄŸlayan kodlara "**Server Code**" deniliyor.
- Hizmet alan kodlara "**Client Code**" deniliyor.



âœï¸ C programlarÄ±nÄ± yazarken sÃ¼rekli kullanÄ±lacak olan varlÄ±klarÄ±n barÄ±ndÄ±rÄ±lacaÄŸÄ± kendi baÅŸlÄ±k dosyamÄ±zÄ± oluÅŸturalÄ±m;

```C
// YazÄ±lan 'nutility.h' dosyasÄ±

#ifndef NUTILITY_H
#define NUTILITY_H

#define ISLEAP(y) (((y) % 4 == 0) && ( ((y) % 100 != 0) || ((y) % 400 == 0)))

int ndigit(int);
int sumdigit(int);
int isprime(int);
int dayofweek(int day, int mount, int year);
int max2(int, int);
int max3(int, int, int);
int getmid(int, int, int);
void putline(void);

#endif
```


ğŸ‘‡ AÅŸaÄŸÄ±daki program parÃ§asÄ±nda **Tomohiko Sakamotoâ€™s Algorithm** uygulayan bir fonksiyon incelenebilir. 
```C
// 'nutility.c' dosyasÄ± eklenen varlÄ±klar


// AÅŸaÄŸÄ±daki fonksiyon aldÄ±ÄŸÄ± tam sayÄ±nÄ±n kaÃ§ basamaklÄ± olduÄŸu bilgisini dÃ¶ndÃ¼rÃ¼r. 
int ndigit(int x)
{
    if(x == 0)
        return 1;

    int digit_count = 0;

    while(x){
        ++digit_count;
        x /= 10;
    }

    return digit_count;
}

// AÅŸaÄŸÄ±daki fonksiyon aldÄ±ÄŸÄ± tam sayÄ±nÄ±n basamak deÄŸerlerinin toplamÄ±nÄ± dÃ¶ndÃ¼rÃ¼r.
int sumdigit(int x)
{
    int sum = 0;

    while(x){
        sum += x /= 10;
        x = x /= 10; 
    }

    return sum;
}


// AÅŸaÄŸÄ±daki fonksiyon kendisine gÃ¶nderilen sayÄ±nÄ±n asal olup olmadÄ±ÄŸÄ±nÄ± tespit edip geriye 'zero/non-zero' deÄŸer dÃ¶ndÃ¼rmektedir. '1' sayÄ±sÄ± asal sayÄ± deÄŸildir.
int isprime(int x)
{
    if(x < 2)
        return 0;

    if(x % 2 == 0)
        return x == 2;

    if(x % 3 == 0)
        return x == 3;

    if(x % 5 == 0)
        return x == 5;

    for(int i = 7; i * i <= x; i += 2){
        if(x % i == 0){
            return 0;
        }
    }

    return 1;
}

// Sakamuto algoritmasÄ± girilen tarihten haftanÄ±n kaÃ§Ä±ncÄ± gÃ¼nÃ¼ olduÄŸunu tespit eder.
// Sadece 1900'den sonraki tarihler iÃ§in geÃ§erlidir.
// 
// return value;
// 0 ise: Pazar
// 1 ise: Pazartesi
// 2 ise: SalÄ±
// 3 ise: Ã‡arÅŸamba
// 4 ise: PerÅŸembe
// 5 ise: Cuma
// 6 ise: Cumartesi
int dayofweek(int d, int m, int y)  
{
    static int t[] = { 0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4 };
    y -= m < 3;
    return ( y + y / 4 - y / 100 + y / 400 + t[m - 1] + d) % 7;
}

// Ä°ki sayÄ±dan bÃ¼yÃ¼ÄŸÃ¼nÃ¼ dÃ¶ndÃ¼ren fonksiyon
int max2(int x, int y)
{
    return x > y ? x : y;
}

// ÃœÃ§ sayÄ±dan bÃ¼yÃ¼ÄŸÃ¼nÃ¼ dÃ¶ndÃ¼ren fonksiyon
int max3(int x, int y, int z)
{
    int max = x;

    if(y > max)
        max = y;
    
    if(z > max)
        max = z;
    
    return max;
}

// Kendisine argÃ¼man olarak verilen sayÄ±lardan ortanca olan sayÄ±yÄ± dÃ¶nen foksiyon
int getmid(int x, int y, int z)
{
    // '(x > y && x > z)' ifadesi 'x' en bÃ¼yÃ¼k sayÄ± mÄ± sorgulamasÄ±
    // '(x < y && x < z)' ifadesi 'x' en kÃ¼Ã§Ã¼k sayÄ± mÄ± sorgulamasÄ±
    // YukarÄ±da aÃ§Ä±klanan iki ifadenin veya ile birleÅŸtirilmesinden oluÅŸan ifade de 'x'in ortanca olmama durumunun mantÄ±ksal gÃ¶sterimidir.
    // YukarÄ±da aÃ§Ä±klanan iki ifadenin deÄŸilinin alÄ±ndÄ±ÄŸÄ± durumdaki ifade ise 'x'in ortanca sayÄ± olma durumunu gÃ¶sterecektir.
    if( !((x > y && x > z) || (x < y && x < z)) )
        return x;

    if( !((y > x && y > z) || (y < x && y < z)) )
        return y;

    return z;
}

void putline(void)
{
    printf("\n---------------------------------------------------------\n");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda girilen bir tarihe gÃ¶re haftanÄ±n gÃ¼nÃ¼nÃ¼n adÄ±nÄ± yazan program gÃ¶rÃ¼lebilir, bu iÅŸlemi yapmak iÃ§in kendi yazdÄ±ÄŸÄ±mÄ±z `nutility.h` baÅŸlÄ±k dosyasÄ±nÄ± kullanÄ±yoruz.
```C
#define _CRT_SECURE_NO_WARNINGS

#include "nutility.h" // Kendi tanÄ±mladÄ±ÄŸÄ±mÄ±z baÅŸlÄ±k dosyasÄ±
#include <stdio.h>

const char* to_day_name_v1(int weekday)
{
    switch(weekday){
        case 0: return "sunday";
        case 1: return "monday";
        case 2: return "tuesday";
        case 3: return "wednesday";
        case 4: return "thursday";
        case 5: return "friday";
        case 6: return "saturday";
        default: return "";
    }
}

const char* to_day_name_v2(int weekday)
{
    // 'pday' adÄ±ndaki karakter dizisi bir 'lookup table' varlÄ±ktÄ±r.
    static const char* const pday = {
        "pazar",
        "pazartesi",
        "sali",
        "carsamba",
        "persembe",
        "cuma",
        "cumartesi"
    };

    return pday[weekday];
}

int main(void)
{
    int day, month, year;

    printf("gun ay yil olrak tarihi girin: ");
    scanf("%d%d%d", &day, &month, &year);
    
    int weekday = dayofweek(day, month, year); // Buradaki 'dayofweek' fonksiyonu kendi yazdÄ±ÄŸÄ±mÄ±z baÅŸlÄ±k dosyasÄ±nda bildirilmiÅŸtir.

    printf("%d\n", weekday);
    printf("%s\n", to_day_name_v1(weekday));
    printf("%s\n", to_day_name_v2(weekday));
}
```


â—â—â— AyrÄ± modÃ¼l olarak yazÄ±lan bir **source file** kendi **head file** dosyasÄ±nÄ± iÃ§ermek zorundadÄ±r, yoksa arada bir baÄŸlantÄ± kurulmamÄ±ÅŸ olacaktÄ±r.


â—â—â— Bir **head file** kendi dosyasÄ± **.h** uzantÄ±lÄ± dosya bildirimlerine sahip olabilir yani bir baÅŸlÄ±k dosyasÄ± baÅŸka baÅŸlÄ±k dosyalarÄ±nÄ± kendi bÃ¼nyesinde eklemiÅŸ olabilir.


## Type Conversions(TÃ¼r DÃ¶nÃ¼ÅŸÃ¼mleri) 


Bu konuya baÅŸlamadan Ã¶nce **static typing ve dynamic typing** terimlerinin ne anlama geldiÄŸinin iyi bilinmesi gerekiyor.

C dili **static tÃ¼r** kavramÄ±na sahiptir, derleyici derleme anÄ±nda deÄŸiÅŸkenlerin tÃ¼rÃ¼nÃ¼ biliyor ve ona gÃ¶re **Ã§alÄ±ÅŸma zamanÄ±nda(run-time)** hangi mikroiÅŸlemci komutlarÄ±nÄ±n Ã§alÄ±ÅŸtÄ±rÄ±lacaÄŸÄ±na karar veriyor. </br>
**Dynamic typing** Ã¶zelliÄŸine sahip bir dilde yorumlayÄ±cÄ± **run-time** anÄ±nda deÄŸiÅŸkenlerin tÃ¼rÃ¼nÃ¼ anlÄ±yor ve ona gÃ¶re mikroiÅŸlemci komutlarÄ±nÄ± oluÅŸturuyor.

Programda Ã¶yle yerler vardÄ±r ki derleyici dilin kurallarÄ±na dayanarak bir tÃ¼rÃ¼ 

1. **Implicity Type Conversions(Ã–rtÃ¼lÃ¼ TÃ¼r DÃ¶nÃ¼ÅŸÃ¼mleri)**: Derleyicinin dilin kurallarÄ± gereÄŸi yaptÄ±ÄŸÄ± tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mleridir.
2. **Explicit Type Conversions(AÃ§Ä±k TÃ¼r DÃ¶nÃ¼ÅŸÃ¼mleri)**: Derleyicinin yapmasÄ± istenilen tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mlerinin kodda aÃ§Ä±k ÅŸekilde belirtildiÄŸi dÃ¶nÃ¼ÅŸÃ¼m tÃ¼rÃ¼dÃ¼r(`(type)` tÃ¼r dÃ¶nÃ¼ÅŸÃ¼m operatÃ¶rÃ¼ kullanÄ±larak yapÄ±lan tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼dÃ¼r).


ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã¶rtÃ¼lÃ¼ tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ iÅŸleminin uygulandÄ±ÄŸÄ± bir durum incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    double dval = 2.32723;
    int x;

    x = dval; // Burada 'Implicity Type Conversions' uygulanÄ±yor.

    x = (int)dval; // Burada '(int)' operatÃ¶rÃ¼nÃ¼n adÄ± 'type cast operator'dÃ¼r ve burada 'Explicit Type Conversions' uygulanÄ±yor.
}
```



**Assignment Conversions**: SaÄŸ operant olan ifadenin tÃ¼rÃ¼ sol operant olan nesnenin tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r, bu iÅŸlemin yapÄ±ldÄ±ÄŸÄ± durumlar aÅŸaÄŸÄ±daki gibi Ã¼Ã§ adettir;
1. **Ä°lk deÄŸer verme(initialization) iÅŸlemlerinde**: `unsigned uval = 2134; int x = uval;` gibi bir kodlamada deÄŸer atanan deÄŸiÅŸkenin tÃ¼rÃ¼ deÄŸeri atanan deÄŸiÅŸken tÃ¼rÃ¼nden farklÄ±ysa atama tÃ¼r dÃ¶nÃ¼ÅŸÃ¼m iÅŸlemi uygulanÄ±r.
2. **Fonksiyonlara geÃ§ilen argÃ¼man iÅŸlemlerinde**: EÄŸer fonksiyonun parametre deÄŸiÅŸkeninin tÃ¼rÃ¼ fonksiyonun Ã§aÄŸrÄ±ldÄ±ÄŸÄ± yerde geÃ§ilen argÃ¼manlarÄ±n tÃ¼rleri aynÄ± deÄŸilse atama tÃ¼r dÃ¶nÃ¼ÅŸÃ¼m iÅŸlemi uygulanÄ±r.
3. **FonksiyonlarÄ±n return ettiÄŸi deÄŸerlerin atama iÅŸlemlerinde**: Bir fonksiyondan return edilen deÄŸerin tÃ¼rÃ¼ ile bu tÃ¼rÃ¼n atandÄ±ÄŸÄ± deÄŸiÅŸkenin tÃ¼rÃ¼ birbirindne farklÄ± olduÄŸu durumlarda tÃ¼r dÃ¶nÃ¼ÅŸÃ¼m iÅŸlemi uygulanÄ±r.


### Arithmetic Conversions 

Aritmetik iÅŸlemlerde aÅŸaÄŸÄ±daki durumlarda tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ iÅŸlemi yapÄ±lmasÄ± gerekebiliyor.

1. Binary operatÃ¶rlerin operandlarÄ± farklÄ± tÃ¼rlerden ise.
2. BazÄ± durumlarda binary operatÃ¶rÃ¼n operandlarÄ± aynÄ± tÃ¼rden ise.
3. BazÄ± durumlarda bir unary operatÃ¶rÃ¼n operandÄ± dilin kurallarÄ±na gÃ¶re bu iÅŸlemlerin yapÄ±lacaÄŸÄ± kodun derleyici tarafÄ±ndan Ã¼retilmesi aÅŸamasÄ±nda farklÄ± bir tÃ¼re dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r.



â—â—â— Neden **type conversions** konusu Ã¶nemlidir? </br>
TÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼nÃ¼n yapÄ±lÄ±p yapÄ±lmamasÄ±na gÃ¶re aÅŸaÄŸÄ±daki durumlar oluÅŸabilir.
1. TÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼nÃ¼n yapÄ±lÄ±p yapÄ±lmamasÄ±na gÃ¶re **Undefined behavior** oluÅŸabilir.
2. TÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼nÃ¼n yapÄ±lÄ±p yapÄ±lmamasÄ±na gÃ¶re **Data loss(Veri kaybÄ±)** oluÅŸabilir.
3. TÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼nÃ¼n yapÄ±lÄ±p yapÄ±lmamasÄ±na gÃ¶re **Implementation defined(Derleyiciye baÄŸlÄ± farklÄ± olarak uygulanan davranÄ±ÅŸlar)** oluÅŸabilir. Bir C programÄ± hep **Gcc** derleyicisiyle derlenip kullanÄ±lmÄ±ÅŸsa ve sonradna **Clang** derleyicisiyle derlenip kullanÄ±lmak istendiÄŸinde programÄ±n davranÄ±ÅŸÄ±nÄ±n deÄŸiÅŸtiÄŸi durumlarÄ± belirtmektedir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki bÃ¶lme iÅŸleminde oluÅŸan veri kaybÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int x = 17;
    int y = 3;

    double d = x / y; // Buradaki iÅŸlemin sonucu int tÃ¼rÃ¼nden olacaÄŸÄ± iÃ§in veri kaybÄ± oluÅŸur.

    printf("d = %f\n", d);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki int tÃ¼rÃ¼nÃ¼n deÄŸerinin aÅŸÄ±lamsÄ±ndan kaynaklÄ± **ub** durumu incelenebilir. Bu hata Ã§ok sÄ±k yapÄ±lmaktadÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int x = 18466456564;
    int y = 18466456564;

    x + y; // Burada int tÃ¼rÃ¼nÃ¼n sÄ±nÄ±rlarÄ±nÄ± aÅŸan bir deÄŸer oluÅŸacaÄŸÄ± iÃ§in 'ub' vardÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program `int` ve `unsigned int` tÃ¼rleri arasÄ±ndaki karÅŸÄ±laÅŸtÄ±rma iÅŸleminin beklenmedik ÅŸekilde Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± gÃ¶rmek iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int x = -1;
    unsigned int y = 10;

    if(x > y)
        printf("dogru");
    else
        printf("yanlis");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `char` ve `int` tÃ¼rÃ¼ arasÄ±nda yapÄ±lan tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼yle ilgili durum incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    char c = 154;

    if(c == 154)
        printf("dogru");
    else
        printf("yanlis");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda ondalÄ±klÄ± deÄŸer tutan veri tÃ¼rlerine deÄŸer atandÄ±ÄŸÄ±nda `float` tÃ¼rÃ¼ne deÄŸer atama iÅŸleminde veri kaybÄ± olduÄŸu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a = 1234567987;
    float f = a; // Buradaki atamada veri kaybÄ± olacaktÄ±r.
    double d = a; // Buradaki atamada veri kaybÄ± olmayacaktÄ±r.

    printf("%.0f", f);
    printf("%.0d", d);
}
```

â—Her C mÃ¼lakatÄ±nda tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mleriyle ilgili soru sorulmaktadÄ±r.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.25-10.46 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***

â— Derleyici aritmetik tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ iÅŸlemlerini en az veri kaybÄ± olacak ÅŸekilde yapmaya Ã§alÄ±ÅŸÄ±r, aÅŸaÄŸÄ±dan bu iÅŸlem iÃ§in hangi sÄ±rayla tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mlerinin yapÄ±lacaÄŸÄ± sÄ±ralama gÃ¶rÃ¼lebilir.



ğŸ§­ Derleyici aritmetik iÅŸlemlerde yapÄ±lacak tÃ¼r dÃ¶nÃ¼ÅŸÃ¼m iÅŸlemini belirlerken aÅŸaÄŸÄ±daki Ã¶nceliklere gÃ¶re iÅŸlem yapar; 
1. EÄŸer operandlardan biri `long double` ise diÄŸer operand da `long double` tÃ¼rÃ¼ne dÃ¶nÅŸtÃ¼rÃ¼lÃ¼r ve iÅŸlem `long double` tÃ¼rÃ¼nde yapÄ±lÄ±r.
2. EÄŸer operandlardan biri `double` diÄŸer operand da `double` tÃ¼rÃ¼ne dÃ¶nÅŸtÃ¼rÃ¼lÃ¼r ve iÅŸlem `double` tÃ¼rÃ¼nde yapÄ±lÄ±r.
3. EÄŸer operandlardan biri `float` diÄŸer operand da `float` tÃ¼rÃ¼ne dÃ¶nÅŸtÃ¼rÃ¼lÃ¼r ve iÅŸlem `float` tÃ¼rÃ¼nde yapÄ±lÄ±r.
    - `int [[operator]] double` => Buradaki iÅŸlem `double` tÃ¼rÃ¼nde yapÄ±lacaktÄ±r.
    - `float [[operator]] char` => Buradaki iÅŸlem `float` tÃ¼rÃ¼nde yapÄ±lacaktÄ±r.
    - `long double [[operator]] float` => Buradaki iÅŸlem `long double` tÃ¼rÃ¼nde yapÄ±lacaktÄ±r.

4. operandlardan biri ya da her ikisinin **rank**'i `int` tÃ¼rÃ¼nden kÃ¼Ã§Ã¼k olan tÃ¼rlerden(`short`, `unsigned short`, `char`, `signed char`, `unsigned char`, `_Bool`) ise **integral promotion** iÅŸlemi uygulanÄ±r yani bu tÃ¼rden operandlar `int` tÃ¼rÃ¼ne yÃ¼kseltilir.
    
    **integral promotion**: SÃ¶zcÃ¼k anlamÄ± olarak **terfi etmek** anlamÄ±na gelmektedir. TutabileceÄŸi deÄŸeri(**rank** deÄŸeri) `int` tÃ¼rÃ¼nden kÃ¼Ã§Ã¼k olan tÃ¼rlerin(`short`, `unsigned short`, `char`, `signed char`, `unsigned char`, `_Bool`) `int` tÃ¼rÃ¼ne yÃ¼kseltilmesi iÅŸlemine verilen addÄ±r.

5. Bu aÅŸamada sadece ÅŸu tam sayÄ± tÃ¼rleri operandlarda bulunabilir(Ã§Ã¼nkÃ¼ Ã¶nceki aÅŸamalarda diÄŸer tÃ¼rler vardÄ±ysa zaten iÅŸlemler yukarÄ±da belirtilen kurallara gÃ¶re yapÄ±lmÄ±ÅŸtÄ±r) "`unsigned long long`, `long long`, `unsigned long`, `long`, `unsigned int`, `int`" 

    â— AynÄ± tam sayÄ± tÃ¼rÃ¼nÃ¼n iÅŸaretlisi ve iÅŸaretsizi aynÄ± **rank**'e sahiptir.

    Rank sÄ±ralamasÄ± aÅŸaÄŸÄ±daki gibidir;
 
    1. `unsigned long long` ve `long long` aynÄ± **rank**'tedir.
    2. `unsigned long` ve `long` aynÄ± **rank**'tedir.
    3. `unsigned int` ve `int` aynÄ± **rank**'tedir.

    â—EÄŸer operandlar farklÄ± **rank**'lerde ise ve operandlardan yÃ¼ksek **rank**'te olan iÅŸaretsiz ise iÅŸlem iÅŸaretsiz tÃ¼rde yapÄ±lÄ±r.
    â—operandlar aynÄ± **rank**'te ise ancak biri iÅŸaretli ve diÄŸeri iÅŸaretsiz ise iÅŸlem iÅŸaretsiz tÃ¼rde yapÄ±lÄ±r.

    Mesela bazÄ± veri tÃ¼rlerinin bir operatÃ¶r ile iÅŸleme girmesinde iÅŸlenin hangi tÃ¼rde yapÄ±lacaÄŸÄ± aÅŸaÄŸÄ±daki kurallara gÃ¶re belirlenebilir;
    - `int` [[operator]] `unsigned int` binary operant ile iÅŸleme tabi tutulursa bu iÅŸlemdeki iki operantta **rank**'Ä± yÃ¼ksek olan `unsigned int` tÃ¼rÃ¼nde olacaktÄ±r(burada pozitif deÄŸerlerin kayÄ±rÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶rebilirsin yani iÅŸlem en fazla pozitif deÄŸeri tutabilecek ÅŸekilde ele alÄ±nÄ±yor).
    - `unsigned long` [[operator]] `unsigned long long` binary operant ile iÅŸleme tabi tutulursa bu iÅŸlemdeki iki operantta **rank**'Ä± yÃ¼ksek olan `unsigned long long` tÃ¼rÃ¼nde olacaktÄ±r.
    - `int` [[operator]] `unsigned int` binary operant ile iÅŸleme tabi tutulursa bu iÅŸlem `unsigned int` tÃ¼rÃ¼nde yapÄ±lÄ±r.

6. Operandlar farklÄ± **rank**'te ise ancak yÃ¼ksek **rank**'te olan operant iÅŸaretli ise ve diÄŸeri iÅŸaretsiz ise 

    EÄŸer sistemdeki bÃ¼yÃ¼k olan **rank**'teki tÃ¼r kÃ¼Ã§Ã¼k olan iÅŸaretsiz **rank**'teki tÃ¼rÃ¼n bÃ¼tÃ¼n deÄŸerlerini iÃ§ine alÄ±yorsa o zaman iÅŸlem iÅŸaretli yÃ¼ksek **rank**'teki tÃ¼rde yapÄ±lacaktÄ±r, aksi halde(en kafa karÄ±ÅŸtÄ±rÄ±cÄ± yer burasÄ±) mesela `long` tÃ¼rÃ¼ `unsigned int` tÃ¼rÃ¼nÃ¼n bÃ¼tÃ¼n deÄŸerlerini iÃ§ine almÄ±yorsa iÅŸlem bÃ¼yÃ¼k olan **rank**'in iÅŸaretsiz tÃ¼rÃ¼nde yapÄ±lacaktÄ±r, buradaki durumda iÅŸlem `unsigned long` tÃ¼rÃ¼nde yapÄ±lacaktÄ±r.

    - `long` [[operator]] `unsigned int` => Buradaki iÅŸlem `unsigned long` tÃ¼rÃ¼nde yapÄ±lacaktÄ±r
    - `long long` [[operator]] `unsigned int` => Buradaki iÅŸlem `unsigned long long` tÃ¼rÃ¼nde yapÄ±lacaktÄ±r
    - `long long` [[operator]] `unsigned long` => Buradaki iÅŸlem `unsigned long long` tÃ¼rÃ¼nde yapÄ±lacaktÄ±r

    â—Mesela kullanÄ±lan derleyicide `long` tÃ¼rÃ¼ 4 byte ve `int` tÃ¼rÃ¼ 4 byte ise "`long` [[operator]] `int`" ÅŸeklindeki bir iÅŸlem yÃ¼ksek tÃ¼rÃ¼n iÅŸaretsiz tÃ¼rÃ¼nde yapÄ±lacaktÄ±r burada `unsigned long` tÃ¼rÃ¼nde yapÄ±lacaktÄ±r. Bunun nedeni `long` tÃ¼rÃ¼nÃ¼n `unsigned int` tÃ¼rÃ¼nÃ¼n bÃ¼tÃ¼n deÄŸerlerini iÃ§ine almamasÄ±dÄ±r.



Uniery operatÃ¶rler iÃ§in de tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ uygulanmaktadÄ±r. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda **uniery operator** olan `+` operatÃ¶rÃ¼nÃ¼n `char` tÃ¼rÃ¼nden bir ifadeyi `int` tÃ¼rÃ¼ne yÃ¼kselttiÄŸi gÃ¶rÃ¼lmelidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    char c = 'C';

    +c; // Buradaki '+c' ifadenin tÃ¼rÃ¼ 'integral promotion' iÅŸlemi uygulandÄ±ÄŸÄ± iÃ§in 'int' olmaktadÄ±r.
}
```



â—Necati Ergin kendi yaprÄ±ÄŸÄ± C mÃ¼lakatlarÄ±nda en Ã§ok sorduÄŸu en basit sorulardan biri aÅŸaÄŸÄ±dki gibidir, bu soruya iÅŸi profesyonel olarak C programÄ± yazmak olanlarÄ±n %60 civarÄ± yanlÄ±ÅŸ cevap veriyormuÅŸ.
- ğŸ‘‡ AÅŸaÄŸÄ±daki programda `char` tÃ¼rlerinde yapÄ±lan iÅŸlemlerdeki **integral promotion** durumunun nasÄ±l uygulandÄ±ÄŸÄ± incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    char c1 = 3;
    char c2 = 7;

    c1 + c2; // Buradaki 'c1 + c2' ifadenin tÃ¼rÃ¼ 'integral promotion' iÅŸlemi uygulandÄ±ÄŸÄ± iÃ§in 'int' olmaktadÄ±r.


    short s1 = 3;
    short s2 = 7;

    s1 + s2; // Buradaki 's1 + s2' ifadenin tÃ¼rÃ¼ 'integral promotion' iÅŸlemi uygulandÄ±ÄŸÄ± iÃ§in 'int' olmaktadÄ±r.
}
```


#### Ä°fadelerde TÃ¼r DÃ¶nÃ¼ÅŸÃ¼mÃ¼ne YÃ¶nelik SÄ±k YapÄ±lan Kodlama HatalarÄ± 


1. Bir iÅŸaretli tam sayÄ± ile bir iÅŸaretsiz tam sayÄ± karÅŸÄ±laÅŸtÄ±rÄ±lÄ±rken aÅŸaÄŸÄ±daki programdaki gibi bir durum oluÅŸu

    **Wrap around**: Ä°ÅŸaretli bir tam sayÄ± tÃ¼rden ifadenin iÅŸaretsiz tam sayÄ± tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lme iÅŸlemidir, bu iÅŸlemde ifadenin deÄŸerinin bitleri deÄŸiÅŸtirilmemektedir.
    
    
    ğŸ‘‡ AÅŸaÄŸÄ±daki programda `int` ve `unsigned int` tÃ¼rÃ¼nden iki farklÄ± deÄŸiÅŸkenin unery iÅŸleme tabi tutulduÄŸunda iÅŸlemin hangi tÃ¼rde yapÄ±lacaÄŸÄ± gÃ¶rÃ¼lebilir.
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include "nutility.h"

    int main(void)
    {
        int x = -1;
        unsigned int y = 1;

        // AÅŸaÄŸÄ±daki 'x > y' ifadesinin iÅŸlemi 'unsigned int' tÃ¼rÃ¼nden yapÄ±lacaktÄ±r, burada 'wrap around' iÅŸlemi yapÄ±lÄ±yor.
        if(x > y)
            printf("dogru");
    }
    ```

    >â”
    > 
    > Sorulan soru;
    > 
    > Ä°ki char toplandÄ±ÄŸÄ±nda int'e yÃ¼kseltmesinin nedeni char olarak ifade edilemeycek olmasÄ± mÄ± yoksa daha iyi ifade edilebilmesi iÃ§in mi?
    > 
    > Temelde bu C standardÄ±nÄ±n kuralÄ±dÄ±r.
    > 
    > Bu soruya verilebilecek en doÄŸru cevap donanÄ±msal olarak yapÄ±labilecek olan iÅŸlemlere girecek operandlarÄ±n tÃ¼rÃ¼nÃ¼n en kÃ¼Ã§Ã¼k `int` boyutunda olma zorunluluÄŸudur.

2. Ä°ÅŸaretli tam sayÄ±larda yapÄ±lan aritmetik iÅŸlemlerdeki taÅŸma **ub** durumuna neden olmaktadÄ±r.
    
    Ä°ÅŸaretsiz tam sayÄ±larda yapÄ±lan aritmetik iÅŸlemlerdeki taÅŸma **wrap around** iÅŸlemine tabi turulur ve burada dilin standardÄ±nda **ub** olmadÄ±ÄŸÄ± belirtilmiÅŸtir.

    ğŸ‘‡ AÅŸaÄŸÄ±daki programda taÅŸma durumundna kaynaklÄ± **ub** iÃ§celeenbilir.
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include "nutility.h"

    int main(void)
    {
        int x = INT_MAX;
        int y = INT_MAX;

        printf("x + y = ", x + y); // Burada 'ub' vardÄ±r

    }
    ```

    ğŸ‘‡ AÅŸaÄŸÄ±daki programda iÅŸaretsiz tÃ¼rlerde yapÄ±lan toplama iÅŸleminde oluÅŸan taÅŸma durumu **ub** oluÅŸturmayacaktÄ±r.
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include "nutility.h"

    int main(void)
    {
        unsigned int x = UNIT_MAX;
        unsigned int y = 1;

        printf("x + y = ", x + y); // Burada 'ub' yoktur
    }
    ```

    âš ï¸ TaÅŸmalardan kaynaklanan sorunlarÄ± Ã§Ã¶zmek iÃ§in neler yapÄ±labileceÄŸi ileriki derslerde ayrÄ±ca detaylÄ± iÅŸlenecektir.

3. BÃ¶lme iÅŸlemleri yapÄ±lÄ±rken sonucun **floating point** olmasÄ± iÃ§in **Explicit Type Conversions** ile belirtilmelidir.

    ğŸ‘‡ AÅŸaÄŸÄ±daki programda bÃ¶lme iÅŸlemlerinde iÅŸlemin hangi tÃ¼rde yapÄ±lacaÄŸÄ± incelenebilir. 
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include "nutility.h"

    int main(void)
    {
        int x = 23432;
        int y = 7;

        double z1 = x / y; // SonuÃ§ 'int' tÃ¼rÃ¼nden olacaktÄ±r.
        double z2 = x / (double)y; // SonuÃ§ 'double' tÃ¼rÃ¼nden olacaktÄ±r.
        double z3 = x / 3.; // SonuÃ§ 'double' tÃ¼rÃ¼nden olacaktÄ±r.

        printf("z1 = %f, z2 = %f, z3 = %f", z1, z2, z3);
    }
    ```

4. OperatÃ¶r Ã¶nceliÄŸine ve yÃ¶nÃ¼ne gÃ¶re hesaplanan iÅŸlemin tÃ¼rÃ¼nÃ¼ belirlenmektedir.

    ğŸ‘‡ AÅŸaÄŸÄ±daki programda sabit sayÄ±ya eklenen tek bir nokta token'Ä±nÄ±n nasÄ±l iÅŸlemin tÃ¼rÃ¼nÃ¼ deÄŸiÅŸtirdiÄŸi gÃ¶rÃ¼lebilir.
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include "nutility.h"
    #include<limits.h>

    int factorial(int x)
    {
        return x < 2 ? 1 : x * factorial(x - 1);
    }

    int main(void)
    {
        double sum = 0;
        double sum2 = 0;

        for(int i = 0; i < 10; ++i){
            sum += 1 / factorial(i); // Buradaki bÃ¶lme iÅŸlemi int tÃ¼rÃ¼nden yapÄ±lacaktÄ±r
            sum2 += 1. / factorial(i); // Buradaki bÃ¶lme iÅŸlemi double tÃ¼rÃ¼nden yapÄ±lacaktÄ±r. 
        }

        printf("sum1 = %f\n", sum1);
        printf("sum2 = %f\n", sum2);
    }
    ```

    ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki ifade iÃ§in ekrana yazdÄ±rÄ±lan deÄŸerlerin farklÄ± olduÄŸu gÃ¶rÃ¼lecektir, bunun nedeni taÅŸmadÄ±r ve .
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include "nutility.h"

    int main(void)
    {
        int x1 = 23432, x2 = 234324;
        double d = 23424.;

        printf("(x1 * x2 * d) = %f, (d * x1 * x2) = %f", x1 * x2 * d, d * x1 * x2);
    }
    ```

5. Ternary operatÃ¶rÃ¼nÃ¼n ikinci ve Ã¼Ã§Ã¼ncÃ¼ operandÄ± farklÄ± tÃ¼rden olduÄŸunda tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ uygulanÄ±r. 

    â—â—â— C ve C++ dillerinde ifadelerin tÃ¼rleri derleme anÄ±nda bellidir, Ã§alÄ±ÅŸma anÄ±nda belirlenmez.

    ğŸ‘‡ AÅŸaÄŸÄ±daki programda ternary operatÃ¶r ile oluÅŸturulan ifadelerin nasÄ±l deÄŸerler Ã¼rettiÄŸi incelenebilir.
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include "nutility.h"

    int main(void)
    {
        int x = 20;
        double d = 23424.;

        x > 5 ? 3 : 2.4; // Buradaki ifadenin tÃ¼rÃ¼ 'double' tÃ¼rÃ¼dÃ¼r.

        double dval = 10 / (x > 5 ? 3 : 2.4); // Burada '=' operatÃ¶rÃ¼nÃ¼n saÄŸ operandÄ±nÄ±n tÃ¼rÃ¼ 'double' tÃ¼rÃ¼dÃ¼r.
        printf("dval = %f\n", dval); // Burada ekrana '3.33333' yazacaktÄ±r.

        printf("d = %lf\n", (x > 5 ? 2.4 : 3));
    }
    ```

â—â—â— TÃ¼r dÃ¶nÃ¼ÅŸÃ¼mlerindeki iÅŸlemler kalÄ±cÄ± deÄŸildir sadece o anda yapÄ±lan iÅŸlemleri dilin kurallarÄ±na gÃ¶re yapabilmek iÃ§in **primitive data type** deÄŸerlerinin o anda deÄŸiÅŸtirilmesidir ama bu deÄŸiÅŸiklik deÄŸiÅŸkenin tÃ¼rÃ¼nÃ¼ o iÅŸlemden sonraki iÅŸlemler iÃ§in etkilememektedir.


### Atama TÃ¼r DÃ¶nÃ¼ÅŸÃ¼mleri 


ğŸ§­ Nerelerde atama tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapÄ±lÄ±yor bunun listesi aÅŸaÄŸÄ±dan gÃ¶rÃ¼lebilir(bu dersin baÅŸÄ±nda da yine bu liste verilmiÅŸti);
1. Ä°lk deÄŸer verme tanÄ±mlamalarÄ±nda.
2. Atama deyimlerinde, `a = b;`.
3. Fonksiyon Ã§aÄŸrÄ±larÄ±nda.
4. FonksiyonlarÄ±n `return` deyimlerinde.



â—â—â— Atanan atama yapÄ±lan deÄŸiÅŸkenin tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lecektir, her zaman kural budur. 

â— Atama dÃ¶nÃ¼ÅŸÃ¼mleri programda soruna yol aÃ§ar mÄ± diye sorulursa evet aÃ§abilir ve bunlara dikkat etmek gerekiyor.

ğŸ§­ AÅŸaÄŸÄ±daki dÃ¶nÃ¼ÅŸÃ¼mleri yaparken sorunlar Ã§Ä±kabilir;
- BÃ¼yÃ¼k tam sayÄ± tÃ¼rÃ¼nen kÃ¼Ã§Ã¼k tam sayÄ± tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸÃ¼mlerde.
- KÃ¼Ã§Ã¼k tam sayÄ± tÃ¼rÃ¼nen bÃ¼yÃ¼k tam sayÄ± tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸÃ¼mlerde.
- Tam sayÄ± tÃ¼rlerinden gerÃ§ek sayÄ± tÃ¼rlerine.
- GerÃ§ek sayÄ± tÃ¼rlerinden tam sayÄ± tÃ¼rlerine.
- GerÃ§ek sayÄ± tÃ¼rlerinden gerÃ§ek sayÄ± tÃ¼rlerine.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda kÃ¼Ã§Ã¼k tam sayÄ± tÃ¼rÃ¼ bÃ¼yÃ¼k tam sayÄ± tÃ¼rÃ¼ne atama iÅŸlemlerinde veri kaybÄ± olmayacaÄŸÄ± gÃ¶rÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    signed char x = 5;
    signed short y = 984;
    
    int ival = x; // Burada bir sorun olmayacaktÄ±r Ã§Ã¼nkÃ¼ kÃ¼Ã§Ã¼k tam sayÄ± tÃ¼rÃ¼ bÃ¼yÃ¼k tam sayÄ± tÃ¼rÃ¼ne atanÄ±yor.
    ival = y; // Burada bir sorun olmayacaktÄ±r Ã§Ã¼nkÃ¼ kÃ¼Ã§Ã¼k tam sayÄ± tÃ¼rÃ¼ bÃ¼yÃ¼k tam sayÄ± tÃ¼rÃ¼ne atanÄ±yor.
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda bÃ¼yÃ¼k tam sayÄ± tÃ¼rÃ¼nden kÃ¼Ã§Ã¼k tam sayÄ± tÃ¼rÃ¼ne atama iÅŸleminde veri kaybÄ± olabileceÄŸi ve derleyicinin uyarÄ± vereceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int ival = 112;
    short sval = ival;
    char cval = ival;

    printf("sval = %d\n", sval);
    printf("cval = %d\n", cval);
}
```


> â”	
> SorduÄŸum soru; 
> 
> Veri kaybÄ± olan durumlar "**ub**" sayÄ±lÄ±yor muydu? 
> 
> Cevap;
> 
> HayÄ±r, veri kaybÄ± **ub** olmadan da olabilir ama **ub** durumuna neden olarak ta olabilir, duruma gÃ¶re deÄŸiÅŸir.
>
> ğŸ‘‡ AÅŸaÄŸÄ±daki programda sorulan soruyla ilgili olarak inceleme yapÄ±labilir.
> ```C
> #define _CRT_SECURE_NO_WARNINGS
> 
> #include <stdio.h>
> #include "nutility.h"
> 
> int main(void)
> {
>     int ival = 8787234;
>    
>     short s = ival; // Burada 'ub' yoktur ama veri kaybÄ± vardÄ±r. Bu durumlarda Ã§oÄŸu derleyici dÃ¼ÅŸÃ¼k anlamlÄ± bitleri kÃ¼Ã§Ã¼k deÄŸiÅŸkene atayacaktÄ±r yani yÃ¼ksek anlmlÄ± bitler gÃ¶rmezden gelinir.
>     char c = ival; //  Burada 'ub' yoktur ama veri kaybÄ± vardÄ±r.
>       
>     printf("s = %d\n", s); // Ã‡oÄŸu derleyici 's = 5410' ÅŸeklinde Ã§Ä±ktÄ± Ã¼retecektir. 
> }
> ```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda kullanÄ±lan "x1" ve "x2" deÄŸiÅŸkenleri aynÄ± deÄŸere atanacaktÄ±r, "x1" deÄŸiÅŸkeninin deÄŸer atama ÅŸekli C dilinin idiomatic bir kullanÄ±mÄ± olarak Ã§ok tercih edilmektedir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include<limits.h>

int main(void)
{
    unsigned int x1 = -1;
    unsigned int x2 = UINT_MAX; // 'limits.h' dosyasÄ±nda tanÄ±mlÄ± bir makro
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.01-12.13 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `unsigned int` tÃ¼rÃ¼ne `short` tÃ¼rÃ¼nden bir deÄŸerin atanmasÄ± iÅŸleminde ilk Ã¶nce `short` tÃ¼rÃ¼nden `int` tÃ¼rÃ¼ne tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapÄ±lacaktÄ±r ardÄ±ndan `int` tÃ¼rÃ¼nden `unsigned int` tÃ¼rÃ¼ne tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapÄ±larak atama iÅŸleminin gerÃ§ekleÅŸtirildi durum incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    short x = -342;
    unsigned int uval;

    uval = x; // Burada ilk Ã¶nce 'short' tÃ¼rÃ¼nden 'int' tÃ¼rÃ¼ne ardÄ±ndan 'unsigned int' tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸÃ¼m yapÄ±lacaktÄ±r.
}
```


### OndalÄ±klÄ± SayÄ±lardan Tam SayÄ±lara YapÄ±lan DÃ¶nÃ¼ÅŸÃ¼mler 


**Taruncate**: Kayan noktalÄ± sayÄ±larda ondalÄ±k kÄ±smÄ±n gÃ¶rmezden gelinip sadece tam sayÄ± kÄ±smÄ±nÄ±n alÄ±nÄ±p kullanÄ±lmasÄ± durumuna verilen addÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda ondalÄ±klÄ± sayÄ± tÃ¼rlerinin tam sayÄ± tÃ¼rlerine atama iÅŸlemini yaparken oluÅŸabilecek durumlar incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    double d1 = 234121.53534;
    double d2 = 12345678913.3546343;
    int ival;

    ival = d1; // Burada 'ival'e '234121' deÄŸeri atanÄ±r, bu ÅŸekilde yazÄ±lmamalÄ±dÄ±r. 
    ival = (int)d1; // Burada 'ival'e '234121' deÄŸeri atanÄ±r, bu ÅŸekilde kullanÄ±labilir.

    printf("ival = %d", ival);

    ival = d2; // Burada 'ub' vardÄ±r Ã§Ã¼nkÃ¼ int tÃ¼rÃ¼nÃ¼n kapsamÄ± aÅŸÄ±lÄ±yor.

    printf("ival = %d", ival);
}
```



ğŸ§  OndalÄ±k kÄ±sÄ±mlarda aÅŸaÄŸÄ±daki gibi iÅŸlemler yapÄ±lmak istendiÄŸinde `math.h` dosyasÄ±ndaki fonksiyonlar kullanÄ±labilir ama bu fonksiyonlar baÅŸka bir derste iÅŸlenecektir.
1. `trunc`
2. `ceil`
3. `floor`
4. `round`
5. `modf`, bu fonksiyon 


ğŸ‘‡ AÅŸaÄŸÄ±daki program ondalÄ±klÄ± sayÄ±larda yuvarlama iÅŸlemleriyle ilgili `math.h` kÃ¼tÃ¼phanesinin fonksiyonlarÄ±nÄ±n nasÄ±l kullanÄ±ldÄ±ÄŸÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <limits.h>
#include <math.h>

int main(void)
{
    double dval = -3.7576;

    printf("%f\n", trunc(dval));
    printf("%f\n", ceil(dval));
    printf("%f\n", floor(dval));
    printf("%f\n", round(dval));
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programdan `modf` fonksiyonu ile ondalÄ±klÄ± sayÄ±larÄ±n nasÄ±l ayrÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <limits.h>
#include <math.h>

int main(void)
{
    double dval = 2.754276;
    double int_part;

    double float_part = modf(dval, &int_part);

    printf("int_part   = %f\n", int_part);
    printf("float_part = %f\n", float_part);
}
```


### Tam SayÄ±dan OndalÄ±klÄ± SayÄ±lara YapÄ±lan DÃ¶nÃ¼ÅŸÃ¼mler 

ğŸ§  Tam sayÄ±lardan kesirli sayÄ±lara Ã§evirme iÅŸlemlerinde(**Ieee 754** formatÄ± kesirli sayÄ±larÄ±n gÃ¶sterimi iÃ§in en Ã§ok kullanÄ±lan formattÄ±r)
**Ieee 754** standardÄ±nda kesirli sayÄ±yÄ± temsil etmek iÃ§in sayÄ± Ã¼Ã§ parÃ§aya ayrÄ±lmaktadÄ±r, bu kÄ±sÄ±mlar **sayÄ±nÄ±n iÅŸareti kÄ±smÄ±**, **sayÄ±nÄ±n tam sayÄ± kÄ±smÄ±** ve **sayÄ±nÄ±n ondalÄ±k kÄ±smÄ±**.



ğŸ‘‡ AÅŸaÄŸÄ±daki program `float` tÃ¼rÃ¼ndeki taÅŸma durumlarÄ±nÄ± incelemek iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int x1 = 16'777'200;
    int x2 = 16'777'218;

    float f1 = x1;
    float f2 = x2;

    printf("f1 = %.0f\n", f1); // TaÅŸma yoktur. Burada kullanÄ±lan '%.0f' formatÄ± ile ondalÄ±klÄ± kÄ±sÄ±m yazdÄ±Ä±rlmamÄ±ÅŸ olur.
    printf("f2 = %.0f\n", f2); // TaÅŸma var.
}
```

â—OndalÄ±klÄ± sayÄ±lardan(floating point) tam sayÄ±lara yapÄ±lan tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mlerinde veri kaybÄ± olmadan atama yapÄ±labilir, deÄŸer kaybÄ± ile atama yapÄ±labilir ya da **ub** oluÅŸabilir.


### OndalÄ±k SayÄ±lar ArasÄ±nda YapÄ±lan TÃ¼r DÃ¶nÃ¼ÅŸÃ¼mleri 


KÃ¼Ã§Ã¼k kayan noktalÄ± sayÄ±larÄ± bÃ¼yÃ¼k kayan noktalÄ± sayÄ±lara dÃ¶nÃ¼ÅŸtÃ¼rme iÅŸlemlerinde herhangi bir sorun oluÅŸmamaktadÄ±r.
- `float` tÃ¼rden `double` tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸÃ¼mlerde her hengi bir sorun oluÅŸmayacaktÄ±r.
- `float` tÃ¼rden `long double` tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸÃ¼mlerde her hengi bir sorun oluÅŸmayacaktÄ±r.
- `double` tÃ¼rden `long double` tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸÃ¼mlerde her hengi bir sorun oluÅŸmayacaktÄ±r.



ğŸš€ Explicity tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mleri ne iÃ§in kullanÄ±lÄ±r. 
1. Bir iÅŸlemin kendi istediÄŸimiz tÃ¼rde yapÄ±lmasÄ±nÄ± saÄŸlamak iÃ§in kullanÄ±lÄ±r.
2. Bir iÅŸlem kendi istediÄŸimiz gibi yapÄ±lÄ±yor ama kodu okuyana iÅŸlemin bilinÃ§li olarak yapÄ±ldÄ±ÄŸÄ±nÄ± belirtmek iÃ§in kullanÄ±lÄ±r. 


â— Explicity tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mleri iÃ§in **type-cast** adÄ±ndaki `(target type)` operatÃ¶rÃ¼ kullanÄ±lÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki program **type-cast** operatÃ¶rÃ¼nÃ¼n kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int ival = 18;

    double dval1 = (double)ival; // Buradaki tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ iÅŸlemi 'explicity type conversion' yÃ¶ntemiyle yapÄ±lÄ±yor.
    double dval2 = (double)(ival); // Buradaki '(ival)' ifadesindeki parantezler Ã¶ncelik parantezidir.

    // double dval3 = double(ival); // Bu kullanÄ±m sadece C++ dilinde olan tÃ¼r dÃ¶nÃ¼ÅŸtÃ¼rme operatÃ¶rÃ¼nÃ¼n fonksiyonel formu olarak belirtilen kullanÄ±mÄ± mevcuttur.
}
```



â—â—â— C standardÄ± ifadelerin(expression) **value category** bilgisinden aÃ§Ä±k ÅŸekilde bahsedilmemektedir sadece C++ standardÄ±nda resmi olarak mevcuttur ama bazÄ± iÅŸlemleri anlayabilmek iÃ§in **value category** bilinmesi gerekiyor.

â— **type-cast** operatÃ¶rÃ¼ ile oluÅŸturulan ifadeler **R value expression** olur.


ğŸ‘‡ AÅŸaÄŸÄ±daki program **type-cast** operatÃ¶rÃ¼yle oluÅŸturulan ifadelerden hangilerinin geÃ§erli hangilerinin geÃ§ersiz olduÄŸunu anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int ival = 19;

    (double)ival = 123460; // Burada sÃ¶zdizim hatasÄ±(syntax error) vardÄ±r Ã§Ã¼nkÃ¼ 'type-cast' operatÃ¶rÃ¼nÃ¼n oluÅŸturacaÄŸÄ± deÄŸer R-value kategorisindedir ve bu kategorideki ifadelere deÄŸer atamasÄ± yapÄ±lamaz.
    ++(double)ival; // Burada sÃ¶zdizim hatasÄ±(syntax error) vardÄ±r Ã§Ã¼nkÃ¼ 'type-cast' operatÃ¶rÃ¼nÃ¼n oluÅŸturacaÄŸÄ± deÄŸer R-value kategorisindedir ve bu kategorideki ifadelere deÄŸer atamasÄ± yapÄ±lamaz.
    ((double)ival)++; // Burada sÃ¶zdizim hatasÄ±(syntax error) vardÄ±r Ã§Ã¼nkÃ¼ 'type-cast' operatÃ¶rÃ¼nÃ¼n oluÅŸturacaÄŸÄ± deÄŸer R-value kategorisindedir ve bu kategorideki ifadelere deÄŸer atamasÄ± yapÄ±lamaz.
}
```


â— R-value **ifadeler(expression)** atama operatÃ¶rlerinin sol operandÄ± olamaz. R-value **ifadeler(expression)** `++`, `--`, `&` operatÃ¶rlerinin operandÄ± olamaz.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda **type-cast** operatÃ¶rÃ¼nÃ¼n farklÄ± kullanÄ±mlarÄ±nda nasÄ±l sonuÃ§lar Ã¼retildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <limits.h>
#include <math.h>

int main(void)
{
    int i1 = 10;
    int i2 = 3;
    double dval;

    dval = i1 / i2;
    printf("dval = %f\n", dval);

    dval = (double)i1 / i2;
    printf("dval = %f\n", dval);

    dval = i1 / (double)i2;
    printf("dval = %f\n", dval);

    dval = 1. * i1 / i2;
    printf("dval = %f\n", dval);
    
    dval = (double)(i1 / i2);
    printf("dval = %f\n", dval);
}
```


Ders sonu ...
