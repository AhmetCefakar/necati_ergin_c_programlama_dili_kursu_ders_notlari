# 48.Ders 06.07.2025 ğŸ•˜

Derse 5(09:02)-7(09:05)-9(09:18)-10(09:22)-11(09:35)-12(09:55)-12(10:05)-11(10:25)-11(10:50)-12(11:30)-13(11:41)-13(12:05)-11(12:52) kiÅŸi katÄ±ldÄ±.
---


Bir Ã¶nceki derste kendi `date` kÃ¼tÃ¼phenemizi oluÅŸturmuÅŸtuk, bu derste de bir Ã¶nceki derste yazÄ±lan kÃ¼tÃ¼phanemizi tamamlayacaÄŸÄ±z.



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan `set_date` fonksiyonunun nasÄ±l sÄ±nandÄ±ÄŸÄ± gÃ¶rÃ¼lebilir.
```C
#include "date.h"
#include <stdio.h>

int main(void)
{
    Date date1;

    if(set_date(&date1, 29, 2, 2017) == NULL){
        printf("gecersiz bir tarih.\n");
        return 1;
    }

    printf("gecerli bir tarih.\n"); // Burada gizli 'else' kullanÄ±mÄ± vardÄ±r.
}
```


âœï¸ Burada `date` adÄ±ndaki kendi modÃ¼lÃ¼mÃ¼zÃ¼n kaynak dosyasÄ±nÄ± yazmaya aÅŸaÄŸÄ±daki gibi devam ediyoruz.
```C
#define _CRT_SECURE_NO_WARNINGS

#include "date.h"
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h> // Ä°lk olarak 'atoi' fonksiyonunu kullanmak iÃ§in eklendi.
#include <time.h>

#define YEARBASE            1900
#define PRIVATE             static
#define PUBLIC              
#define RANDOM_YEAR_MIN     1950
#define RANDOM_YEAR_MAX     2024

#define ISLEAP(Y)           (((Y) % 4 == 0) && ( ((Y) % 100 != 0) || ((Y) % 400 == 0)))
#define MONTHDAYS(Y, M)     (daytabs[ISLEAP(Y)][M])

#define GET_YEAR(D)         ((D).y_)
#define GET_MOUNT(D)        ((D).m_)
#define GET_MOUNT_DAY(D)    ((D).d_)


PRIVATE const int daytabs[][13] = {
    { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
    { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
};

// TanÄ±mÄ± aÅŸaÄŸÄ±da ama bir Ã§ok fonksiyon bu fonksiyonlarÄ± Ã§aÄŸÄ±rdÄ±ÄŸÄ± iÃ§in fonksiyonlarÄ±n bildirimleri buraya eklenmiÅŸtir.
PRIVATE Date* set(Date* p, int d, int m, int y);
PRIVATE int day_of_week(int d, int m, int y);
PRIVATE bool is_valid_date(int d, int m, int y);
PRIVATE int totaldays(const Date* p);
PRIVATE Date* from_tdays_to_date(Date* p, int tdays);


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Set functions(mutaters)

PUBLIC Date* set_date(Date* p, int d, int m, int y)
{
    return set(p, d, m, y);
}


// Kendisine geÃ§ilen yazÄ± formatÄ±ndaki 'pstr' nesnesini(object) ki "14-06-2021" benzeri bir tarih deÄŸeri geÃ§ilecek, 'Date' tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rÃ¼p geriye dÃ¶nmektedir. 
PUBLIC Date* set_date_str(Date* p, const char* pstr)
{
    int d = atoi(pstr);
    int m = atoi(pstr + 3);
    int y = atoi(pstr + 6);

    return set(p, d, m, y);
}



PUBLIC Date* set_date_today(Date* p)
{
    time_t sec;
    time(&sec);
    struct tm* tp = localtime(&sec);

    int d = tp->tm_mday;
    int m = tp->tm_mon + 1; // 'struct tm' tÃ¼rÃ¼nde ay bilgisi indeks olarak '0'dan baÅŸlÄ±yor. 
    int y = tp->tm_year + 1900; // 'struct tm' tÃ¼rÃ¼ndeki yÄ±l bilgisi '1900' yÄ±lÄ±ndan sonrasÄ± iÃ§in tutuluyor. 

    return set(p, d, m, y);
}



PUBLIC Date* set_random_date(Date* p)
{
    int y = rand() % (RANDOM_YEAR_MAX - RANDOM_YEAR_MIN + 1) + RANDOM_YEAR_MIN;
    int m = rand() % 12 + 1;

    int d = rand() % MONTHDAYS(y, m) + 1;

    return set(p, d, m, y);
}


PUBLIC Date* set_year(Date* p, int y)
{
    return set(p, GET_MONTH_DAY(*p), GET_MOUNT(*p), y);
}

PUBLIC Date* set_month(Date* p, int m)
{
    return set(p, GET_MONTH_DAY(*p), m, GET_YEAR(*p));
}

PUBLIC Date* set_month_day(Date* p, int d)
{
    return set(p, d, GET_MOUNT(*p), GET_YEAR(*p));
}


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Get functions, getters, accessors

PUBLIC int get_week_day(const Date* p)
{
    return day_of_week(GET_MOUNT_DAY(*p), GET_MOUNT(*p), GET_YEAR(*p));
}

//  
// Girilen tarihin yÄ±lÄ±n kaÃ§Ä±ncÄ± gÃ¼nÃ¼ olduÄŸu bilgisini geriye dÃ¶nen fonksiyon
PUBLIC int get_year_day(const Date* p)
{
    int sum = GET_MOUNT_DAY(*p); // Bulunulan ayÄ±n kaÃ§Ä±ncÄ± gÃ¼nÃ¼ olduÄŸu bilgisi 'sum' deÄŸiÅŸkenine alÄ±nÄ±yor.
    int m = GET_MOUNT(*p);
    int y = GET_YEAR(*p);

    for(int i = 1; i < m; ++i)
        sum += MONTHDAYS(y, i);
    
    return sum;
}


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Formatet input-output functions



PUBLIC void print_date(const Date* p)
{
    // AylarÄ± dizinin indis deÄŸeriyle eÅŸitlemek iÃ§in dizinin 0. elemanÄ± boÅŸ yazÄ± yapÄ±lÄ±yor.
    static const char* const pmons[] = { "", "Ocak", "Subat", "Mart", "Nisan", "Mayis", "Haziran", "Temmuz", "Agustos", "Eylul", "Ekim", "Kasim", "Aralik", };
    
    static const char* const pdays[] = { "Pazar", "Pazartesi", "Sali", "Carsamba", "Persembe", "Cuma", "Cumartesi", };

    printf("%02d %s %d %s\n", GET_MONTH_DAY(*p), pmons[GET_MONTH(*p)], GET_YEAR(*p), pdays[get_week_day(p)]);
}



PUBLIC Date* scan_date(Date* p)
{
    int d, m, y;
    scanf("%d%d%d", d, m, y);
    return set(p, d, m, y);
}


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Utility functions

// Ä°ki datihi karÅŸÄ±laÅŸtÄ±ran fonksiyon. 
int cmp_date(const Date* p1, const Date* p2)
{
    // SÄ±rasÄ±yla yÄ±l, ay ve gÃ¼n kÄ±yaslamasÄ± yapÄ±lacak ve bu yÃ¶ntemle;
    // Ä°lk tarih ikinciden bÃ¼yÃ¼kse pozitif deÄŸeri geriye dÃ¶ndÃ¼rÃ¼lecektir.
    // Ä°lk tarih ikinciden kÃ¼Ã§Ã¼kse negatif deÄŸeri geriye dÃ¶ndÃ¼rÃ¼lecektir.
    // Ä°lk tarih eÅŸitse '0' deÄŸeri geriye dÃ¶ndÃ¼rÃ¼lecektir.

    int y1 = GET_YEAR(*p1);
    int y2 = GET_YEAR(*p2);

    if(y1 != y2)
        return y1 - y2;
    
    int m1 = GET_MONTH(*p1);
    int m2 = GET_MONTH(*p2);

    if(m1 != m2)
        return m1 - m2;
    
    return GET_MONTH_Day(*p1) - GET_MONTH_Day(*p2);
}

// Ä°ki tarih arasÄ±ndaki gÃ¼n farkÄ±nÄ± hesaplayan fonksiyon. 
PUBLIC date_diff(const Date* p1, const Date* p2)
{
    return totaldays(p1) - totaldays(p2);
}

// Bulunulan tarihten 'n' gÃ¼n sonraki tarihin ne olacaÄŸÄ±nÄ± hesaplayan fonksiyon. 
PUBLIC Date* ndays_after(Date* pdest, const Date* psource, int n)
{
    return from_tdays_to_date(pdest, totaldays(psource) + n);
}

// Bulunulan tarihten 'n' gÃ¼n Ã¶nceki tarihin ne olacaÄŸÄ±nÄ± hesaplayan fonksiyon. 
PUBLIC Date* ndays_before(Date* pdest, const Date* psource, int n)
{
    return from_tdays_to_date(pdest, totaldays(psource) + n);
}


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// PRIVATE functions

PRIVATE Date* set(Date* p, int d, int m, int y)
{
    p->d_ = d;
    p->m_ = m;
    p->y_ = y;

    return p;
}

// AÅŸaÄŸÄ±daki programda 'Tomahako Sakamota' algoritmasÄ± kullanÄ±lmÄ±ÅŸtÄ±r.
// Bu fonksiyondan geriye dÃ¶nen deÄŸer 0: Pazar, 1: Pazartesi, 2: Sali ... 6: Cumartesi
PRIVATE int day_of_week(int d, int m, int y)
{
    static const int tb[] = { 0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4 };

    if(m < 3)
        --y;
    
    return ((y + y / 4 - y / 100 + y / 400 + tb[m - 1] + d) % 7);
}

PRIVATE bool is_valid_date(int d, int m, int y)
{
    // return y >= YEARBASE && 
    //     m > 0 && m <= 12 && daytabs[ISLEAP(y)][m];

    return y >= YEARBASE && 
        m > 0 && m <= 12 && MONTHDAYS(y, m);
}

// 1 1 YEARBASE'den sonra geÃ§en gÃ¼n sayÄ±sÄ±.  
PRIVATE int totaldays(const Date* p)
{
    int sum = get_year_dat(p); // Fonksiyona geÃ§ilen tarihin yÄ±lÄ±ndaki gÃ¼n sayÄ±sÄ± elde ediliyor.
    int y = GET_YEAR(*p); // Fonksiyona geÃ§ilen tarihin yÄ±lÄ± bilgisi elde ediliyor.

    for(int i = YEARBASE; i < y; ++i){
        sum += ISLEAP(i) ? 366 : 365;
    }

    return sum;
}


// 'tdays' deÄŸeriyle Ã§eÃ§ilen gÃ¼n sayÄ±sÄ± '1.1.1900' tarihinden sonra geÃ§en gÃ¼n sayÄ±sÄ± olarak kabul edilip o gÃ¼nÃ¼n tarihini geriye dÃ¶ndÃ¼ren fonksiyon. 
PRIVATE Date* from_tdays_to_date(Date* p, int tdays)
{
    int y = YEARBASE;

    while(tdays > (ISLEAP(y) ? 366 : 365)){
        tdays -= ISLEAP(y) ? 366 : 365;
        ++y;
    }

    int m = 1;

    while(tdays > MONTHDAYS(y, m)){
        tdays -= MONTHDAYS(y, m);
        ++m;
    }

    int d = tdays;

    return set(p, d, m, y);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program `get_year_day` fonksiyonunu sÄ±namak iÃ§in yazÄ±lmÄ±ÅŸtÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include "date.h"
#include <stdio.h>

int main(void)
{
    Date date1;

    set_date(&date1, 31, 1, 2025);
    printf("%d\n", get_year_day(&date1)); // '31' Ã§Ä±ktÄ±sÄ± Ã¼retilmeli
    
    set_date(&date1, 31, 12, 2025);
    printf("%d\n", get_year_day(&date1)); // '365' Ã§Ä±ktÄ±sÄ± Ã¼retilmeli

    set_date(&date1, 31, 12, 2028);
    printf("%d\n", get_year_day(&date1)); // '366' Ã§Ä±ktÄ±sÄ± Ã¼retilmeli
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program `print_date` fonksiyonunu sÄ±namak iÃ§in yazÄ±lmÄ±ÅŸtÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include "date.h"
#include <stdio.h>

int main(void)
{
    Date date1;

    set_date(&date1, 31, 12, 2028);
    print_date(&date1); // '31 Aralik 2028' Ã§Ä±ktÄ±sÄ± Ã¼retilmeli
    
    set_date_today(&date1);
    print_date(&date1); // ProgramÄ±n Ã§alÄ±ÅŸtÄ±rÄ±lacaÄŸÄ± tarihin Ã§Ä±ktÄ±sÄ± Ã¼retilmeli
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program `scan_date` fonksiyonunu sÄ±namak iÃ§in yazÄ±lmÄ±ÅŸtÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include "date.h"
#include <stdio.h>

int main(void)
{
    Date date1;

    printdf("dogum yilinizi giriniz: ");
    scan_date(&date1);
    print_date(&date1);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda yazdÄ±ÄŸÄ±mÄ±z `date` kÃ¼tÃ¼phene modÃ¼lÃ¼nÃ¼deki `set_date`, `set_date_str`, `set_year`, `set_month`, `set_month_day` fonksiyonlarÄ± sÄ±namak iÃ§in yazÄ±lanlar gÃ¶rÃ¼lebilir.
```C
#include "date.h"

int main(void)
{
    Date date1;
    set_date(&date1, 5, 6, 1955);
    print_date(&date1);
    set_date_str(&date1, "02-09-2044");
    print_date(&date1);

    set_year(&date1, 1994);
    print_date(&date1);
    set_month(&date1, 11);
    print_date(&date1);
    set_month_day(&date1, 24);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `date.h` dosyasÄ±ndaki `set_random_date` fonksiyonunu sÄ±namak iÃ§in yazÄ±lmÄ±ÅŸtÄ±r.
```C
#include "date.h"

int main(void)
{
    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda rastgele 'dd MonthDay yyy Day' biÃ§iminde tarihlerin Ã§Ä±ktÄ± olarak Ã¼retiliyor olmasÄ± gerekiyor.
    for(int i = 0; i < 100; ++i){
        Date x;
        set_random_date(&x);
        print_date(&x);
    } 
}
```


[10:01:45-10-09-00]
ğŸ‘‡ AÅŸaÄŸÄ±daki programda `date.h` dosyasÄ±ndaki `print_date`, `cmp_date`, `set_random_date` fonksiyonlarÄ±nÄ±n nasÄ±l sÄ±nandÄ±ÄŸÄ± incelenebilir. </br> 
Bu programda Ã¶nceden Ã¶ÄŸrendiÄŸimiz dilin araÃ§larÄ±nÄ± kullanacaÄŸÄ±z. 
```C
#include "date.h"
#include <stdio.h>
#include <stdlib.h> // 'qsort' fonksiyonunu kullanmak iÃ§in eklenen baÅŸlÄ±k dosyasÄ±.
#include <time.h> // Ä°ÅŸlem sÃ¼resini Ã¶lÃ§mek iÃ§in eklenen baÅŸlÄ±k dosyasÄ±.
#include <conio.h> // Standart olmayan bir modÃ¼l


// cmp_date fonksiyonunu sÄ±namak icin aÅŸaÄŸÄ±daki iÅŸlemleri afÄ±m adÄ±m yazalÄ±m;
// a) Dinamik bir 'Date' dizisini oluÅŸtur
// b) Dizinin elemanlarÄ±nÄ± rastgele deÄŸerler ile doldur.
// c) Diziyi standart C fonksiyonu olan 'qsort' ile kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe doÄŸru sÄ±rala.
// d) SÄ±ralanmÄ±ÅŸ diziyi standar output'a gÃ¶nder.
// e) dizinin bellek alanÄ±nÄ± serbest bÄ±rak.


// 'qsort' fonksiyonu iÃ§in kullanÄ±lan sarmalayÄ±cÄ± fonksiyon.
static int wdcmp(const void* vp1, const void* vp2)
{
    return cmp_date((const void*)vp1, (const void*)vp2);
}


// ElemanlarÄ± 'Date' tÃ¼rÃ¼nden olan bir diziyi rastgele deÄŸerlerle dolduran bir fonksiyon, bunu cliend code kendi yazÄ±yor.
// AÅŸaÄŸÄ±daki fonksiyonda 'int', 'double' vb. tÃ¼rlerden dizilerle birlikte nasÄ±l gÃ¶sterici aritmetiÄŸi kullanÄ±ldÄ±ysa burada da yapÄ± tÃ¼rÃ¼nden bir dizi iÃ§in gÃ¶sterici aritmetiÄŸi kullanÄ±lmÄ±ÅŸtÄ±r.
Date* set_date_array(Date* p, size_t size)
{
    Date* ptemp = p; // Burada fonksiyondan geriye dÃ¶ndÃ¼rÃ¼lecek olan dizinin adresinin kaybedilmemesi iÃ§in o adres deÄŸerinin 'ptemp' deÄŸiÅŸkenine ilk deÄŸer olarak veriliyor.

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ dizinin elemana sayÄ±sÄ± kadar dÃ¶necektir.
    while(size--){
        set_random_date(p++);
    }

    return ptemp;
}

// ElemanlarÄ± 'Date' tÃ¼rÃ¼nden olan bir diziyi 'print_date' fonksiyonu ile formatlÄ± olarak standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderen fonksiyon.
void print_date_array(const Date* p, size_t size)
{
    while(size--){
        print_date(p++);
    }
}


int main(void)
{
    size_t size;

    printf("kac elemanli bir dizi olsun: ");
    scanf("%zu", &size);

    Date* pd = (Date*)malloc(size * sizeof(Date));
    if(!pd){
        fprintf(stderr, "bellek yetersiz!\n"); // bu fonkisyon Ã§aÄŸrÄ±sÄ±na sonradan deÄŸinilecek. 
        return 1;
    }

    set_date_array(pd, size); // Bir Ã¶nceki derste yazÄ±lmÄ±ÅŸ olan sÄ±nama kodunda buradaki fonksiyon Ã§aÄŸrÄ±sÄ±nÄ±n yazÄ±lmasÄ± unutulmuÅŸ, ÅŸimdi ekliyoruz.

    printf("siralama basladi.\n");
    clock_t start = clock();
    qsort(pd, size, sizeof(*pd), &wdcmp);
    clock_t end = clock();
    printf("siralama bitti %.2f saniye.\n", (double)(end - start) / CLOCKS_PER_SEC);
    _getch(); // ProgramÄ± burada durdurmak iÃ§in kullanÄ±lan 'conio.h' modÃ¼lÃ¼ndeki standart olmayan fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±lÄ±yor.
    print_date_array(pd, size); 

    free(pd);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±da programdan `data.h` dosyasÄ±ndaki `date_diff` fonksiyonunun nasÄ±l sÄ±nandÄ±ÄŸÄ± gÃ¶rÃ¼lebilir.
```C
#include "date.h"
#include <stdio.h>

int main(void)
{
    Date bdate;

    printf("bedenlenis tarihinizi giriniz: ");
    scan_date(&bdate);
    printf("bedenlenis tarihiniz: ");
    print_date(&bdate);

    Date today;
    set_date_today(&today);
    printf("bugunun tarihi: ");
    print_date(&today);
    printf("bugun varolusunuzun %d. gunu, anlamini bulabildin mi?\n", date_diff(&today, &bdate));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan `data.h` dosyasÄ±ndaki `ndays_after` fonksiyonunun nasÄ±l test edildiÄŸi gÃ¶rÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include "date.h"
#include <stdio.h>

int main(void)
{
    printf("bugunden kac gun sonrasi: ");
    int n;
    scan_date("%d", n);

    Date today;
    set_date_today(&today);
    printf("bugun: ");
    print_date(&today);

    Date future_date;
    ndays_after(&future_date, &today, n);
    print_date(&future_date);
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.30-10.50 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


## YapÄ±larÄ±n ElemanlarÄ±nÄ±n YapÄ± TÃ¼rlerinden OlmasÄ± 

Programlamada bir **kullanÄ±cÄ± tanÄ±mlÄ± tÃ¼rÃ¼n(user defined type)** elemanÄ±nÄ±n yine baÅŸka bir **kullanÄ±cÄ± tanÄ±mlÄ± tÃ¼rÃ¼n(user defined type)** olmasÄ±na **composition** denilmektedir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programdan yapÄ± tÃ¼rÃ¼nden Ã¼yeye sahip bir yapÄ±nÄ±n bellek boyutunun ne olcaÄŸÄ± incelenebilir.
```C
#include <stdio.h>

struct Member {
    int x, y, z;
};

// AÅŸaÄŸÄ±daki 'struct Owner' tÃ¼rÃ¼nÃ¼n bir elemanÄ± baÅŸka bir yapÄ± olan 'struct Member' yapÄ± tÃ¼rÃ¼nden deÄŸiÅŸkene sahiptir.
struct Owner {
    int a, b;
    struct Member mx;
};

int main(void)
{
    printf("sizeof(struct Member) = %zu", sizeof(struct Member));
    printf("sizeof(struct Owner) = %zu", sizeof(struct Owner));
}
```


âš ï¸ Bu baÅŸlÄ±ktaki bundan sonra yazÄ±lan programlarÄ±n herbiri Ã¶nemlidir, dikkatle incelenmeli ve Ã¶zÃ¼msenmelidir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan yapÄ± tÃ¼rÃ¼nden Ã¼yeye sahip bir yapÄ±nÄ±n elemanlarÄ±na nasÄ±l eriÅŸilebileceÄŸi incelenebilir.
```C
#include <stdio.h>


struct Member {
    int x, y, z;
};

struct Owner {
    int a, b;
    struct Member mx;
};


int main(void)
{
    struct Owner x;

    // 'x' ifadesinin tÃ¼rÃ¼ 'struct Owner' tÃ¼rÃ¼dÃ¼r ve bu ifade 'L-value' Ã¶zelliktedir.
    // 'x.a' ifadesinin tÃ¼rÃ¼ 'int' tÃ¼rÃ¼dÃ¼r ve bu ifade 'L-value' Ã¶zelliktedir.
    // 'x.mx' ifadesinin tÃ¼rÃ¼ 'struct Member' tÃ¼rÃ¼dÃ¼r ve bu ifade 'L-value' Ã¶zelliktedir.

    // AÅŸaÄŸÄ±daki atama iÅŸlemlerinin sol operantlarÄ±ndaki ifadelerde birden fazla '.' operatÃ¶rÃ¼ kullanÄ±ldÄ±ÄŸÄ± gÃ¶rÃ¼lecektir, bazÄ± ifadelerde 'n' tane '.' operatÃ¶rÃ¼ kullanÄ±ldÄ±ÄŸÄ± durumlarla karÅŸÄ±laÅŸÄ±labilir.
    x.mx.z = 5;
    (x.mx).z = 5; // Buradaki statament bir Ã¼stteki statement ile denktir.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan yapÄ± tÃ¼rÃ¼nden Ã¼yeye sahip bir yapÄ±ya nasÄ±l ilk deÄŸer verilebileceÄŸi incelenebilir.
```C
#include <stdio.h>

struct Member {
    int x, y, z;
};

struct Owner {
    int a, b;
    struct Member mx;
};


int main(void)
{
    struct Owner s1 = { 10, 20, { 3, 4, 6 } };
    struct Owner s2 = { .mx = { 4, 5, 6 } };
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan yapÄ± tÃ¼rÃ¼nden Ã¼yeye sahip bir yapÄ± tÃ¼rÃ¼nden olan dizilere nasÄ±l ilk deÄŸer verilebileceÄŸi incelenebilir.
```C
#include <stdio.h>

struct Member {
    int x, y, z;
};

struct Owner {
    int a, b;
    struct Member mx;
};


int main(void)
{
    struct Owner ar[] = { { 2, 4, {1, 1, 1 } }, { 3, 6, { 2, 2, 2 } } };
    struct Owner ar[10] = { [5] = { .mx = { 2, 1, 0} }, [7] = { 2, 3, { 0, 2, 7 } } }; // 'Designated initializer' ile ilk deÄŸer veriliyor.
}
```





ğŸ‘‡ AÅŸaÄŸÄ±daki programdan bir yapÄ± nesnesinin baÅŸka bir yapÄ± nesnesinin gÃ¶stericisi tÃ¼rÃ¼nden Ã¼yeye(kendi tÃ¼rÃ¼nden gÃ¶stericiye de sahip olabilir) sahip olabileceÄŸi gÃ¶rÃ¼lmelidir.
```C
#include <stdio.h>

struct Member {
    int x, y, z;
};

struct Owner {
    int a, b;
    struct Member* pm;
};


int main(void)
{
    struct Owner x;
    struct Owner* p = &x;

    // some code here ...

    // AÅŸaÄŸÄ±daki gibi birden fazla '.' ve '->' operatÃ¶rÃ¼ iÃ§eren ifadeler kullanÄ±labileceÄŸi gÃ¶rÃ¼lmelidir.
    x.pm->y = 5;
    p->pm->z = 2;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan bir yapÄ± nesnesi dizisi nesnesi Ã¼zerinden yapÄ± Ã¼yelerine nasÄ±l eriÅŸilebileceÄŸi incelenebilir.
```C
#include <stdio.h>

struct Member {
    int x, y, z;
};

struct Owner {
    int a, b;
    struct Member* pm;
};


int main(void)
{
    struct Owner ar[5];

    // some code here ...

    ar[4].pm->z = 5; // Burada aynÄ± ifade iÃ§inde '[]', '.', '->' operatÃ¶rlerinin kullanÄ±lÄ±ÅŸÄ± incelenebilir.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan bir yapÄ± nesnesi Ã¼yesinin bir fonksiyon gÃ¶stericisi olabileceÄŸi gÃ¶rÃ¼lmelidir.
```C
#include <stdio.h>

struct Member {
    int x, y, z;
    int (*fp)(void); // 'fp' adÄ±ndaki yapÄ± Ã¼yesi 'int (*)(void)' tÃ¼rÃ¼nden bir fonksiyon gÃ¶stericisidir.
};

struct Owner {
    int a, b;
    struct Member* pm;
};


int main(void)
{
    struct Owner ar[5];

    // some code here ...

    // AÄŸaÄŸÄ±daki iki ifade de aynÄ± anlama gelmektedir.
    ar[4].pm->fp();
    (((ar[4]).pm)->fp)();
}
```



â—â—â— Bir yapÄ±nÄ±n elemanÄ±, kendi tÃ¼rÃ¼nden olamaz, bunun nedeni bu biÃ§imdeki bir kullanÄ±mda yapÄ±nÄ±n kendi tÃ¼rÃ¼nden Ã¼yenin **incomplate type** durumunda olmasÄ±dÄ±r. </br>
â—â—â— Bir yapÄ±nÄ±n elemanÄ±, kendi tÃ¼rÃ¼nden gÃ¶sterici olabilir.
```C
#include <stdio.h>

struct Nec1 {
    int x, y;
    struct Nec1 nc; // 'struc Nec' is an incomplate type here. Burada sÃ¶zdizim(syntax) hatasÄ± vardÄ±r.
};

struct Nec2 {
    int x, y;
    struct Nec2* p; 
};

int main(void)
{
    
}
```


**Self Referential Structures**: Kendi kendisinin gÃ¶stericisi tÃ¼rÃ¼nden Ã¼yesi olan yapÄ±lar iÃ§in kullanÄ±lan bir terimdir, bu terimi C standardÄ± kullanmamaktadÄ±r, programcÄ±larÄ±n yoÄŸun olarak kullandÄ±ÄŸÄ± bir terimdir.



â—â—â— BazÄ± veri yapÄ±larÄ±nÄ±n(linked-list, tree vb.) gerÃ§ekleÅŸtirimlerinde dinamik olarak oluÅŸturulmuÅŸ yapÄ± nesnelerinin kendi tÃ¼rÃ¼nden bir nesnenin pointer Ã¼yesi olduÄŸu durumlar sÄ±klÄ±kla kullanÄ±lmaktadÄ±r.


**Node(DÃ¼ÄŸÃ¼m)**: Veri yapÄ±larÄ±nda, dizi veri yapÄ±sÄ± tÃ¼rleri dÄ±ÅŸÄ±nda kendi tÃ¼rÃ¼nÃ¼ bir biÃ§imde gÃ¶stermesi gereken veri yapÄ±sÄ± tÃ¼rlerinde o veri yapÄ±sÄ±nÄ±n her bir elemanÄ±nÄ± belirtmek iÃ§in kullanÄ±lan bir terimdir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir yapÄ± nesnesinin elemanlarÄ±ndan birinin kendi tÃ¼rÃ¼nÃ¼n gÃ¶stericisi olabileceÄŸi gÃ¶rÃ¼lebilir.
```C
#include <stdio.h>

// AÅŸaÄŸÄ±daki 'struct Node' tÃ¼rÃ¼ne benzer biÃ§imde kendi tÃ¼rÃ¼nÃ¼n gÃ¶sterisisi tÃ¼rÃ¼nden Ã¼yeye sahip yapÄ±lar veri yapÄ±larÄ±nÄ±n gerÃ§ekleÅŸtirimlerini yaparken sÄ±klÄ±kla kullanÄ±lmaktadÄ±r.
struct Node {
    int x, y;
    struct Node* p; 
};

int main(void)
{
    struct Node* px;

    px->p;
}
```




âš ï¸âš ï¸âš ï¸ C ve C++ dilleri arasÄ±nda bazÄ± **sÃ¶zdizim(syntax)** farklÄ±lÄ±klarÄ± var.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iÃ§ iÃ§e yapÄ± iÃ§eren yapÄ± tÃ¼rÃ¼nden bir tÃ¼rÃ¼n bellek boyutunun ne olacaÄŸÄ± incelenebilir.
```C
#include <stdio.h>

// nested type
// member type
// nested structure
struct Nec {
    int x, y;

    // AÅŸaÄŸÄ±daki yapÄ± bildiriminde Ã¼yenin adÄ± verilmemiÅŸtir, bu yapÄ± bildirimi C11 ve sonrasÄ± iÃ§in geÃ§erlidir(C++ dilinde Ã§ok Ã¶ncelerden beri standarttÄ±r) ve C11 Ã¶ncesinde de Ã§oÄŸu derleyicinin extenson olarak desteklediÄŸi bir kullanÄ±mdÄ±r.
    struct Erg {
        int a, b, c;
    };
};

int main(void)
{
    printf("sizeof(struct Erg) = %zu\n", sizeof(struct Erg)); // 32 bitlik sistemde standart Ã§Ä±ktÄ± akÄ±mÄ±na en az(alignment'dan dolayÄ±) 'sizeof(struct Erg) = 12\n' gÃ¶nderilir.
    printf("sizeof(struct Nec) = %zu\n", sizeof(struct Nec)); // 32 bitlik sistemde standart Ã§Ä±ktÄ± akÄ±mÄ±na en az(alignment'dan dolayÄ±) 'sizeof(struct Nec) = 20\n' gÃ¶nderilir.
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda iÃ§ iÃ§e yapÄ± iÃ§eren yapÄ± tÃ¼rÃ¼nÃ¼n elemanlarÄ±na nasÄ±l eriÅŸilebildiÄŸi incelenebilir.
```C
#include <stdio.h>

struct Nec {
    int x, y;

    // Ä°Ã§ yapÄ± bildiriminde, bildirilen yapÄ±dan bir deÄŸiÅŸken adÄ± belirtilmektedir.
    struct Erg {
        int a, b, c;
    }erg; 
};

int main(void)
{
    struct Nec nec1;

    // 'struct Nec' tÃ¼rÃ¼nÃ¼n 'struct Erg' tÃ¼rÃ¼nden 'erg' Ã¼yesi Ã¼zerinden 'struct Erg' tÃ¼rÃ¼nÃ¼n Ã¼yelerine eriÅŸilmektedir.
    nec1.erg.a;
    nec1.erg.b;
    nec1.erg.c;
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda iÃ§ iÃ§e yapÄ± iÃ§eren yapÄ± tÃ¼rÃ¼nÃ¼n elemanlarÄ±na nasÄ±l eriÅŸilebildiÄŸi incelenebilir.
```C
#include <stdio.h>

struct Nec {
    int x, y;

    // Ä°Ã§ yapÄ± bildiriminde, bildirilen yapÄ±dan bir deÄŸiÅŸken adÄ± belirtilmemektedir.
    struct Erg {
        int a, b, c;
    }; 
};

int main(void)
{
    struct Nec nec1;

    // 'struct Nec' tÃ¼rÃ¼nÃ¼n 'struct Erg' tÃ¼rÃ¼nden 'erg' Ã¼yesi Ã¼zerinden 'struct Erg' tÃ¼rÃ¼nÃ¼n Ã¼yelerine eriÅŸilmektedir.
    nec1.a;
    nec1.b;
    nec1.c;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir yapÄ±nÄ±n sahip olduÄŸu bir iÃ§ yapÄ± tÃ¼rÃ¼nden Ã¼Ã§ tane deÄŸiÅŸken bildirildiÄŸinde en kapsayÄ±cÄ± yapÄ±nÄ±n bellek boyutunun ne olacaÄŸÄ± gÃ¶rÃ¼lebilir.
```C
#include <stdio.h>

struct Nec {
    int x, y;

    struct Erg {
        int a, b, c;
    }e1, e2, e3; 
};

int main(void)
{
    printf("sizeof(struct Nec) = %zu\n", sizeof(struct Nec)); // 32 bitlik sistemde standart Ã§Ä±ktÄ± akÄ±mÄ±na en az(alignment'dan dolayÄ±) 'sizeof(struct Nec) = 44\n' gÃ¶nderilir.

    struct Nec nec;
    nec.a;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir yapÄ±nÄ±n sahip olduÄŸu bir iÃ§ yapÄ± tÃ¼rÃ¼nden iki tane gÃ¶sterici deÄŸiÅŸken bildirildiÄŸinde en kapsayÄ±cÄ± yapÄ±nÄ±n bellek boyutunun ne olacaÄŸÄ± gÃ¶rÃ¼lebilir.
```C
#include <stdio.h>

struct Nec {
    int x, y;

    // AÅŸaÄŸÄ±da 'struct Erg' tÃ¼rÃ¼nden bir yapÄ±yÄ± gÃ¶steren iki farklÄ± deÄŸiÅŸken bildirilmiÅŸtir, her 'object-like pointer' nesnenin bellekte kapladÄ±ÄŸÄ± alan sabittir, burayÄ± iyi anlamak ve bu projede main fonksiyonunda standart Ã§Ä±ktÄ±ya gÃ¶nderilen deÄŸeri iyi anlamak gerekiyor.
    struct Erg {
        int a, b, c;
    }*p1, *p2; 
};

int main(void)
{
    printf("sizeof(struct Nec) = %zu\n", sizeof(struct Nec)); // 32 bitlik sistemde standart Ã§Ä±ktÄ± akÄ±mÄ±na en az(alignment'dan dolayÄ±) 'sizeof(struct Nec) = 16\n' gÃ¶nderilir.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iÃ§ iÃ§e yapÄ± kullanÄ±mÄ±nda iÃ§teki yapÄ±ya deÄŸiÅŸken adÄ± verilmediÄŸinde iÃ§teki yapÄ±nÄ±n Ã¼yelerine nasÄ±l eriÅŸildiÄŸi incelenebilir.
```C
#include <stdio.h>

struct Nec1 {
    int x, y;

    struct Erg1 {
        int a, b, c;
    }; 
};

struct Nec2 {
    int x, y;

    struct Erg2 {
        int a, b, c;
    }erg; 
};


// int '4 byte' ise 'struct Erg' bellek bÃ¼yÃ¼klÃ¼ÄŸÃ¼ en az '12 byte' olacaktÄ±r.
// int '4 byte' ise 'struct Nec1' bellek bÃ¼yÃ¼klÃ¼ÄŸÃ¼ en az '20 byte' olacaktÄ±r.

int main(void)
{
    struct Nec1 nec1;
    nec1.a;
    nec1.b;
    nec1.c;


    struct Nec2 nec2;
    nec2.erg.a;
    nec2.erg.b;
    nec2.erg.c;
}
```



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programda iÃ§ iÃ§e yapÄ± kullanÄ±mÄ±nÄ±n daha sade bir hali incelenebilir.
```C
#include <stdio.h>

struct Nec1 {
    int x, y;

    // AÅŸaÄŸÄ±daki yapÄ± nested olarak C11 standardÄ±ndan sonra adÄ± olmadan da tanÄ±mlanabilmektedir. 
    struct {
        int a, b, c;
    };

    // En Ã¶nemli soru, peki neden aÅŸaÄŸÄ±daki gibi kullanmÄ±yoruz da yukarÄ±daki gibi kullanÄ±yoruz, arada ne fark var, bu sorunun cevabÄ±nÄ± 'union' konusuna gelince Ã¶ÄŸreneceÄŸiz.
    // struct {
    int a, b, c;
    // }; 
};

// int '4 byte' ise 'struct Erg' bellek bÃ¼yÃ¼klÃ¼ÄŸÃ¼ en az '12 byte' olacaktÄ±r.
// int '4 byte' ise 'struct Nec1' bellek bÃ¼yÃ¼klÃ¼ÄŸÃ¼ en az '20 byte' olacaktÄ±r.

int main(void)
{
    printf("sizeof(struct Nec) = %zu\n", sizeof(struct Nec));

    struct Nec1 nec1;
    nec1.a;
    nec1.b;
    nec1.c;
}
```


> â” 
> 
> Sorulan soru;
> 
> Peki `struct Nec` tÃ¼rÃ¼ne ait bir deÄŸiÅŸken oluÅŸturunca bu 5 deÄŸiÅŸken iÃ§in ardÄ±ÅŸÄ±k olarak mÄ± bellekte yer ayrÄ±lacak?
> 
> Cevap;
> 
> Bir yapÄ± nesnesinin elemanlarÄ±nÄ±n bellekte sÄ±ralÄ± olarak yerleÅŸtirileceÄŸi kesin olarak dilin standardÄ± tarafÄ±ndan belirtilmiÅŸtir.


â—â—â— C dilinin standardo bir yapÄ±nÄ±n Ã¼yelerinin bellekte sÄ±ralÄ± olacaÄŸÄ±nÄ± kesin olarak belirtmektedir. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda yukarÄ±daki kesinliÄŸin doÄŸruluÄŸu gÃ¶rÃ¼lebilir.
```C
#include <stdio.h>

struct Nec1 {
    int x;
    double y;
    char str[20];
};

int main(void)
{
    struct Nec nec;

    printf("%p\n", &nec.x);
    printf("%p\n", &nec.y);
    printf("%p\n", nec.str); // Burada 'array decay' uygulanÄ±yor ve 'nec.str' ifadesi '&nec.str[0]' ifadesine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼yor.

    // AÅŸaÄŸÄ±da yazdÄ±rÄ±lan iki ifadenin de adresi sayÄ±sal olarak aynÄ± olmak zorundadÄ±r.
    printf("%p\n", &nec);
    printf("%p\n", &nec.x);
}
```



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki gÃ¶sterilen **alignment(hizalama)** konusu incelenebilir, bu kavran sonraki derslerde detaylÄ± olarak incelenevektir. 
```C
#include <stdio.h>

struct Nec {
    char c1;
    int i;
    char c2;
};

int main(void)
{
    printf("sizeof(struct Nec) = %zu\n", sizeof(struct Nec)); // Burada 'struct Nec' tÃ¼rÃ¼nden nesnenin elemanlarÄ±nÄ±n bellekte sÄ±ralÄ± olacaÄŸÄ± kesin ama 'alignment(hizalama)' durumundan dolayÄ± bellek boyutu beklenenden bÃ¼yÃ¼k olabilir.
}
```

**Alignment(hizalama)**: Derleyicilerin yapÄ±larÄ±n deÄŸerlerini daha kolay her tÃ¼r sabit bir temel veri boyutunda olmasÄ± iÃ§in arada bazÄ± tÃ¼rlerden sonra kullanÄ±lmayan byte'larÄ±n yapÄ± nesnesinin bellek alanÄ±na eklenmesi durumuna verilen tanÄ±mlamadÄ±r.

**Padding Bytes or Hole Bytes**: Alignment(hizalama) durumlarÄ±nda veri tutulmayan byte alanlarÄ±nÄ± belirtmek iÃ§in kullanÄ±lan terimdir.



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programda iÃ§ iÃ§e bildirilen yapÄ±lardan iÃ§ yapÄ±nÄ±n ad arama(name lookup) iÅŸleminde gÃ¶rÃ¼nÃ¼r olduÄŸu her yerde de gÃ¶rÃ¼nÃ¼r olduÄŸu anlaÅŸÄ±lmalÄ±dÄ±r.
```C
#include <stdio.h>

struct Nec {
    int x, y;

    struct Erg {
        int a, b, c;
    }e1; 
}

struct Erg e1, e2;  // Bu biÃ§imde deÄŸiÅŸken bildirimi C dilinde legal ama C++ dilinde legal deÄŸildir.

int main(void)
{
    struct Erg x; // Bu biÃ§imde deÄŸiÅŸken bildirimi C dilinde legal ama C++ dilinde legal deÄŸildir.
    struct Erg* ptr;  // Bu biÃ§imde deÄŸiÅŸken bildirimi C dilinde legal ama C++ dilinde legal deÄŸildir.

    // struct Nec::Erg; // Bu kullanÄ±m C++ dilinde legaldir.
}
```


## Bir YapÄ±nÄ±n ElemanÄ±nÄ±n BaÅŸka Bir TÃ¼rden YapÄ± OlmasÄ± Durumu 

Bir yapÄ±nÄ±n baÅŸka bir yapÄ± tÃ¼rÃ¼nÃ¼ iÃ§ermesi durumuna **composition** deniliyor.


âœï¸ Burada `Person` adÄ±ndaki kendi modÃ¼lÃ¼mÃ¼zÃ¼n baÅŸlÄ±k dosyasÄ±nÄ± aÅŸaÄŸÄ±daki gibi yazÄ±yoruz.
```C
// YazÄ±lan 'person.h' dosyasÄ±.

#pragma one // Ã‡oÄŸu derleyicinin desteklediÄŸi makro kullanÄ±mÄ±.

#include "date.h"

typedef struct{
    int id;
    char name[20];
    char surname[24];
    Date bdate;
}Person;

Person* set_random_person(Person*);
void print_person(const Person*);
int cmp_person(const Person* p1, const Person* p2);
```



âœï¸ Burada `Person` adÄ±ndaki kendi modÃ¼lÃ¼mÃ¼zÃ¼n kaynak dosyasÄ±nÄ± aÅŸaÄŸÄ±daki gibi yazÄ±yoruz.
```C
// YazÄ±lan 'person.c' dosyasÄ±.

#include "person.h"
#include "nutility.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

Person* set_random_person(Person* p)
{
    p->id = rand() + 1000;
    strcpy(p->name, random_name());
    strcpy(p->surname, random_surname());
    set_random_date(&p->bdate);

    return p;
}

void print_person(const Person* p)
{
    printf("%-8d %-16s %-24s ", p->id, p->name, p->surname);
    print_date(&p->bdate);
}

// Ä°ki 'personel' nesnesi kÄ±yaslanÄ±rken ÅŸu sÄ±raya gÃ¶re kÄ±yaslama yapÄ±lacak: ad, soyad, doÄŸum senesi, id
int cmp_person(const Person* p1, const Person* p2)
{
    int cmp_result = strcmp(p1->name, p2->name);
    if(cmp_result)
        return cmp_result;

    cmp_result = strcmp(p1->surname, p2->surname);
    if(cmp_result)
        return cmp_result;
    
    cmp_result = cmp_date(&p1->bdate, &p2->bdate);
    if(cmp_result)
        return cmp_result;
    
    return p1->id - p2->id;
}
```


âœï¸ Burada `nutility` adÄ±ndaki kendi modÃ¼lÃ¼mÃ¼ze rastgele ad ve soyad soyad Ã¼retecek ayrÄ± ayrÄ± iki fonksiyon ekliyoruz.
```C
// YazÄ±lan 'nutility.h' dosyasÄ±na eklenenler.

#define RANDOM_ELEM(a)      (a[rand() % ASIZE(a)])

const char* random_name(void);
const char* random_surname(void);
```


```C
// YazÄ±lan 'nutility.c' dosyasÄ±na eklenenler.

// Rastgele ad verisi almak iÃ§in kullanÄ±lan fonksiyon. 
const char* random_name(void)
{
    static const char* const p[] = {
        "ata", "emrecan", "adem", "burhan", "korhan", "demir", "bilal", "emrecan", "celik", "zahide",
        "dost", "lale", "baran", "saniye", "poyraz", "saadet", "aynur", "yeliz", "berivan", "mukerrem",
        "melih", "necati", "cezmi", "muslum", "azize", "atif", "rupen", "alev", "haldun", "hulusi",
        "yelda", "billur", "yasemin", "tarcan", "yasar", "tarkan", "refik", "berk", "kenan", "izzet",
        "adnan", "sefa", "kazim", "gursel", "huseyin", "suheyla", "binnaz", "nusret", "aykut", "efecan"
        "esra", "tonguc", "kunter", "yurdanur", "abdi", "fugen", "ayse", "aydan", "edip", "nazli",
        "nucahit", "onat", "cumhur", "yalcin", "ziya", "ali", "ismail", "recep", "sarp", "yilmaz",
        "hilal", "atakal", "cemre", "emirhan", "ceylan", "sabriye", "necmettin", "nagehan", "muhsin", "perihan",
        "suleyman", "zeliha", "cahide", "beril", "askin", "zahit", "sevim", "ege", "utku", "ercument",
        "seyhan", "sadegul", "yenes", "sadi", "candan", "cemile", "tansel", "turgut", "sumeyye", "aylin",
        "hakan", "ferhunde", "cebnail", "nihat", "alparslan", "osman", "efa", "ece", "soner", "necmi",
        "polat", "daci", "pelinsu", "keram", "eylul", "beste", "mert", "akin", "kamile", "kerem",
        "bekir", "nalan", "bulent", "tijen", "durmus", "cansu", "sadri", "atil", "yesim", "sevilay",
        "furkan", "ediz", "helin", "sadettin", "gulden", "samet", "binnur", "celal", "murat", "sezer",
        "bilge", "yunus", "cem", "temel", "sefer", "petek", "haluk", "teoman", "aslican", "aycan",
        "azmi", "nazife", "nurullah", "yasin", "nedim", "abdulmuttalip", "gulsen", "devlet", "mahin", "tarik",
        "yurduagul", "nisan", "derya", "emre", "sade", "leyla", "fadime", "tamer", "julide", "busra",
        "feramuz", "dilek", "dilber", "tansu", "abdullah", "mehmet", "nuri", "gizem", "nefes", "yavuz",
        "demet", "zekai", "zerrin", "umit", "gul", "emine", "sezen", "ugur", "turhan", "aziz",
        "tuncer", "handan", "irkam", "lamia", "can", "kelami", "ceyhan", "cahit", "metin", "bilgin",
        "su", "tayyar", "ferhat", "nuriye", "cemal", "engin", "pelin", "yusuf", "garo", "iffet",
        "galip", "deniz", "belgin", "muzaffer", "hiyazi", "kayahar", "hulki", "kaya", "necmiye", "kasim",
        "hulya", "sidre", "esin", "suphi", "cengiz", "olcay", "rumeysa", "tugay", "asim", "yurdakul",
        "feraye", "derin", "cuneyt", "keriman", "nuriye", "esen", "tevfik", "naz", "gurbuz", "cetin",
        "bora", "taci", "sadullah", "gulsah", "menekse", "semsit", "burak", "fikret", "cahan", "ceyda",
        "selenay", "alicap", "figen", "hasullah", "oesim", "zubeyde", "sezai", "melike", "nurdan", "arda",
        "nazif", "fuat", "gunay", "tufan", "fahri", "handesu", "kezban", "halime", "beyhan", "ciler",
        "tayyip", "afacan", "mustafa", "kunthar", "tugra", "ahmet", "hasan", "hakkÄ±", "metin", "dytac",
        "pinat", "selin", "kaan", "melisa", "sevde", "nihal", "nevsin", "pakize", "teslime", "tunc",
        "nahit", "ceyhun", "hismet", "ede", "malik", "ani", "caÄŸan", "egemen", "hande", "hilmÄ±",
        "muvvafet", "cemil", "diana", "tayfun", "zarife", "tekin", "murathan", "caner", "devrim", "agah",
        "kamil", "ayla", "papatya", "kayhan", "durriye", "melek", "tanuj", "sinem", "jade", "sadiye",
        "refika", "birhan", "sami", "orkun", "erdem", "ufuk", "dogan", "atalay", "fazilet",
        "tancer", "polathan", "bennur", "aslihan", "cihat",
    };

    return RANDOM_ELEM(p);
}

// Rastgele soyad verisi almak iÃ§in kullanÄ±lan fonksiyon.
const char* random_surname(void)
{
    static const char* const p[] = {
        "acar", "acgoze", "acuka", "ademoglu", "adiguzel", "agaoglu", "akarsu", "akcalar", "akgunes", "akkay",
        "akkuyu", "aklikit", "aksakal", "akyildiz", "akyoldas", "alemdar", "alniacik", "altindag", "altinsik", "altinorak",
        "arcan", "aslan", "avci", "abyezay", "aylak", "azmak", "bahceli", "bakirci", "baklavaci", "barutcu",
        "baturalp", "bayraktar", "bekar", "belgeli", "beyaz", "bilgic", "bozkaya", "boztas", "canbay", "candamar",
        "cangoz", "cankoc", "canlikaya", "cansever", "cansiz", "celik", "celiker", "cengaver", "cevikkol", "cilingir",
        "comakci", "corbaci", "cubukay", "cuhadar", "daglarca", "damar", "degirmenci", "demirdogen", "demirel", "derin",
        "dingin", "dokmeci", "dokuzcan", "dosteli", "dumbuk", "dunyalik", "ecevit", "edepeli", "edepsiz", "efelik",
        "elebasi", "eliagir", "elibol", "elitemiz", "elkizi", "elmanli", "eloglu", "emirkulu", "engerek", "engereke",
        "erdogan", "ergin", "erim", "ersoy", "ertakan", "esereli", "esendur", "estererli", "etci", "ezgercer",
        "fakir", "fedai", "fincan", "firatonu", "fitrat", "gamsiz", "gedik", "geldik", "gilgamis", "girik",
        "gucusur", "gultekin", "gumus", "gurkas", "hamsikoylu", "harmanci", "haselici", "hepguler", "hurmaci", "iliksiz",
        "issiz", "jilet", "kabasakal", "kadersiz", "kahraman", "kalemsiz", "kalinkas", "kalpsiz", "kalpten", "kapan",
        "kapici", "kaplan", "kara", "karabatur", "karaduman", "karealmas", "karakis", "karakoyun", "karakuzyu", "karamuk",
        "karaorman", "karasaban", "karataban", "karayeyl", "kayabasi", "kazanci", "kecisakal", "kelepce", "kelleci", "keskin",
        "kesman", "kilicdar", "kilimci", "kilinc", "kiriboga", "kircisi", "koygirit", "kolcak", "komcu", "komurcu",
        "konak", "konca", "koralp", "korukcu", "kosnuk", "kotek", "koylu", "kucukkaya", "kulaksiz", "kurban",
        "kurtulus", "kusmen", "lalezar", "lokmaci", "lombak", "lufer", "maganda", "malazgirt", "malkaciran", "mazgirt",
        "merdane", "mertek", "merzifon", "mirza", "miskin", "miskinoglu", "muglali", "nazik", "nurtopu", "olmez",
        "oltu", "onan", "ongun", "ordulu", "ornancan", "ormanci", "ortaca", "osmaneli", "otaci", "ovacik",
        "oztoklu", "ozveneci", "pakdaman", "pirlanta", "polatkan", "portakol", "poturgeli", "reis", "renacan", "resimci",
        "saferikli", "safkan", "salca", "saldiray", "sallabas", "samanci", "saricakir", "sarikafa", "sarpdemir", "savaskan",
        "sefiloglu", "selercan", "semiz", "seney", "serce", "serinsun", "sessiz", "silahdar", "silifkeli", "simsek",
        "sivri", "sofougolu", "sonmez", "sonuzun", "soylu", "soysalan", "soybozuk", "sucu", "sulugoz", "supuren",
        "takes", "tamgun", "tamirci", "tantana", "tarumar", "tekinalp", "tekkaya", "tekkilic", "telek", "temiz",
        "temizel", "temizkalp", "tepecik", "tepsici", "tercan", "terlemez", "tertemiz", "tilki", "tokatci", "tombeki",
        "topatan", "topkapi", "tozkoparan", "tufancan", "tunali", "tuzcu", "tuztas", "ufukcu", "ugursuz", "ulakci",
        "uluocak", "umutsuz", "unalani", "unalmis", "unkapani", "uraz", "uslu", "uyar", "uzay", "uzunadam",
        "yagizeli", "yanardag", "yanardoner", "yangin", "yaracan", "yaradan", "yarama", "yasayavas", "yasli", "yasmek",
        "yavas", "yayasan", "yaygara", "yelden", "yeldirme", "yersiz", "yikilmaz", "yildirim", "yilgin", "yilmaz",
        "yolyapan", "yorganci", "yorgun", "yosun", "yurdakul", "yurekli", "yurekyakan", "yurtsuz", "zaimoglu", "zalim",
        "zengin", "zebani",
    };
    
    return RANDOM_ELEM(p);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `person` modÃ¼lÃ¼nÃ¼ sÄ±namak iÃ§in yapÄ±lan iÅŸlemler incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"
#include "person.h"

int main(void)
{
    printf("sizeof(Person) = %zu\n", sizeof(Person)); 

    randomize();
    
    Person p;
    set_random_person(&p);
    print_person(&p);

}
```


> â” 
> 
> Sorulan soru;
> 
> Bu fonksiyonlari person struct'i icine koyma sansimiz var mi? direkt olmasa da adres olarak?
> 
> Cevap;
> 
> C dilinde bir yapÄ±nÄ±n Ã¼yesi bir fonksiyon olamaz. </br>
> Bir yapÄ±nÄ±n elemanÄ± bir fonksiyon gÃ¶stericisi olabilir ama sadece bunun gerekeceÄŸi durumlarda kullanÄ±lmalÄ±dÄ±r, diÄŸer durumlarda gereksiz yere yapÄ± nesnelerinin boyutu arttÄ±rÄ±lmÄ±ÅŸ olur.



***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.05-12.15 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***



ğŸ‘‡ AÅŸaÄŸÄ±daki program `nutility` modÃ¼lÃ¼ne eklenen `random_name` ve `random_surname` fonksiyonlarÄ±nÄ± sÄ±namak iÃ§in yapÄ±lmÄ±ÅŸtÄ±r.
```C
#include <stdio.h>
#include "nutility.h"
#include "person.h"

int main(void)
{
    randomize();

    for(int i = 0; i < 40; ++i){
        printf("%s %s\n", random_name(), random_name());
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program `set_radom_person` fonksiyonunu sÄ±namak iÃ§in yapÄ±lmÄ±ÅŸtÄ±r.
```C
#include <stdio.h>
#include "nutility.h"
#include "person.h"

int main(void)
{
    randomize();

    Person p;

    for(int i = 0; i < 40; ++i){
        set_radom_person(&p);
        print_person(&p);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda aÅŸaÄŸÄ±da listelenen iÅŸlemler yapÄ±lmÄ±ÅŸtÄ±r;
- 5 milyon elemanlÄ± bir person dizisi oluÅŸturun. 
- Dizinin elemanlarÄ±na rastgele deÄŸerler verin. 
- Diziyi kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe sÄ±ralayÄ±n(qsort).
- SÄ±ralama sÃ¼reci sonunda diziyi yazdÄ±rÄ±n.
- Dizinin belleÄŸini iade edin.
```C
#include <stdio.h>
#include "nutility.h"
#include "person.h"
#include <stdlib.h>
#include <time.h>


static int wpcmp(const void* vp1, const void* vp2)
{
    return cmp_person((const Person*)vp1, (const Person*)vp2);
}

void set_person_array(const Person* pa, size_t size)
{
    Person* pret = pa;

    while(size--)
        set_random_person(pa++);

    return pret;
}

void print_person_array(const Person* pa, size_t size)
{
    while(size--)
        print_person(pa++);
}

int main(void)
{
    const int array_size = 1'000'000;

    Person* pd = (Person*)malloc(array_size * sizeof(Person));
    if(!pd){
        printf("bellek yetersiz.\n");
        return 1;
    }

    set_person_array(pd, array_size); 

    primtf("siralama basladi.\n");
    clock_t start = clock();
    qsort(pd, array_size, sizeof(Person), &wpcmp);
    printf("siralama bitti %f saniye\n", (double)(clock - start) / CLOCK_PER_SEC);
    (void)getchar(); // programÄ± burada durdurmak iÃ§in kullanÄ±ldÄ±.

    print_person_array(pd, array_size);
}
```



ğŸ“Œ `CLOCK_PER_SEC` standart `time` modÃ¼lÃ¼nde bir makrodur, `CLK_TCK` ise Unix tÃ¼revi iÅŸletim sistemlerinde standart olan bir Ã¶ÄŸedir, bir Ã§ok derleyici `CLK_TCK` makrosunu da vermektedir, `CLK_TCK` makrosu Ã§oÄŸu zaman `CLOCK_PER_SEC` makrosuna denktir.


ğŸ“Œ `Person` adÄ±ndaki modÃ¼lÃ¼mÃ¼zÃ¼ **composition** kullanÄ±mÄ±nÄ± anlamak iÃ§in yazdÄ±k.


## Linklist Data Structure(BaÄŸlÄ± Listeler Veri YapÄ±sÄ±) 

ğŸ“Œ Kaliteli bir mÃ¼latata girildiÄŸinde hangi programlama dili olursa olsun, programlamayla ilgili sorulardan baÄŸlÄ± listelere iliÅŸkin bir ya da birkaÃ§ tane soru sorulur.


**Linked List(BaÄŸlÄ± liste)**: Bu veri yapÄ±sÄ± dinamik dizilerden daha az kullanÄ±lmakla birlikte kullanÄ±lmasÄ± gereken bir Ã§ok yer olduÄŸu gÃ¶rÃ¼lecektir.

Linked ÅŸist(baÄŸlÄ± liste) Ã§eÅŸitleri aÅŸaÄŸÄ±daki gibidir;
- **Signly Linked List(Tekli BaÄŸlÄ± Liste)**
- **Doubly Linked List(Ã‡ifte BaÄŸlÄ± Liste)**
- **Rotating Linked List(dairesel baÄŸlÄ± liste)** ya da **Circular Linked List(dairesel baÄŸlÄ± liste)**



ğŸ‘‡ AÅŸaÄŸÄ±daki sÃ¶zde kodda bir baÄŸlÄ± liste veri yapÄ±sÄ±nÄ±n nasÄ±l gezileceÄŸi incelenebilir.
```bash

Node* pfirt = ilk_dugum_adresi;

for(Node* p = pfirt; p != NULL; p = p->pnext){
    p->data;
}
```



Bir veri yapÄ±sÄ±nÄ± dolaÅŸmak, gezmek, eleman eleman gezmek anlamÄ±na gelen aÅŸaÄŸÄ±daki terimleri bilmelisin;
- **Traverse** fiilinin ad hali **Traversal**
- **Navigate** 
- **Itarete**
- Bir dinamik diziyi dolaÅŸÄ±yorsak **dinamik array treversal** olarak niteleriz.
- Bir baÄŸlÄ± listeyi dolaÅŸÄ±yorsak **linked-list treversal** olarak niteleriz.


ğŸ‘‡ AÅŸaÄŸÄ±daki program **Signly Linked List(Tekli BaÄŸlÄ± Liste)** ve **Doubly Linked List(Ã‡ifte BaÄŸlÄ± Liste)** 
```C
typedef struct Node{
    int data;
    struct Node* pnext;
};

typedef struct Node{
    int data;
    struct Node* pnext;
    struct Node* pprev;
};
```


Veri yapÄ±larÄ± ve algoritmalar konusuyla ilgili olarak bir mÃ¼lakatta sorulabilecek en temel sorulardan biri, **dynamic array(dinamik dizi)** ve **linked list(baÄŸlÄ± liste)** veri yapÄ±larÄ± arasÄ±ndaki farkÄ±n ne olduÄŸudur.

ğŸ§­ 1000 tane tam sayÄ±(`int`) daÄŸeri aÅŸaÄŸÄ±daki veri yapÄ±larÄ±nda tutulduÄŸunda ne gibi bir farklÄ±lÄ±k olacaÄŸÄ± aÅŸaÄŸÄ±dan incelenebilir;
1. Bir dinamik dizide;
    - `sizeof(int) * 1000` kadarlÄ±k bellek alanÄ± kaplayacaktÄ±r.
    - Eleman ekleme ve silme iÅŸleminde sÃ¼rekli bellekten yer alÄ±nÄ±p iade edilmesi gerekmemektedir, sadece dizi bÃ¼yÃ¼klÃ¼ÄŸÃ¼ deÄŸiÅŸtiÄŸinde dinamik bellek yÃ¶netimi yapÄ±lacaktÄ±r.
2. Bir tekli baÄŸlÄ± listede;
    - En az `(sizeof(int) * sizeof(pointer)) * 1000` kadarlÄ±k bellek alanÄ± kaplayacaktÄ±r.
    - Eleman ekleme ve silme iÅŸleminde sÃ¼rekli bellekten yer alÄ±nÄ±p iade edilmesi gereken bir veri yapÄ±sÄ±dÄ±r.
3. Bir Ã§ift baÄŸlÄ± listede;
    - En az `(sizeof(int) * (sizeof(pointer) * 2)) * 1000` kadarlÄ±k bellek alanÄ± kaplayacaktÄ±r.
    - Eleman ekleme ve silme iÅŸleminde sÃ¼rekli bellekten yer alÄ±nÄ±p iade edilmesi gereken bir veri yapÄ±sÄ±dÄ±r.


Ders sonu ...
