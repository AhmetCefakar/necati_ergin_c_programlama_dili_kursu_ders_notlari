# 23.Ders 05.04.2025 ğŸ•˜

Derse 13(09:01)-16(09:38)-17(10:03)-18(10:52)-17(11:11)-18(12:10) kiÅŸi katÄ±ldÄ±.
---


## Arrays(Diziler) Devam


ğŸ‘‡ AÅŸaÄŸÄ±daki programdan bir tam sayÄ± dizisinin nasÄ±l tanÄ±mlandÄ±ÄŸÄ± ve elemanlarÄ±nÄ±n yazdÄ±rÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int ary[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 };

    for(int i = 0; i < asize(ary); ++i){
        printf("%d ", ary[i]);
    }
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programdan en sade haliyle for dÃ¶ngÃ¼sÃ¼yle bir dizinin elemanlarÄ±nÄ±n deÄŸerini sÄ±ralÄ± olarak atama ve dizinin elemanlarÄ±nÄ± yazdÄ±rma iÅŸlemi incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

#define SIZE 30

int main(void)
{
    int a[SIZE];

    for(int i = 0; i < SIZE; ++i){
        a[i] = i;
    }

    for(int i = 0; i < SIZE; ++i){
        printf("%d ", a[i]);
    }
}
```



âœï¸ Dizilerle ilgili Ã§ok kullanacaÄŸÄ±mÄ±z bazÄ± iÅŸlemleri fonksiyon olarak **nutility** dosyalarÄ±mÄ±za yazacaÄŸÄ±z, bu fonksiyonlarda pointer kullanacaÄŸÄ±z, sonraki hafta pointer konusuna geÃ§ilince bu kullanÄ±mlar anlaÅŸÄ±labilir olacaktÄ±r.
```c
// 'nutility.h' dosyasÄ±na aÅŸaÄŸÄ±daki 'fuction decleration' eklemelerini yapÄ±yoruz.

void print_array(const int* p, int size);
void set_array_random(int* p, int size);
```

```c
// 'nutility.c' dosyasÄ±na aÅŸaÄŸÄ±daki 'fuction definition' eklemelerini yapÄ±yoruz.

#include <stdlib.h> // bu baslik dosyasini 'rand' fonksiyonunu kullanabilmek icin ekliyoruz.

// p    : Yazdirilaca olan dizinin ilk elemaninin adresi.
// size : Yazdirilaca olan dizinin eleman sayisi.
void print_array(const int* p, int size)
{
    for(int i = 0; i < size; ++i){
        // dongu degiskeni 0 degilse ve 20'nin kati olan dongu adimindaysa yeni satirdan devam edilsin diye 'if statement' yazildi.
        if(i && i % 20 == 0){
            printf("\n");
        }

        // dizinin ilgili adimdaki elemani uc birimlik alana formatli yazdirilacak.
        printf("%3d ", p[i]);
    }
    
    printf("\n---------------------------------------------------------\n");
}

// p    : Elemanlarina deger atanacak olan dizinin ilk elemaninin adresi.
// size : Elemanlarina deger atanacak olan dizinin eleman sayisi.
void set_array_random(int* p, int size)
{
    for(int i = 0; i < size; ++i){
        p[i] = rand() % 1000;
    }
}
```


ğŸ‘‡ YukarÄ±da yazÄ±lmÄ±ÅŸ olan bir dizi oluÅŸturma ve o diziyi yazdÄ±rma iÅŸlemlerinin "nutility" dosyalarÄ±na eklenen fonksiyonlar yardÄ±mÄ±yla aynÄ± programÄ±n nasÄ±l yazÄ±labileceÄŸi gÃ¶rÃ¼lebilir. 
```C
#include <stdio.h>
#include "nutility.h"

#define SIZE 30

int main(void)
{
    int a[SIZE];

    set_array_random(a, SIZE);
    print_array(a, SIZE);
}
```

## Random Number Generation (Rastgele SayÄ± Ãœretimi) 

Rastgele SayÄ± Ãœretimi matematikle ilgili olan bir konudur ve tÃ¼m programlama dillerinde Ã¶nemli kullanÄ±mÄ± olan bir konudur. 

Rastgelelik Ã¶ngÃ¶rÃ¼lemezlikle iliÅŸkilidir, ne kadar Ã¶ngÃ¶rÃ¼lemez sayÄ± Ã¼retiliyorsa o kadar rastgele sayÄ± Ã¼retilecektir denilebilir.

ğŸ§­ Ä°ki tÃ¼rlÃ¼ rastgele sayÄ± Ã¼retim yÃ¶ntemi vardÄ±r, bunlar;
1. **True Random Number Generation(GerÃ§ek Rastgele SayÄ± Ãœretimi)**: DoÄŸadaki bazÄ± olaylardan yararlanÄ±larak Ã¼retilen rastgele sayÄ±lardÄ±r, mesela atmosferdeki gÃ¼rÃ¼ltÃ¼den yararlanÄ±larak Ã¼retilen rastgele sayÄ±lar.
2. **Pseudo Random Number Generation(SÃ¶zde Rastgele SayÄ± Ãœretimi)**: Bir algoritma kullanÄ±larak Ã¼retilen **deterministic** rastgele sayÄ±lardÄ±r. 
    - â—**Deterministic** yÃ¶ntemle Ã¼retilen rastgele sayÄ±lar verilen ilk deÄŸere baÄŸlÄ±dÄ±r, ilk deÄŸer aynÄ± olduÄŸu sÃ¼rece aynÄ± sÄ±raya gÃ¶re restgele sayÄ±lar Ã¼retilecektir.
    - â—Rastgele sayÄ±larÄ± oluÅŸturmak iÃ§in verilen ilk deÄŸere **tohum deÄŸeri(seed value)** deniliyor. 
    - â—Ratgele sayÄ± Ã¼retimi iÃ§in kullanÄ±lan algoritma ne olursa olsun **deterministic** yÃ¶ntemle Ã¼retilen rastgele sayÄ±lar belirli bir noktadan sonra tekrar edecektir bu â—tekrar etme durumuna da **frekans** denilmektedir.
    - â—Ratgele sayÄ± Ã¼retimi iÃ§in kullanÄ±lan algoritmanÄ±n Ã¼reteceÄŸi sayÄ±larÄ±n birbirini tekrar etme sÄ±klÄ±ÄŸÄ±(**frekans**) Ã§ok bÃ¼yÃ¼k olabilir ya da nispeten kÃ¼Ã§Ã¼k olabilir.
    - Mesela ratgele sayÄ± Ã¼retimi iÃ§in kullanÄ±lan algoritmanÄ±n **frekans** deÄŸeri 1 milyon ise bu noktadan itibaren tekrara dÃ¼ÅŸecektir.


**Ãœretilen rastgele sayÄ± zinciri**: Algoritmada kullanÄ±lan bir deÄŸer vardÄ±r bu deÄŸere **tohum deÄŸeri(seed value)** deniliyor. KullanÄ±lan algoritma iÃ§in verilen **tohum deÄŸerine(seed value)** gÃ¶re oluÅŸturulacak olan **rastgele sayÄ± zinciri** zaten her zaman aynÄ± olacaktÄ±r. 

### Rastgele SayÄ± Ãœretimi Nerelerde KullanÄ±lÄ±r 

**Pseudo Random Number Generation(SÃ¶zde Rastgele SayÄ± Ãœretimi)** aÅŸaÄŸÄ±daki alanlarda kullanÄ±labilir;
- SimÃ¼lasyon programlarÄ±nda
- Oyun programlarÄ±nda
- BazÄ± algoritmalarÄ±n implemantasyonunda(Genetik algoritmalar vb.)
- Kriptoloji alanÄ±nda
- Algoritmic Trading alanÄ±nda


âš ï¸ C++ dilinin standart kÃ¼tÃ¼phanesinde rastgele sayÄ± Ã¼retimi iÃ§in "**random**" kÃ¼tÃ¼phenesi vardÄ±r ve bu kÃ¼tÃ¼phane profesyonel Ã¼retimlerde kullanÄ±labilecek seviyededir.

âš ï¸ C dilinde rastgele sayÄ± Ã¼retimi iÃ§in C dilinin standart kÃ¼tÃ¼phanesindeki destek Ã§ok kÄ±sÄ±tlÄ±dÄ±r ve C standardÄ± kendilerinin saÄŸladÄ±ÄŸÄ± rastgele sayÄ± Ã¼retimi araÃ§larÄ±nÄ± profesyonel programlarda kullanÄ±lmamasÄ± gerektiÄŸini belirtir, standart kÃ¼tÃ¼phane yerine Ã¼Ã§Ã¼ncÃ¼ taraflarÄ±n saÄŸladÄ±ÄŸÄ± profesyonel seviyedeki rastgele sayÄ± Ã¼retimi kÃ¼tÃ¼pheneleri kullanÄ±lmalÄ±dÄ±r.

ğŸ§  21. yÃ¼zyÄ±lÄ±n ilk yarÄ±sÄ±nda profesyonel programlarda rastgele sayÄ± Ã¼retimi iÃ§in en Ã§ok "**Mersenne-Twister Algorithim**" algoritmasÄ± kullanÄ±lÄ±yor ama bunun dÄ±ÅŸÄ±nda da kullanÄ±lan baÅŸka algoritmalar vardÄ±r.


â—â—â— Rastgele sayÄ± Ã¼retimi ile Ã¼retilen rastgele sayÄ±larÄ±n belirli bir modele gÃ¶re daÄŸÄ±tÄ±lmasÄ± gerekecektir bu iÅŸlem rast gele sayÄ± Ã¼retiminden tamamen ayrÄ± bir sÃ¼reÃ§tir, elde edilen rastgele sayÄ± iÅŸlenerek kullanÄ±lmak istenilen tam sayÄ± ya da ondalÄ±klÄ± sayÄ± aralÄ±ÄŸÄ±na alÄ±nmasÄ± iÅŸlemi yapÄ±lmasÄ± gerekecektir iÅŸte bu iÅŸleme **distribution** denilmektedir.


**Uniform distribution(DaÄŸÄ±lÄ±m)**: Bir algoritmadaki Ã¼retilmesi gereken sarstgele sayÄ±larÄ±n belirli bir aralÄ±kta olmasÄ± gerekiyor olabilir, mesela zarla oynanan bir oyunda rastgele sayÄ±larÄ±n 1-6 arasÄ±nda olmasÄ± gerekiyor bu durumda kullanÄ±lan rastgele sayÄ± Ã¼retimi algoritmesÄ±ndan elde edilen sayÄ±nÄ±n baÅŸka bir algoritmayla rastgele sayÄ±nÄ±n 1-6 arasÄ±nda eÅŸit aÄŸÄ±rlÄ±kta rastgele olmasÄ± iÃ§in iÅŸlem yapÄ±lmasÄ± gerekiyor, bu iÅŸleme rastgele sayÄ±larÄ±n daÄŸÄ±lÄ±mÄ±nÄ±n belirlenmesi iÅŸlemi denilmektedir.

**Gauss distribution(Normal DaÄŸÄ±lÄ±m)**: Ã‡an eÄŸrisi ÅŸeklinde olan daÄŸÄ±lÄ±m modelidir. Not deÄŸerleri, insanlarÄ±n kilolarÄ±nÄ±n deÄŸerleri vb. deÄŸerler Ã§an eÄŸrisine gÃ¶re daÄŸÄ±lÄ±r, bu veriler iÃ§in Ã¼retilecek olan raskgele sayÄ±larÄ±n 

ğŸ§  C++ dilinin standart kÃ¼tÃ¼phanesinde yirmiye yakÄ±n daÄŸÄ±lÄ±m modeli(**Ki-Kare**, **bernoulli distribution**) algoritmasÄ± sunulmaktadÄ±r.

â— SÃ¶zde rastgele sayÄ± Ã¼retimi yaklaÅŸÄ±mlarÄ±nda ilk Ã¶nce rastgele sayÄ± Ã¼retimi iÃ§in kullanÄ±lacak algoritma belirlenir ardÄ±ndan Ã¼retilecek olan rastgele sayÄ±nÄ±n olmasÄ± istenilen aralÄ±ÄŸa indirgerken kullanÄ±lacak olan model belirlenir.

âš ï¸ Kriptoloji alanÄ±nda kullanÄ±lacak olan rastgele sayÄ± Ã¼retim iÃ§in C++ dilinin kendi standart kÃ¼tÃ¼phenesindeki araÃ§lar kullanÄ±lmamasÄ± gereki.

Ä°ÅŸletim sistemlerinin donanÄ±mÄ±n saÄŸlayabileceÄŸi bazÄ± veriler ile yazÄ±lÄ±mlar beslenerek daha kaliteli ve Ã¶ngÃ¶rÃ¼lemez ÅŸekilde rastgele sayÄ± Ã¼retimi saÄŸlanabilir, mesela programÄ±n Ã¼zerinde Ã§alÄ±ÅŸtÄ±ÄŸÄ± cihazÄ±n sÄ±caklÄ±k deÄŸerleri, ram ya da sabit disc'in kullanÄ±mÄ±yla ilgili metrikler kullanÄ±larak bu saÄŸlanabilir ama bunlar bu eÄŸitimin kapsamÄ±nda olmayan ayrÄ± detaylÄ± konulardÄ±r.

### C Dilindeki Rastgele SayÄ± Ãœretimiyle Ä°lgili Fonksiyonlar 

`stdlib.h` baÅŸlÄ±k dosyasÄ±ndaki `rand` ve `srand` fonksiyonlarÄ± standart kÃ¼tÃ¼phenenin rastgele sayÄ± Ã¼retimi iÃ§in saÄŸladÄ±ÄŸÄ± araÃ§lardÄ±r.
- `int rand(void);`: Bu fonksiyon rastgele sayÄ± Ã¼retimi iÃ§in kullanÄ±lan standart C fonksiyonudur. Bu fonksiyonda Ã¼retilebilecek en kÃ¼Ã§Ã¼k deÄŸer `0` ama Ã¼retilebilecek en bÃ¼yÃ¼k sayÄ± `RAND_MAX` adÄ±nda bir makro'dur, `RAND_MAX` makrosunun deÄŸerinin ne olacaÄŸÄ±nÄ±n kararÄ± derleyiciye bÄ±rakÄ±lmÄ±ÅŸtÄ±r. Bu fonksiyondaki daÄŸÄ±lÄ±m **uniform distribution** olacaÄŸÄ± standart tarafÄ±ndan belirlenmiÅŸtir. Bu fonksiyonun standardÄ±n belirlediÄŸi **tohum deÄŸeri(seed value)** "1" rakamÄ±dÄ±r.
- `void srand(unsigned int);`: Bu fonksiyon rastgele sayÄ± Ã¼retimi iÃ§in kullanÄ±lan `rand` fonksiyonun tohum deÄŸerini belirlemek iÃ§in kullanÄ±lmaktadÄ±r, 



ğŸ‘‡ AÅŸaÄŸÄ±daki program `rand` fonksiyonunun varsayÄ±lan deÄŸer "1" **tohum deÄŸeriyle(seed value)** Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda nasÄ±l sonuÃ§lar elde edildiÄŸini anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"
#include <stdlib.h>

int main(void)
{
    for(int i = 0; i < 10; ++i){
        printf("%d\n", rand());
    }

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼de Ã¼retilen rastgele sayÄ±larÄ±n ilk on tanesi yukarÄ±daki dÃ¶ngÃ¼de elde edilen on tane deÄŸer ile aynÄ± olacaktÄ±r, burayÄ± anlamak Ã¶nemlidir. 
    for(int i = 0; i < 20; ++i){
        printf("%d\n", rand());
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda aynÄ± **tohum deÄŸeriyle(seed value)** ne kadar Ã§alÄ±ÅŸtÄ±rÄ±lÄ±rsa Ã§alÄ±ÅŸtÄ±rÄ±lsÄ±n her seferinde Ã¼retilecek olan `100'000`. sayÄ± aynÄ± olacaktÄ±r.
```C
#include <stdio.h>
#include "nutility.h"
#include <stdlib.h>

int main(void)
{
    // Seed-value = 1
    for(int i = 0; i < 100000 - 1; ++i){
        rand();
    }

    printf("%d\n", rand()); // Burada 100'000. rastgele sayÄ± yazdÄ±rÄ±lacaktÄ±r ve bu sayÄ± program her Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda aynÄ± olacaktÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `rand` fonksiyonuyla Ã¼retilecek rastgele sayÄ±larÄ±n **rastgele sayÄ± zincirini** deÄŸiÅŸtirmek iÃ§in **tohum deÄŸerinin(seed value)** `srand` fonksiyonuyla deÄŸiÅŸtirilebileceÄŸi gÃ¶rÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <stdlib.h>

int main(void)
{
    srand(184950); // Burada tohum deÄŸeri '184950' olarak belirleniyor.
    for(int i = 0; i < 10; ++i){
        printf("%d\n", rand());
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program **deterministic** yÃ¶ntemle Ã¼retilen rastgele sayÄ±larÄ±n **tohum deÄŸerine(seed value)** gÃ¶re hangi ÅŸekilde Ã¼retildiÄŸi incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <stdlib.h>

void print_random_numbers(unsigned int seed_value)
{
    srand(seed_value);

    for(int i = 0; i < 1000; ++i){
        rand();
    }

    for(int i = 0; i < 10; ++i){
        printf("%d ", rand());
    }

    printf("\n"); 
}

int main(void)
{
    // AÅŸaÄŸÄ±da aynÄ± deÄŸer ile fonksiyon Ã§aÄŸÄ±rÄ±lÄ±yor ve bu isteklerden sonra iki defa aynÄ± 'rastgele sayÄ± zinciri' ile sayÄ±larÄ±n Ã¼retildiÄŸi gÃ¶rÃ¼lecektir.
    print_random_numbers(651u);
    print_random_numbers(651u);

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile rastgele sayÄ± Ã¼retecek fonksiyona tohum deÄŸeri farklÄ± gÃ¶nderildiÄŸi iÃ§in her seferinde farklÄ± 'rastgele sayÄ± zinciri' Ã¼retilecektir.
    for(int i = 0; i < 100; ++i){
        print_random_numbers(i + 10);
    }
}
```


âš ï¸ Ãœretim ortamÄ±nda asla `%` operatÃ¶rÃ¼ **uniform daÄŸÄ±lÄ±mÄ±** saÄŸlamak iÃ§in kullanÄ±lmamalÄ±dÄ±r Ã§Ã¼nkÃ¼ bu ÅŸekilde ideal olarak **uniform daÄŸÄ±lÄ±m** saÄŸlanamaz ama kursttaki programlarda kolaylÄ±k saÄŸladÄ±ÄŸÄ± iÃ§in kullanÄ±lacaktÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki program rastgele tavla zarÄ± deÄŸeri elde etme iÅŸleminin nasÄ±l yapÄ±lacaÄŸÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <stdlib.h>
#include <conio.h> // Bu kÃ¼tÃ¼phane standart kÃ¼tÃ¼phene deÄŸildir ve "_getch()" fonksiyonunu kullanmak iÃ§in eklenmiÅŸtir. 

#define SIZE 100

int main(void)
{
    while(1){
        printf("%d ", rand() % 6 + 1);
        _getch();
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program rastgele ÅŸekilde belirli bir yÄ±l aralÄ±ÄŸÄ±nÄ±n belirlenmesi iÅŸleminin nasÄ±l yazÄ±labileceÄŸini anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <stdlib.h>
#include <conio.h> // Bu kÃ¼tÃ¼phane standart kÃ¼tÃ¼phene deÄŸildir ve "_getch()" fonksiyonunu kullanmak iÃ§in eklenmiÅŸtir. 

#define YEAR_MIN 2010
#define YEAR_MAX 2040

int main(void)
{
    while(1){
        printf("%d ", rand() % (YEAR_MAX - YEAR_MIN + 1) + YEAR_MIN);
        _getch();
    }
}
```


â— AynÄ± **tohum deÄŸeri(seed value)** iÃ§in aynÄ± sayÄ± zincirinin Ã¼retiliyor olmasÄ± bazen bu iÅŸimize gelen ama bazen de iÅŸimize gelmeyen bir durumdur, mesela oyunlarda gerekli olan rastgele sayÄ±lar elde edebilmek iÃ§in bu istenilen bir durum deÄŸildir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda rastgele sayÄ± Ã¼retimi tohum deÄŸeri hep aynÄ± olduÄŸu iÃ§in Ã§ok ta rastgele olmayacaÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <stdlib.h>
#include <conio.h> // Bu kÃ¼tÃ¼phane standart kÃ¼tÃ¼phene deÄŸildir ve "_getch()" fonksiyonunu kullanmak iÃ§in eklenmiÅŸtir. 

int main(void)
{
    for(int i = 0; i < 10; ++i){
        int dice1 = rand() % 6 + 1;
        int dice2 = rand() % 6 + 1;

        printf("%d %d\n", dice1, dice2);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda zamandan faydalanarak rastgele sayÄ± Ã¼retimi iÃ§in nasÄ±l iÅŸlem yapÄ±labileceÄŸi gÃ¶rÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <stdlib.h>
#include <conio.h> // Bu kÃ¼tÃ¼phane standart kÃ¼tÃ¼phene deÄŸildir ve "_getch()" fonksiyonunu kullanmak iÃ§in eklenmiÅŸtir. 
#include <time.h> // Kursun ikinci yarÄ±sÄ±nda bu standart baÅŸlÄ±k dosyasÄ± ve fonksiyonlarÄ± incelenecektir.

time_t time(time_t* p); // 'time.h' baÅŸlÄ±k dosyasÄ±nda 'time(time_t* p)' fonksiyonu Microsoft derleyicisinde '01 01 1970 00:00:00' tarihinden itibaren geÃ§en saniye deÄŸerini geriye dÃ¶nmektedir, her derleyici iÃ§in 'time' fonksiyonunun gerÃ§ekleÅŸtirimi standardÄ±n izin verdiÄŸi kadar farklÄ± olabilir.

int main(void)
{
    printf("%lld", time(NULL));

    srand(time(NULL)); // Burada Ã¶rtÃ¼lÃ¼ olarak 'long long int' tÃ¼rÃ¼nden 'unsigned int' tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸÃ¼m yapÄ±lÄ±yor, burada ana akÄ±m derleyiciler uyarÄ± verecektir.
    //srand((unsigned int)time(NULL)); // Burada tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ deÄŸeriyle 'long long' tÃ¼rÃ¼nden 'unsigned int' tÃ¼rÃ¼ne bilinÃ§li tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapÄ±ldÄ±ÄŸÄ± belirtiliyor.
    //srand((unsigned int)time(0)); // Burada 'NULL' kullanmak ile '0' kullanmak aynÄ± anlama gelmektedir.

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼de Ã¼retilen rastgele deÄŸerler program her Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda farklÄ± olacaktÄ±r.
    for(int i = 0; i < 10; ++i){
        printf("%d ", rand());
    }
}
```



âœï¸ Rastgele sayÄ± Ã¼retimiyle ilgili Ã§ok kullanacaÄŸÄ±mÄ±z `randomize` adlÄ± fonksiyonu "nutility" dosyalarÄ±mÄ±za ekleyelim.
```c
// 'nutility.h' dosyasÄ±na aÅŸaÄŸÄ±daki 'fuction decleration' eklemelerini yapÄ±yoruz.

void randomize(void);
```

```c
// 'nutility.c' dosyasÄ±na aÅŸaÄŸÄ±daki 'fuction definition' eklemelerini yapÄ±yoruz.

#include <time.h> // bu baslik dosyasini 'time' fonksiyonunu kullanabilmek icin ekliyoruz.

// 'rand' fonksiyonunun tohum deÄŸerini sistemin saat bilgisine gÃ¶re deÄŸiÅŸtirmek iÃ§in yazÄ±lan fonksiyon
void randomize(void)
{
    srand((unsigned int)time(NULL));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "nutility" dosyasÄ±ndaki `randomize` fonksiyonu nasÄ±l kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <stdlib.h>
#include <conio.h>

int main(void)
{
    randomize(); // 'rand' fonksiyonunun tohum deÄŸerini deÄŸiÅŸtirmek iÃ§in Ã§aÄŸrÄ± yapÄ±lan fonksiyon.
    for(int i = 0; i < 10; ++i){
        printf("%d ", rand());
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "nutility" dosyasÄ±ndaki fonksiyonlarÄ± kullanarak oluÅŸturulan dizilerin nasÄ±l rastgele sayÄ± deÄŸerleriyle doldurulacaÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <stdlib.h>
#include <conio.h>

#define SIZE 100

int main(void)
{
    int a[SIZE];

    randomize(); // 'rand' fonksiyonunun tohum deÄŸerini deÄŸiÅŸtirmek iÃ§in Ã§aÄŸrÄ± yapÄ±lan fonksiyon.
    set_array_random(a, SIZE);
    print_array(a, SIZE);
}
```



Elimizde kaliteli bir rastgele sayÄ± Ã¼reticisi varsa ve eilimizde kaliteli bir rastgele daÄŸÄ±lÄ±m kodu var ise karmaÅŸÄ±k olasÄ±lÄ±k problemleri iÃ§in matematiksel Ã§Ã¶zÃ¼m oluÅŸturmak yerine **Monte Carlo Simulation** ile olasÄ±lÄ±k deÄŸerini rastgele sayÄ± Ã¼retiminden faydalanarak bulabiliriz.



ğŸ‘‡ AÅŸaÄŸÄ±daki program yazÄ± tura atma iÅŸlemini simÃ¼le etmek iÃ§in yazÄ±lmÄ±ÅŸtÄ±r, burada `%` ile **uniform distribution** saÄŸlanmaya Ã§alÄ±ÅŸÄ±lmÄ±ÅŸtÄ±r ama prodesyonel kodlarda bu ÅŸekilde iÅŸlem yapÄ±lmamalÄ±dÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <stdlib.h>
#include <conio.h>

#define HEADS 1
#define NUMBER_OF_TOSS 20000

int main(void)
{
    int head_count = 0;

    for(int i = 0; i < NUMBER_OF_TOSS; ++i){
        if(rand() % 2 ==  HEADS)
            ++head_count;
    }

    double prob = (double)head_count / NUMBER_OF_TOSS;

    pritf("prop = %f\n", prob);
}
```



ğŸ§  Pi sayÄ±sÄ±nÄ± hesaplamak iÃ§in **Monte Carlo Simulation** kullanalÄ±m ile ÅŸu ÅŸekilde: Bir birim kare iÃ§ine Ã§izilen Ã§eyrek Ã§ember ile bu karenin iÃ§indeki alana rastgele noktalar eklenerek Ã§eyrek dairedeki noktalarÄ±n tÃ¼m karedeki sayÄ±lara oranÄ±nÄ± alarak "pi / 4" sayÄ±sÄ±na yakÄ±nsanacak ÅŸekilde limit iÅŸlemi yapÄ±labilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir birim kare iÃ§ine Ã§izilen Ã§eyrek Ã§ember ile bu karenin iÃ§indeki alana rastgele noktalar eklenerek Ã§eyrek dairedeki noktalarÄ±n tÃ¼m karedeki sayÄ±lara oranÄ±nÄ± alarak "pi / 4" sayÄ±sÄ±na yakÄ±nsanacak ÅŸekilde limit iÅŸlemi yapÄ±lmÄ±ÅŸ olacaktÄ±r. AÅŸaÄŸÄ±daki programda rastgele sayÄ± Ã¼retimi iÃ§in kullanÄ±lan ilkel bir fonksiyon ile nasÄ±l pi sayÄ±sÄ±nÄ±n hesaplandÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <stdlib.h>
#include <conio.h>

#define NUMBER_OF_POINTS 2000

// AÅŸaÄŸÄ±daki fonksiyon 0-1 aralÄ±ÄŸÄ±nda rastgele sayÄ± Ã¼retmenin en ilkel yoludur, Ã¼retimde kullanÄ±lmamalÄ±dÄ±r.
double get_random_cordinate(void)
{
    // Buradaki 'RAND_MAX' makrosu kullanÄ±lan derleyiciye gÃ¶re farklÄ± tam sayÄ± deÄŸer almaktadÄ±r.
    return (double)rand() / RAND_MAX;
}

int main(void)
{
    int inside_count = 0;

    for(int i = 0; i < NUMBER_OF_POINTS; ++i){
        double x = get_random_cordinate();
        double y = get_random_cordinate();

        if(x * x + y * y <= 1.)
            ++inside_count;
    }

    pritf("pi = %.12f\n", 4. * inside_count / NUMBER_OF_POINTS);
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.52-11.11 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


ğŸ§­ Programlama mÃ¼lakatlarÄ±nda da sorulan, **Monte Carlo Simulation** kullanÄ±larak basit bir kumar oyunu olan "**Craps Casino Game**" programÄ±nÄ± yazalÄ±m, oyun ÅŸu ÅŸekildedir;
- ğŸ² Oyuncu iki zar atacak ve aÅŸaÄŸÄ±daki durumlarda kacanma kaybetme durumlarÄ± gerÃ§ekleÅŸecek.
- Ä°lk zar attÄ±ÄŸÄ±nda iki zarÄ±n toplam deÄŸeri "7 - 11" gelirse oyuncu kazanÄ±r.
- Ä°lk zar attÄ±ÄŸÄ±nda iki zarÄ±n toplam deÄŸeri "2 - 3 - 12" gelirse oyuncu kaybeder
- 4 - 5 - 6 - 8 - 9 - 10 sayÄ±larÄ± gelince aynÄ± sayÄ± toplamÄ±nÄ± atarsa kazanÄ±r ama iki zarÄ±n toplamÄ± 7 gelirse kaybeder.
- Oyuncunun kazandÄ±ÄŸÄ± bir oyun ÅŸu ÅŸekildedir: 8 9 11 3 4 11 8
- Oyuncunun kaybettiÄŸi bir oyun ÅŸu ÅŸekildedir: 6 2 11 5 4 9 12 7


âš ï¸ Bu oyunda oyuncunun oyunu kazanma olasÄ±lÄ±ÄŸÄ± nedir diye sorulsa bu olasÄ±lÄ±ÄŸÄ± hesaplamak kaÄŸÄ±t kalem ile biraz zor olacaktÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **Craps Casino Game** oyununun C diliyle nasÄ±l yazÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <stdlib.h>
#include <conio.h>

#define NUMBER_OF_GAMES 100'000

// Bu fonksiyon bir oyuncunun atacaÄŸÄ± iki zarÄ±n toplamÄ±nÄ± dÃ¶necektir
double roll_dice(void)
{
    //return rand() % 11 + 2; // Buradaki gibi yazÄ±lmamalÄ±dÄ±r, cÃ¼nkÃ¼ bu durumda tÃ¼m sayÄ± deÄŸerlerinin gelme olasÄ±lÄ±ÄŸÄ± aynÄ± olacaktÄ±r ama iki zar olduÄŸu iÃ§in iki zarÄ±n ne geleceÄŸinin ayrÄ± ayrÄ± hesaplanmasÄ± gerekir.

    int dice1 = rand() % 6 + 1; // Burada 'uniform daÄŸÄ±lÄ±m' iÃ§in standart C kÃ¼tÃ¼phanesinin 'rand' fonksiyonu kullanÄ±ldÄ± ama bu kullanÄ±m Ã§ok kaliteli deÄŸildir.
    int dice2 = rand() % 6 + 1;

    return dice1 + dice2;
}

int game_(int dice)
{
    // AÅŸaÄŸÄ±daki sonsÃ¼z dÃ¶ngÃ¼ 'while(1)' kullanÄ±larak ta yazÄ±labilir.
    for(;;){
        int new_dice = roll_dice();

        if(new_dice == dice)
            return 1;
        
        if(new_dice == 7)
            return 0;
    }
}

// if return value is 1 => player wins
// if return value is 0 => player loses
// This function includes first game rouls.
int game(void)
{
    int dice = roll_dice();

    switch(dice){
        case 7:
        case 11: return 1;
        case 2:
        case 3:
        case 12: return 0;
        default: return game_(dice);
    }
}

int main(void)
{
    int win_count = 0;

    for(int i = 0; i < NUMBER_OF_GAMES; ++i){
        win_count += game();
    }

    pritf("oyuncunun kazanma olasiligi %f\n", (double)win_count / NUMBER_OF_GAMES);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **Craps Casino Game** oyununun C++ diliyle nasÄ±l yazÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <stdlib.h>
#include <conio.h>
#include <random> // C++ dilinin standart kÃ¼tÃ¼phenesinin rastgele sayÄ± Ã¼retimiyle ilgili kÃ¼tÃ¼phane dosyasÄ± ekleniyor

#define NUMBER_OF_GAMES 100'000

// Bu fonksiyon bir oyuncunun atacaÄŸÄ± iki zarÄ±n toplamÄ±nÄ± dÃ¶necektir
// C++ dilinin kaynaklarÄ±nÄ± kullanarak daha baÅŸarÄ±lÄ± 'uniform daÄŸÄ±lÄ±m' saÄŸlayan bir fonksiyon
double roll_dice(void)
{
    static std::mt19937 eng;
    std::uniform_int_distribution dist{ 1, 6 };

    int dice1 = dist(eng);// rand() % 6 + 1;
    int dice2 = dist(eng);// rand() % 6 + 1;

    return dice1 + dice2;
}

int game_(int dice)
{
    // AÅŸaÄŸÄ±daki sonsÃ¼z dÃ¶ngÃ¼ 'while(1)' kullanÄ±larak ta yazÄ±labilir.
    for(;;){
        int new_dice = roll_dice();

        if(new_dice == dice)
            return 1;
        
        if(new_dice == 7)
            return 0;
    }
}

// if return value is 1 => player wins
// if return value is 0 => player loses
// This function includes first game rouls.
int game(void)
{
    int dice = roll_dice();

    switch(dice){
        case 7:
        case 11: return 1;
        case 2:
        case 3:
        case 12: return 0;
        default: return game_(dice);
    }
}

int main(void)
{
    int win_count = 0;

    for(int i = 0; i < NUMBER_OF_GAMES; ++i){
        win_count += game();
    }

    pritf("oyuncunun kazanma olasiligi %f\n", (double)win_count / NUMBER_OF_GAMES);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program rastgele parola Ã¼reten bir fonksiyonun nasÄ±l yazÄ±labileceÄŸini anlamak iÃ§in incelenebilir. MÃ¼lakatlarda buna benzer programlarÄ±n yazÄ±lmasÄ± ve dÃ¶ngÃ¼ iÃ§inde rastgele sayÄ± Ã¼retiminde kullanÄ±lan tohum deÄŸerinin belirlenmesindeki durumun aÃ§Ä±klanmasÄ± istenebiliyor.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include "nutility.h"

#define MIN_LEN 5
#define MAX_LEN 9

int get_random_char(void)
{
    int ch;

    while(1){
        ch = rand() % 128;
        if(isalnum(ch)) // Buradaki ÅŸart ile 0-127 arasÄ±nda elde edilen sayÄ±nÄ±n 'alfanumeric' karakterine karÅŸÄ±lÄ±k geldiÄŸi durum iÃ§in dÃ¶ngÃ¼den Ã§Ä±kÄ±lacak.
            return ch;
    }

    return 0; // Bu statement sadece derleyici uyarÄ± vermesin diye yazÄ±lmÄ±ÅŸtÄ±r.
}

void print_random_password(void)
{
    int len = rand() % (MAX_LEN - MIN_LEN + 1) + MAX_LEN;

    for(int i = 0; i < len; ++i){
        putchar(get_random_char());
    }
    printf("\n");
}

int main(void)
{
    randomize(); // Bu fonksiyon burada bir defa Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ±ndan Ã¼retilen rastgele sayÄ± zincirinin elemanlarÄ± sÄ±rasÄ±yla 'rand()' fonksiyonunun Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ± anda kullanÄ±lacaktÄ±r.

    for(int i = 0; i < 20 ;++i){
        print_random_password();
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program rastgele parola Ã¼reten bir fonksiyonda kullanÄ±lan bizim `nutility.h` baÅŸlÄ±k dosyasÄ±nda yer alan `randomize` fonksiyonunun bir dÃ¶ngÃ¼ iÃ§inde kullanÄ±lmasÄ± durumunda iÅŸlemcinin Ã§ok hÄ±zlÄ± Ã§alÄ±ÅŸmasÄ±ndan dolayÄ± bir saniye geÃ§meden aynÄ± tohum deÄŸerini rastgele sayÄ± Ã¼retimi iÃ§in kullanmasÄ±ndan kaynaklÄ± olarak hep aynÄ± parolayÄ± Ã¼rettiÄŸi durumu anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include "nutility.h"

#define MIN_LEN 5
#define MAX_LEN 9

int get_random_char(void)
{
    int ch;

    while(1){
        ch = rand() % 128;
        if(isalnum(ch)) // Buradaki ÅŸart ile 0-127 arasÄ±nda elde edilen sayÄ±nÄ±n 'alfanumeric' karakterine karÅŸÄ±lÄ±k geldiÄŸi durum iÃ§in dÃ¶ngÃ¼den Ã§Ä±kÄ±lacak.
            return ch;
    }

    return 0; // Bu statement sadece derleyici uyarÄ± vermesin diye yazÄ±lmÄ±ÅŸtÄ±r.
}

void print_random_password(void)
{
    randomize(); // Bu fonksiyonun burada Ã§aÄŸÄ±rÄ±lmamasÄ± gerekiyor.
    int len = rand() % (MAX_LEN - MIN_LEN + 1) + MAX_LEN;

    for(int i = 0; i < len; ++i){
        putchar(get_random_char());
    }
    printf("\n");
}

int main(void)
{
    for(int i = 0; i < 20 ; ++i){
        print_random_password();
    }
}
```


>â”
> 
> Sorulan soru; 
> 
> Tohum deÄŸerini mikro saniye olarak kullanabiliyor muyuz? 
> 
> Cevap;
> 
> EÄŸer yukarÄ±daki programlarda soruna neden olan saniye tÃ¼rÃ¼ndeki tohum deÄŸeri yerine "mikro saniye" tÃ¼rÃ¼nden tohum deÄŸeri kullanÄ±lÄ±rsa yaÅŸanÄ±lan sorun oluÅŸmayabilirdi ama bu "mikro saniye" kullanÄ±mÄ±yla ilgili kÃ¼tÃ¼phaneyi incelediÄŸimiz zaman Ã¶ÄŸreneceÄŸimiz bir konu(dilin standart kÃ¼tÃ¼phanesiyle mi yoksa iÅŸletim sisteminin sistem fonksiyonu Ã§aÄŸÄ±rarak mÄ± bu yapÄ±labilir bunu ileride Ã¶ÄŸrenebileceÄŸiz). 


## Diziler konusuna Geri DÃ¶nÃ¼ldÃ¼ 


ğŸ‘‡ AÅŸaÄŸÄ±daki program dizi deÄŸerleri toplamÄ± ve ortalamasÄ±nÄ±n hesaplanmasÄ± iÅŸlemlerini gÃ¶rmek iÃ§in incelenebilir. 
- AÅŸaÄŸÄ±daki "**Accumulate Algorithm**" kullanÄ±mÄ±nÄ±n algoritmik karmaÅŸÄ±klÄ±ÄŸÄ± $O(n)$ durumundadÄ±r.
- AÅŸaÄŸÄ±daki programda sayÄ± toplamÄ± alÄ±ndÄ±ÄŸÄ± iÃ§in Ã§ok bÃ¼yÃ¼k sayÄ±lar toplanÄ±yorsa iÅŸaretli tam sayÄ±larda iÅŸlem yaparken taÅŸma oluÅŸursa bu "**ub**" durumu oluÅŸturabilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <ctype.h>
#include "nutility.h"
#include <conio.h>
#include <stdio.h>

#define SIZE 100

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    // Accumulate(dizinin elemanlarÄ±nÄ±n toplamÄ±) iÅŸlemi
    int sum = 0; // KÃ¼mÃ¼latif toplam tutacak olan deÄŸiÅŸken tanÄ±mÄ±.

    for(int i = 0; i < SIZE; ++i){
        sum += ar[i]; // Burada dizinin elemanlarÄ±nÄ±n toplamÄ± 'int' tÃ¼rÃ¼nÃ¼n deÄŸer aralÄ±ÄŸÄ±nÄ± aÅŸarsa 'ub' durumuna neden olur.
    }

    printf("sum = %d\n", sum); // Dizinin eleman sayÄ±larÄ±nÄ±n toplamÄ±.
    printf("mean = %f\n", (double)sum / SIZE); // Dizinin eleman sayÄ±larÄ±nÄ±n ortalamasÄ±.
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki program bir dizideki tek-Ã§ift(odd-even) sayÄ±lar Ã¼zerinde nasÄ±l iÅŸlem yapÄ±labileceÄŸini anlamak iÃ§in incelenebilir.
- AÅŸaÄŸÄ±daki programda sayÄ± toplamÄ± alÄ±ndÄ±ÄŸÄ± iÃ§in Ã§ok bÃ¼yÃ¼k sayÄ±lar toplanÄ±yorsa iÅŸaretli tam sayÄ±larda iÅŸlem yaparken taÅŸma oluÅŸursa bu **ub** durumu oluÅŸturabilir.
- AÅŸaÄŸÄ±daki programda kullanÄ±lan dizinin tÃ¼m elemanlarÄ± Ã§ift ise "**odd_count**" deÄŸerinin 0 olma ihtimali vardÄ±r ve sÄ±fÄ±ra bÃ¶lme hatasÄ± da **ub** durumu oluÅŸturur, programda bunun iÃ§in Ã¶nlem alÄ±nmÄ±ÅŸtÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <ctype.h>
#include "nutility.h"
#include <conio.h>
#include <stdio.h>

#define SIZE 100

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    // Tek(odd) hesabÄ±
    // Bu kodda iki tane tanÄ±msÄ±z davranÄ±ÅŸ oluÅŸabilir ilki iÅŸaretli tam sayÄ±lardaki taÅŸma durumu, diÄŸeri '0'a bÃ¶lme durumu.
    int odd_count = 0;
    int sum_odd = 0;

    for(int i = 0; i < SIZE; ++i){
        if(ar[i] % 2 != 0){
            ++odd_count;
            sum_odd += ar[i];
        }
    }

    if(odd_count)
        printf("array has no odd values.");
    else
        printf("the mean of odd values = %f\n", (double)sum_odd / odd_count);
}
```


>â”
> 
> Sorulan soru; 
> Ben hala taÅŸma durumu iÃ§in nasÄ±l bir "best practice" yaparÄ±z Ã§Ã¶zemedim.
> 
> Cevap;
> 
> Ã‡Ã¶zÃ¼m iÃ§in
> 1. Kod taÅŸmaya neden olmayacak ÅŸekilde yazÄ±labilir.
> 2. KaÅŸma olup olmadÄ± bir kontrole baÄŸlanabilir ama bu iÅŸlem karmaÅŸÄ±k olduÄŸu iÃ§in ÅŸimdiki dersin konusu deÄŸil, ilerideki bir dersim konusu olabilir.
> 
> C++ dilinde bu durumu dilin araÃ§larÄ±yla yapabilirdik ama C dilinde bu araÃ§lar yok.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.10-12.20 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


Dizilerle en sÄ±k yapÄ±lan iÅŸlemlerden biri olan bir dizinin **en bÃ¼yÃ¼k/en kÃ¼Ã§Ã¼k elemanlarÄ±nÄ± bulma algoritmalarÄ±(max elemant/min elemant algorithm)**. </br>
Dizinin **max elemant/min elemant algorithm** programÄ±nÄ± yazarken ilk elemanÄ± en bÃ¼yÃ¼k/en kÃ¼Ã§Ã¼k kabul et ve diziyi dolaÅŸÄ±rken gerekiyorsa bu deÄŸeri deÄŸiÅŸtir.

ğŸ‘‡ AÅŸaÄŸÄ±daki program **max elemant/min elemant algorithm** nasÄ±l yazÄ±ldÄ±ÄŸÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <ctype.h>
#include "nutility.h"
#include <conio.h>
#include <stdio.h>

#define SIZE 100

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    int max = ar[0];
    int max_idx = 0;

    for(int i = 1; i < SIZE; ++i){
        if(ar[i] > max){
            max = ar[i];
            max_idx = i;
        }
    }

    printf("max = %d ve dizinin %d indisli elemani.\n", max, max_idx);


    int min = ar[0];
    int min_idx = 0;

    for(int i = 1; i < SIZE; ++i){
        if(ar[i] < min){
            min = ar[i];
            min_idx = i;
        }
    }

    printf("min = %d ve dizinin %d indisli elemani.\n", min, min_idx);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir dizinin hem en kÃ¼Ã§Ã¼k hem de en bÃ¼yÃ¼k elemanÄ±nÄ± hesaplayÄ±ÅŸ iÅŸleminin tek bir dÃ¶ngÃ¼de yapÄ±lÄ±ÅŸÄ± incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <ctype.h>
#include "nutility.h"
#include <conio.h>
#include <stdio.h>

#define SIZE 100

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    int min = ar[0];
    int min_idx = 0;
    int max = ar[0];
    int max_idx = 0;
    
    for(int i = 0; i < SIZE; ++i){
        if(ar[i] > max){
            max = ar[i];
            max_idx = i;
        }
        else if(ar[i] < min){
            min = ar[i];
            min_idx = i;
        }
    }

    printf("min = %d ve dizinin %d indisli elemani.\n", min, min_idx);
    printf("max = %d ve dizinin %d indisli elemani.\n", max, max_idx);
}
```

**Runner-up**: Bir yarÄ±ÅŸmada birinci deÄŸil de birinciden sonra gelen birincinin kastedildiÄŸi durumu ifade etmek iÃ§in kullanÄ±lan bir terimdir.



MÃ¼lakatlarda sorulan bu algoritmanÄ±n tipik bir kullanÄ±mÄ± var buna **runner-up** deniliyor, burada en bÃ¼yÃ¼k eleman deÄŸil de en bÃ¼yÃ¼k ikinci eleman soruluyor.
- ğŸ‘‡ AÅŸaÄŸÄ±daki programda **runner-up** deÄŸerini hesaplayan bir programÄ±n nasÄ±l yazÄ±labileceÄŸi gÃ¶rÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <ctype.h>
#include "nutility.h"
#include <conio.h>
#include <stdio.h>

#define SIZE 20

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    int max = ar[0];
    int runner_up = ar[1];
    
    if(ar[0] < ar[1]){
        max = ar[1], runner_up = ar[0];
    }

    for(int i = 2; i < SIZE; ++i){
        if(ar[i] > max){
            runner_up = max;
            max = ar[i];
        }
        else if(ar[i] > runner_up){
            runner_up = ar[i];
        }
    }

    printf("runner_up = %d\n", runner_up);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**Linear Search**" algoritmasÄ±nÄ±n nasÄ±l yazÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <ctype.h>
#include "nutility.h"
#include <conio.h>
#include <stdio.h>

#define SIZE 20

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    int key;

    printf("aranacak degeri giriniz: ");
    scanf("%d", &key);

    // Bayrak deÄŸiÅŸken kullanarak yapÄ±lan Ã§Ã¶zÃ¼m, ama bu Ã§Ã¶zÃ¼mde bulunan elemanÄ±n 'index' deÄŸerini Ã¶ÄŸrenemeyiz.
    int flag = 0;

    for(int i = 0; i < SIZE; ++i){
        if(ar[i] == key){
            flag = 1;
            break;
        }
    }

    if(flag)
        printf("bulundu.\n", i);
    else
        printf("bulunamadi.\n");


    // Bu Ã§Ã¶zÃ¼mde bulunan elemanÄ±n 'index' deÄŸerini alabilmek iÃ§in dÃ¶ngÃ¼ iÅŸleminin dÃ¶ngÃ¼ deÄŸerini tutan deÄŸiÅŸkeni dÃ¶ngÃ¼ dÄ±ÅŸÄ±na aldÄ±k ve bu yapÄ±lÄ±nca da 'flag' deÄŸiÅŸkenine de gerek kalmadÄ±.
    int i;
    for(i = 0; i < SIZE; ++i){
        if(ar[i] == key){
            break;
        }
    }

    if(i < SIZE)
        printf("bulundu, dizinin %d indisli elemani.\n", i);
    else
        printf("bulunamadi.\n");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**Linear Search**" algoritmasÄ±nÄ±n nasÄ±l **C idiom**'u ile yazÄ±labileceÄŸi gÃ¶rÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <ctype.h>
#include "nutility.h"
#include <conio.h>
#include <stdio.h>

#define SIZE 20

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    int key;

    printf("aranacak degeri giriniz: ");
    scanf("%d", &key);

    int i;
    for(i = 0; i < SIZE && ar[i] != key; ++i)
        ; // null statement

    if(i < SIZE)
        printf("bulundu, dizinin %d indisli elemani.\n", i);
    else
        printf("bulunamadi.\n");
}
```



**Donald Knuth**: Veri yapÄ±larÄ± ve algoritmalar konusunda halen Ã§alÄ±ÅŸmakta olan ve bilgisayar bilimine en Ã§ok katkÄ± yapan kiÅŸidir biridir, kendi geliÅŸtirdiÄŸi bir Ã§ok algoritmasÄ± vardÄ±r. Kendi yazdÄ±ÄŸÄ± **Algoritms** kitabÄ±, algoritmalar konusunda yazÄ±lmÄ±ÅŸ en kapsamlÄ± kaynaktÄ±r.

**Unsuccesful Search**: Dizide bir deÄŸer arama iÅŸleminde aranÄ±lan elemanÄ±n dizide bulunamama durumunu belirtmek iÃ§in kullanÄ±lan terimdir.


ğŸ“– Ã–dev-1
- **Donald Knuth**'un algoritmalar kitabÄ±ndaki ÅŸu sorunun Ã§Ã¶zÃ¼lmesi isteniyor, "**Linear Search** algoritmasÄ±nÄ±n ilk akla gelen en kolay Ã§Ã¶zÃ¼mÃ¼nde dÃ¶ngÃ¼ iÃ§inde Ã¼Ã§ adet karÅŸÄ±laÅŸtÄ±rma iÅŸlemi yapÄ±lyor, bu dÃ¶ngÃ¼nÃ¼n Ã¼Ã§ yerine iki iÅŸlem ile nasÄ±l yapÄ±labilir?" 
- ğŸ‘‡ AÅŸaÄŸÄ±daki programda yukarÄ±daki sorunun aÃ§Ä±klamasÄ± mevcuttur, Ã§Ã¶zÃ¼mÃ¼nÃ¼ dÃ¼ÅŸÃ¼nerek yapmaya Ã§alÄ±ÅŸ.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <ctype.h>

#define SIZE 20

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    int key;
    printf("aranacak degeri giriniz: ");
    scanf("%d", &key);

    // Bu Ã§Ã¶zÃ¼mdeki dÃ¶ngÃ¼de 'i < SIZE', 'ar[i] == key' ve '++i' bir iÅŸlemdir ve bu dÃ¶ngÃ¼de '3 * SIZE' adet iÅŸlem yapÄ±lÄ±yor, bizden '2 * SIZE' adet iÅŸlemle aynÄ± dÃ¶ngÃ¼nÃ¼n yazÄ±lmasÄ± isteniyor.
    int i;
    for(i = 0; i < SIZE; ++i){
        if(ar[i] == key){
            break;
        }
    }

    if(i < SIZE)
        printf("bulundu, dizinin %d indisli elemani.\n", i);
    else
        printf("bulunamadi.\n");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **reverse(diziyi ters Ã§evirme)** algoritmasÄ±nÄ±n **gerÃ§ekleÅŸtiriminin(implementation)** nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir. AlgoritmanÄ±n karmaÅŸÄ±klÄ±ÄŸÄ± $O(n)$ seviyesindedir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <ctype.h>
#include "nutility.h"
#include <conio.h>
#include <stdio.h>

#define SIZE 20

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    for(int i = 0; i < SIZE / 2; ++i){
        int temp = ar[i];
        ar[i] = ar[SIZE - 1 -i];
        ar[SIZE - 1 -i] = temp;
    }
    
    print_array(ar, SIZE);
}
```


Ders sonu ...
