# 56.Ders 27.08.2025 ğŸ•˜

---

## `stdout`, `stdin`, `stderr` KullanÄ±mÄ±


ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki dosyaya yazdÄ±rmak iÃ§in kullanÄ±lan fonksiyonlara **Standat output**'u temsil eden referans geÃ§ildiÄŸi iÃ§in bu fonksiyon Ã§aÄŸrÄ±larÄ±ndan sonra standart Ã§Ä±ktÄ± akÄ±mÄ±na yazm aiÅŸlemi yapÄ±lacaktÄ±r.
```C
#include <stdio.h>

int main(void)
{
    fprintf(stdout, "neco");
    fputc('X', stdout);
    fputs('timur', stdout);
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda dosyadan okuma iÅŸlemi yapmak iÃ§in kullanÄ±lan `fscanf` fonksiyonu nasÄ±l **Standat input**'tan okuma yapmak iÃ§in kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x;

    printf("bir sayi girin: ");
    fscanf(stdin, "%d", &x);
    printf("x = %d\n", x);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `fprintf` fonksiyonuna **Standat error** handler olarak geÃ§ildiÄŸinde Ã§Ä±ktÄ± varsayÄ±lan hata akÄ±mÄ±na yazdÄ±rÄ±lacaktÄ±r o da ekrana baÄŸlÄ± olduÄŸu iÃ§in ekrana yazdÄ±rÄ±lacaktÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    fprintf(stderr, "bu bir hata iletisidir.\n");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `print_info` adÄ±ndaki fonksiyonun herhangi bir dosyaya yazdÄ±rma iÅŸlemi iÃ§in nasÄ±l sarmalayÄ±cÄ± bir fonksiyon olarak kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

void print_info(FILE* f, const char* str)
{
    fprintf(f, str);
}

int main(void)
{
    FILE* f = fopen("out.txt", "w");
    if(!f){
        return 1;
    }

    print_info(f, "necati ergin"); // Ä°letilen veri 'out.txt' dosyasÄ±na yazdÄ±rÄ±lÄ±r.

    print_info(stdout, "necati ergin"); // Ä°letilen veri 'standart output'a yazdÄ±rÄ±lÄ±r.
    
    close(f);
}
```



âœï¸ Burada `date.h` kÃ¼tÃ¼phanesinin deneme iÃ§in `print_date_` fonksiyonunu ekliyoruz.
```C

#include <stdio.h>

void print_date_(FILE* f, const Date* p);
```



âœï¸ Burada `date.c` kÃ¼tÃ¼phanesinin deneme iÃ§in `print_date_` fonksiyonunu ekliyoruz.
```C

PUBLIC void print_date(FILE* f, const Date* p)
{
    // AylarÄ± dizinin indis deÄŸeriyle eÅŸitlemek iÃ§in dizinin 0. elemanÄ± boÅŸ yazÄ± yapÄ±lÄ±yor.
    static const char* const pmons[] = { "", "Ocak", "Subat", "Mart", "Nisan", "Mayis", "Haziran", "Temmuz", "Agustos", "Eylul", "Ekim", "Kasim", "Aralik", };
    
    static const char* const pdays[] = { "Pazar", "Pazartesi", "Sali", "Carsamba", "Persembe", "Cuma", "Cumartesi", };

    fprintf(f, "%02d %s %d %s\n", GET_MONTH_DAY(*p), pmons[GET_MONTH(*p)], GET_YEAR(*p), pdays[get_week_day(p)]);
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `date.h` dosyasÄ±na eklenen `print_date_` fonksiyonunu kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "date.h"

int main(void)
{
    Date mydate;
    set_date(&mydate, 27, 7, 2015);

    print_date_(stdout, &mydate); // VarsayÄ±lan Ã§Ä±ktÄ± akÄ±mÄ±na yazdÄ±rma iÅŸlemi.
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `date.h` dosyasÄ±na eklenen `print_date_` fonksiyonunu kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "date.h"

int main(void)
{
    FILE* f = fopen("out.txt", "w");
    if(!f){
        fprintf(str, "%s dosyasi acilamadi.\n");
        return 1;
    }

    Date mydate;
    set_date(&mydate, 27, 7, 2015);

    print_date_(f, &mydate); // Dosyaya yazdÄ±rma iÅŸlemi.

    close(f);
}
```



Dosya iÅŸlemleriyle ilgili sÄ±k karÅŸÄ±laÅŸÄ±lan mÃ¼lakat sorulardan biri: "`stdout` ve `stderr` de ekrana baÄŸlÄ± ise neden hata iletilerini `strerr` akÄ±mÄ±na vermeliyiz?"
Cevap: </br>
Hata iletileri doÄŸrudan programÄ± kullananÄ± ilgilendiriyor bir hata olduÄŸunda prograÄ± kullananÄ±n o hatayÄ± gÃ¶rebilmesi gerekir. </br>
Hata iletilerini `stdout` akÄ±mÄ±na yÃ¶nlendirirsek eÄŸer **standart output** bir nedenden dolayÄ± baÅŸka bir dosyaya yÃ¶nlendirilirse bu durumda programÄ± kullanan hata iletilerini gÃ¶remez.



ğŸ‘‡ AÅŸaÄŸÄ±daki programnÄ±n varsayÄ±lan Ã§Ä±ktÄ± akÄ±mÄ±nÄ± komut satÄ±rÄ±ndan `program_name > yonlendirilecek_dosya.xtx` komutu girilerek `yonlendirilecek_dosya.xtx` dosyasÄ±na yÃ¶nlendirilirse kullanÄ±cÄ±nÄ±n gÃ¶rmesi gereken hata iletilerini kullanÄ±cÄ±nÄ±n gÃ¶rÃ¼p gÃ¶remeyeceÄŸi incelenebilir. </br>
â—â—â— BurayÄ± anlamk Ã¶nemli yani hata iletilerinde neden `strerr` ile iÅŸlem yapÄ±ldÄ±ÄŸÄ± bilgisi.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "date.h"
#include "nutility.h"
#include <stdlib.h>

int main(void)
{
    randomize();

    for(int i = 0; i < 10; ++i){
        printf("%d", rand());
    }

    // pritnf("bellek yetersiz... devam etmek icin bir tusa basin!"); // hata iletisi varsayÄ±lan Ã§Ä±ktÄ± akÄ±mÄ±na veriliyor.
    fpritnf(strerr ,"bellek yetersiz... devam etmek icin bir tusa basin!"); // hata iletisi varsayÄ±lan hata akÄ±mÄ±na veriliyor
}
```


â—â—â— Ä°ÅŸletim sistemlerinin Ã§oÄŸunda **standart output**'u yÃ¶nlendirmek iÃ§in `>` karakteri kullanÄ±lÄ±yor, **standart input**'u yÃ¶nlendirmek iÃ§in `<` karakteri kullanÄ±lÄ±yor, **standart error**'u yÃ¶nlendirmek iÃ§in `2>` karakterleri kullanÄ±lÄ±yor. 


ğŸ‘‡ AÅŸaÄŸÄ±daki programÄ±n girdileri varsayÄ±lan olarak **standart input**'tan yani klavyeden, Ã§Ä±ktÄ±larÄ± da varsayÄ±lan olarak **standart output**'a yani ekrana gÃ¶nderilir. </br>
ProgramÄ±n kaynak kodlarÄ±nda hiÃ§bir deÄŸiÅŸiklik yapmadan programÄ± Ã§alÄ±ÅŸtÄ±rÄ±rken **standart input** ve **standart output** yÃ¶nlendirmeleri deÄŸiÅŸtirilebilir, mesela program CLI'dan `_programÄ±n Ã§alÄ±ÅŸtÄ±rÄ±labilir dosyasÄ±nÄ±n adÄ±_ > out.txt < data.txt` biÃ§iminde Ã§alÄ±ÅŸtÄ±rÄ±lÄ±rsa program girdisini "data.txt" dosyasÄ±nda alÄ±r ve Ã§Ä±ktÄ±sÄ±nÄ± da "out.txt" dosyasÄ±na yazar.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    for(int i = 0; i < 10; ++i){
        int x;

        scanf("%d", &x);
        printf("%d * %d = %d", x, x, x * x);
    }
}
```


## `freopen` Fonksiyonu 

`freopen` fonksiyonunun prototipi `FILE* freopen(const char* filename, const char* mode, FILE* stream);` biÃ§imindedir, bu fonksiyon Ã¼Ã§Ã¼ncÃ¼ parametresine geÃ§ilen handle'a iliÅŸkin dosyayÄ± ikinci parametresine geÃ§ilen durumda(okuma, yazma vb.) birinci parametresine geÃ§ilen dosyaya yÃ¶nlenrme iÅŸlemini yapÄ±yor. </br>
Bu fonksiyon Ã§oÄŸunlukla **standart output**'un ya da **standart input**'un yÃ¶nlendirilmesi iÃ§in kullanÄ±lÄ±yor.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `freopen` fonksiyonuyla **standart output**'un istenilen dosyaya yÃ¶nlendirilebildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    puts("necati ergin");

    if(freopen("out.txt", "w", stdout) == NULL){ // Burada 'standart output'un 'out.txt' dosyasÄ±na yÃ¶nlendirilmek iÃ§in fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±lÄ±yor.
        fprintf(stderr, "freopen failed!\n");
        return 1;
    }

    puts("bu yazi dosyaya yazilacak.\n");

    fclose(stdout);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `freopen` fonksiyonuyla **standart input**'un istenilen dosyaya yÃ¶nlendirilebildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    puts("necati ergin");

    if(freopen("in.txt", "r", stdin) == NULL){ // Burada 'standart input'un 'in.txt' dosyasÄ±ndan okunmasÄ± iÃ§in fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±lÄ±yor.
        fprintf(stderr, "freopen failed!\n");
        return 1;
    }

    int a, b, c;
    scanf("%d%d%d", &a, &b, &c);

    printf("a = %d", a);
    printf("b = %d", b);
    printf("c = %d", c);

    fclose(stdout);
}
```


## `setbuf` ve `setvbuf` FonksiyonlarÄ± 

Bu fonksiyonlarÄ±n adlarÄ±ndaki "**buf**" kÄ±saltmasÄ± "**buffer**" sÃ¶zcÃ¼ÄŸÃ¼nden gelmektedir, `fflash` fonksiyonu handler'Ä± kendisine verilen dosyaya yazma iÅŸlemi iÃ§in kullanÄ±lmataydÄ±. </br>
`stdio.h` dosyasÄ± iÃ§inde bulunan `BUFSIZE` object-like makrosu mar bu makro varsayÄ±lan buffer deÄŸerini belirlemektedir. </br>
`setbuf` ve `setvbuf` fonksiyonlarÄ± buffer'lama mekanizmasÄ±nÄ± dÃ¼zenlemek iÃ§in kullanÄ±lmaktadÄ±r.

`setvbuf` fonksiyonunun prototipi `int setvbuf(FILE* f, char* buffer, int mode, size_t size);` biÃ§imindedir, bu fonksiyon **test function** bir fonksiyondur, fonksiyon baÅŸarÄ±lÄ± olduÄŸunda "0" ve baÅŸarÄ±sÄ±z olduÄŸunda da "non-zero" deÄŸer dÃ¶ner. Ä°lk parametre ilgili dosyanÄ±n handler'Ä±, ikinci parametre buffer olarak kullanÄ±lacak olan dizinin adresi, Ã¼Ã§Ã¼ncÃ¼ parametre Ã¼Ã§ farklÄ± makro deÄŸer alabilen buffer'Ä±n mode Ã¶zellik bilgisi, dÃ¶rdÃ¼ncÃ¼ parametre buffer olarak kullanÄ±lacak olan dizinin boyutudur. </br>

`setvbuf` fonksiyonunun Ã¼Ã§Ã¼ncÃ¼ parametresi aÅŸaÄŸÄ±daki makrolarÄ±ndan birini alabilir;
- `_IOFBF`: Bu makronun adÄ± "**input/output full buffering**" sÃ¶zcÃ¼klerinden gelmektedir.
- `_IOLBF`: Bu makronun adÄ± "**input/output line buffering**" sÃ¶zcÃ¼klerinden gelmektedir, bu mode'da iken yeni satÄ±r karakteri(`\n`) geldiÄŸinde ya da buffer dolduÄŸunda **flush** iÅŸlemi yapÄ±lacaktÄ±r. Mesela `printf` Ã§aÄŸrÄ±larÄ±nda "new-line" kullanÄ±lmasÄ±nÄ±n nedeni sadece alt satÄ±ra geÃ§iÅŸi saÄŸlamak eÄŸil bu aynÄ± zamanda flush iÅŸleminin yapÄ±lmasÄ± anlamÄ±na geliyor. 
- `_IONBF`: Bu makronun adÄ± "**input/output no buffering**" sÃ¶zcÃ¼klerinden gelmektedir, mesela **standart error**'Ã¼n buffer modu budur.

`setvbuf` fonksiyonunun ikinci parametresine **NULL pointer** geÃ§ilirse bu ÅŸu anlamÄ±na geliyor: Ben buffer dizisi saÄŸlamak istemiyorum bunu sen ayarla anlamÄ±na geliyor.

`setvbuf` fonksiyonunu dosya aÃ§Ä±ldÄ±ktan hemen sonra dosya Ã¼zerinde hiÃ§bir iÅŸlem yapmadan Ã§aÄŸÄ±rmak gerekiyor yoksa **ub** durumu oluÅŸmaktadÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `setvbuf` kullanÄ±mÄ± gÃ¶rÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "date.h"
#include "nutility.h"
#include <stdlib.h>

int main(void)
{
    setvbuf(stdout, NULL, _IOLBF, 0); // Burada 'standart output'un buffer'Ä± '_IOLBF' olarak ve buffer iÃ§in kullanÄ±lacak olan diziyi de fonksiyon kendisi ayarlayacak biÃ§imde bir dÃ¼zenleme yapÄ±lmÄ±ÅŸ oluyor.
    // setvbuf(stdout, NULL, _IOLBF, BUFSIZ); // Bu satÄ±rdaki fonksiyon Ã§aÄŸrÄ±sÄ± yukarÄ±daki fonksiyon Ã§aÄŸrÄ±sÄ±yla denktir.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `setvbuf` fonksiyonunun oluÅŸturulan bir diziyle Ã§aÄŸrÄ±lÄ±ÅŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "date.h"
#include "nutility.h"
#include <stdlib.h>

char buf[1024];

int main(void)
{
    FILE* f = fopen("out.txt", "w");
    if(!f)
        return 1;

    if(setvbuf(f, buf, _IOFBF, sizeof(buf))){
        fprintf(stderr, "setvbuf failed!\n");
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `setvbuf` fonksiyonunun herhangi bir tamponlama olmadak kullanÄ±lÄ±ÅŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "date.h"
#include "nutility.h"
#include <stdlib.h>

char buf[1024];

int main(void)
{
    setvbuf(stdout, NULL, _IONBF, 0); // Burada 'standart output'un buffer'Ä±nÄ±n '_IONBF' olarak tamponlama olmadan kullanÄ±lacaÄŸÄ± bildiriliyor.

    setvbuf(stderr, NULL, _IONBF, 0); // Burada 'standart error'un buffer'Ä±nÄ±n '_IONBF' olarak tamponlama olmadan kullanÄ±lacaÄŸÄ± bildiriliyor ama varsayÄ±lanÄ± bu olduÄŸu iÃ§in bu kod gereksizdir.
}
```



`setbuf` fonksiyonunun prototipi `void setbuf(FILE* f, char* buffer);` biÃ§imindedir, ilk parametre ilgili dosyanÄ±n handler'Ä±, ikinci parametre buffer olarak kullanÄ±lacak olan dizinin adresidir, bu fonksiyon `setvbuf` fonkiyonunun sadeleÅŸtirilmiÅŸ bir halidir. </br>
`setbuf(f, buf);` biÃ§imindeki bir bir fonksiyon Ã§aÄŸrÄ±sÄ± `setvbuf(f, buf, _IOFBF, BUFSIZ);` fonksiyon Ã§aÄŸrÄ±sÄ±na denktir. </br>
`setbuf(f, NULL);` biÃ§imindeki bir bir fonksiyon Ã§aÄŸrÄ±sÄ± `setvbuf(f, buf, _IONBF, BUFSIZ);` fonksiyon Ã§aÄŸrÄ±sÄ±na denktir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `setbuf` fonksiyonunun temel kullanÄ±mlarÄ± incelenebilir, `setbuf` fonksiyonu kullanÄ±mÄ±nda buffer'lama yaklaÅŸÄ±mÄ±nÄ± deÄŸiÅŸtiremiyoruz ya **full buffering** kullanÄ±labilir ya da **no-buffering** kullanÄ±labiliyor.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "date.h"
#include "nutility.h"
#include <stdlib.h>

char buf[1024];

int main(void)
{
    setbuf(stdout, NULL); // Bu fonksiyon Ã§aÄŸrÄ±sÄ± 'standart output'un buffer'lanmamasÄ± anlamÄ±na gelmektedir.

    setbuf(stdout, buf); // Bu fonksiyon Ã§aÄŸrÄ±sÄ± 'standart output'un full buffer'lanmamasÄ± ve 'buf' nesnesinin buffer olarak kullanÄ±lmasÄ± anlamÄ±na gelir.
}
```


âš ï¸âš ï¸âš ï¸ **Standat output**, **Standat output**, **Standat error** esasÄ±nda bir dosya olduklarÄ± iÃ§in bunlar Ã¼zerinde yapÄ±lan iÅŸlemler herhangi bir dosya Ã¼zerinde de yapÄ±labilir.



## `ungetc` Fonksiyonu 

`ungetc` fonksiyonunun prototipi `int ungetc(int c, FILE* f);` biÃ§imindedir, bu fonksiyon bir dosyanÄ±n buffer'Ä±ndan okunan bir karakteri iÅŸlem sonrasÄ±nda yeniden o buffer'a geri koymak iÃ§in kullanÄ±lÄ±yor. </br>


âš ï¸ Bu baÅŸlÄ±ÄŸÄ± bir defa daha gzden geÃ§irmek gerekiyor! âš ï¸


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `ungetc` kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "date.h"
#include "nutility.h"
#include <stdlib.h>

char buf[1024];

int main(void)
{
    FILE* f = fopen("main.c", "r");
    if(!f){
        fprintf(stderr, "dosya acilamadi!\n");
        return 1;
    }

    int c = fgetc(f);
    printf("okunan karakter %c %d\n", c, c);

    // AÅŸaÄŸÄ±daki koÅŸul bloÄŸunda dosyanÄ±n sonuna gelinmediyse, 'c' karakterini dosya geri koyacaktÄ±r.
    if(ungetc(c, f) != EOF){
        printf("karakter geri koyuldu\n");
    }

    c = fgetc(f);
    printf("okunan karakter %c %d\n", c, c);

    fclose(f);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `ungetc` kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>

void process_input(FILE* f)
{
    int ch = fgetc(f); // Burada ilgili dosyanÄ±n 'file pointer'Ä±nÄ±n gÃ¶sterdiÄŸi yerde bir karakter okunmaktadÄ±r.

    // AÅŸaÄŸÄ±daki kodlar Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±rsa standart Ã§Ä±ktÄ± akÄ±mÄ±na 'val = 72349' yazacaktÄ±r.
    // if(isdigit(ch)){
    //     int val;
    //     fscan(f, "%d", &val);
    //     printf("val = %d\n", val);
    // }
    // else{
    //     printf("okunan karakter %c\n", ch);
    // }

    // AÅŸaÄŸÄ±daki kodlar Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±rsa standart Ã§Ä±ktÄ± akÄ±mÄ±na 'val = 872349' yazacaktÄ±r.
    if(isdigit(ch)){
        ungetc(ch, f); // Burada 'f' dosyasÄ±na 'ch' karakteri geri koyuluyor.
        int val;
        fscan(f, "%d", &val);
        printf("val = %d\n", val);
    }
    else{
        printf("okunan karakter %c\n", ch);
    }
}

int main(void)
{
    FILE* f = fopen("in.txt", "r"); // Buradaki 'in.txt' dosyasÄ±nda tek satÄ±r olarak '872349' yamaktadÄ±r.
    if(!f){
        fprintf(stderr, "dosya acilamadi!\n");
        return 1;
    }

    process_input(f);
}
```


## C Dilinde Hatalar 

Hatalar temelde ikiye ayrÄ±lÄ±r;
- **Programming error**: Bu tÃ¼r hatalar programÄ±n kodunun yanlÄ±ÅŸ yazÄ±ldÄ±ÄŸÄ± durumlarÄ± ifade eder. Bu tÃ¼r hatalarÄ± Ã§Ã¶zmek iÃ§in programdaki hatalÄ± kodlarÄ± tespitedip dÃ¼zeltmek gerekir, programdaki hatalarÄ± dÃ¼zeltmek iÃ§in **bug fixing** iÅŸlemleri yapÄ±lÄ±r.
- **Runtime error**: Bu tÃ¼r hatalar programÄ±n kodundan baÄŸÄ±msÄ±z olarak meydana gelen hatalardÄ±r, mesela prograÄ±n kullandÄ±ÄŸÄ± bir dosyanÄ±n ilgili yerden silinmiÅŸ olmasÄ±, bellek alanÄ±nÄ±n yetersiz olmasÄ±ndan kaynaklanan hatalar vb.

**API boundary(API SÄ±nÄ±rÄ±)**: Bir hatanÄ±n tÃ¼rÃ¼nÃ¼n duruma gÃ¶re bazen **programming error**, bazen de **runtime error** olmasÄ± durumuna verilen adlandÄ±rmadÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki program parÃ§asÄ±ndaki `foo` fonksiyonundan alÄ±nabilecek hata duruma gÃ¶re **programming error** ya da **runtime error** olabilir, eÄŸer kendi yazdÄ±ÄŸÄ±mÄ±z koddan `foo` fonksiyonu "0" deÄŸeriyle Ã§aÄŸrÄ±lÄ±yorsa **programming error** olacaktÄ±r ama bir **client code** `foo` fonksiyonu "0" deÄŸeriyle Ã§aÄŸrÄ±lÄ±yorsa **runtime error** olacaktÄ±r. Ä°ÅŸte burada gibi kodda oluÅŸabilecek hatanÄ±n tÃ¼rÃ¼nÃ¼n deÄŸiÅŸebilir olmasÄ± **API boundary(API SÄ±nÄ±rÄ±)** olarak tanÄ±mlanmaktadÄ±r.
```C
int foo(int x)
{
    // buraya gelen 'x'in deÄŸeri '0' olmamalÄ±, eÄŸer '0' olursa hata sÄ±fÄ±ra bÃ¶lme hatasÄ± oluÅŸacaktÄ±r.
    int y = 241231 / x;
}
```


C++, Java, C# gibi diller programÄ±n Ã§alÄ±ÅŸma zamanÄ±nda oluÅŸabilecek hatalarÄ± yÃ¶netebilmek iÃ§in C dilinde olmayan "**Exception Handing**" olarak adlandÄ±rÄ±lan bir araÃ§ seti iÃ§ermektedir, bÃ¶yle **runtime error** hatalarÄ±na o dillerde "**Exception**" deniliyor.


### C Dilinde Runtime errors 

**Conventional error handling(geleneksel hata yÃ¶netimi)** 

C dilinde Ã¼Ã§ farklÄ± biÃ§imde **runtime error** hatalarÄ± yÃ¶netilmektedir. </br>
Bir fonksiyon iÅŸini yapamadÄ±ÄŸÄ±nda kullanÄ±lan yÃ¶ntemler;
1. Geri dÃ¶nÃ¼ÅŸ deÄŸeri mekanizmasÄ± ile iÅŸini yapamadÄ±ÄŸÄ±nÄ± belirten bir deÄŸer dÃ¶ndÃ¼rÃ¼r.
    `stdio.h` dosyasÄ±nda neredeyse tÃ¼m fonksiyonlar bÃ¶yl eÃ§alÄ±ÅŸmaktadÄ±r, mesela;
    - `fopen` fonksiyonu iÅŸini yapabilirse bir dosya nesnesi adresi dÃ¶ndÃ¼rÃ¼yor ama iÅŸini yapamazsa **NULL pointer** deÄŸer dÃ¶ndÃ¼rÃ¼yor.
    - `malloc` fonksiyonu iÅŸini yapabilirse ayrÄ±lan bellek bloÄŸunun adresi dÃ¶ndÃ¼rÃ¼yor ama iÅŸini yapamazsa **NULL pointer** deÄŸer dÃ¶ndÃ¼rÃ¼yor.
    - `remove`, `rename` fonksiyonlarÄ± Ã¼zerlerinde iÅŸlem yaptÄ±klarÄ± dosyalarda baÅŸarÄ±lÄ± iÅŸlem yaptÄ±ÄŸÄ±nda geriye "0" deÄŸer dÃ¶ndÃ¼rÃ¼yor, yapamazlarsa "non-zero" deÄŸer dÃ¶ndÃ¼rÃ¼yor.
    - `ftell` fonksiyonu iÅŸini yapabilirse bir file pointer deÄŸeri dÃ¶ndÃ¼rÃ¼r, iÅŸini yapamazsa "-1" deÄŸerini dÃ¶ndÃ¼rÃ¼r. 
2. Fonksiyon dÄ±ÅŸarÄ±dan bir argÃ¼man alÄ±r, eÄŸer hata oluÅŸursa oluÅŸan hatayla ilgili bilgi bu **output** deÄŸiÅŸkene yazÄ±lÄ±r, fonkisyonu Ã§aÄŸÄ±ran kod hata olup olmadÄ±ÄŸÄ±nÄ± **output** deÄŸiÅŸkene bakarak anlar.
3. Standart C fonksiyonlarÄ±nda kullanÄ±lan ve Unix/Linux sistem fonksiyonlarÄ±nda yoÄŸun olarak kullanÄ±lan **errno**, bu hata yÃ¶netim yaklaÅŸÄ±mÄ±nÄ± detaylÄ± inceleyeceÄŸiz.


### `errno` DeÄŸiÅŸkeni Ä°le Hata YÃ¶netimi 

`errno`yu derleyiciler Ã§oÄŸunlukla object-like makro tÃ¼rÃ¼nden olan **extern** olarak bildirilmiÅŸ bir global deÄŸiÅŸkene karÅŸÄ±lÄ±k gelmektedir, bu deÄŸiÅŸken global olduÄŸu iÃ§in tÃ¼m fonksiyonlar deÄŸerini deÄŸiÅŸtirebilir ve kullanabilir. "**errno**" adÄ± "**Error Number**" sÃ¶zcÃ¼klerinden gelmektedir.

`errno` deÄŸiÅŸkeni `errno.h` baÅŸlÄ±k dosyasÄ±nda bulunan programda oluÅŸabilecek olan hatalarÄ±n tutulmasÄ± iÃ§in kullanÄ±lacak olan global bir deÄŸiÅŸkendir, `errno` deÄŸeri "0" ise bu herhangi bir hata olmadÄ±ÄŸÄ± anlamÄ±na gelmektedir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `errno` deÄŸiÅŸkeninin varsayÄ±lan durumdaki deÄŸerinin "0" olduÄŸu incelenebilir.
```C
#include <errno.h>
#include <stdio.h>

int main(void)
{
    printf("errno = %d", errno); // 'errno' deÄŸeri bir hata yokken '0'dÄ±r.
}
```


Ã–yle standart C fonksiyonlarÄ± var ki, bunlar C standardÄ±nda belirtiliyor, bu fonksiyonlar bir hata ile karÅŸÄ±laÅŸtÄ±klarÄ±nda ya tek yol olarak `errno` deÄŸiÅŸkeninin deÄŸerini deÄŸiÅŸtiriyorlar ya da hem geri dÃ¶nÃ¼ÅŸ deÄŸeriyle hatayÄ± Ã§aÄŸÄ±ran koda belirtiyorlar hem de aynÄ± zamanda `errno` deÄŸiÅŸkeninin deÄŸerini deÄŸiÅŸtiriyorlar.

`errno` deÄŸiÅŸkeninin deÄŸerinin "0" haricinde bir deÄŸer olmasÄ± bir hata oluÅŸtuÄŸunu ve bu hatanÄ±n tÃ¼rÃ¼nÃ¼ belirtmektedir. </br> 
`errno` deÄŸiÅŸkeninin tam sayÄ± deÄŸerlerinin hangi hata olduÄŸunu anlamak iÃ§in kullanÄ±lan iki farklÄ± fonksiyon vardÄ±r, bunlar;
- `stdio.h` baÅŸlÄ±k dosyasÄ±nda bulunan `perror` fonksiyonu.
- `string.h` baÅŸlÄ±k dosyasÄ±nda bulunan `strerror` fonksiyonu.


`errno` deÄŸiÅŸkenine bakÄ±lacaÄŸÄ± zaman ÅŸuna dikkate edilmelidir: Bir fonksiyonu Ã§aÄŸÄ±rmadan Ã¶nce `errno` deÄŸiÅŸkeninin deÄŸeri "0" yapÄ±lmalÄ±dÄ±r, ardÄ±ndan ilgili fonksiyon Ã§aÄŸÄ±rÄ±lmalÄ± ve en son `errno` deÄŸerine bakÄ±lmalÄ±dÄ±r, `errno` deÄŸeri "0" ise hata alÄ±nmadÄ±ÄŸÄ± anlamÄ±na gelmektedir ama "0" haricinde bir deÄŸer ise o zaman ilgili fonksiyon Ã§aÄŸrÄ±sÄ±nda hata oluÅŸtuÄŸu anlaÅŸÄ±lÄ±r.


> â” 
> 
> Sorulan soru;
> 
> Paralelde Ã§alÄ±ÅŸan fonksiyonlarÄ±n eÅŸ zamanlÄ± olarka `errno` deÄŸiÅŸkenini deÄŸiÅŸtirme ihtimali yok mu?
> 
> Cevap;
> 
> Bu konuda C dilinin standartlarÄ± devreye giriyor, **Unix/Linux** sistemlerde `errno` deÄŸiÅŸkeninin **thread safe** bir sersiyonu var. </br>
> C11 standardÄ±yla `errno` deÄŸiÅŸkeni **thread safe** hale getirildi. </br>
> Bu konu tamamen **thread**'ler ile ilegili ve bu konu bu kursun kapsamÄ± dÄ±ÅŸÄ±ndadÄ±r. </br>
> C++ dili kursunda C++ dilinin standar kÃ¼tÃ¼phenesinin **concurrency** araÃ§larÄ± da incelenmektedir.  



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `fopen` ve `fclose` fonksiyonlarÄ±nÄ±n `errno` deÄŸerini deÄŸiÅŸtiren fonksiyon olduklarÄ± incelenebilir.
```C
#include <errno.h>
#include <stdio.h>

int main(void)
{
    printf("errorno = %d\n", errno);
    FILE* f = fopen("omeroylar.txt", "r"); // Okunabilecek 'omeroylar.txt' adÄ±nda bir fonksiyon olmadÄ±ÄŸÄ±nda dosya aÃ§Ä±lamayacaktÄ±r, bu durumda `fopen` fonksiyonu `errno` deÄŸerini ilgili hata koduyla deÄŸiÅŸtirecektir.
    printf("errorno = %d\n", errno);
}
```


#### `perror` ve `strerror` FonksiyonlarÄ± 

`perror` fonksiyonunun prototipi `void perror(const char*);` biÃ§imindedir, eÄŸer bir yazÄ± bu fonksiyona argÃ¼man olarak geÃ§ilirse, ilk Ã¶nce o yazÄ± yazdÄ±rÄ±lÄ±r ve `:` karakteri eklendikten sonra `errno` kodunun aÃ§Ä±klamasÄ± yazdÄ±rÄ±lÄ±r. Bu fonksiyon `errno` deÄŸerinin karÅŸÄ±lÄ±k geldiÄŸi hatanÄ±n aÃ§Ä±klamasÄ±nÄ± standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶ndermektedir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `fopen` ve `fclose` fonksiyonlarÄ±nÄ±n `errno` deÄŸerini deÄŸiÅŸtiren fonksiyon olduklarÄ± incelenebilir.
```C
#include <errno.h>
#include <stdio.h>

int main(void)
{
    printf("errorno = %d\n", errno);
    FILE* f = fopen("omeroylar.txt", "r"); // Okunabilecek 'omeroylar.txt' adÄ±nda bir fonksiyon olmadÄ±ÄŸÄ±nda dosya aÃ§Ä±lamayacaktÄ±r, bu durumda `fopen` fonksiyonu `errno` deÄŸerini ilgili hata koduyla deÄŸiÅŸtirecektir.
    printf("errorno = %d\n", errno);

    perror("error"); // Burada 'error: No such file or directory' yazÄ±sÄ± standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderilecektir.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `perror` fonksiyonunun kullanÄ±mÄ± incelenebilir.
```C
#include <errno.h>
#include <stdio.h>

int main(void)
{
    printf("errorno = %d\n", errno);
    FILE* f = fopen("main.c", "r"); // Burada okuma amacÄ±yla 'main.c' dosyasÄ± aÃ§Ä±lmaktadÄ±r.

    fprintf(f, "bugÄ±un pazar\n"); // Burada okuma amacÄ±yla aÃ§Ä±lan dosyaya yazma iÅŸlemi yapÄ±lmak istendiÄŸi iÃ§in hata alÄ±nacaktÄ±r.

    printf("errorno = %d\n", errno);

    perror("hata"); // Burada 'hata: Bad file descriptor' yazÄ±sÄ± standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderilecektir.
}
```


> â” 
> 
> Sorulan soru;
> 
> `errno`'nun kendisi bir makro mu?
> 
> Cevap;
> 
> `errno` bir makro ve bu makronun kendisi `extern` bildirimine aÃ§Ä±lÄ±yor, bizi ilgilendiren `errno` kullanÄ±lÄ±nca global bir deÄŸiÅŸkenin kullanÄ±lÄ±yor plmasÄ±dÄ±r. </br>
> `errno` global deÄŸiÅŸkenin kendisi deÄŸildir, o global deÄŸiÅŸkenin `extern` bildirimi yapÄ±lan global deÄŸiÅŸkene karÅŸÄ±lÄ±k gelen makrodur.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strerror` fonksiyonunun kullanÄ±mÄ± incelenebilir.
```C
#include <errno.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    FILE* f = fopen("main.c", "r"); // Burada okuma amacÄ±yla 'main.c' dosyasÄ± aÃ§Ä±lmaktadÄ±r.

    put(strerror(6)); // Buradaki kullanÄ±mda 'strerror' fonksiyonu 'errno' deÄŸerinin '6' deÄŸerine sahip olmasÄ±nÄ±n ne anlama geldiÄŸi bilgisini geriye yazÄ± olarak dÃ¶nmektedir.
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 11.46-12.05 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strerror` fonksiyonu kullanÄ±larak [0, 29] arasÄ±ndaki hata kodlarÄ±nÄ±n aÃ§Ä±klamalarÄ±nÄ±n ne olduÄŸu standart Ã§Ä±ktÄ± akÄ±mÄ±na yazdÄ±rÄ±lmaktadÄ±r.
```C
#include <errno.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    for(int i = 0; i < 30; ++i){
        printf("error value %d : %s \n", i, strerror(i);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `perror` fonksiyonunun kullanÄ±mÄ± incelenebilir.
```C
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <strlib.h> // 'strtol' kullanabilmek iÃ§in eklendi.

int main(void)
{
    const char* p = "999999999999999999999";
    char* endptr;

    // some code here ...

    errno = 0; // 'strtol' iÅŸleminde hata olup olmadÄŸÄ±nÄ± anlayabilmek iÃ§in bu deÄŸiken "0" yapÄ±lÄ±yor.
    long lval = strtol(p, &endptr, 10); // 'strtol' ile 'p' yazÄ±sÄ±nÄ±n 'long' tÃ¼rÃ¼ne Ã§evrilebilmesi iÃ§in iÅŸlem yapÄ±lÄ±yor.

    if(errno == ERANGE){
        printf("aralik disi deger\n");
    }

    if(errno){
        perror("strtol");
    }
    else if(endptr == p){
        printf("sayi elde edilemedi\n");
    }
    else{
        printf("elde edilen deger = %ld\n", lval);
    }
}
```


## `assert` Function-like Makrosu 

`assert` makrosu `assert.h` dosyasÄ±nda tanÄ±mlanmÄ±ÅŸ olan bir function-like makrdur. </br>

Programlama hatalarÄ± nasÄ±l tespit edilebilmek iÃ§in kullanÄ±lan yaklaÅŸÄ±mlar aÅŸaÄŸÄ±daki gibidir;
- Kodu yazarken hatalara yÃ¶nelik Ã¶nlem almak. Kodlama yapÄ±lÄ±rken yazÄ±lan koda Ã¶yle kodlar eklenir ki eklenen kodlarÄ±n amacÄ± iÅŸ gÃ¶rmek deÄŸil kodlama hatalarÄ± varsa o kodlama hatalarÄ±bulmaya yÃ¶nelik kodlardÄ±r.


â—â—â— Bir C programcÄ±sÄ±nÄ±n yazdÄ±ÄŸÄ± kodlar iki temel Ã¶beÄŸe ayrÄ±lmaktadÄ±r;
- DoÄŸrudan algoritmalarÄ±n gerektirdiÄŸi iÅŸi yapan kodlar.
- Ä°ÅŸ yapan kodlarda oluÅŸabilecek olan hatalarÄ± yakalamaya yÃ¶nelik yazÄ±lan kodlar. Bu tÃ¼r kodlara **Assertion Code** denilmektedir, **assert** fiilinin sÃ¶zcÃ¼k "doÄŸrulamak" anlamÄ±na gelmektedir.

â—â—â— **Assertion Code**'lar da kendi iÃ§inde iki Ã¶beÄŸe ayrÄ±lmaktadÄ±r, buradaki terimler programlama dilleri genelinde geÃ§erli terimlerdir;
- **Static Assertions** ya da **Compile Time Assertions**: YazÄ±lan kodda derleme anÄ±nda bir hata varsa hata oluÅŸacak ama kodda bir hata yoksa dermele zamanÄ±nda bir hata oluÅŸmayacaÄŸÄ± durumlarÄ± ifade eden kod doÄŸrulama yÃ¶ntemidir. C11 standardÄ±na kadar bu yaklaÅŸÄ±ma yÃ¶nelik bir araÃ§ yoktu.
- **Dynamic Assertions** ya da **Run Time Assertions**: Ã‡alÄ±ÅŸma anÄ±ndaki hatalarÄ± tespit iÃ§in kullanÄ±lan yÃ¶ntemdir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **Static Assertions** kullanÄ±mÄ±yla `int` tÃ¼rÃ¼nÃ¼n 4 byte olma ÅŸartÄ±nÄ±n saÄŸlanÄ±ÅŸÄ±nÄ±n derleme zamanÄ± hatasÄ± ile nasÄ±l saÄŸlanabildiÄŸi gÃ¶rÃ¼lebilir, bu yÃ¶ntemler mecburiyetten dolayÄ± programcÄ±lar tarafÄ±ndan uydurulan kÃ¶tÃ¼ yÃ¶ntemlerdir.
```C
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <strlib.h> // 'strtol' kullanabilmek iÃ§in eklendi.

// C dilinin sÃ¶zdizim kuralÄ± olarak bir dizinin boyutu "0" olamaz.
int ary1_[sizeof(int) == 4]; // Derleyicide 'int' tÃ¼rÃ¼ 4 byte deÄŸil ise derleme hatasÄ± alÄ±nacaktÄ±r.

int ary2_[sizeof(long) == 8]; // Derleyicide 'long' tÃ¼rÃ¼ 4 byte deÄŸil ise derleme hatasÄ± alÄ±nacaktÄ±r(Microsolt derleyicisinde 'long' tÃ¼rÃ¼).

typedef int asr_0[sizeof(int) == 4]; // Derleyicide 'int' tÃ¼rÃ¼ 4 byte deÄŸil ise derleme hatasÄ± alÄ±nacaktÄ±r.

int main(void)
{
    // some code here ...
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda C11 ile dile eklenen **Static Assertions** kullanÄ±mÄ± incelenebilir.
```C
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <strlib.h>

_Static_assert(sizeof(int) == 4, "int tutu 4 byte olmali"); // Bu kullanÄ±m C11 ile dile eklenen 'Static Assertions' aracÄ±nÄ±n kullanÄ±mÄ± incelenebilir, bu yÃ¶ntem standart bir yÃ¶ntemdir.

int main(void)
{
    // some code here ...
}
```


### Dynamic Assertion Ä°le YapÄ±lan Ã‡alÄ±ÅŸma ZamanÄ± HatalarÄ±nÄ±nn YakalanmasÄ± 

ğŸ‘‡ AÅŸaÄŸÄ±daki programda **Dynamic Assertions** ile Ã§alÄ±ÅŸma zamanÄ± hatalarÄ±nÄ± tespit etmek iÃ§in kullanÄ±lan basit bir yÃ¶ntem incelenebilir, bu yÃ¶ntemin kullanÄ±mÄ± doÄŸru deÄŸildir Ã§Ã¼nkÃ¼ koda bakar bakmaz **Dynamic Assertions** kodu olup olmadÄ±ÄŸÄ± hemen anlaÅŸÄ±lmÄ±yor ve baÅŸka Ã¶nemli bir sorun da **assertions** kodlarÄ±nÄ±n hata arama aÅŸamasÄ± sona erdikten sonra derlenecek kodda olmasÄ±nÄ±n istenmemesidir bu yÃ¶ntemi kullanÄ±nca **assertions** kodlarÄ±nÄ± programdan kolayca Ã§Ä±kartamayÄ±yoruz.
```C
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <strlib.h>

int foo(int x)
{
    // Projedeki kodlama hatasÄ±nÄ± yakalamaya yÃ¶nelik bir kod yazÄ±yoruz.
    if(x == 0){
        printf("foo fonksiyonunda hata x == 0\n");
        abrot(); // Ã‡alÄ±ÅŸma zamanÄ± oluÅŸabilecek hata oluÅŸur oluÅŸmaz program hemen sonlandÄ±rÄ±lacaktÄ±r, 
    }

    // some code here ...

    return 21;
}


int main(void)
{
    int* ptr = NULL;

    // some code here ...

    if(ptr == NULL){
        // ...
        abort();
    }

    int x = *ptr;
}
```



**Dynamic Assertions** yapabilmek iÃ§in C dilinin standardÄ± bir function-like makro saÄŸlamaktadÄ±r, C dilinin Ã¶nemli baÅŸlÄ±k dosyalarÄ±ndan biri `assert.h` baÅŸlÄ±k dosyasÄ±dÄ±r, tÃ¼m derleyiciler `assert` adÄ±nda bir function-like makro saÄŸlamak zorundadÄ±r.

ğŸ‘‡ AÅŸaÄŸÄ±daki programda C dilinin standardÄ±nda olan `assert` adÄ±ndaki funciton-like makrosunun kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <assert.h>
#include <stdio.h>

void foo(int x)
{
    assert(x != 0); // Buradaki 'assert' bir function-like mokro'dur, 'x' deÄŸiÅŸkeninin deÄŸeri '0' deÄŸerinden farklÄ± olduÄŸunda hata oluÅŸacak ve programÄ±n akÄ±ÅŸÄ± kesilip hata iletisi verilecektir.
    x++;
}


int main(void)
{
    foo(1);
    printf("main devam ediyor ...\n");
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda C dilinin standardÄ±nda olan `assert` adÄ±ndaki funciton-like makrosunun kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#define NDEBUG // Bu bildirim ile koddaki tÃ¼m `assert` kullanÄ±mlarÄ± devredÄ±ÅŸÄ± bÄ±rakÄ±lmÄ±ÅŸ olur
#include <assert.h>
#include <stdio.h>

void foo(int x)
{
    assert(x != 0); // Buradaki kod '#define NDEBUG' bildiriminden dolayÄ± '(void)0' olarak aÃ§Ä±lacaktÄ±r, bu iÅŸlevsiz bir koddur.
    // x++;
}


int main(void)
{
    foo(1);
    printf("main devam ediyor ...\n");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±da `assert` makrosunun gerÃ§ekleÅŸtirimini derleyiciler yapmaktadÄ±r, her derleyici kendine gÃ¶re bir tane gerleÅŸtirim yapar, olabilecek en basit `assert` makrosu aÅŸaÄŸÄ±daki gibi olabilir;
```C
//sample assert macro implementation

#include <stdio.h>

#ifndef NDEBUG
#define ASSERT (EXPR) (                           \
    (EXPR)? (void)0: (                            \
        printf("%s:%d: failed assertion '%s' \n", \
        __FILE__, __LINE__, #EXPR                 \
        ),                                        \
        abort()                                   \
    ))                                            \
#else                                             \
#define ASSERT(EXPR) ((void)0)                    \
#endif /* NDEBUG */                               \
```


`assert` makrosu kodlarda run-time hata sÄ±namalarÄ±nÄ± yapabilmek iÃ§in gereken yerlerde kullanÄ±lmalÄ±dÄ±r, bazÄ± programcÄ±lar `assert` makrosunu bilmedikleri iÃ§in Ã§alÄ±ÅŸma zamanÄ± hatalarÄ±nÄ± tespit edebilmek iÃ§in farklÄ± yÃ¶ntemler kullanabiliyormuÅŸ, `assert` makrosunu Ã¶ÄŸrenip gerektiÄŸi yerlerde kullanmak doÄŸru yaklaÅŸÄ±m olacaktÄ±r.



***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 13.04-12.15 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


`assert` makrosunun kullanÄ±mÄ±nda yapÄ±labilecek iki hatadan biri yan etkisi olan ifadelerin `assert` makrosuyla birlikte kullanÄ±lmasÄ±dÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `assert` makrosuna verilen ifadenin yan etkiye sahip olan bir ifade olmasÄ±ndan kaÃ§Ä±nÄ±lmasÄ± gerektiÄŸi durum incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

// #define NDEBUG // Bu bildirim ile koddaki tÃ¼m `assert` kullanÄ±mlarÄ± devredÄ±ÅŸÄ± bÄ±rakÄ±lmÄ±ÅŸ olur
#include <assert.h>
#include <stdio.h>

int main(void)
{
    int cnt = 10;

    // ...

    --cnt;
    assert(cnt > 0);

    // assert(--cnt > 0); // 'assert' maktosuna yan etkisi olan ifade verilmiÅŸ, bÃ¶yle kullanÄ±mlardan kaÃ§Ä±nÄ±lmalÄ±dÄ±r, buradaki statement yukarÄ±daki gibi iki farklÄ± statement olarak kullanÄ±mÄ± daha doÄŸrudur.
}
```


`assert` makrosunun kullanÄ±mÄ±nda yapÄ±labilecek iki hatadan diÄŸeri, `assert` makrosuyla birlikte `&&` operatÃ¶rÃ¼nÃ¼n dikkatli biÃ§imde kullanÄ±lmamasÄ±dÄ±r, `&&` operatÃ¶rÃ¼ kÄ±sa devre davranÄ±ÅŸÄ±na sahip olduÄŸu iÃ§in hata oluÅŸtuÄŸu durumda hata nedeninin tespiti zor olabileceÄŸi iÃ§in kullanÄ±mÄ±n adikkate etmek gerekmektedir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `assert` makrosuna verilen ifadenin `&&` operatÃ¶rÃ¼nÃ¼ iÃ§ermesi durumunda dikkat edilmesi gereken drumlar incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

// #define NDEBUG // Bu bildirim ile koddaki tÃ¼m `assert` kullanÄ±mlarÄ± devredÄ±ÅŸÄ± bÄ±rakÄ±lmÄ±ÅŸ olur
#include <assert.h>
#include <stdio.h>

void func(int x)
{
    assert(x > 0 && x < 100); // Buradaki gibi bir kullanÄ±m uygulanabilir Ã§Ã¼nkÃ¼ 'x'in deÄŸer aralÄ±ÄŸÄ± sÄ±nanmaktadÄ±r.
}

void foo(const int* p, size_t size)
{
    assert(p != NULL);
    assert(size > 10);

    // assert(p != NULL && size > 10); // Buradaki gibi tek `assert` ile iki farklÄ± ifadenin doÄŸruluÄŸu sÄ±nanmamalÄ±dÄ±r., bunun yerine iki farklÄ± 'assert' ile sÄ±nama iÅŸlemi yapÄ±lmalÄ±dÄ±r.
}

int main(void)
{
    // ...     
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `assert` makrosunun kullanÄ±mÄ±nÄ±n geniÅŸletimi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

// #define NDEBUG // Bu bildirim ile koddaki tÃ¼m `assert` kullanÄ±mlarÄ± devredÄ±ÅŸÄ± bÄ±rakÄ±lmÄ±ÅŸ olur
#include <assert.h>
#include <stdio.h>

#define assert_msg(MSG, EXPR)       assert((MSG, (EXPR))) // Burada iki farklÄ± yazÄ±nÄ±n yan yana konulmasÄ± sonucunda derleyicinin o yazÄ±larÄ± tek bir yazÄ± olarak birleÅŸtirmesinden yararlanarak `assert` makrosuna Ã¶zel bir yazÄ± eklenebilir surette kullanÄ±labilir hale getiren `assert_msg` makrosu bildirilmiÅŸtir.

int main(void)
{
    int x = 5;

    assert_msg("invariant not hold: ", x > 10);
}
```


## C99 StandardÄ± ve Bu Standart ile Gelen Eklemeler 

Bu baÅŸlÄ±k altÄ±nda C diline C99 standardÄ± ile eklenen yenilikleri inceleyeceÄŸiz.

Gelen yeniliklerin bir bÃ¶lÃ¼mÃ¼nÃ¼ aÅŸaÄŸÄ±daki gibi listeleyelim;
- `//` tek satÄ±r yorum satÄ±rÄ± kullanÄ±mÄ± C99 ile dile eklenmiÅŸtir.
- `for(int i = ; ...)` biÃ§iminde `for` ifadesi iÃ§inde object(nesne) tanÄ±mlanabilmesi Ã¶zelliÄŸi C99 ile dile eklenmiÅŸtir.
- C89 standardÄ±nda bir blok iÃ§inde yapÄ±lan bildirimlerin executable bir statemnet kullanÄ±lmadan Ã¶nce yapÄ±lmÄ±ÅŸ olma zorunluluÄŸu vardÄ±r, C99 ile bu dilden kaldÄ±rÄ±ldÄ±. 
    ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki kullanÄ±m C89 standardÄ±nda sÃ¶zdizim hatasÄ±ydÄ± C99 ile hata olmaktan Ã§Ä±kartÄ±ldÄ±.
    ```C
    #include <stdio.h>

    int main(void)
    {
        printf("naber\n");
        int x = 10; // Buradaki deÄŸiÅŸken bildiriminden bir Ã¶nceki statement bir executable statement olduÄŸu iÃ§in C89 standardÄ±nda bu kullanÄ±m derleme hatasÄ±na neden olur.
    }
    ```
- `for` dÃ¶ngÃ¼sÃ¼ne dair garip bir durum aÅŸaÄŸÄ±daki programdan incelenebilir. 
    ğŸ‘‡ AÅŸaÄŸÄ±daki programda `for` dÃ¶ngÃ¼sÃ¼ne Ã¶zgÃ¼ olan olan Ã¶zel bir durum incelenebilir.
    ```C
    #include <stdio.h>

    int main(void)
    {
        for(int i = 0; i < 10; ++i){
            int i = 342; // C dilinde bu tanÄ±mlama legaldir ve dÃ¶ngÃ¼nÃ¼n iÃ§ bloÄŸunda bildirilen bir deÄŸiÅŸkendir, buradaki 'i' deÄŸiÅŸkeni dÃ¶ngÃ¼nÃ¼n sayaÃ§ deÄŸiÅŸkenine 'name hiding' uygulayacaktÄ±r, C++ dilinde sÃ¶zdizim hatasÄ±dÄ±r.
            printf("i = %d", i);
        }
    }
    ```
- `long long` ve `_Bool` tÃ¼rleri C99 standardÄ±yla birlikte C diline eklenmiÅŸtir. 
- **VLA(Varible Length Array)**
- **Compound Literals**
- **Flexible Array Members**
- **Designated Initializers**
- **Restrict**


> â” 
> 
> Sorulan soru;
> 
> `long long` tÃ¼rÃ¼ne sÄ±ÄŸmayan bir tam sayÄ± olduÄŸunda bunu saklamak iÃ§in dizi gibi bir araÃ§ mÄ± kullanÄ±lmalÄ±?
> 
> Cevap;
> 
> Bu gÃ¼zel bir soru. </br>
> Bu durumda farklÄ± Ã§Ã¶zÃ¼mler olabilir; </br>
> 1. Derleyicilerin genellikle **extension** olarak saÄŸladÄ±ÄŸÄ± 128 bitlik tam sayÄ± deÄŸiÅŸken tÃ¼rÃ¼ kullanÄ±labilir, bu yÃ¶ntemde kodun taÅŸÄ±nabilirlik sorunu olabilir. </br>
> 2. BÃ¼yÃ¼k tam sayÄ±larÄ± tutmayÄ± saÄŸlayabilecek **user defined type** deÄŸiÅŸkenler oluÅŸturulup kullanÄ±labilir, bunun iÃ§in ayrÄ±ca bir Ã§ok aÃ§Ä±k kaynak olarak oluÅŸturulmuÅŸ Ã¼Ã§Ã¼ncÃ¼ taraf kÃ¼tÃ¼pheneler mevcuttur.


### VLA(Varible length array) 

Bu Ã¶zellik C99 ile dile eklendi ve C11 ile opsional hale getirildi, 

ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki **VLA** kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 10;

    int ary[x]; // 'VLA' Ã¶zelliÄŸini destekleyen bir derleyici burada sÃ¶zdizim hatasÄ± vermeyecektir.
}
```


ğŸš€ **VLA(Varible length array)** Ã¶zelliÄŸinin gerÃ§ekleÅŸtirildiÄŸi derleyicilerde bu diziler yine **automatic storage duration** deÄŸiÅŸkenlerin yer aldÄ±ÄŸÄ± bellek alanÄ±nda yer alacaktÄ±r, bunu yapmak iÃ§in standart bir C fonksiyonu bulunmuyor ama **Unix/Linux** sistemlerde `alloca` adÄ±nda **Posix**(Posix farklÄ± kdemelerden oluÅŸan **Unix/Linux** sistemler iÃ§in geliÅŸtirilmiÅŸ bir standarttÄ±r) fonksiyonu vardÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki **VLA** kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int row, col;

    printf("matrisin satir ve sutun sayisi: "); 
    scanf("%d %d", &row, &col);
    int cnt = 0;

    int ar[row][col];
    
    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile iki boyutlu dizinin elemanlarÄ±na deÄŸer atanmaktadÄ±r.
    for (int i = 0; i < row; ++i) {
        for (int j = 0; j < col; ++j) { 
            ar[i][j] = cnt++;
        }
    }

    printf("\n");
    
    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile iki boyutlu dizi yazdÄ±rÄ±lmaktadÄ±r.
    for (int i = 0; i < row; ++i) {
        for (int j = 0; j < col; ++j) { 
            printf("%d ", ar[i][j]);
        }
        printf("\n");
    }
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki **VLA** kullanÄ±mÄ±nda deÄŸiÅŸken boyutlu dizilere ilk deÄŸer verilemediÄŸi incelenebilir, verilmesi sÃ¶zdizim hatasÄ±na neden olur. AÅŸaÄŸÄ±daki program Gcc ve Clang derleyicilerinde Ã§alÄ±ÅŸÄ±r ama Microsoft derleyicisinde Ã§alÄ±ÅŸmayacaktÄ±r.
```C
#include <stdio.h>

int main(void)
{
    int x = 5;
    int ary[x] = { 2, 5, 7, 8, 4, };
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda median deÄŸerinin iki farklÄ± yolla nasÄ±l hesaplandÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>

int icmp(const void* vp1, const void* vp2)
{
    return *(const void*)vp1 - *(const void*)vp2;
}

// AÅŸaÄŸÄ±daki fonksiyon bir tam sayÄ± dizisinin sÄ±ralandÄ±ktan sonra ortasÄ±ndaki median deÄŸerini geriye 'dinamic memory managament' kullanÄ±larak dÃ¶nmektedir.
int get_median(const int* p, size_t size)
{
    int *pd = (int*)malloc(size * sizeof(int));
    if(!pd){
        fprintf(stderr, "cannot allocate memory!\n");
        exit(EXIT_FAILURE);
    }

    memcpy(pd, p, size * sizeof(int));
    qsort(pd, sizeof(int), &icmp);
    int retval = pd[size / 2];

    free(pd);

    return retval;
}

// AÅŸaÄŸÄ±daki fonksiyon bir tam sayÄ± dizisinin sÄ±ralandÄ±ktan sonra ortasÄ±ndaki median deÄŸerini geriye 'VLA' kullanÄ±larak dÃ¶nmektedir.
int get_median2(const int* p, size_t size)
{
    int ar[size];

    memcpy(ar, p, size * sizeof(int));
    qsort(ar, sizeof(int), &icmp);

    return ar[size / 2];
}

int main(void)
{
    
}
```


Ders sonu ...
