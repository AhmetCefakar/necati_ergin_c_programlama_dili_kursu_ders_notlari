# 54.Ders 20.07.2025 ğŸ•˜

Derse 4(09:01)-5(09:25)-6(09:48)-7(10:15)-6(10:55)-7(10:57) kiÅŸi katÄ±ldÄ±.
---


## `remove` ve `rename` FonksiyonlarÄ±

`remove` fonksiyonunun prototipi `int remove(const char* filename);` biÃ§imindedir, bu fonksiyon bir dosyayÄ± silme iÅŸlemini gerÃ§ekleÅŸtirmektedir. Bu fonksiyon dosya silme iÅŸlemini baÅŸarÄ±lÄ± biÃ§imde yaparsa geriye `0` deÄŸerini dÃ¶ndÃ¼rÃ¼yor, silme iÅŸlemi baÅŸarÄ±sÄ±z olursa `-1` deÄŸerini dÃ¶ndÃ¼rÃ¼yor. </br>
`rename` fonksiyonunun prototipi `int rename(const char* oldname, const char* newnme);` biÃ§imindedir, bu fonksiyon dosya adÄ±nÄ± deÄŸiÅŸtirme iÅŸlemini gerÃ§ekleÅŸtirmektedir. Bu fonksiyon bir dosyanÄ±n adÄ±nÄ± eÄŸiÅŸtirme iÅŸlemini baÅŸarÄ±lÄ± biÃ§imde yaparsa geriye `0` deÄŸerini dÃ¶ndÃ¼rÃ¼yor, bir dosyanÄ±n adÄ±nÄ± eÄŸiÅŸtirme iÅŸleminde baÅŸarÄ±sÄ±z olursa `-1` deÄŸerini dÃ¶ndÃ¼rÃ¼yor. </br>

Ä°ÅŸletim sistemlerinin Ã§oÄŸunda bir dosyanÄ±n silinmesi iÃ§in ve dosyanÄ±n adÄ±nÄ±n deÄŸiÅŸtirilmesi iÃ§in dosyanÄ±n kapalÄ± olmasÄ± gerekiyor, aÃ§Ä±k bir dosyanÄ±n silinmeye Ã§alÄ±ÅŸÄ±lmasÄ± ya da adÄ±nÄ±n deÄŸiÅŸtirilmeye Ã§alÄ±ÅŸÄ±lmasÄ± iÅŸlemi baÅŸarÄ±sÄ±z olur, ama bu sonuÃ§ta programÄ±n Ã¼zerinde Ã§aÄ±ÅŸacaÄŸÄ± sisteme baÄŸlÄ±dÄ±r. 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir dosyayÄ± silme iÅŸlemini yapan program incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int result = remove("METE_HAN.txt");

    printf("result = %d", result);

    if(result){
        printf("dosya silindi.\n");
    }
    else{
        printf("dosya silinemedi.\n");
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir dosyanÄ±n adÄ±nÄ±n deÄŸiÅŸtirilmesi iÅŸlemini yapan program incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    if(rename("notlar.txt", "notes.txt")){
        printf("dosya adi degistirilemedi.\n");
    }
    else{
        printf("dosya adi degistirildi.\n");
    }
}
```


ğŸ‘‡ Komut satÄ±rÄ±ndan Ã§alÄ±ÅŸtÄ±rÄ±lan dosya "mete.exe" 1000 byte parÃ§aya ayrÄ±lacak, mesela 14512 byte boyutundaki bir dosya 14 tane 1000 byte'lÄ±k ve bir tane 512 byte'lÄ±k dosyadan oluÅŸacak, ardÄ±ndan bu parÃ§alarÄ± birleÅŸtirecek bir program aÅŸaÄŸÄ±daki gibi yazÄ±labilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir dosyayÄ± belirli boyutta parÃ§alara bÃ¶len program incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

#define MAX_FILENAME_LEN    80

int main(int argc, char **argv)
{
    if(argc != 3){
        printf("kullanim: <dosbol> <dosya adi> <parca byte sayisi>\n");
        return 1;
    }
    
    FILE* fs = fopen(argv[1], "rb");
    if(!fs){
        printf("%s dosya acilamadi.\n", argv[1]);
        return 2;
    }

    int chunk = atoi(argv[2]);
    int file_count = 0;
    int byte_count = 0;
    int c;
    FILE* fd = NULL;
    char dest_file_name[MAX_FILENAME_LEN + 1];

    while((c = fgetc(fs)) != EOF){
        if(fd == NULL){
            sprintf(dest_file_name, "parca%03d.par", file_count + 1);
            fd = fopen(dest_file_name, "wb");

            if(!fd){
                printf("%s dosyasi olusturulamadi.\n", dest_file_name);
                fclose(fs);
                return 3;
            }

            ++file_count;
        }

        fputc(c, fd);

        ++byte_count;

        if(byte_count % chunk == 0){
            fclose(fd);
            fd = NULL;
        }
    }

    fclose(fs);
    if(fd)
        fclose(fd);

    printf("%d byte'lik %s adli dosya %d byte'lik %d parcaya bolundu.\n", byte_count, argv[1], chunk, file_count);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda parÃ§alara bÃ¶lÃ¼nmÃ¼ÅŸ bir dosyanÄ±n yeniden birleÅŸtirilmesi iÅŸlemini yapan program incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

#define MAX_FILENAME_LEN    80

int main(int argc, char **argv)
{
    if(argc != 2){
        printf("kullanim: <dosbil> <dosya adi>\n");
        return 1;
    }

    // Yazma amaÃ§lÄ± dosya oluÅŸturuluyor, bu dosya birleÅŸtirme iÅŸlemiyle tek parÃ§a yapÄ±lacak dosyadÄ±r.
    FILE* fd = fopen(argv[1], "wb");
    if(!fd){
        printf("%s dosyasi olusturulamadi.\n", argv[1]);
        return 2;
    }
    
    FILE* fs;
    int file_count = 0;
    int byte_count = 0;
    char source_file_name[MAX_FILENAME_LEN + 1];
    int c;

    for(;;){ // Sonsuz dÃ¶ngÃ¼ kullanÄ±ldÄ±.
        sprintf(source_file_name, "parca%03d.par", file_count + 1);
        fs = fopen(source_filename, "rb");
        
        if(!fs)
            break;
        while((c = fgetc(fs)) != EOF){
            fputc(c, fd);
            ++byte_count;
        }

        fclose(fd);

        // BirleÅŸtirilen dosya parÃ§asÄ± siliniyor.
        if(remove(source_filename)){
            printf("%s dosyasi silinemedi.\n", source_filename);
            fclose(fd);
            return 3;
        }

        ++file_count;
    }

    fclose(fd);
    printf("%d adet dosya %d byte'lik %s dosyasi olarak birlestirildi.\n", file_count, byte_count, argv[1]);
}
```

## `tmpnam` Fonksiyonu 

`tmpnam` fonksiyonunun prototipi `char* tmpnam(char*);` biÃ§imindedir, bu fonksiyon rastgele eÅŸsiz bir dosya adÄ± bilgisi dÃ¶ndÃ¼rÃ¼r.

â—â—â— Yazma amaÃ§lÄ± bir dosya oluÅŸturulduÄŸu zaman oluÅŸturulan dizinde aynÄ± ada sahip baÅŸka bir dosya olmasÄ± durumunu Ã¶nlemek iÃ§in ÅŸu yollar denenebilir;
1. Ã–ncelikle dosya okuma amaÃ§lÄ± aÃ§Ä±lmaya Ã§alÄ±ÅŸÄ±lÄ±r, dosya aÃ§Ä±lmÄ±yorsa dosyanÄ±n olmadÄ±ÄŸÄ± anlamÄ±na gelebilir fakat bu yÃ¶ntem %100 Ã§alÄ±ÅŸmayacaktÄ±r Ã§Ã¼nkÃ¼ dosya baÅŸka nedenlerden dolayÄ± aÃ§Ä±lmayabilir.
2. Ä°ÅŸletim sistemlerinin "**Unique Filename Generator**" olarak adlnadÄ±rÄ±lan bir dizinde dosya oluÅŸtururken var olan bir dosyayÄ± ezmemek iÃ§in bir dosya adÄ± Ã¶neren bir fonksiyon bulunuyor, C dilinin standardÄ±nda de iÅŸletim sisteminin bu fonksiyonunu sarmalayan `tmpnam` fonksiyonu vardÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda parÃ§alara bÃ¶lÃ¼nmÃ¼ÅŸ bir dosyanÄ±n yeniden birleÅŸtirilmesi iÅŸlemini yapan program incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

#define MAX_FILENAME_LEN    80

int main(void)
{
    char filename[L_tmpnam]; // 'L_tmpnam' makrosu 'tmpnam' fonksiyonundan dÃ¶necen olan bir dosyanÄ±n adÄ± olabilecek eÅŸsiz bir yazÄ±nÄ±n taÅŸma hatasÄ± olmayacaÄŸÄ± kadar bÃ¼yÃ¼k bir deÄŸerdir.

    tmpnam(filename); // EÅŸsiz bir dosya adÄ± yazÄ±sÄ± 'filename' dizisine yÄŸklenecektir.

    puts(filename);
}
```

## Basit Bir Åifreleme AlgoritmasÄ± KullanÄ±mÄ± 

Bu baÅŸlÄ±k altÄ±nda basit bir ÅŸifreleme algoritmasÄ± ile bir dosyanÄ±n ÅŸifreleyelim.



ğŸ‘‡ AÅŸaÄŸÄ±daki program basit bir ÅŸifreleme algoritmasÄ±yla bir dosyanÄ±n nasÄ±l ÅŸifrelendiÄŸini anlamak iÃ§in incelenebilir(aynÄ± program ÅŸifre Ã§Ã¶zme iÅŸlemi de yapÄ±labilmektedir).
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

#define MAX_FILENAME_LEN    80

int main(int argc, char **argv)
{
    if(argc != 3){
        printf("usage: <encfile> <filename> <psw>\n");
        return 1;
    }

    FILE* fs = fopen(argv[1], "rb");
    if(!fs){
        printf("cannot open file %s.\n", argv[1]);
        return 2;
    }

    char temp_file_name[L_tmpnam];
    tmpnam(temp_file_name);

    FILE* fd fopen(temp_file_name, "wb");
    if(!fd) {
        printf("cannot create temporary file!\n");
        fclose(fs);
        return 3;
    }

    unsigned int seed = (unsigned int)strtoul(argv[2], NULL, 10);
    srand(seed);

    int c;

    while((c =fgets(fs)) != EOF){
        fputc(c ^ rand(), fd);
    }

    fclose(fs);
    fclose(fd);

    if(remove(argv[1])){
        printf("%s dosyasi silinemedi.\n", argv[1]);
        _fcloseall(); // Standart olmayan ilgili process'in kullandÄ±ÄŸÄ± tÃ¼m aÃ§Ä±k dosyalarÄ± kapatan fonksiyona Ã§aÄŸrÄ± yapÄ±lÄ±yor.
        return 4;
    }
    
    if(rename(temp_file_name, argv[1])){
        printf("ad degisikligi yapilamadi.\n");
        _fcloseall(); // Standart olmayan ilgili process'in kullandÄ±ÄŸÄ± tÃ¼m aÃ§Ä±k dosyalarÄ± kapatan fonksiyona Ã§aÄŸrÄ± yapÄ±lÄ±yor.
        return 4;
    }
}
```


## `fprintf` Fonksiyonu ile Dosyadan FormatlÄ± Okuma ve Yazma Ä°ÅŸlemleri 

`fprintf` fonksiyonunun prototipi `int fprintf(FILE*, const char* pfm, ...);` biÃ§imindedir, bu fonksiyon bir dosyaya formatlÄ± olarak yazma iÅŸlemini yapmak iÃ§in kullanÄ±lmaktadÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda sade biÃ§imde bir dosyaya formatlÄ± yazma iÅŸleminin nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenbilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    FILE* fd = fopen("out.txt", "w");
    if(!fd){
        printf("dosya olusturulamadi.\n");
        return 1;
    }

    for(int i = 0; i < 10; ++i){
        fpintf(fd, "%d * %d = %d", i, i , i * i); // Dosyaya formatlÄ± yazdÄ±rma iÅŸlemi yapÄ±lÄ±yor.
    }

    fclose(fd);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda ilk bir milyon asal sayÄ±yÄ± "asal1000000.txt" adÄ±ndaki bir dosyaya formatlÄ± olarak her satÄ±rsa on asal sayÄ± olacak biÃ§imde yazdÄ±rÄ±lÄ±ÅŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int n;
    char filename[40];

    printf("ilk kac asal sayi:\n");
    scanf("%d", &n);
    sprintf(filename, "asal%d.txt", n);

    FILE* fd = fopen(filename, "w");

    if(!fd){
        printf("dosya olustutulamadi.\n");
        return 1;
    }

    int x = 2;
    int prime_count = 0;
    
    while(prime_count < n){
        if(isprime(x)){
            if(prime_count && prime_count % 10 == 0){
                fprintf(fd, "\n");    
            }
            
            fprintf(fd, "%12d ", x);
            ++prime_count;
        }
        ++x;
    }

    close(fd);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã¼retilen rastgele kullanÄ±cÄ± bilgilerinin bir dosyaya nasÄ±l kaydedildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

int main(void)
{    
    int n;
    char filename[40];

    printf("kac kayit.\n");
    scanf("%d", &n);
    sprintf(filename, "kayit%d.txt", n);

    FILE* fd = fopen(filename, "w");

    if(!fd){
        printf("dosya olustutulamadi.\n");
        return 1;
    }

    for(int i = 0; i < n; ++i){
        fprintf(fd, "%d %s %s %d\n", rand(), random_name(), random_surname(), rand() % 101);
    }

    close(fd);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã¼retilen rastgele kullanÄ±cÄ± bilgilerinin bir dosyaya nasÄ±l kaydedildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

int main(void)
{
    int n;
    char filename[40];

    printf("kac kayit.\n");
    scanf("%d", &n);
    sprintf(filename, "kayit%d.txt", n);

    FILE* fd = fopen(filename, "w");

    if(!fd){
        printf("dosya olustutulamadi.\n");
        return 1;
    }

    for(int i = 0; i < n; ++i){
        fprintf(fd, "%-8d %-16s %-20s %d\n", rand(), random_name(), random_surname(), rand() % 101);
    }

    close(fd);
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.27-10.56 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


## `fscanf` Fonksiyonu 

`fscanf` fonksiyonunun prototipi `int fscanf(FILE*, const char* pfm, ...);` biÃ§imindedir, bu fonksiyon dosyadan okuma iÅŸlemleri iÃ§in kullanÄ±lmaktadÄ±r.

`scanf` fonksiyonu standart giriÅŸ akÄ±mÄ±ndan, `sscanf` fonksiyonu bellekten, `fscanf` fonksiyonu da dosyadan okuma yapmak iÃ§in kullanÄ±lmaktadÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã¶nceden oluÅŸturulmuÅŸ ve iÃ§eriÄŸinde asal sayÄ±lar bulunan bir dosyadan okuma iÅŸleminin nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

int main(void)
{
    FILE* fs = fopen("asal100.txt", "r");

    if(!fs){
        printf("cannot open file.\n");
        return 1;
    }

    int x, y, z;
    int result = fscanf(fs, "%d%d%d", &x, &y, &z);

    printf("result = %d\n", result);
    printf("x = %d\n", x);
    printf("x = %d\n", y);
    printf("x = %d\n", z);

    close(fs);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã¶nceden oluÅŸturulmuÅŸ ve iÃ§eriÄŸinde asal sayÄ±lar bulunan bir dosyadan tek tek bir tam sayÄ± okunup standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderilme iÅŸleminin nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // '_getch' kullanÄ±mÄ± iÃ§in eklendi.
#include "nutility.h"

int main(void)
{
    FILE* fs = fopen("asal100.txt", "r");

    if(!fs){
        printf("cannot open file.\n");
        return 1;
    }

    int x;

    while(fscanf(fs, "%d", &x) != EOF){
        printf("%d\n", x);
        _getch(); // Standart olmayan Microsoft derleyicisnin fonksiyonu.
    }    
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã¶nceden oluÅŸturulmuÅŸ ve iÃ§eriÄŸinde kullanÄ±cÄ± bilgileri bulunan bir dosyadan her dÃ¶ngÃ¼ adÄ±mÄ±nda bir kullanÄ±cÄ± bilgisi okunup standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderilme iÅŸleminin nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // '_getch' kullanÄ±mÄ± iÃ§in eklendi.
#include "nutility.h"

int main(void)
{
    FILE* fs = fopen("kayit500.txt", "r");

    if(!fs){
        printf("cannot open file.\n");
        return 1;
    }

    int id;
    char name[20];
    char surname[20];
    int grade;

    while(fscanf(fs, "%d%s%s%d", &id, name, surname, &grade) != EOF){
        printf("%-5d %-16s %-20s %d\n", id, name, surname, grade);
        _getch(); // Standart olmayan Microsoft derleyicisnin fonksiyonu.
    }    
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã¶nceden oluÅŸturulmuÅŸ ve iÃ§eriÄŸinde kullanÄ±cÄ± bilgileri bulunan bir dosyadan her dÃ¶ngÃ¼ adÄ±mÄ±nda bir kullanÄ±cÄ± bilgisi okunup standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderilme iÅŸleminin nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // '_getch' kullanÄ±mÄ± iÃ§in eklendi.
#include "nutility.h"

int main(void)
{
    FILE* fs = fopen("kayit500.txt", "r");

    if(!fs){
        printf("cannot open file.\n");
        return 1;
    }

    int id;
    char name[20];
    char surname[20];
    int grade;

    int grade_entry;
    char name_entry;

    printf("ad ve not girin: ");
    scanf("%s%d", name_entry, &grade_entry);

    while(fscanf(fs, "%d%s%s%d", &id, name, surname, &grade) != EOF){
        if(grade_entry == grade && !strcmp(name, name_entry)){
            printf("%-5d %-16s %-20s %d\n", id, name, surname, grade);
            _getch(); // Standart olmayan Microsoft derleyicisnin fonksiyonu.
        }
    }
}
```



MÃ¼lakat sorusu; </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda her satÄ±rda Ã¶ÄŸrenci bilgileriyle birlikte not bilgisi yeralan bir dosyadan okunan Ã¶ÄŸrencilerin bilgilerinin aldÄ±klarÄ± notlara uygun dosyalara nasÄ±l yazdÄ±rÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // '_getch' kullanÄ±mÄ± iÃ§in eklendi.
#include "nutility.h"

int main(void)
{
    FILE* fa[101];
    char filename[20];

    FILE* fs = fopen("kayit1000000.txt", "r");
    if(!fs){
        printf("dosya acilmadi.\n");
        return 1;
    }

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ Ã¶ÄŸrenci notlarÄ±na gÃ¶re Ã¶ÄŸrencileri uygun dosyalara yazacak olan dosyalarÄ± oluÅŸturmaktadÄ±r.
    for(int i = 0; i < 101; ++i){
        sprint(filename, "not%03d.txt", i);
        fa[i] = fopen(filename, "w");

        if(!fa[i]){
            printf("%s dosyasi olusmadi\n", filename);
            return 1;
        }
    }

    char id[13], name[17], surname[20];
    int grade; // Not bilgisini tutacak deÄŸiÅŸken.

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile her bir Ã¶ÄŸrenci sahipolduÄŸu not bilgisine gÃ¶re uygun olan dosyaya yazÄ±lÄ±yor.
    while(fscanf(fs, "%s%s%s%d", id, name, surname, &grade) != EOF){
        fprintf(fa[grade], "%-13s %-17s %-20s %d\n", id, name, surname, grade);
    }

    int result = fcloseall();

    printf("toplam %d dosya kapatildi.\n", result);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir dosyadan tam sayÄ±larÄ±n nasÄ±l okunduÄŸu incelenebilir, bu programda sonsuz dÃ¶ngÃ¼ye giriliyor.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // '_getch' kullanÄ±mÄ± iÃ§in eklendi.
#include "nutility.h"

int main(void)
{
    FILE* f = fopen("out.txt", "r"); // 'out.txt' dosyasÄ±nÄ±n iÃ§eriÄŸi '23 45 67 atilla 98 23 55 bora 77 456 yagiz 90 91 867 979'
    if(!f){
        printf("dosya acilmadi.\n");
        return 1;
    }

    int x;

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ 'out.txt' dosyasÄ±nÄ±n iÃ§eriÄŸinden dolayÄ± '67' deÄŸerini okuduktan sonra gelen bir sayÄ± deÄŸil de bir yazÄ± olduÄŸu iÃ§in 'fscanf 'fonksiyonu '0' sonucu dÃ¶nÃ¼yor bundan dolayÄ± da sonsuz dÃ¶ngÃ¼de kalÄ±yor. 
    while(fscanf(f, "%d", &x) != EOF){
        printf("%d ", x);
    }

    fclose(f);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir dosyadan tam sayÄ±larÄ±n nasÄ±l okunduÄŸu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // '_getch' kullanÄ±mÄ± iÃ§in eklendi.
#include "nutility.h"

int main(void)
{
    FILE* f = fopen("out.txt", "r"); // 'out.txt' dosyasÄ±nÄ±n iÃ§eriÄŸi '23 45 67 atilla 98 23 55 bora 77 456 yagiz 90 91 867 979'
    if(!f){
        printf("dosya acilmadi.\n");
        return 1;
    }

    int x;
    char buf[100]; // Okunan dosyada tam sayÄ± olmayan deÄŸerlerin yazÄ± olarak kaydedileceÄŸi dizi.

    while(1){
        int ret = fscanf(f, "%d", &x);
        
        if(ret == EOF){
            break;
        }

        if(ret == 0){
            fscanf(f, "%d", buf);
            printf("\n%s gecerli bir tam sayi degil.\n", buf);
        }
        else{
            printf("%d ", x);
        }
    }

    fclose(f);
}
```


## `fgetc` ve `fgets` Fonksiyonu ile Dosyadan Okuma Ä°ÅŸlemleri 

`fgets` fonksiyonunun prototipi `int fgets(char*, int, FILE*);` biÃ§imindedir.

Metin dosyalarÄ±ndan okuma yapmak iÃ§in en az Ã¼Ã§ farklÄ± yÃ¶ntemimiz mevcut. 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "main.c" dosyasÄ±nÄ±n iÃ§eriÄŸi standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // '_getch' kullanÄ±mÄ± iÃ§in eklendi.
#include "nutility.h"

int main(void)
{
    FILE* f = fopen("main.c", "r");
    if(!f){
        printf("dosya acilmadi.\n");
        return 1;
    }
    
    int c;

    while((c = fgetc(f)) != EOF){
        putchar(c);
        _getch(); // KullanÄ±cÄ±dan bir tuÅŸa basmasÄ± bekleniyor.
    }

    fclose(f);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "main.c" dosyasÄ±nÄ±n iÃ§eriÄŸi karakterler arasÄ±nda bir boÅŸluk vererek nasÄ±l standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // '_getch' kullanÄ±mÄ± iÃ§in eklendi.
#include "nutility.h"

int main(void)
{
    FILE* f = fopen("main.c", "r");
    if(!f){
        printf("dosya acilmadi.\n");
        return 1;
    }
    
    int c;

    while((c = fgetc(f)) != EOF){
        printf("%c ", c);
        // _getch(); // KullanÄ±cÄ±dan bir tuÅŸa basmasÄ± bekleniyor.
    }

    fclose(f);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "main.c" dosyasÄ±nÄ±n iÃ§eriÄŸi her karakterden iki tane olacak biÃ§imde nasÄ±l standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // '_getch' kullanÄ±mÄ± iÃ§in eklendi.
#include "nutility.h"

int main(void)
{
    FILE* f = fopen("main.c", "r");
    if(!f){
        printf("dosya acilmadi.\n");
        return 1;
    }
    
    int c;

    while((c = fgetc(f)) != EOF){
        printf("%c%c", c, c);
        // _getch(); // KullanÄ±cÄ±dan bir tuÅŸa basmasÄ± bekleniyor.
    }

    fclose(f);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "main.c" dosyasÄ±nÄ±n iÃ§eriÄŸinin boÅŸluklar dikkate alÄ±nmadan nasÄ±l standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // '_getch' kullanÄ±mÄ± iÃ§in eklendi.
#include <ctype.h>
#include "nutility.h"

int main(void)
{
    FILE* f = fopen("main.c", "r");
    if(!f){
        printf("dosya acilmadi.\n");
        return 1;
    }
    
    int c;

    while((c = fgetc(f)) != EOF){
        if(!isspace(c))
            putchar(c);
    }

    fclose(f);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "main.c" dosyasÄ±nÄ±n iÃ§eriÄŸinin `fscanf` fonksiyonu ile boÅŸluklarla ayrÄ±lÄ±r biÃ§imde okunup nasÄ±l standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // '_getch' kullanÄ±mÄ± iÃ§in eklendi.
#include <ctype.h>
#include "nutility.h"

int main(void)
{
    FILE* f = fopen("main.c", "r");
    if(!f){
        printf("dosya acilmadi.\n");
        return 1;
    }
    
    char buf[100];

    while(fscanf(f, "%s", buf) != EOF){
        puts(buf);
        _getch(); // KullanÄ±cÄ±dan bir tuÅŸa basmasÄ± bekleniyor.
    }

    fclose(f);
}
```


`fgets` fonksiyonu satÄ±r satÄ±r dosyadan okuma yapmak iÃ§in kullanÄ±lan bir fonksiyondur, dosyada okunacak stÄ±r kalmadÄ±ÄŸÄ±nda geriye **NULL pointer** dÃ¶nmektedir, okunacan satÄ±r bildirilen satÄ±r karakter sayÄ±sÄ±ndan bÃ¼yÃ¼kse bildirilen karakter sayÄ±sÄ± kadar karakter deÄŸiÅŸkene atanacaktÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `fgets` fonksiyonu ile bir dosyadan satÄ±r satÄ±r okuma iÅŸleminin nasÄ±l yapÄ±lacaÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // '_getch' kullanÄ±mÄ± iÃ§in eklendi.
#include <ctype.h>
#include "nutility.h"

#define BUFFER_SIZE     1000

int main(void)
{
    char buf[BUFFER_SIZE];

    FILE* fs = fopen("kayit500.txt", "r");
    if(!fs){
        printf("dosya acilamadi.\n");
        return 1;
    }

    while(fgets(buf, BUFFER_SIZE, fs)){
        printf("%s", buf);
    }

    fclose(fs);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `fgets` fonksiyonu ile bir dosyadan satÄ±r satÄ±r okunan verinin `qsort` ile sÄ±ralanÄ±ÅŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // '_getch' kullanÄ±mÄ± iÃ§in eklendi.
#include <ctype.h>
#include "nutility.h"

int mycmp(const void* vp1, const void* vp2)
{
    return strcmp(*(const void**)vp1, *(const void**)vp2); 
}

int main(void)
{
    FILE* f = fopen("kayit500.txt", "r");
    if(!f){
        printf("dosya acilamadi.\n");
        return 1;
    }

    char** pd = NULL;
    int cnt = 0;

    while(fgets(buf, 1000, f)){
        char* p = _strdup(buf);
        pd = (char**)realloc(pd, (cnt + 1) * sizeof(char*));
    
        if(!pd){
            printf("bellek yetersiz!\n");
        }

        pd[cnt++] = p;
    }

    // YukarÄ±daki dÃ¶ngÃ¼ aÅŸaÄŸÄ±daki gibi de yazÄ±labilir.
    // while(fgets(buf, 1000, f)){
    //     pd = (char**)realloc(pd, (cnt + 1) * sizeof(char*));
    
    //     if(!pd){
    //         printf("bellek yetersiz!\n");
    //     }

    //     pd[cnt++] = _strdup(buf);
    // }


    // Bu satÄ±ra kadar yapÄ±lmÄ±ÅŸ programÄ±n sÄ±nanmasÄ± iÃ§in yazÄ±lan kodlar.
    // printf("toplam satir sayisi %d\n", cnt);
    // for(int i = cnt - 1; i >= 0; ++i){
    //     printf("%s", pd[i]);
    // }

    // fclose(f);

    // for(int i = cnt - 1; i < cnt; ++i){
    //     free(pd[i]);
    // }

    // free(pd);

    qsort(pd, cnt, sizeof(*pd), &mycmp);

    for(int i = 0; i < cnt; ++i){
        printf("%s", pd[i]);
    }


    // some code here ...

    for(int i = 0; i < cnt; ++i){
        free(pd[i]);
    }

    free(pd);
}
```


Dosyalar ilkel bir veri tabanÄ± olarak kullanÄ±labiliyor, ufak uygulamalarda dosyalarÄ±n veri saklamak iÃ§in kullanÄ±lÄ±ÅŸÄ± yangÄ±n bir yaklaÅŸÄ±mdÄ±r.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.02-12.16 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


## `fputs` Fonksiyonu 

`fputs` fonksiyonunun prototipi `int fputs(char*, int, FILE*);` biÃ§imindedir, bu fonksiyon **null character** ile sonlanan yazÄ±yÄ± dosyaya yazmak iÃ§in kullanÄ±lmaktadÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `fputs` fonksiyonu ile bir dosyadan satÄ±r satÄ±r okuma iÅŸleminin nasÄ±l yapÄ±lacaÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <ctype.h>
#include "nutility.h"

#define BUFFER_SIZE     1000

int main(void)
{
    char str[] = "bugun 20 Temmuz 2025 Pazar.\n";

    FILE* f = fopen("out.txt", "w");
    if(!f){
        printf("dosya acilamadi.\n");
        return 1;
    }
    
    fputs(str, f);
    fputs(str, f);
    fputs(str, f);
    fputs(str, f);
    fputs(str, f);

    fclose(f);
}
```


## FormatsÄ±z Okuma Yazma Ä°ÅŸlemleri ğŸŒŸ 

Bu konu biraz vakit alacak. </br>
Bir dosyadaki byte'larÄ±n hiÃ§bir karakter dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapÄ±lmadan 1 0 dizisi olarak yazma ve okuma iÅŸlemlerine formatsÄ±z okuma yazma iÅŸlemleri denilmektedir. </br>
C standardÄ±nda olan `fread` ve `fwrite` dosyadan belleÄŸe ve bellekten dosyaya aktarÄ±m yapan fonkisyonlardÄ±r. </br>
`fread` fonksiyonu dosyadaki byte'larÄ± belleÄŸe aktarÄ±yor, `fwrite` fonksiyonu bellekteki byte'larÄ± dosyaya yazmak iÃ§in kullanÄ±lÄ±yor, bu iki fonksiyonun prototipi biraz karmaÅŸÄ±ktÄ±r. </br>
Bu iki fonksiyonun da bildirimi `stdio.h` baÅŸlÄ±k dosyasÄ±ndadÄ±r.


### `fread` ve `fwrite` FonksiyonlarÄ±

`fread` fonksiyonunun prototipi `size_t fread(void*, size_t sz, size_t n, FILE*);` biÃ§imindedir. </br>
`fwrite` fonksiyonunun prototipi `size_t fwrite(const void*, size_t sz, size_t n, FILE*);` biÃ§imindedir. 

Bir dosyaya okuma ya da yazma iÅŸlemi yapan fonksiyonlar hangi byte'tan itibaren bu iÅŸlemi yapacaÄŸÄ±nÄ± **dosya konum gÃ¶stericisi(file pointer)** deÄŸerine bakarak belirlemektedir. </br>
`fread` ve `fwrite` fonksiyonlarÄ± okuma ya da yazma iÅŸlemi yapacaÄŸÄ± dosyanÄ±n hangi byte'Ä±ndan itibaren iÅŸlem yapacaÄŸÄ± bilgisini fonksiyona Ã§aÄŸrÄ± yapan koddan almazlar, **dosya konum gÃ¶stericisi(file pointer)** deÄŸerine bakarak kara verilir. </br>
Dosyadan okuma ya da yazma iÅŸlemi yapan fonksiyonlar **dosya konum gÃ¶stericisi(file pointer)** deÄŸerini deÄŸiÅŸtirmektedir. </br>
**Dosya konum gÃ¶stericisi(file pointer)** deÄŸeri okuma ve yazma iÅŸlemlerinde ortak olarak kullanÄ±lan tek bir deÄŸerdir.


ilk bir milyon asal sayÄ±yÄ± formatsÄ±z olarak bir dosyaya yazdÄ±rÄ±nca yazdÄ±rma iÅŸleminin yapÄ±ldÄ±ÄŸÄ± dosyanÄ±n bÃ¼yÃ¼klÃ¼ÄŸÃ¼ `1'000'000 * sizeof(int)` olacaktÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `fwrite` ile bir dosyaya formatsÄ±z olarak byte'larÄ±n yazdÄ±rÄ±lÄ±ÅŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <ctype.h>
#include "nutility.h"

#define BUFFER_SIZE     1000

int main(void)
{
    FILE* f = fopen("nec.dat", "wb");
    if(f == NULL){
        printf("dosya acilamadi.\n");
        return 1;
    }
    
    randomize();

    for(int i = 0; i < 100; ++i){
        int x = rand();
        fwrite(&x, sizeof(int), 1, f);
    }

    fclose(f);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `fread` ile bir dosyadan formatsÄ±z olarak byte'larÄ±n nasÄ±l okunduÄŸu incelenebilir(yukarÄ±daki programda `nec.dat` dosyasÄ±na yazdÄ±rÄ±lan byte'lar okunuyor).
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <ctype.h>
#include "nutility.h"

#define BUFFER_SIZE     1000

int main(void)
{
    FILE* f = fopen("nec.dat", "rb");
    if(f == NULL){
        printf("dosya acilamadi.\n");
        return 1;
    }

    int x;

    while(fread(&x, sizeof x, 1, f))
        printf("%d\n", x);
    
    fclose(f);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `fwrite` fonksiyonu ile dosyalara formatsÄ±z olarak byte'larÄ±n yazdÄ±rÄ±lÄ±ÅŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <ctype.h>
#include "nutility.h"

#define BUFFER_SIZE     1000

void creat_prime_numbers_file(const char* filename, int prime_count)
{
    FILE* f = fopen(filename, "wb");
    if(f == NULL){
        printf("dosya acilamadi.\n");
        return 1;
    }
    
    int prime_counter = 0;
    int x = 2;

    while(prime_counter < prime_count){
        if(isprime(x)){
            fwrite(&x, sizeof(int), 1, f);
            ++prime_counter;
        }
        ++x;
    }
    
    fclose(f);
}

int main(void)
{
    creat_prime_numbers_file("primes1000000.dat", 1'000'000);
    creat_prime_numbers_file("primes100000.dat", 100'000);
    creat_prime_numbers_file("primes10000.dat", 10'000);
    creat_prime_numbers_file("primes5000.dat", 5'000);

}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `fwrite` fonksiyonu ile dosyalara formatsÄ±z olarak byte'larÄ±n yazdÄ±rÄ±lÄ±ÅŸÄ± incelenebilir(burada `Person` tÃ¼rÃ¼ yazdÄ±rÄ±lÄ±yor).
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <ctype.h>
#include "nutility.h"
#include "peerson.h"

#define BUFFER_SIZE     1000

int main(void)
{
    printf("sizeof(Person) = %zu", sizeof(Person));

    FILE* f = fopen("people1000", "wb");
    if(!f){
        printf("dosya olustutulamadi.\n");
        return 1;
    }

    randomize();
    Person per;

    for(int i = 0; i < 1000; ++i){
        set_random_person(&per);
        fwrite(&per, sizeof(Person), 1, f);
    }

    fclose(f);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `fread` fonksiyonu ile dosyalardan formatsÄ±z olarak tek seferde tek bir `int` tÃ¼rÃ¼ kadar byte'larÄ±n nasÄ±l okunduÄŸu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <ctype.h>
#include "nutility.h"
#include "peerson.h"

#define BUFFER_SIZE     1000

int main(void)
{
    printf("sizeof(Person) = %zu", sizeof(Person));

    FILE* f = fopen("primes10000.dat", "rb");
    if(!f){
        printf("dosya acilamadi.\n");
        return 1;
    }

    int x;

    while(fread(&x, sizeof x, 1, f)){
        printf("%d ", x);
        _getch();
    }

    fclose(f);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `fread` fonksiyonu ile dosyalardan formatsÄ±z olarak tek seferde on tane `int` tÃ¼rÃ¼ kadar byte'larÄ±n nasÄ±l okunduÄŸu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <ctype.h>
#include "nutility.h"
#include "peerson.h"

#define BUFFER_SIZE     1000

int main(void)
{
    FILE* f = fopen("primes10000.dat", "rb");
    if(!f){
        printf("dosya acilamadi.\n");
        return 1;
    }

    int ar[10];
    
    while(fread(ar, sizeof(int), 10, f)){
        printf_array(ar, 10);
    }

    fclose(f);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `fread` fonksiyonu ile dosyalardan formatsÄ±z olarak tek seferde bir tane `Person` tÃ¼rÃ¼ kadar byte'larÄ±n nasÄ±l okunduÄŸu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <ctype.h>
#include "nutility.h"
#include "peerson.h"

#define BUFFER_SIZE     1000

int main(void)
{
    FILE* f = fopen("people10000.dat", "rb");
    if(!f){
        printf("dosya acilamadi.\n");
        return 1;
    }

    Person per;
    
    while(fread(&per, sizeof(int), 1, f)){
        printf_person(&per);
        _getch();
    }

    fclose(f);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `fread` fonksiyonu ile dosyalardan formatsÄ±z olarak her seferinde bir tane `Person` tÃ¼rÃ¼ kadar byte'larÄ±n nasÄ±l okunduÄŸu ve sadece belirli bir gÃ¼n/ay deÄŸerinde doÄŸanlarÄ±n standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderiliÅŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <ctype.h>
#include "nutility.h"
#include "peerson.h"

#define BUFFER_SIZE     1000

int main(void)
{
    FILE* f = fopen("people10000.dat", "rb");
    if(!f){
        printf("dosya acilamadi.\n");
        return 1;
    }

    int day, mon;
    printf("ayin gunu ve ay degerini girin: ");
    scanf("%d%d", &day, &mon);

    Person per;
    
    while(fread(&per, sizeof(int), 1, f)){
        if(per.bdate.d_ == day && per.bdate.m_ = mon){
            print_person(&per);
            _getch();
        }
    }

    fclose(f);
}
```



MÃ¼lakatlarda sorulan soru: `fread` ve  `fwrite` fonksiyonlarÄ±nÄ± kullanarak dosya kopyalayan bir program yazÄ±nÄ±z? </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda `fread` ve  `fwrite` fonksiyonlarÄ± kullanÄ±larak yapÄ±lan dosya kopyalama iÅŸlemi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <ctype.h>
#include "nutility.h"
#include "peerson.h"

#define BUFFER_SIZE     1024

int main(int argc, char** argv)
{
    if(argc != 3){
        printf("usage: <fcopy> <source file name> <dest file name>\n");
        return 1;
    }

    FILE* fs = fopen(argv[1], "rb");
    if(!fs){
        printf("File %s cannot be opened.\n", argv[1]);
        return 1;
    }
    
    FILE* fd = fopen(argv[2], "wb");
    if(!fd){
        printf("File %s cannot be opened.\n", argv[2]);
        fclose(fs);
        return 1;
    }

    char buf[BUFFER_SIZE];
    size_t n;
    size_t total_size = 0;

    while((n = fread(buf, 1, BUFFER_SIZE, fs)) != 0){
        total_size += n;
        fwrite(buf, 1, n, fd);
    }

    fclose(fs);
    fclose(fd);

    printf("the file %s of %zu bytes copied as file %s\n", argv[1], total_size, argv[2]);
}
```


Ders sonu ...
