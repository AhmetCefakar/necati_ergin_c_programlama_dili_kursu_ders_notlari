# 56.Ders 27.08.2025 🕘

---

## `stdout`, `stdin`, `stderr` Kullanımı


👇 Aşağıdaki programdaki dosyaya yazdırmak için kullanılan fonksiyonlara **Standat output**'u temsil eden referans geçildiği için bu fonksiyon çağrılarından sonra standart çıktı akımına yazm aişlemi yapılacaktır.
```C
#include <stdio.h>

int main(void)
{
    fprintf(stdout, "neco");
    fputc('X', stdout);
    fputs('timur', stdout);
}
```


👇 Aşağıdaki programda dosyadan okuma işlemi yapmak için kullanılan `fscanf` fonksiyonu nasıl **Standat input**'tan okuma yapmak için kullanıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x;

    printf("bir sayi girin: ");
    fscanf(stdin, "%d", &x);
    printf("x = %d\n", x);
}
```



👇 Aşağıdaki programda `fprintf` fonksiyonuna **Standat error** handler olarak geçildiğinde çıktı varsayılan hata akımına yazdırılacaktır o da ekrana bağlı olduğu için ekrana yazdırılacaktır.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    fprintf(stderr, "bu bir hata iletisidir.\n");
}
```



👇 Aşağıdaki programda `print_info` adındaki fonksiyonun herhangi bir dosyaya yazdırma işlemi için nasıl sarmalayıcı bir fonksiyon olarak kullanıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

void print_info(FILE* f, const char* str)
{
    fprintf(f, str);
}

int main(void)
{
    FILE* f = fopen("out.txt", "w");
    if(!f){
        return 1;
    }

    print_info(f, "necati ergin"); // İletilen veri 'out.txt' dosyasına yazdırılır.

    print_info(stdout, "necati ergin"); // İletilen veri 'standart output'a yazdırılır.
    
    close(f);
}
```



✍️ Burada `date.h` kütüphanesinin deneme için `print_date_` fonksiyonunu ekliyoruz.
```C

#include <stdio.h>

void print_date_(FILE* f, const Date* p);
```



✍️ Burada `date.c` kütüphanesinin deneme için `print_date_` fonksiyonunu ekliyoruz.
```C

PUBLIC void print_date(FILE* f, const Date* p)
{
    // Ayları dizinin indis değeriyle eşitlemek için dizinin 0. elemanı boş yazı yapılıyor.
    static const char* const pmons[] = { "", "Ocak", "Subat", "Mart", "Nisan", "Mayis", "Haziran", "Temmuz", "Agustos", "Eylul", "Ekim", "Kasim", "Aralik", };
    
    static const char* const pdays[] = { "Pazar", "Pazartesi", "Sali", "Carsamba", "Persembe", "Cuma", "Cumartesi", };

    fprintf(f, "%02d %s %d %s\n", GET_MONTH_DAY(*p), pmons[GET_MONTH(*p)], GET_YEAR(*p), pdays[get_week_day(p)]);
}
```


👇 Aşağıdaki programda `date.h` dosyasına eklenen `print_date_` fonksiyonunu kullanımı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "date.h"

int main(void)
{
    Date mydate;
    set_date(&mydate, 27, 7, 2015);

    print_date_(stdout, &mydate); // Varsayılan çıktı akımına yazdırma işlemi.
}
```


👇 Aşağıdaki programda `date.h` dosyasına eklenen `print_date_` fonksiyonunu kullanımı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "date.h"

int main(void)
{
    FILE* f = fopen("out.txt", "w");
    if(!f){
        fprintf(str, "%s dosyasi acilamadi.\n");
        return 1;
    }

    Date mydate;
    set_date(&mydate, 27, 7, 2015);

    print_date_(f, &mydate); // Dosyaya yazdırma işlemi.

    close(f);
}
```



Dosya işlemleriyle ilgili sık karşılaşılan mülakat sorulardan biri: "`stdout` ve `stderr` de ekrana bağlı ise neden hata iletilerini `strerr` akımına vermeliyiz?"
Cevap: </br>
Hata iletileri doğrudan programı kullananı ilgilendiriyor bir hata olduğunda prograı kullananın o hatayı görebilmesi gerekir. </br>
Hata iletilerini `stdout` akımına yönlendirirsek eğer **standart output** bir nedenden dolayı başka bir dosyaya yönlendirilirse bu durumda programı kullanan hata iletilerini göremez.



👇 Aşağıdaki programnın varsayılan çıktı akımını komut satırından `program_name > yonlendirilecek_dosya.xtx` komutu girilerek `yonlendirilecek_dosya.xtx` dosyasına yönlendirilirse kullanıcının görmesi gereken hata iletilerini kullanıcının görüp göremeyeceği incelenebilir. </br>
❗❗❗ Burayı anlamk önemli yani hata iletilerinde neden `strerr` ile işlem yapıldığı bilgisi.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "date.h"
#include "nutility.h"
#include <stdlib.h>

int main(void)
{
    randomize();

    for(int i = 0; i < 10; ++i){
        printf("%d", rand());
    }

    // pritnf("bellek yetersiz... devam etmek icin bir tusa basin!"); // hata iletisi varsayılan çıktı akımına veriliyor.
    fpritnf(strerr ,"bellek yetersiz... devam etmek icin bir tusa basin!"); // hata iletisi varsayılan hata akımına veriliyor
}
```


❗❗❗ İşletim sistemlerinin çoğunda **standart output**'u yönlendirmek için `>` karakteri kullanılıyor, **standart input**'u yönlendirmek için `<` karakteri kullanılıyor, **standart error**'u yönlendirmek için `2>` karakterleri kullanılıyor. 


👇 Aşağıdaki programın girdileri varsayılan olarak **standart input**'tan yani klavyeden, çıktıları da varsayılan olarak **standart output**'a yani ekrana gönderilir. </br>
Programın kaynak kodlarında hiçbir değişiklik yapmadan programı çalıştırırken **standart input** ve **standart output** yönlendirmeleri değiştirilebilir, mesela program CLI'dan `_programın çalıştırılabilir dosyasının adı_ > out.txt < data.txt` biçiminde çalıştırılırsa program girdisini "data.txt" dosyasında alır ve çıktısını da "out.txt" dosyasına yazar.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    for(int i = 0; i < 10; ++i){
        int x;

        scanf("%d", &x);
        printf("%d * %d = %d", x, x, x * x);
    }
}
```


## `freopen` Fonksiyonu 

`freopen` fonksiyonunun prototipi `FILE* freopen(const char* filename, const char* mode, FILE* stream);` biçimindedir, bu fonksiyon üçüncü parametresine geçilen handle'a ilişkin dosyayı ikinci parametresine geçilen durumda(okuma, yazma vb.) birinci parametresine geçilen dosyaya yönlenrme işlemini yapıyor. </br>
Bu fonksiyon çoğunlukla **standart output**'un ya da **standart input**'un yönlendirilmesi için kullanılıyor.



👇 Aşağıdaki programda `freopen` fonksiyonuyla **standart output**'un istenilen dosyaya yönlendirilebildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    puts("necati ergin");

    if(freopen("out.txt", "w", stdout) == NULL){ // Burada 'standart output'un 'out.txt' dosyasına yönlendirilmek için fonksiyon çağrısı yapılıyor.
        fprintf(stderr, "freopen failed!\n");
        return 1;
    }

    puts("bu yazi dosyaya yazilacak.\n");

    fclose(stdout);
}
```



👇 Aşağıdaki programda `freopen` fonksiyonuyla **standart input**'un istenilen dosyaya yönlendirilebildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    puts("necati ergin");

    if(freopen("in.txt", "r", stdin) == NULL){ // Burada 'standart input'un 'in.txt' dosyasından okunması için fonksiyon çağrısı yapılıyor.
        fprintf(stderr, "freopen failed!\n");
        return 1;
    }

    int a, b, c;
    scanf("%d%d%d", &a, &b, &c);

    printf("a = %d", a);
    printf("b = %d", b);
    printf("c = %d", c);

    fclose(stdout);
}
```


## `setbuf` ve `setvbuf` Fonksiyonları 

Bu fonksiyonların adlarındaki "**buf**" kısaltması "**buffer**" sözcüğünden gelmektedir, `fflash` fonksiyonu handler'ı kendisine verilen dosyaya yazma işlemi için kullanılmataydı. </br>
`stdio.h` dosyası içinde bulunan `BUFSIZE` object-like makrosu mar bu makro varsayılan buffer değerini belirlemektedir. </br>
`setbuf` ve `setvbuf` fonksiyonları buffer'lama mekanizmasını düzenlemek için kullanılmaktadır.

`setvbuf` fonksiyonunun prototipi `int setvbuf(FILE* f, char* buffer, int mode, size_t size);` biçimindedir, bu fonksiyon **test function** bir fonksiyondur, fonksiyon başarılı olduğunda "0" ve başarısız olduğunda da "non-zero" değer döner. İlk parametre ilgili dosyanın handler'ı, ikinci parametre buffer olarak kullanılacak olan dizinin adresi, üçüncü parametre üç farklı makro değer alabilen buffer'ın mode özellik bilgisi, dördüncü parametre buffer olarak kullanılacak olan dizinin boyutudur. </br>

`setvbuf` fonksiyonunun üçüncü parametresi aşağıdaki makrolarından birini alabilir;
- `_IOFBF`: Bu makronun adı "**input/output full buffering**" sözcüklerinden gelmektedir.
- `_IOLBF`: Bu makronun adı "**input/output line buffering**" sözcüklerinden gelmektedir, bu mode'da iken yeni satır karakteri(`\n`) geldiğinde ya da buffer dolduğunda **flush** işlemi yapılacaktır. Mesela `printf` çağrılarında "new-line" kullanılmasının nedeni sadece alt satıra geçişi sağlamak eğil bu aynı zamanda flush işleminin yapılması anlamına geliyor. 
- `_IONBF`: Bu makronun adı "**input/output no buffering**" sözcüklerinden gelmektedir, mesela **standart error**'ün buffer modu budur.

`setvbuf` fonksiyonunun ikinci parametresine **NULL pointer** geçilirse bu şu anlamına geliyor: Ben buffer dizisi sağlamak istemiyorum bunu sen ayarla anlamına geliyor.

`setvbuf` fonksiyonunu dosya açıldıktan hemen sonra dosya üzerinde hiçbir işlem yapmadan çağırmak gerekiyor yoksa **ub** durumu oluşmaktadır.



👇 Aşağıdaki programda `setvbuf` kullanımı görülebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "date.h"
#include "nutility.h"
#include <stdlib.h>

int main(void)
{
    setvbuf(stdout, NULL, _IOLBF, 0); // Burada 'standart output'un buffer'ı '_IOLBF' olarak ve buffer için kullanılacak olan diziyi de fonksiyon kendisi ayarlayacak biçimde bir düzenleme yapılmış oluyor.
    // setvbuf(stdout, NULL, _IOLBF, BUFSIZ); // Bu satırdaki fonksiyon çağrısı yukarıdaki fonksiyon çağrısıyla denktir.
}
```



👇 Aşağıdaki programda `setvbuf` fonksiyonunun oluşturulan bir diziyle çağrılışı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "date.h"
#include "nutility.h"
#include <stdlib.h>

char buf[1024];

int main(void)
{
    FILE* f = fopen("out.txt", "w");
    if(!f)
        return 1;

    if(setvbuf(f, buf, _IOFBF, sizeof(buf))){
        fprintf(stderr, "setvbuf failed!\n");
    }
}
```



👇 Aşağıdaki programda `setvbuf` fonksiyonunun herhangi bir tamponlama olmadak kullanılışı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "date.h"
#include "nutility.h"
#include <stdlib.h>

char buf[1024];

int main(void)
{
    setvbuf(stdout, NULL, _IONBF, 0); // Burada 'standart output'un buffer'ının '_IONBF' olarak tamponlama olmadan kullanılacağı bildiriliyor.

    setvbuf(stderr, NULL, _IONBF, 0); // Burada 'standart error'un buffer'ının '_IONBF' olarak tamponlama olmadan kullanılacağı bildiriliyor ama varsayılanı bu olduğu için bu kod gereksizdir.
}
```



`setbuf` fonksiyonunun prototipi `void setbuf(FILE* f, char* buffer);` biçimindedir, ilk parametre ilgili dosyanın handler'ı, ikinci parametre buffer olarak kullanılacak olan dizinin adresidir, bu fonksiyon `setvbuf` fonkiyonunun sadeleştirilmiş bir halidir. </br>
`setbuf(f, buf);` biçimindeki bir bir fonksiyon çağrısı `setvbuf(f, buf, _IOFBF, BUFSIZ);` fonksiyon çağrısına denktir. </br>
`setbuf(f, NULL);` biçimindeki bir bir fonksiyon çağrısı `setvbuf(f, buf, _IONBF, BUFSIZ);` fonksiyon çağrısına denktir.



👇 Aşağıdaki programda `setbuf` fonksiyonunun temel kullanımları incelenebilir, `setbuf` fonksiyonu kullanımında buffer'lama yaklaşımını değiştiremiyoruz ya **full buffering** kullanılabilir ya da **no-buffering** kullanılabiliyor.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "date.h"
#include "nutility.h"
#include <stdlib.h>

char buf[1024];

int main(void)
{
    setbuf(stdout, NULL); // Bu fonksiyon çağrısı 'standart output'un buffer'lanmaması anlamına gelmektedir.

    setbuf(stdout, buf); // Bu fonksiyon çağrısı 'standart output'un full buffer'lanmaması ve 'buf' nesnesinin buffer olarak kullanılması anlamına gelir.
}
```


⚠️⚠️⚠️ **Standat output**, **Standat output**, **Standat error** esasında bir dosya oldukları için bunlar üzerinde yapılan işlemler herhangi bir dosya üzerinde de yapılabilir.



## `ungetc` Fonksiyonu 

`ungetc` fonksiyonunun prototipi `int ungetc(int c, FILE* f);` biçimindedir, bu fonksiyon bir dosyanın buffer'ından okunan bir karakteri işlem sonrasında yeniden o buffer'a geri koymak için kullanılıyor. </br>


⚠️ Bu başlığı bir defa daha gzden geçirmek gerekiyor! ⚠️


👇 Aşağıdaki programda `ungetc` kullanımı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "date.h"
#include "nutility.h"
#include <stdlib.h>

char buf[1024];

int main(void)
{
    FILE* f = fopen("main.c", "r");
    if(!f){
        fprintf(stderr, "dosya acilamadi!\n");
        return 1;
    }

    int c = fgetc(f);
    printf("okunan karakter %c %d\n", c, c);

    // Aşağıdaki koşul bloğunda dosyanın sonuna gelinmediyse, 'c' karakterini dosya geri koyacaktır.
    if(ungetc(c, f) != EOF){
        printf("karakter geri koyuldu\n");
    }

    c = fgetc(f);
    printf("okunan karakter %c %d\n", c, c);

    fclose(f);
}
```



👇 Aşağıdaki programda `ungetc` kullanımı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>

void process_input(FILE* f)
{
    int ch = fgetc(f); // Burada ilgili dosyanın 'file pointer'ının gösterdiği yerde bir karakter okunmaktadır.

    // Aşağıdaki kodlar çalıştırıldırsa standart çıktı akımına 'val = 72349' yazacaktır.
    // if(isdigit(ch)){
    //     int val;
    //     fscan(f, "%d", &val);
    //     printf("val = %d\n", val);
    // }
    // else{
    //     printf("okunan karakter %c\n", ch);
    // }

    // Aşağıdaki kodlar çalıştırıldırsa standart çıktı akımına 'val = 872349' yazacaktır.
    if(isdigit(ch)){
        ungetc(ch, f); // Burada 'f' dosyasına 'ch' karakteri geri koyuluyor.
        int val;
        fscan(f, "%d", &val);
        printf("val = %d\n", val);
    }
    else{
        printf("okunan karakter %c\n", ch);
    }
}

int main(void)
{
    FILE* f = fopen("in.txt", "r"); // Buradaki 'in.txt' dosyasında tek satır olarak '872349' yamaktadır.
    if(!f){
        fprintf(stderr, "dosya acilamadi!\n");
        return 1;
    }

    process_input(f);
}
```


## C Dilinde Hatalar 

Hatalar temelde ikiye ayrılır;
- **Programming error**: Bu tür hatalar programın kodunun yanlış yazıldığı durumları ifade eder. Bu tür hataları çözmek için programdaki hatalı kodları tespitedip düzeltmek gerekir, programdaki hataları düzeltmek için **bug fixing** işlemleri yapılır.
- **Runtime error**: Bu tür hatalar programın kodundan bağımsız olarak meydana gelen hatalardır, mesela prograın kullandığı bir dosyanın ilgili yerden silinmiş olması, bellek alanının yetersiz olmasından kaynaklanan hatalar vb.

**API boundary(API Sınırı)**: Bir hatanın türünün duruma göre bazen **programming error**, bazen de **runtime error** olması durumuna verilen adlandırmadır.



👇 Aşağıdaki program parçasındaki `foo` fonksiyonundan alınabilecek hata duruma göre **programming error** ya da **runtime error** olabilir, eğer kendi yazdığımız koddan `foo` fonksiyonu "0" değeriyle çağrılıyorsa **programming error** olacaktır ama bir **client code** `foo` fonksiyonu "0" değeriyle çağrılıyorsa **runtime error** olacaktır. İşte burada gibi kodda oluşabilecek hatanın türünün değişebilir olması **API boundary(API Sınırı)** olarak tanımlanmaktadır.
```C
int foo(int x)
{
    // buraya gelen 'x'in değeri '0' olmamalı, eğer '0' olursa hata sıfıra bölme hatası oluşacaktır.
    int y = 241231 / x;
}
```


C++, Java, C# gibi diller programın çalışma zamanında oluşabilecek hataları yönetebilmek için C dilinde olmayan "**Exception Handing**" olarak adlandırılan bir araç seti içermektedir, böyle **runtime error** hatalarına o dillerde "**Exception**" deniliyor.


### C Dilinde Runtime errors 

**Conventional error handling(geleneksel hata yönetimi)** 

C dilinde üç farklı biçimde **runtime error** hataları yönetilmektedir. </br>
Bir fonksiyon işini yapamadığında kullanılan yöntemler;
1. Geri dönüş değeri mekanizması ile işini yapamadığını belirten bir değer döndürür.
    `stdio.h` dosyasında neredeyse tüm fonksiyonlar böyl eçalışmaktadır, mesela;
    - `fopen` fonksiyonu işini yapabilirse bir dosya nesnesi adresi döndürüyor ama işini yapamazsa **NULL pointer** değer döndürüyor.
    - `malloc` fonksiyonu işini yapabilirse ayrılan bellek bloğunun adresi döndürüyor ama işini yapamazsa **NULL pointer** değer döndürüyor.
    - `remove`, `rename` fonksiyonları üzerlerinde işlem yaptıkları dosyalarda başarılı işlem yaptığında geriye "0" değer döndürüyor, yapamazlarsa "non-zero" değer döndürüyor.
    - `ftell` fonksiyonu işini yapabilirse bir file pointer değeri döndürür, işini yapamazsa "-1" değerini döndürür. 
2. Fonksiyon dışarıdan bir argüman alır, eğer hata oluşursa oluşan hatayla ilgili bilgi bu **output** değişkene yazılır, fonkisyonu çağıran kod hata olup olmadığını **output** değişkene bakarak anlar.
3. Standart C fonksiyonlarında kullanılan ve Unix/Linux sistem fonksiyonlarında yoğun olarak kullanılan **errno**, bu hata yönetim yaklaşımını detaylı inceleyeceğiz.


### `errno` Değişkeni İle Hata Yönetimi 

`errno`yu derleyiciler çoğunlukla object-like makro türünden olan **extern** olarak bildirilmiş bir global değişkene karşılık gelmektedir, bu değişken global olduğu için tüm fonksiyonlar değerini değiştirebilir ve kullanabilir. "**errno**" adı "**Error Number**" sözcüklerinden gelmektedir.

`errno` değişkeni `errno.h` başlık dosyasında bulunan programda oluşabilecek olan hataların tutulması için kullanılacak olan global bir değişkendir, `errno` değeri "0" ise bu herhangi bir hata olmadığı anlamına gelmektedir.



👇 Aşağıdaki programda `errno` değişkeninin varsayılan durumdaki değerinin "0" olduğu incelenebilir.
```C
#include <errno.h>
#include <stdio.h>

int main(void)
{
    printf("errno = %d", errno); // 'errno' değeri bir hata yokken '0'dır.
}
```


Öyle standart C fonksiyonları var ki, bunlar C standardında belirtiliyor, bu fonksiyonlar bir hata ile karşılaştıklarında ya tek yol olarak `errno` değişkeninin değerini değiştiriyorlar ya da hem geri dönüş değeriyle hatayı çağıran koda belirtiyorlar hem de aynı zamanda `errno` değişkeninin değerini değiştiriyorlar.

`errno` değişkeninin değerinin "0" haricinde bir değer olması bir hata oluştuğunu ve bu hatanın türünü belirtmektedir. </br> 
`errno` değişkeninin tam sayı değerlerinin hangi hata olduğunu anlamak için kullanılan iki farklı fonksiyon vardır, bunlar;
- `stdio.h` başlık dosyasında bulunan `perror` fonksiyonu.
- `string.h` başlık dosyasında bulunan `strerror` fonksiyonu.


`errno` değişkenine bakılacağı zaman şuna dikkate edilmelidir: Bir fonksiyonu çağırmadan önce `errno` değişkeninin değeri "0" yapılmalıdır, ardından ilgili fonksiyon çağırılmalı ve en son `errno` değerine bakılmalıdır, `errno` değeri "0" ise hata alınmadığı anlamına gelmektedir ama "0" haricinde bir değer ise o zaman ilgili fonksiyon çağrısında hata oluştuğu anlaşılır.


> ❔ 
> 
> Sorulan soru;
> 
> Paralelde çalışan fonksiyonların eş zamanlı olarka `errno` değişkenini değiştirme ihtimali yok mu?
> 
> Cevap;
> 
> Bu konuda C dilinin standartları devreye giriyor, **Unix/Linux** sistemlerde `errno` değişkeninin **thread safe** bir sersiyonu var. </br>
> C11 standardıyla `errno` değişkeni **thread safe** hale getirildi. </br>
> Bu konu tamamen **thread**'ler ile ilegili ve bu konu bu kursun kapsamı dışındadır. </br>
> C++ dili kursunda C++ dilinin standar kütüphenesinin **concurrency** araçları da incelenmektedir.  



👇 Aşağıdaki programda `fopen` ve `fclose` fonksiyonlarının `errno` değerini değiştiren fonksiyon oldukları incelenebilir.
```C
#include <errno.h>
#include <stdio.h>

int main(void)
{
    printf("errorno = %d\n", errno);
    FILE* f = fopen("omeroylar.txt", "r"); // Okunabilecek 'omeroylar.txt' adında bir fonksiyon olmadığında dosya açılamayacaktır, bu durumda `fopen` fonksiyonu `errno` değerini ilgili hata koduyla değiştirecektir.
    printf("errorno = %d\n", errno);
}
```


#### `perror` ve `strerror` Fonksiyonları 

`perror` fonksiyonunun prototipi `void perror(const char*);` biçimindedir, eğer bir yazı bu fonksiyona argüman olarak geçilirse, ilk önce o yazı yazdırılır ve `:` karakteri eklendikten sonra `errno` kodunun açıklaması yazdırılır. Bu fonksiyon `errno` değerinin karşılık geldiği hatanın açıklamasını standart çıktı akımına göndermektedir.



👇 Aşağıdaki programda `fopen` ve `fclose` fonksiyonlarının `errno` değerini değiştiren fonksiyon oldukları incelenebilir.
```C
#include <errno.h>
#include <stdio.h>

int main(void)
{
    printf("errorno = %d\n", errno);
    FILE* f = fopen("omeroylar.txt", "r"); // Okunabilecek 'omeroylar.txt' adında bir fonksiyon olmadığında dosya açılamayacaktır, bu durumda `fopen` fonksiyonu `errno` değerini ilgili hata koduyla değiştirecektir.
    printf("errorno = %d\n", errno);

    perror("error"); // Burada 'error: No such file or directory' yazısı standart çıktı akımına gönderilecektir.
}
```



👇 Aşağıdaki programda `perror` fonksiyonunun kullanımı incelenebilir.
```C
#include <errno.h>
#include <stdio.h>

int main(void)
{
    printf("errorno = %d\n", errno);
    FILE* f = fopen("main.c", "r"); // Burada okuma amacıyla 'main.c' dosyası açılmaktadır.

    fprintf(f, "bugıun pazar\n"); // Burada okuma amacıyla açılan dosyaya yazma işlemi yapılmak istendiği için hata alınacaktır.

    printf("errorno = %d\n", errno);

    perror("hata"); // Burada 'hata: Bad file descriptor' yazısı standart çıktı akımına gönderilecektir.
}
```


> ❔ 
> 
> Sorulan soru;
> 
> `errno`'nun kendisi bir makro mu?
> 
> Cevap;
> 
> `errno` bir makro ve bu makronun kendisi `extern` bildirimine açılıyor, bizi ilgilendiren `errno` kullanılınca global bir değişkenin kullanılıyor plmasıdır. </br>
> `errno` global değişkenin kendisi değildir, o global değişkenin `extern` bildirimi yapılan global değişkene karşılık gelen makrodur.



👇 Aşağıdaki programda `strerror` fonksiyonunun kullanımı incelenebilir.
```C
#include <errno.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    FILE* f = fopen("main.c", "r"); // Burada okuma amacıyla 'main.c' dosyası açılmaktadır.

    put(strerror(6)); // Buradaki kullanımda 'strerror' fonksiyonu 'errno' değerinin '6' değerine sahip olmasının ne anlama geldiği bilgisini geriye yazı olarak dönmektedir.
}
```


***
==================================================

✦✦✦✦✦ 11.46-12.05 birinci ara verildi. ✦✦✦✦✦

==================================================
***



👇 Aşağıdaki programda `strerror` fonksiyonu kullanılarak [0, 29] arasındaki hata kodlarının açıklamalarının ne olduğu standart çıktı akımına yazdırılmaktadır.
```C
#include <errno.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    for(int i = 0; i < 30; ++i){
        printf("error value %d : %s \n", i, strerror(i);
    }
}
```



👇 Aşağıdaki programda `perror` fonksiyonunun kullanımı incelenebilir.
```C
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <strlib.h> // 'strtol' kullanabilmek için eklendi.

int main(void)
{
    const char* p = "999999999999999999999";
    char* endptr;

    // some code here ...

    errno = 0; // 'strtol' işleminde hata olup olmadğını anlayabilmek için bu değiken "0" yapılıyor.
    long lval = strtol(p, &endptr, 10); // 'strtol' ile 'p' yazısının 'long' türüne çevrilebilmesi için işlem yapılıyor.

    if(errno == ERANGE){
        printf("aralik disi deger\n");
    }

    if(errno){
        perror("strtol");
    }
    else if(endptr == p){
        printf("sayi elde edilemedi\n");
    }
    else{
        printf("elde edilen deger = %ld\n", lval);
    }
}
```


## `assert` Function-like Makrosu 

`assert` makrosu `assert.h` dosyasında tanımlanmış olan bir function-like makrdur. </br>

Programlama hataları nasıl tespit edilebilmek için kullanılan yaklaşımlar aşağıdaki gibidir;
- Kodu yazarken hatalara yönelik önlem almak. Kodlama yapılırken yazılan koda öyle kodlar eklenir ki eklenen kodların amacı iş görmek değil kodlama hataları varsa o kodlama hatalarıbulmaya yönelik kodlardır.


❗❗❗ Bir C programcısının yazdığı kodlar iki temel öbeğe ayrılmaktadır;
- Doğrudan algoritmaların gerektirdiği işi yapan kodlar.
- İş yapan kodlarda oluşabilecek olan hataları yakalamaya yönelik yazılan kodlar. Bu tür kodlara **Assertion Code** denilmektedir, **assert** fiilinin sözcük "doğrulamak" anlamına gelmektedir.

❗❗❗ **Assertion Code**'lar da kendi içinde iki öbeğe ayrılmaktadır, buradaki terimler programlama dilleri genelinde geçerli terimlerdir;
- **Static Assertions** ya da **Compile Time Assertions**: Yazılan kodda derleme anında bir hata varsa hata oluşacak ama kodda bir hata yoksa dermele zamanında bir hata oluşmayacağı durumları ifade eden kod doğrulama yöntemidir. C11 standardına kadar bu yaklaşıma yönelik bir araç yoktu.
- **Dynamic Assertions** ya da **Run Time Assertions**: Çalışma anındaki hataları tespit için kullanılan yöntemdir.



👇 Aşağıdaki programda **Static Assertions** kullanımıyla `int` türünün 4 byte olma şartının sağlanışının derleme zamanı hatası ile nasıl sağlanabildiği görülebilir, bu yöntemler mecburiyetten dolayı programcılar tarafından uydurulan kötü yöntemlerdir.
```C
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <strlib.h> // 'strtol' kullanabilmek için eklendi.

// C dilinin sözdizim kuralı olarak bir dizinin boyutu "0" olamaz.
int ary1_[sizeof(int) == 4]; // Derleyicide 'int' türü 4 byte değil ise derleme hatası alınacaktır.

int ary2_[sizeof(long) == 8]; // Derleyicide 'long' türü 4 byte değil ise derleme hatası alınacaktır(Microsolt derleyicisinde 'long' türü).

typedef int asr_0[sizeof(int) == 4]; // Derleyicide 'int' türü 4 byte değil ise derleme hatası alınacaktır.

int main(void)
{
    // some code here ...
}
```



👇 Aşağıdaki programda C11 ile dile eklenen **Static Assertions** kullanımı incelenebilir.
```C
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <strlib.h>

_Static_assert(sizeof(int) == 4, "int tutu 4 byte olmali"); // Bu kullanım C11 ile dile eklenen 'Static Assertions' aracının kullanımı incelenebilir, bu yöntem standart bir yöntemdir.

int main(void)
{
    // some code here ...
}
```


### Dynamic Assertion İle Yapılan Çalışma Zamanı Hatalarınınn Yakalanması 

👇 Aşağıdaki programda **Dynamic Assertions** ile çalışma zamanı hatalarını tespit etmek için kullanılan basit bir yöntem incelenebilir, bu yöntemin kullanımı doğru değildir çünkü koda bakar bakmaz **Dynamic Assertions** kodu olup olmadığı hemen anlaşılmıyor ve başka önemli bir sorun da **assertions** kodlarının hata arama aşaması sona erdikten sonra derlenecek kodda olmasının istenmemesidir bu yöntemi kullanınca **assertions** kodlarını programdan kolayca çıkartamayıyoruz.
```C
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <strlib.h>

int foo(int x)
{
    // Projedeki kodlama hatasını yakalamaya yönelik bir kod yazıyoruz.
    if(x == 0){
        printf("foo fonksiyonunda hata x == 0\n");
        abrot(); // Çalışma zamanı oluşabilecek hata oluşur oluşmaz program hemen sonlandırılacaktır, 
    }

    // some code here ...

    return 21;
}


int main(void)
{
    int* ptr = NULL;

    // some code here ...

    if(ptr == NULL){
        // ...
        abort();
    }

    int x = *ptr;
}
```



**Dynamic Assertions** yapabilmek için C dilinin standardı bir function-like makro sağlamaktadır, C dilinin önemli başlık dosyalarından biri `assert.h` başlık dosyasıdır, tüm derleyiciler `assert` adında bir function-like makro sağlamak zorundadır.

👇 Aşağıdaki programda C dilinin standardında olan `assert` adındaki funciton-like makrosunun kullanımı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <assert.h>
#include <stdio.h>

void foo(int x)
{
    assert(x != 0); // Buradaki 'assert' bir function-like mokro'dur, 'x' değişkeninin değeri '0' değerinden farklı olduğunda hata oluşacak ve programın akışı kesilip hata iletisi verilecektir.
    x++;
}


int main(void)
{
    foo(1);
    printf("main devam ediyor ...\n");
}
```


👇 Aşağıdaki programda C dilinin standardında olan `assert` adındaki funciton-like makrosunun kullanımı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#define NDEBUG // Bu bildirim ile koddaki tüm `assert` kullanımları devredışı bırakılmış olur
#include <assert.h>
#include <stdio.h>

void foo(int x)
{
    assert(x != 0); // Buradaki kod '#define NDEBUG' bildiriminden dolayı '(void)0' olarak açılacaktır, bu işlevsiz bir koddur.
    // x++;
}


int main(void)
{
    foo(1);
    printf("main devam ediyor ...\n");
}
```



👇 Aşağıda `assert` makrosunun gerçekleştirimini derleyiciler yapmaktadır, her derleyici kendine göre bir tane gerleştirim yapar, olabilecek en basit `assert` makrosu aşağıdaki gibi olabilir;
```C
//sample assert macro implementation

#include <stdio.h>

#ifndef NDEBUG
#define ASSERT (EXPR) (                           \
    (EXPR)? (void)0: (                            \
        printf("%s:%d: failed assertion '%s' \n", \
        __FILE__, __LINE__, #EXPR                 \
        ),                                        \
        abort()                                   \
    ))                                            \
#else                                             \
#define ASSERT(EXPR) ((void)0)                    \
#endif /* NDEBUG */                               \
```


`assert` makrosu kodlarda run-time hata sınamalarını yapabilmek için gereken yerlerde kullanılmalıdır, bazı programcılar `assert` makrosunu bilmedikleri için çalışma zamanı hatalarını tespit edebilmek için farklı yöntemler kullanabiliyormuş, `assert` makrosunu öğrenip gerektiği yerlerde kullanmak doğru yaklaşım olacaktır.



***
==================================================

✦✦✦✦✦ 13.04-12.15 ikinci ara verildi. ✦✦✦✦✦

==================================================
***


`assert` makrosunun kullanımında yapılabilecek iki hatadan biri yan etkisi olan ifadelerin `assert` makrosuyla birlikte kullanılmasıdır.


👇 Aşağıdaki programda `assert` makrosuna verilen ifadenin yan etkiye sahip olan bir ifade olmasından kaçınılması gerektiği durum incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

// #define NDEBUG // Bu bildirim ile koddaki tüm `assert` kullanımları devredışı bırakılmış olur
#include <assert.h>
#include <stdio.h>

int main(void)
{
    int cnt = 10;

    // ...

    --cnt;
    assert(cnt > 0);

    // assert(--cnt > 0); // 'assert' maktosuna yan etkisi olan ifade verilmiş, böyle kullanımlardan kaçınılmalıdır, buradaki statement yukarıdaki gibi iki farklı statement olarak kullanımı daha doğrudur.
}
```


`assert` makrosunun kullanımında yapılabilecek iki hatadan diğeri, `assert` makrosuyla birlikte `&&` operatörünün dikkatli biçimde kullanılmamasıdır, `&&` operatörü kısa devre davranışına sahip olduğu için hata oluştuğu durumda hata nedeninin tespiti zor olabileceği için kullanımın adikkate etmek gerekmektedir.


👇 Aşağıdaki programda `assert` makrosuna verilen ifadenin `&&` operatörünü içermesi durumunda dikkat edilmesi gereken drumlar incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

// #define NDEBUG // Bu bildirim ile koddaki tüm `assert` kullanımları devredışı bırakılmış olur
#include <assert.h>
#include <stdio.h>

void func(int x)
{
    assert(x > 0 && x < 100); // Buradaki gibi bir kullanım uygulanabilir çünkü 'x'in değer aralığı sınanmaktadır.
}

void foo(const int* p, size_t size)
{
    assert(p != NULL);
    assert(size > 10);

    // assert(p != NULL && size > 10); // Buradaki gibi tek `assert` ile iki farklı ifadenin doğruluğu sınanmamalıdır., bunun yerine iki farklı 'assert' ile sınama işlemi yapılmalıdır.
}

int main(void)
{
    // ...     
}
```



👇 Aşağıdaki programda `assert` makrosunun kullanımının genişletimi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

// #define NDEBUG // Bu bildirim ile koddaki tüm `assert` kullanımları devredışı bırakılmış olur
#include <assert.h>
#include <stdio.h>

#define assert_msg(MSG, EXPR)       assert((MSG, (EXPR))) // Burada iki farklı yazının yan yana konulması sonucunda derleyicinin o yazıları tek bir yazı olarak birleştirmesinden yararlanarak `assert` makrosuna özel bir yazı eklenebilir surette kullanılabilir hale getiren `assert_msg` makrosu bildirilmiştir.

int main(void)
{
    int x = 5;

    assert_msg("invariant not hold: ", x > 10);
}
```


## C99 Standardı ve Bu Standart ile Gelen Eklemeler 

Bu başlık altında C diline C99 standardı ile eklenen yenilikleri inceleyeceğiz.

Gelen yeniliklerin bir bölümünü aşağıdaki gibi listeleyelim;
- `//` tek satır yorum satırı kullanımı C99 ile dile eklenmiştir.
- `for(int i = ; ...)` biçiminde `for` ifadesi içinde object(nesne) tanımlanabilmesi özelliği C99 ile dile eklenmiştir.
- C89 standardında bir blok içinde yapılan bildirimlerin executable bir statemnet kullanılmadan önce yapılmış olma zorunluluğu vardır, C99 ile bu dilden kaldırıldı. 
    👇 Aşağıdaki programdaki kullanım C89 standardında sözdizim hatasıydı C99 ile hata olmaktan çıkartıldı.
    ```C
    #include <stdio.h>

    int main(void)
    {
        printf("naber\n");
        int x = 10; // Buradaki değişken bildiriminden bir önceki statement bir executable statement olduğu için C89 standardında bu kullanım derleme hatasına neden olur.
    }
    ```
- `for` döngüsüne dair garip bir durum aşağıdaki programdan incelenebilir. 
    👇 Aşağıdaki programda `for` döngüsüne özgü olan olan özel bir durum incelenebilir.
    ```C
    #include <stdio.h>

    int main(void)
    {
        for(int i = 0; i < 10; ++i){
            int i = 342; // C dilinde bu tanımlama legaldir ve döngünün iç bloğunda bildirilen bir değişkendir, buradaki 'i' değişkeni döngünün sayaç değişkenine 'name hiding' uygulayacaktır, C++ dilinde sözdizim hatasıdır.
            printf("i = %d", i);
        }
    }
    ```
- `long long` ve `_Bool` türleri C99 standardıyla birlikte C diline eklenmiştir. 
- **VLA(Varible Length Array)**
- **Compound Literals**
- **Flexible Array Members**
- **Designated Initializers**
- **Restrict**


> ❔ 
> 
> Sorulan soru;
> 
> `long long` türüne sığmayan bir tam sayı olduğunda bunu saklamak için dizi gibi bir araç mı kullanılmalı?
> 
> Cevap;
> 
> Bu güzel bir soru. </br>
> Bu durumda farklı çözümler olabilir; </br>
> 1. Derleyicilerin genellikle **extension** olarak sağladığı 128 bitlik tam sayı değişken türü kullanılabilir, bu yöntemde kodun taşınabilirlik sorunu olabilir. </br>
> 2. Büyük tam sayıları tutmayı sağlayabilecek **user defined type** değişkenler oluşturulup kullanılabilir, bunun için ayrıca bir çok açık kaynak olarak oluşturulmuş üçüncü taraf kütüpheneler mevcuttur.


### VLA(Varible length array) 

Bu özellik C99 ile dile eklendi ve C11 ile opsional hale getirildi, 

👇 Aşağıdaki programdaki **VLA** kullanımı incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 10;

    int ary[x]; // 'VLA' özelliğini destekleyen bir derleyici burada sözdizim hatası vermeyecektir.
}
```


🚀 **VLA(Varible length array)** özelliğinin gerçekleştirildiği derleyicilerde bu diziler yine **automatic storage duration** değişkenlerin yer aldığı bellek alanında yer alacaktır, bunu yapmak için standart bir C fonksiyonu bulunmuyor ama **Unix/Linux** sistemlerde `alloca` adında **Posix**(Posix farklı kdemelerden oluşan **Unix/Linux** sistemler için geliştirilmiş bir standarttır) fonksiyonu vardır.



👇 Aşağıdaki programdaki **VLA** kullanımı incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int row, col;

    printf("matrisin satir ve sutun sayisi: "); 
    scanf("%d %d", &row, &col);
    int cnt = 0;

    int ar[row][col];
    
    // Aşağıdaki döngü ile iki boyutlu dizinin elemanlarına değer atanmaktadır.
    for (int i = 0; i < row; ++i) {
        for (int j = 0; j < col; ++j) { 
            ar[i][j] = cnt++;
        }
    }

    printf("\n");
    
    // Aşağıdaki döngü ile iki boyutlu dizi yazdırılmaktadır.
    for (int i = 0; i < row; ++i) {
        for (int j = 0; j < col; ++j) { 
            printf("%d ", ar[i][j]);
        }
        printf("\n");
    }
}
```


👇 Aşağıdaki programdaki **VLA** kullanımında değişken boyutlu dizilere ilk değer verilemediği incelenebilir, verilmesi sözdizim hatasına neden olur. Aşağıdaki program Gcc ve Clang derleyicilerinde çalışır ama Microsoft derleyicisinde çalışmayacaktır.
```C
#include <stdio.h>

int main(void)
{
    int x = 5;
    int ary[x] = { 2, 5, 7, 8, 4, };
}
```



👇 Aşağıdaki programda median değerinin iki farklı yolla nasıl hesaplandığı incelenebilir.
```C
#include <stdio.h>

int icmp(const void* vp1, const void* vp2)
{
    return *(const void*)vp1 - *(const void*)vp2;
}

// Aşağıdaki fonksiyon bir tam sayı dizisinin sıralandıktan sonra ortasındaki median değerini geriye 'dinamic memory managament' kullanılarak dönmektedir.
int get_median(const int* p, size_t size)
{
    int *pd = (int*)malloc(size * sizeof(int));
    if(!pd){
        fprintf(stderr, "cannot allocate memory!\n");
        exit(EXIT_FAILURE);
    }

    memcpy(pd, p, size * sizeof(int));
    qsort(pd, sizeof(int), &icmp);
    int retval = pd[size / 2];

    free(pd);

    return retval;
}

// Aşağıdaki fonksiyon bir tam sayı dizisinin sıralandıktan sonra ortasındaki median değerini geriye 'VLA' kullanılarak dönmektedir.
int get_median2(const int* p, size_t size)
{
    int ar[size];

    memcpy(ar, p, size * sizeof(int));
    qsort(ar, sizeof(int), &icmp);

    return ar[size / 2];
}

int main(void)
{
    
}
```


Ders sonu ...
