# 44.Ders 22.06.2025 ğŸ•˜

Derse 9(09:01)-11(09:05)-12(09:20)-13(10:01)-14(10:20)-15(11:01)-15(12:01) kiÅŸi katÄ±ldÄ±.
---

C ve C++ dillerinde tÃ¼rler(types) iki Ã¶beÄŸe ayrÄ±lmaktadÄ±r;
1. **Basic Types**: Tam sayÄ± ve ondalÄ±klÄ±(kesirli) sayÄ± tÃ¼rlerini tutmak iÃ§in kullanÄ±lan dil tarafÄ±ndan hazÄ±r olarak sunulan Ã¶bektir. AyrÄ±ca **fundamental types**, **built-in types**, **primitive types** adlarÄ± ile de bilinmektedir.
2. **User Defined Types**: Dilin belirli araÃ§larÄ±nÄ±n kullanÄ±lmasÄ±yla dili kullananlarÄ±n oluÅŸturabildiÄŸi tÃ¼rlerdir, C dilinde **user defined type** oluÅŸturmak iÃ§in **Structures(YapÄ±lar)**, **Unions(Birlikler)**, **Enumarations, Enums(NumaralandÄ±rma)** olarak dilin Ã¼Ã§ farklÄ± aracÄ± vardÄ±r.


ğŸ§­ KullanÄ±cÄ± tanÄ±mlÄ± tÃ¼rler olarak C dilinde Ã¼Ã§ farklÄ± veri tÃ¼rÃ¼ vardÄ±r, bunlar;
- **Structures(YapÄ±lar)**, 12 saat zaman alacak
- **Unions(Birlikler)**, 2 saat zaman alacak
- **Enumarations, Enums(NumaralandÄ±rma)**, 2 saat zaman alacak


## User Defined Types

ğŸš€ **Abstraction(Soyutlama)**: Bir varlÄ±ÄŸÄ±n bÃ¼tÃ¼n Ã¶zellikleriyle incelenmesi, gÃ¶zlemlenmesi yerine o varlÄ±ÄŸÄ±n sadece bizi ilgilendiren kÄ±sÄ±mlarÄ±yla incelenmesi, gÃ¶zlemlenmesi duurmunu ifade eden bir terimdir.

Ä°nsanlar gÃ¼nlÃ¼k hayatlarÄ±nda ve kullandÄ±klarÄ± dilde soyutlamalarla yaÅŸamaktadÄ±r, mesela buzdolabÄ± dendiÄŸinde zihinde yiyeceklerin tutulmasÄ± iÃ§in kullanÄ±lan bir cihaz akla gelir fakat bir buzdolabÄ± karmaÅŸÄ±k yapÄ±ya(soÄŸutma sistemi, elektronik sistemi) sahiptir ama dilde tek bir sÃ¶zcÃ¼k ile o cihaz basitleÅŸtirilip soyutlanmÄ±ÅŸ olmaktadÄ±r. </br>
Programlama dilleri de farklÄ± seviyelerde soyutlamalardan oluÅŸmaktadÄ±r.

ğŸš€ **Data Abstraction(Veri soyutlama)**: Programlama dilindeki veri tÃ¼rleri ilgili problem alanÄ±ndaki varlÄ±klara iliÅŸkin soyutlamalarÄ±n yapÄ±lmasÄ±nÄ± saÄŸlamaktadÄ±r, iÅŸte bu biÃ§imde verilere indirgenerek yapÄ±lan soyutlamalara iÃ§in kullanÄ±lan bir terimdir.

C++ dilinin en gÃ¼Ã§lÃ¼ araÃ§larÄ±ndan biri yÃ¼ksek dÃ¼zeyde bir soyutlamaya izin vermesidir. </br>
C dili kÃ¼Ã§Ã¼k bir dil, fazla bir araca sahip deÄŸil, C dili C++, Java, C# gibi dillerle karÅŸÄ±laÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda Ã§ok kÃ¼Ã§Ã¼k bir dildir. </br>
C dilindeki soyutlama desteÄŸi azdÄ±r bu nedenle Ã§ok yÃ¼ksek seviyeli bir soyutlamaya izin vermez. </br>
C dilinin donanÄ±ma Ã§ok yakÄ±n bir dil olmasÄ± sayesinde ihtiyaÃ§ duyulan 


C++ dilinde bulunan kod yazan kod oluÅŸturulabilmeyi saÄŸlayan **template** aracÄ± vardÄ±r. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki program parÃ§asÄ±nda **template** aracÄ±nÄ±n kullanÄ±mÄ± gÃ¶rÃ¼lebilir.
```C++
template<typename T>
void swap(T &x, T &y)
{
    T temp{x};
    x = y;
    y = temp;
}
```


### `struct` AracÄ± 

`struct` aracÄ±nÄ±nn adÄ± **Sutructure** sÃ¶zcÃ¼ÄŸÃ¼nden tÃ¼retilmiÅŸtir. </br>
C dilinde Ã§alÄ±ÅŸÄ±lan problem uzayÄ±ndaki verileri yazÄ±lÄ±msal olarak bir tÃ¼r ile temsil edip o tÃ¼rlerden deÄŸiÅŸkenler oluÅŸturma, o tÃ¼rlerle ilgili fonksiyonlar tanÄ±mlayabilme ve hatta o tÃ¼rleri baÅŸka tÃ¼rlerin oluÅŸturulmasÄ±nda yapÄ±taÅŸÄ± olma imkanÄ± veren araÃ§ `struct` aracÄ±dÄ±r. </br>
C dilinde veri soyutlamak iÃ§in en Ã§ok kullanÄ±lan veri tÃ¼rÃ¼ `struct` veri tÃ¼rÃ¼dÃ¼r. Nerdeyse her C programÄ±nda `struct` veri tÃ¼rÃ¼nÃ¼n kullanÄ±ldÄ±ÄŸÄ± gÃ¶rÃ¼lecektir.


#### `struct` TanÄ±mlama SÃ¶zdizimi 

Bir `struct` bir ada sahiptir ve bunun haricinde elemanlara sahiptir.

ğŸ‘‡ AÅŸaÄŸÄ±daki program `struct` bildiriminin nasÄ±l yapÄ±ldÄ±ÄŸÄ± gÃ¶rÃ¼lebilir.
```C
struct StructName {
    // Burada bildirilen elemanlara 'structure members' denilmektedir. 
};

struct Date {
    int d, m, y;
};

struct Nec {
    int x, y;
    double d1, d2;
};
```


â—â—â— C dilinin kurallarÄ±na gÃ¶re `struct` bir varlÄ±k en az bir tane Ã¼yeye sahip olmalÄ±dÄ±r. </br>
ğŸ‘‡ AÅŸaÄŸÄ±da yukarÄ±daki bilgiyle ifade edilen durum gÃ¶rÃ¼lebilir.
```C
// C derleyicisi aÅŸaÄŸÄ±daki gibi bir yapÄ± tanÄ±mÄ± yapÄ±lmak istendiÄŸinde 'sÃ¶zdizim hatasÄ±(syntax error)' verecektir.
struct Nec {

};
```


â—â—â— Derleyici `struct` tanÄ±mÄ±nÄ± gÃ¶rdÃ¼ÄŸÃ¼nde bellekte yer ayÄ±racak kodu Ã¼retmez, `struct` nesnesi tÃ¼rÃ¼nden deÄŸiÅŸken tanÄ±mlandÄ±ÄŸÄ± zaman bellekte yer ayÄ±racak makine kodu Ã¼retilecektir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda yapÄ± tÃ¼rÃ¼nden deÄŸiÅŸken bildiriminin nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
// 'Nec' adÄ±(identifier) bir 'structure tag'tir. 
// 'Nec' adÄ±ndaki yapÄ± tÃ¼rÃ¼ bellekte tek bir blokta '(4 + 4) + (8 + 8) = 24 byte' yer kaplayacaktÄ±r.
struct Nec {
    int x, y;
    double d1, d2;
};

int main(void)
{
    struct Nec _nec_instand; // 'struct Nec' tÃ¼rÃ¼nden bir deÄŸiÅŸken bildirimi bu ÅŸekilde 'struct' Ã¶neki kullanÄ±larak yapÄ±lmak zorundadÄ±r. Bu tÃ¼m 'user defined type'lar iÃ§in kendi tÃ¼rleri iÃ§in geÃ§erlidir.
}
```


â—â—â—`struct X { ... }`,`union Y { ... }`,`enum Z { ... }` buradaki kullanÄ±cÄ± tanÄ±mlÄ± tÃ¼rlerin bildirimlerindeki `X`, `Y`, `Z` **etiketleri(tag)** tÃ¼rÃ¼ temsil eden adlar deÄŸildir, tÃ¼rÃ¼ temsil eden `struct X`, `union Y`, `enum Z` adlarÄ±dÄ±r. 



â—â—â— Bir `struct` veri tÃ¼rÃ¼ bellekte tek bir blok olarak, yapÄ±nÄ±n Ã¼yeleri yukarÄ±dan aÅŸaÄŸÄ±ya doÄŸru sÄ±ralÄ± olacak biÃ§imde derleyiciden derleyiciye deÄŸiÅŸmeyecek biÃ§imde sÄ±ralÄ± olmak zorundadÄ±r(donanÄ±msal olarak veri tersten sÄ±ralanÄ±yor olabilir ama yazÄ±lÄ±m dili soyutlamasÄ± aÃ§Ä±sÄ±ndna bu bir fark oluÅŸturmaz) </br>
â—â—â— Bir `struct` veri tÃ¼rÃ¼nden oluÅŸturulan deÄŸiÅŸkenin fiziksel bellek adresi `struct` veri tÃ¼rÃ¼nÃ¼n ilk Ã¼yesinin fiziksel bellek adresiyle aynÄ±dÄ±r. </br>



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `struct` veri tÃ¼rÃ¼yle ilgili ve bellek ihtiyacÄ±nÄ±n ne olacaÄŸÄ±yla ilgili bilgi alÄ±nabilir.
```C
#include <stdio.h>

// 'struct Nec' tÃ¼rÃ¼nden deÄŸiÅŸken tanÄ±mlandÄ±ÄŸÄ±nda tanÄ±mlanan deÄŸiÅŸkenin elemanlarÄ± bellekte 'x', 'y', 'd1', 'd2' olarak sÄ±ralÄ± olmak zorundadÄ±r.
struct Nec {
    int x, y;
    double d1, d2;
};

int main(void)
{
    printf("sizeof(struct Nec) = %zu\n", sizeof(struct Nec)); // Burada 'struct Nec' tÃ¼rÃ¼nÃ¼n bellek ihtiyacÄ± en az yaÄŸÄ±nÄ±n Ã¼yelerinin toplamÄ± kadardÄ±r ama bu deÄŸerden de yÃ¼ksek olabilir.
}
```

**YapÄ±larla(structer)** ile ilgili derler devam ederken Ã¶nemli alt baÅŸlÄ±klardan biri **alignment(hizalama)** olacak, **alignment(hizalama)** konusu Ã§ok derin ve Ã¶nemli bir konudur.


**Alligment(Hizalama)**: BazÄ± nedenlerden dolayÄ± `struct` varlÄ±klarÄ±nÄ±n nesneleri bellekte tutulurken yapÄ±nÄ±n Ã¼yesi olan tÃ¼rlerin arasÄ±nda kullanÄ±lmayan byte'larÄ±n olabilmesi durumudur.

â—â—â— Bir `struct` veri tÃ¼rÃ¼nde **pedding bytes** olmadÄ±ÄŸÄ±nda o `struct` veri tÃ¼rÃ¼nÃ¼n bellek ihtiyacÄ± en az elemanlarÄ±nÄ±n toplam bellek ihtiyacÄ± kadardÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `struct` veri tÃ¼rÃ¼yle ilgili ve bellek ihtiyacÄ±nÄ±n ne olacaÄŸÄ±yla ilgili bilgi alÄ±nabilir.
```C
#include <stdio.h>

struct Nec {
    int x, y;
    double d1, d2;
    int s[10];
};

int main(void)
{
    printf("sizeof(struct Nec) = %zu\n", sizeof(struct Nec)); // Burada 'struct Nec' tÃ¼rÃ¼nÃ¼n bellek ihtiyacÄ± en az yaÄŸÄ±nÄ±n Ã¼yelerinin toplamÄ± kadardÄ±r ama bu deÄŸerden de yÃ¼ksek olabilir.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `struct` veri tÃ¼rÃ¼nÃ¼n Ã¼yelerinin hangi tÃ¼rler olabileceÄŸi incelenebilir.
```C
#include <stdio.h>

struct Erg {
    int a, b;
};

struct Nec {
    int x;
    char s[10];
    int a[3];
    int* p;
    int(*fptr)(int);
    struct Erg e;

    struct Nec n; // Bu yapÄ± elemanÄ± legal deÄŸildir.
    struct Nec* pn; // Bu yapÄ± elemanÄ± legaldir, bir yapÄ± kendi tÃ¼rÃ¼nden yapÄ±larÄ±n gÃ¶stericilerine sahip olabilir.
};
```


#### `struct` TÃ¼rÃ¼nÃ¼n YÃ¼zeysel Ä°nceleniÅŸi 



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan `struct` nesnesi tÃ¼rÃ¼nden deÄŸiÅŸkenlerin Ã¶mÃ¼rlerinin kullanÄ±lma biÃ§imlerine gÃ¶re nasÄ±l olacaÄŸÄ± incelenebilir.
```C
#include <stdio.h>

struct Nec {
    int x, y;
    double d;
};

struct Nec n1; // Static Ã¶mÃ¼rlÃ¼ global deÄŸiÅŸken.

void foo(struct Nec p) // Fonksiyon parametresi 'struct Nec' tÃ¼rÃ¼ndendir.
{
    struct Nec n1; // Otomatic Ã¶mÃ¼rlÃ¼ yerel(local) deÄŸiÅŸken.
    static struct Nec n1; // Static Ã¶mÃ¼rlÃ¼ yerel(local) deÄŸiÅŸken.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `struct Nec` tÃ¼rÃ¼nden olan dizi tanÄ±mlanabileceÄŸi incelenebilir, buradaki kullanÄ±m tÃ¼m **user defint type** iÃ§in de geÃ§erlidir.
```C
#include <stdio.h>

struct Nec {
    int x, y;
    double d;
};

int main(void)
{
    struct Nec a1[6]; // ElemanlarÄ± 'struct Nec' tÃ¼rÃ¼nden olan altÄ± elemanlÄ± bir dizi tanÄ±mÄ±.
    struct Nec a1[4][11]; // ElemanlarÄ± 'struct Nec[11]' tÃ¼rÃ¼nden olan dÃ¶rt elemanlÄ± bir dizi tanÄ±mÄ±.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `struct Nec` tÃ¼rÃ¼nden gÃ¶sterici deÄŸiÅŸkenlerin tanÄ±mlanabileceÄŸi gÃ¶rÃ¼lebilir, buradaki kullanÄ±m tÃ¼m **user defint type** iÃ§in de geÃ§erlidir.
```C
#include <stdio.h>

struct Nec {
    int x, y;
    double d;
};

int main(void)
{
    struct Nec mynec;
    struct Nec* p = &mynec;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `struct` nesnesi tÃ¼rlerine nasÄ±l ilk deÄŸer verilebileceÄŸi gÃ¶rÃ¼lebilir.
```C
#include <stdio.h>

struct Nec {
    int x, y;
    double d;
};

int main(void)
{
    struct Nec mynec = { 1, 6, 2.1 }; // Structure initialization
}
```


> â” 
> 
> Sorulan soru;
> 
> Array decay benzeri bir ÅŸey mi oluyor?
> 
> Cevap;
> 
> HayÄ±r Ã¶yle bir ÅŸey yok. Bir yapÄ± nesnesinin adÄ± bir **ifadede(expression)** kullanÄ±ldÄ±ÄŸÄ±nda o yapÄ± nesnesinin adÄ± Ã¶rtÃ¼lÃ¼ olarak baÅŸka bir tÃ¼re dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmemektedir. 




ğŸ‘‡ AÅŸaÄŸÄ±daki programda `struct` nesnelerle birlikte `const`, `extern` gibi **basic types** ile kullanÄ±labilen tanÄ±mlayÄ±cÄ±larÄ±n kullanÄ±labileceÄŸi gÃ¶rÃ¼lebilir.
```C
// main.c dosyasÄ±
#include <stdio.h>

struct Nec {
    int x, y;
    double d;
};


// kemal.c dosyasÄ±
struct Nec mynec = { 1, 6, 2.1 }; // Struct initialization ve buradaki 'mynec' adÄ±ndaki deÄŸiÅŸken dÄ±ÅŸarÄ±ya aÃ§Ä±ktÄ±r.
const struct Nec cn = { 11, 61, 21.1 };


//kemal.h dosyasÄ±
extern struct Nec mynec;
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir fonksiyonun geri dÃ¶nÃ¼ÅŸ tÃ¼rÃ¼nÃ¼n yapÄ± tÃ¼rÃ¼nden olabileceÄŸi incelenebilir.
```C
#include <stdio.h>

struct Nec {
    int x, y;
    double d;
};

struct Nec foo(struct Nec);
struct Nec* bar(struct Nec*);
struct Nec* baz(const struct Nec*);
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `struct` nesnesi tÃ¼rÃ¼nden deÄŸiÅŸkenlerin Ã¼yelerinin hayatlarÄ±na nasÄ±l baÅŸlayacaklarÄ± incelenebilir.
```C
#include <stdio.h>

struct Nec {
    int x, y;
    double d;
};

struct Nec gnec; // 'gnec' tÃ¼rÃ¼ global deÄŸiÅŸken olduÄŸu iÃ§in Ã¼yeleri tÃ¼rlerine gÃ¶re '0', 'NULL pointer' gibi deÄŸerlerle hayatÄ±na baÅŸlar. 

void foo(void)
{
    static struct Nec lnec; // 'lnec' tÃ¼rÃ¼ static local deÄŸiÅŸken olduÄŸu iÃ§in Ã¼yeleri tÃ¼rlerine gÃ¶re '0', 'NULL pointer' gibi deÄŸerlerle hayatÄ±na baÅŸlar. 
    struct Nec lnec2; // 'lnec2' tÃ¼rÃ¼ local deÄŸiÅŸken olduÄŸu iÃ§in Ã¼yeleri hayatÄ±na baÅŸlar Ã§Ã¶p deÄŸerle baÅŸlar. 
}

int main(void)
{

}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda ad Ã§akÄ±ÅŸmasÄ± durumunun olmadÄ±ÄŸÄ± farklÄ± varlÄ±klara aynÄ± adÄ±n verilmesi durumu incelenebilir.
```C
#include <stdio.h>

// 'struct' adÄ± ve bir Ã¼yesinin adÄ± aynÄ±, ama farklÄ± baÄŸlamlarda olmalarÄ±ndan dolayÄ± bu sorun deÄŸil.
struct nec{
    int nec;
};

int main()
{   
    struct nec nec;
    nec.nec = 8;
}   
```


â—â—â— YapÄ± tÃ¼rlerinin tanÄ±mlarÄ± ihtiyaca gÃ¶re ya baÅŸlÄ±k dosyasÄ±nda ya da kaynak dosyada olabilir. Client kodlarÄ± ilgilendiren bir yapÄ± tÃ¼rÃ¼nÃ¼n bildirimi **.h** dosyasÄ±nda yapÄ±lÄ±r, client kodlarÄ± ilgilendirmeyen bir yapÄ± tÃ¼rÃ¼nÃ¼n bildirimi **.c** dosyasÄ±nda yapÄ±lÄ±r Ã§Ã¼nkÃ¼ dÄ±ÅŸarÄ±ya aÃ§Ä±lmayacaktÄ±r.

C Standart kÃ¼tÃ¼phenesinin Ã¶nemli modÃ¼llerinden biri olan `time.h` modÃ¼lÃ¼nde dÄ±ÅŸarÄ±ya aÃ§Ä±k olan `struct tm` adÄ±nda bir **user defient type** bulunuyor ve bu tÃ¼rÃ¼n bildirimi dÄ±ÅŸarÄ±ya aÃ§Ä±k yapÄ±ldÄ±ÄŸÄ±ndan dolayÄ± **.h** dosyasÄ±ndadÄ±r.


#### YapÄ± Nesnesinin ElemanlarÄ±na EriÅŸim 

`.` ve `->` operatÃ¶rlerine **member selection(eleman seÃ§me) operatÃ¶rleri** denmektedir ve bu operatÃ¶rler yapÄ± nesnelerine eriÅŸim saÄŸlamak iÃ§in kullanÄ±lmaktadÄ±r. </br>
`.` operatÃ¶rÃ¼ne **member selection dot(nokta eleman seÃ§me) operatÃ¶rÃ¼** denmektedir. </br>
`->` operatÃ¶rÃ¼ne **member selection arrow(ok eleman seÃ§me) operatÃ¶rÃ¼** denmektedir. </br>



â—â—â— `.` ve `->` operatÃ¶rlerinin ikisi de yapÄ± nesnelerinin elemanlarÄ±na eriÅŸmek iÃ§in kullanÄ±lmaktadÄ±r. AralarÄ±ndaki fark;
- `.` operatÃ¶rÃ¼ ile yapÄ± nesnesinin adÄ± Ã¼zerinden yapÄ±nÄ±n elemanlarÄ±na eriÅŸirken kullanÄ±lan operatÃ¶rdÃ¼r.
- `->` operatÃ¶rÃ¼ ile yapÄ± nesnesinin gÃ¶stericisi Ã¼zerinden yapÄ±nÄ±n elemanlarÄ±na eriÅŸirken kullanÄ±lan operatÃ¶rdÃ¼r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `.` ve `->` operatÃ¶rlerinin kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>

struct Nec {
    int x, y;
    int ar[5];
};

int main()
{   
    struct Nec mynec;
    struct Nec* ptr = &mynec;

    mynec.x = 11;
    ptr->x = 13;
}
```


#### `.` Member Selection Dot Operator 

Nokta operatÃ¶rÃ¼ **binary** Ã¶zellikte olan yani iki operand alan bir operatÃ¶rdÃ¼r. </br>
Nokta operatÃ¶rÃ¼nÃ¼n sol operandÄ± bir `struct` nesnesi ya da bir `union` nesnesi olmak zorundadÄ±r. </br>
Derleyici `str.x` gibi bir ifadeyle karÅŸÄ±laÅŸtÄ±ÄŸÄ±nda ilk Ã¶nce `.` operatÃ¶rÃ¼nÃ¼n sol operandÄ±na bakar, o operant `struct` ya da `union` tÃ¼rÃ¼nden olma durumuna bakar. </br>
ArdÄ±ndan saÄŸ operandÄ±n, nesnenin bir Ã¼yesi olup olmadÄ±ÄŸÄ±na bakar.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `.` operatÃ¶rÃ¼ ile bir yapÄ± nesnesinin elemanlarÄ±na eriÅŸimin nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>

struct Nec {
    int x, y;
    double d1, d2;
};

int main()
{   
    struct Nec mynec;

    mynec.x = 6;
    mynec.y = 6;
    mynec.d1 = 6.;
    mynec.d2 = 6.;

    mynec.a; // SÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.
}
```



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programda `struct Nec` tÃ¼rÃ¼nden tÃ¼retilen ifadelerle ilgili bilgiler incelenebilir. Bu programdaki bilgilerin iyi ÅŸekilde Ã¶zÃ¼mlenmesi gerekiyor.
```C
#include <time.h>

struct Nec {
    int x, y, z;
    double d;
};

int main()
{   
    struct Nec mynec;

    // 'mynec' bu bir ifadedir, tÃ¼m ifadeler gibi bu ifadenin de tÃ¼rÃ¼ vardÄ±r ve bu ifadenin tÃ¼rÃ¼ 'struct Nec' tÃ¼rÃ¼dÃ¼r, bu ifade 'L-value' Ã¶zelliktedir.

    // 'mynec.x' bu bir ifadedir, tÃ¼m ifadeler gibi bu ifadenin tÃ¼rÃ¼ vardÄ±r ve bu ifadenin tÃ¼rÃ¼ 'int' tÃ¼rÃ¼dÃ¼r , bu ifade 'L-value' Ã¶zelliktedir.

    mynec.x = 2.4;
    mynec.d = 1232;
    ++mynec.x; // YapÄ± nesnesinin 'x' adÄ±ndaki nesnesine eriÅŸilip deÄŸeri bir arttÄ±rÄ±lÄ±yor.
    int* p = &mynec.x; // YapÄ± nesnesinin 'x' adÄ±ndaki nesnesinin adres deÄŸeri 'p' deÄŸiÅŸknine atanÄ±yor.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program `.` operatÃ¶rÃ¼yle oluÅŸturulan bazÄ± ifadelerdeki diÄŸer operatÃ¶rlerle birlikte kullanÄ±ldÄ±ÄŸÄ±nda operatÃ¶r Ã¶nceliÄŸinin nasÄ±l olduÄŸunu anlamak iÃ§in incelenebilir. 
```C
#include <time.h>

struct Nec {
    int x, y, z;
};

int main()
{   
    struct Nec mynec;

    mynec.x = 4;

    // AÅŸaÄŸÄ±daki ifadelerin hiÃ§biri Ã¶ncelik parantezine ihtiyaÃ§ duymamaktadÄ±r.
    !mynec.x;
    mynec.x++;
    --mynec.x;
    mynec.x > mynec.y;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda birinci Ã¶ncelik seviyesine sahip operatÃ¶r kullanÄ±mlarÄ±nda iÅŸlem Ã¶nceliÄŸine gÃ¶re Ã¶ncelik parantezi gerekmediÄŸi durumlar incelenebilir.
```C
#include <time.h>

struct Nec {
    int ar[10];
};

int main()
{   
    struct Nec mynec;

    mynec.ar[2] = 4; // Burada Ã¶ncelk parantezi gerekmemektedir.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda birinci Ã¶ncelik seviyesine sahip operatÃ¶r kullanÄ±mlarÄ±nda iÅŸlem Ã¶nceliÄŸine gÃ¶re Ã¶ncelik parantezi gerekmediÄŸi durumlar incelenebilir.
```C
#include <time.h>

struct Nec {
    int ar[10];
    int (*ft)(int); // Fuction pointer
};

int main()
{   
    struct Nec mynec;

    mynec.ar[4]; // Buradaki ifadede '.' ve '[]' operatÃ¶rleri var ve bu operatÃ¶rler birinci Ã¶ncelik seviyesinde ve Ã¶ncelik yÃ¶nÃ¼ soldan saÄŸa olduÄŸu iÃ§in ilk Ã¶nce '.' operatÃ¶rÃ¼nÃ¼ ardÄ±ndan '[]' operatÃ¶rÃ¼ iÅŸletilecektir, bu nedenden dolayÄ± da Ã¶ncelik parantezi gerekmez.
    mynec.ft(10); // Buradaki ifadede '.' ve '()' operatÃ¶rleri var ve bu operatÃ¶rler birinci Ã¶ncelik seviyesinde ve Ã¶ncelik yÃ¶nÃ¼ soldan saÄŸa olduÄŸu iÃ§in ilk Ã¶nce '.' operatÃ¶rÃ¼nÃ¼ ardÄ±ndan '()' operatÃ¶rÃ¼ iÅŸletilecektir, bu nedenden dolayÄ± da Ã¶ncelik parantezi gerekmez.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda birinci Ã¶ncelik seviyesine sahip operatÃ¶r kullanÄ±mlarÄ±nda iÅŸlem Ã¶nceliÄŸine gÃ¶re Ã¶ncelik parantezi gerekmediÄŸi durumlar incelenebilir.
```C
#include <time.h>

struct Nec {
    int ar[10];
    int (*ft)(int); // Fuction pointer
};

int main()
{   
    struct Nec a[5];

    a[2].fp(6); // Ã–ncelik parantezi gerekmemektedir.
    a[2].ar[3]; // Ã–ncelik parantezi gerekmemektedir.
    ((a[2])).ar[3]; // Bir Ã¶nceki statement'taki ile aynÄ± anlama gelen Ã¶ncelik parantezlerinin kullanÄ±ldÄ±ÄŸÄ± statement.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir yapÄ± nesnesinin elemanlarÄ±na nasÄ±l deÄŸer atanabileceÄŸi incelenebilir.
```C
#include <time.h>

struct Nec {
    int x, y, z;
};

int main()
{   
    struct Nec mynec;
    int iv = 65;
    
    // '.' operatÃ¶rÃ¼ ile eriÅŸilen deÄŸerler, eriÅŸilen ilgili Ã¼yenin tÃ¼rÃ¼nÃ¼n kullanabileceÄŸi her yerde kullanÄ±labilir.

    // Mynec oluÅŸturulduÄŸu anda tÃ¼m deÄŸiÅŸkenler dÃ¼nyaya geliyor Ã§Ã¶p deÄŸerde baÅŸlÄ±yor, 
    mynec.x = 56;

    // ...

    mynec.z = iv;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir yapÄ±nÄ±n Ã¼yesi dizi olduÄŸunda o yapÄ±nÄ±n dizi elemanÄ±na eriÅŸilip kullanÄ±ldÄ±ÄŸÄ± ifadelerde de **array decay** uygulanacaÄŸÄ± gÃ¶rÃ¼lmelidir.
```C
#include <time.h>

struct Nec {
    int x, y;
    int ar[10];
};

int main()
{   
    struct Nec mynec;
    
    mynec.x; // Bu ifade 'int' tÃ¼rÃ¼ndedir.
    mynec.ar; // Bu ifadenin tÃ¼rÃ¼ 'array decay' sonucunda 'int*' tÃ¼rÃ¼ndedir.

    int* p1 = mynec.ar;
    int* p2 = &mynec.ar[0]; // Buradaki statement ile yukarÄ±daki statement birbirine denktir.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `nutility.h` baÅŸlÄ±k dosyasÄ±nda bildiirmi olan `randomize`, `set_array_random` ve `print_array` fonksiyonlarÄ±na bir yapÄ±nÄ±n dizi tÃ¼rÃ¼nden Ã¼yesi ile nasÄ±l kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#include <time.h>
#include "nutility.h"

struct Nec {
    int x, y;
    int ar[10];
};

int main()
{   
    struct Nec mynec;
    
    randomize();
    set_array_random(mynec.ar, 10);
    print_array(mynec.ar, 10); // Derleyici buradaki ifadeyi 'print_array(&mynec.ar[0], 10)' ifadesine dÃ¶nÅŸtÃ¼rÃ¼r.
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 11.02-11.22 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


ğŸ§  C dilinde bir yapÄ± nesnesi yalnÄ±zca aÅŸaÄŸÄ±daki operatÃ¶rlerin operandÄ± olabilir, sadece dÃ¶rt operatÃ¶r var, bunlar;
- `.` member selection dot operator.
- `&` address operator.
- `sizeof` operator.
- `->` member selection arrow operator.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir `struct` nesnesinin  `.`, `&`, `sizeof` operatÃ¶rlerinin operandÄ± olma durumu incelenebilir.
```C
#include <time.h>
#include "nutility.h"

struct Nec {
    int x, y;
    int ar[10];
};

int main()
{   
    struct Nec mynec;
    
    mynec.x = 7; // YapÄ± nesnene '.' operatÃ¶rÃ¼nÃ¼n operandÄ± olabilir.
    &mynec; // YapÄ± nesnene '&' operatÃ¶rÃ¼nÃ¼n operandÄ± olabilir.

    // void tÃ¼rÃ¼nden olmayan tÃ¼m ifadeler `sizeof` operatÃ¶rÃ¼nÃ¼n operandÄ± olabilir.
    int ar[sizeof mynec]; // Buradaki kullanÄ±m legaldir.
    int ar[sizeof(struct Nec)]; // Buradaki kullanÄ±m legaldir.
    int ar[sizeof struct Nec]; // Buradaki kullanÄ±m illegaldir, sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.
}
```



â—â—â— C dilinde yapÄ± nesneleri atama operatÃ¶rÃ¼nÃ¼n sol operandÄ± ya da saÄŸ operandÄ± olabilir, sol ve saÄŸ operandÄ±n aynÄ± tÃ¼rden olmasÄ± gerekir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda aynÄ± tÃ¼rden `struct` nesnelerinin birbirine atanmasÄ± iÅŸlemleri incelenebilir.
```C
#include <time.h>
#include "nutility.h"

struct Nec {
    int x, y;
    double d;
    char str[10];
};

struct Erg{
    int x, y;
    double d;
    char str[10];
};

int main()
{   
    struct Nec x = { 3, 7, 2.7, "altar" };
    struct Nec y = x; // Buradaki ilk deÄŸer verme iÅŸlemi legaldir.

    struct Erg e1;
    e1 = x; // Buradaki atama iÅŸlemi illegaldir Ã§Ã¼nkÃ¼ iki yapÄ± nesnesinin tÃ¼rleri farklÄ±dÄ±r.

    struct Nec n1 = { 4, 13, 2.7, "tarkan" };
    struct Nec n2;

    n2 = n1; // Buradaki atama iÅŸlemi legaldir, aynÄ± tÃ¼rden iki yapÄ± nesnesi birbirine atandÄ±ÄŸÄ±nda karÅŸÄ±lÄ±klÄ± olarak aynÄ± Ã¼yeler arasÄ±nda atama iÅŸlemi yapÄ±lÄ±r.
    // memcpy(&n2, &n1, sizeof n1); // Buradaki statement yukarÄ±daki statement'a denktir. C dilinin standardÄ±nÄ±n olmadÄ±ÄŸÄ± ilk dÃ¶nemlerinde iki yapÄ± nesnesi birbirine atanamÄ±yordu, o dÃ¶nemde buradaki gibi 'memcpy' fonksiyonuyla iki yapÄ± nesnesi birbirine atanÄ±yordu.

    printf("%d %d\n", n1.x, n2.x);
    printf("%d %d\n", n1.y, n2.y);
    printf("%f %f\n", n1.d, n2.d);
    printf("%s %s\n", n1.str, n2.str);
}
```


âš ï¸âš ï¸âš ï¸ YapÄ± deÄŸiÅŸkenlerinin birbirine atama iÅŸlemi bir bloktan baÅŸka bir bloÄŸa kopyama iÅŸlemidir, bu da kopyalanacak bellek bloÄŸunun bÃ¼yÃ¼klÃ¼ÄŸÃ¼ne gÃ¶re maliyetli olabilir. YapÄ± nesneleriyle yapÄ±lan atama iÅŸlemlerinde dikkatli olunmasÄ± gerekiyor.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `time.h` modÃ¼lÃ¼ndeki `struct tm` tÃ¼rÃ¼nden deÄŸiÅŸkenin bellek boyutunun ne olacaÄŸÄ± gÃ¶rÃ¼lebilir.
```C
#include <stdio.h>
#include <string.h>
#include <time.h>

#include "nutility.h"

int main()
{
    printf("%zu", sizeof(struct tm));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda yapÄ± tÃ¼rlerindeki atama ve tÃ¼r dÃ¶nÃ¼ÅŸtÃ¼rme iÅŸlemlerinden hangilerinin illegal olduÄŸu incelenebilir.
```C
#include <stdio.h>
#include <string.h>
#include <time.h>

#include "nutility.h"

struct Nec {
    int a, b, c;
};

struct Erg{
    int a, b, c;
};

int main(void)
{   
    struct Nec mynec = { 3, 6, 7 };
    struct Erg myerg;

    myerg = mynec; // Buradaki atama iÅŸlemi illegaldir.

    myerg = (struct Nec)mynec; // Buradaki gibi bir tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ illegaldir. Bir yapÄ± tÃ¼rÃ¼ tÃ¼r dÃ¶nÃ¼ÅŸtÃ¼rme operatÃ¶rÃ¼nde hedef tÃ¼r olamaz.


    struct Nec* p = &mynec;
    (struct Erg*)&myerg; // Buradaki gibi bir , tÃ¼r dÃ¶nÃ¼ÅŸtÃ¼rme operatÃ¶rÃ¼nde hedef tÃ¼r bir 'yapÄ± pointer tÃ¼rÃ¼' olabilir ama hedef tÃ¼r yapÄ± tÃ¼rÃ¼nÃ¼n kendisi olamaz.
}
```



â—â—â— YapÄ± tÃ¼rlerine iliÅŸkin sÃ¶zdiziminin diÄŸer programlama dillerinde olan `class` gibi varlÄ±klar arasÄ±ndaki fark nedir(bunun anlatÄ±lmasÄ±nÄ±n nedeni Java, C# gibi dilleri bilenlerin C dilindeki farklÄ±lÄ±klarÄ± gÃ¶rmesi iÃ§indir)?

1. C dilinde **default member initializer** aracÄ± yoktur.

    ğŸ‘‡ AÅŸaÄŸÄ±daki programda C++ dilinde olan **default member initializer** aracÄ±nÄ±n olmadÄ±ÄŸÄ± gÃ¶rÃ¼lmelidir.
    ```C
    struct Data {
        int x;
        int y;
        double d = 4.6; // Buradaki gibi yapÄ± elemanlarÄ±ndan birine varsayÄ±lan deÄŸer verme aracÄ± yoktu, burada sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.
    };
    ```

2. C dilinde **member function** aracÄ± yoktur.

    ğŸ‘‡ AÅŸaÄŸÄ±daki programda C++ dilinde olan **member function** olarak adlandÄ±rÄ±lan yapÄ±nÄ±n bir Ã¼yesi olarak fonksiyon bulunamadÄ±ÄŸÄ± gÃ¶rÃ¼lmelidir.
    ```C
    struct Data {
        void foo(int); // Ä°llegaldir.
    };
    ```

3. C dilinde **access control(eriÅŸim kontolÃ¼)** aracÄ± yoktur.

    ğŸ‘‡ AÅŸaÄŸÄ±daki programda C++ dilinde diÄŸer bir Ã§ok dilde(Java, C# vb.) olan **access control(eriÅŸim kontolÃ¼)** aracÄ±nÄ±n yoktur, bir yapÄ±nÄ±n elemanlarÄ±nÄ±n hepsi eriÅŸime aÃ§Ä±ktÄ±r().
    ```C
    struct Data {
        public:

        protected:

        private:
    };
    ```


### Structure Initialization 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `struct Nec` tÃ¼rÃ¼ne nasÄ±l ilk deÄŸer verildiÄŸi incelenebilir. 
```C
#include <stdio.h>
#include <string.h>
#include <time.h>
#include "nutility.h"

struct Nec {
    int x, y;
    double d1, d2;
};

int main(void)
{   
    struct Nec nec = { 3, 6, 7.5, 3.98 };

    printf("%d %d %f %f", nec.x, nec.y, nec.d1, nec.d2);
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `struct Nec` tÃ¼rÃ¼ne ilk deÄŸer verirken hangi iÅŸlemlerin doÄŸru veya **sÃ¶zdizim hatasÄ±(syntax error)** olduÄŸu incelenebilir. 
```C
#include <stdio.h>
#include <string.h>
#include <time.h>
#include "nutility.h"

struct Nec {
    int x, y;
    double d1, d2;
};

int main(void)
{   
    struct Nec nec = { 3, 6, 7.5, 3.98, 6 }; // YapÄ±nÄ±n Ã¼ye sayÄ±sÄ±ndan daha fazla baÅŸlangÄ±Ã§ deÄŸeri verilmek istendiÄŸi iÃ§in illegaldir.
    struct Nec nec = { 2 }; // DeÄŸer verilmeyen yapÄ± Ã¼yeleri hayatlarÄ±na tÃ¼m byte'larÄ± '0' yapÄ±larak baÅŸlayacaktÄ±r.
    struct Nec nec = { 0 }; // DeÄŸer verilmeyen yapÄ± Ã¼yeleri hayatlarÄ±na tÃ¼m byte'larÄ± '0' yapÄ±larak baÅŸlayacaktÄ±r.
    struct Nec nec = { }; // C dilinde geÃ§ersiz bir ilk deÄŸer verme bildirimi, C++ dilinde geÃ§erlidir.

    printf("%d %d %f %f", nec.x, nec.y, nec.d1, nec.d2);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir yapÄ±nÄ±n eleanlarÄ±nÄ±n alacaÄŸÄ± deÄŸerlerin **indeterminat value(Ã§Ã¶p deÄŸer)** olup olmayacaÄŸÄ±nÄ±n dizilerdeki kurallar ile aynÄ± olduÄŸu incelenebilir.
```C
#include <stdio.h>
#include <string.h>
#include <time.h>
#include "nutility.h"

struct Nec {
    int x, y;
    double d1, d2;
};

struct Nec nec1; // Buradaki 'nec1' nesnesinin elemanlarÄ±nÄ±n byte deÄŸerleri yaÅŸamlarÄ±na '0' deÄŸeriyle baÅŸlar.

int main(void)
{
    struct Nec nec2; // Buradaki 'nec2' nesnesinin elemanlarÄ± Ã§Ã¶p deÄŸerde olacaktÄ±r.

    printf("%d %d %f %f", nec1.x, nec1.y, nec1.d1, nec1.d2); // Burada bir hata yoktur.
    printf("%d %d %f %f", nec2.x, nec2.y, nec2.d1, nec2.d2); // 'nec2' nesnesinin Ã¼yeleri Ã§Ã¶p deÄŸerde olduÄŸu iÃ§in 'ub' durumu vardÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir yapÄ±nÄ±n eleanlarÄ±nÄ±n alacaÄŸÄ± deÄŸerlerin **indeterminat value(Ã§Ã¶p deÄŸer)** olup olmayacaÄŸÄ±nÄ±n dizilerdeki kurallar ile aynÄ± olduÄŸu incelenebilir.
```C
#include <stdio.h>
#include <string.h>
#include <time.h>
#include "nutility.h"

struct Nec {
    int* p;
    int ar[5];
    int x;
};

struct Nec nec3; // Buradaki 'nec3' nesnesinin elemanlarÄ±nÄ±n byte deÄŸerleri yaÅŸamlarÄ±na '0' deÄŸeriyle baÅŸlar.

int main(void)
{
    struct Nec nec1; // Buradaki 'nec1' nesnesinin elemanlarÄ± Ã§Ã¶p deÄŸerde olacaktÄ±r.

    static struct Nec nec2; // Buradaki 'nec2' nesnesinin elemanlarÄ± tÃ¼m byte'larÄ± '0' oalrak hayatÄ±na baÅŸlar.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda yapÄ± nesnelerine ilk deÄŸer verirken sona eklenen **trailing comma**'nÄ±n legal olduÄŸu gÃ¶rÃ¼lmelidir, bu ne iÅŸe yarÄ±yor bilgisi burada Ã¶nemli deÄŸil. 
```C
#include <stdio.h>
#include <string.h>
#include <time.h>
#include "nutility.h"

struct Nec {
    int x, y, z;
};

int main(void)
{
    struct Nec nec1 = { 2, }; // 'Trailing comma' kullanÄ±labilir.
    struct Nec nec2 = { 2, 4, }; // 'Trailing comma' kullanÄ±labilir.
    struct Nec nec3 = { 2, 4, 9, }; // 'Trailing comma' kullanÄ±labilir.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program yapÄ± nesnelerine ilk deÄŸer verme iÅŸlemlerinin nasÄ±l doÄŸru ÅŸekilde yapÄ±ldÄ±ÄŸÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>
#include <string.h>
#include <time.h>
#include "nutility.h"

struct Nec {
    int ar[5];
    int x, y, z;
};

int main(void)
{
    struct Nec n1 = { { 2, 4, 8, 6, 3 }, 10, 20, 30 };
    struct Nec n2 = { { 2, 4, 8, }, 10, 20, 30 };
    struct Nec n3 = { { 2, }, 10, 20, 30 };
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda yapÄ± nesnelerine ilk deÄŸer verme iÅŸlemlerinde yapÄ±nÄ±n eleman sayÄ±sÄ±ndan eksik ya da deÄŸer kaybÄ± olduÄŸu durumlar incelenebilir.
```C
#include <stdio.h>
#include <string.h>
#include <time.h>
#include "nutility.h"

struct Nec {
    int ar[4];
    double d;
};

int main(void)
{
    struct Nec nec1 = { 2, 4, 8, 6, 3.31 }; // Buradaki ilk deÄŸer verme sÃ¶zdizimi legaldir ama okunurluÄŸu dÃ¼ÅŸÃ¼ktÃ¼r ve kodun niyetinin anlaÅŸÄ±lmasÄ± zordur.
    struct Nec nec2 = { 2, 4, 3.31 }; // Buradaki ilk deÄŸer verme sÃ¶zdizimi legaldir ama veri kaybÄ± olacaktÄ±r.

    printf_array(nec1.ar, 4);
    printf("nec1.d = %f\n", nec1.d);

    printf("~~~~~~~~c-c-c-c-c-c~~~~~~~~\n");

    printf_array(nec2.ar, 4);
    printf("nec2.d = %f\n", nec2.d);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda dizi tÃ¼rÃ¼nden Ã¼yeleri olan bir yapÄ± nesnesine nasÄ±l ilk deÄŸer verildiÄŸi incelenebilir.
```C
#include <stdio.h>
#include <string.h>
#include <time.h>
#include "nutility.h"

struct Nec {
    int x;
    int ar[4][3];
    char str[10];
};

int main(void)
{
    // Bir yapÄ±ya aÅŸaÄŸÄ±daki gibi ilk deÄŸer verilebilir.
    struct Nec nec = { 
        12, // YapÄ±nÄ±n 'x' adlÄ± elemanÄ±nÄ±n ilk deÄŸeri.
        { { 1, 1, 1 }, { 2, 2, 2 }, { 3, 3, 3 }, { 4, 4, 4 } }, // YapÄ±nÄ±n 'ar' adlÄ± iki boyutlu dizisinin elemanÄ±nÄ±n ilk deÄŸeri.
        "altar" // YapÄ±nÄ±n 'str' adlÄ± karakter dizisi(yani bir yazÄ± ya da 'null terminated byte stream') elemanÄ±nÄ±n ilk deÄŸeri.
    };
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda dizi tÃ¼rÃ¼nden Ã¼yeleri olan bir yapÄ± nesnesine nasÄ±l ilk deÄŸer verildiÄŸi incelenebilir.
```C
#include <stdio.h>
#include <string.h>
#include <time.h>
#include "nutility.h"

struct Nec {
    int ar[4][3];
    double dval;
};

struct Erg{
    int x;
    struct Nec nec;
};

int main(void)
{
    // Bir yapÄ±ya aÅŸaÄŸÄ±daki gibi ilk deÄŸer verilebilir.
    struct Erg erg = { 
        2, // YapÄ±nÄ±n 'x' adlÄ± elemanÄ±nÄ±n ilk deÄŸeri.
        { // YapÄ±nÄ±n 'nec' adlÄ± 'struct Nec' tÃ¼rÃ¼nden elemanÄ±na aÅŸaÄŸÄ±daki gibi ilk deÄŸer veriliyor.
            { { 1, 1, 1 }, { 2, 2, 2 }, },  // 'struct Nec' tÃ¼rÃ¼nden yapÄ±nÄ±n 'ar' adlÄ± iki boyutlu dizi elemanÄ±nanÄ±n sadece ilk iki elemanÄ±na ilk deÄŸer veriliyor.
            576.3  // 'struct Nec' tÃ¼rÃ¼nden yapÄ±nÄ±n 'dval' adlÄ± elemanÄ±nÄ±n ilk deÄŸeri.
        } 
    };
}
```


#### **Designated initializer** AracÄ±nÄ±n YapÄ±larla KullanÄ±lÄ±ÅŸÄ± 

â—â—â— **Designated initializer** hem diziler hem de yapÄ±lar iÃ§in kullanÄ±labilir, aÅŸaÄŸÄ±daki kÄ±sa programlarda bu durum incelenebilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **Designated initializer** ile dizilere nasÄ±l ilk deÄŸer verildiÄŸi incelenebilir.
```C
#include <stdio.h>
#include <string.h>
#include <time.h>
#include "nutility.h"

int main(void)
{
    int ar[10] = { [4] = 7, [1] = 9, [5] = 3 };
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **designated initializer** ile yapÄ± nesnelerine nasÄ±l ilk deÄŸer verildiÄŸi incelenebilir.
```C
#include <stdio.h>
#include <string.h>
#include <time.h>
#include "nutility.h"

struct Data {
    int x, y, z;
    char str[10];
    int ar[5];
    double dval;
};

// 'print_data' adÄ±lÄ± fonksiyon 'struct Data' tÃ¼rÃ¼nden bir yapÄ±nÄ±n elemanlarÄ±nÄ± yazdÄ±rmak iÃ§in kullanÄ±lÄ±yor.
void print_data(const struct Data* p)
{
    // AÅŸaÄŸÄ±daki statement'larda kullanÄ±lan '->' operatÃ¶rÃ¼ gelecek derste detaylÄ± incelenecektir.
    printf("x = %d, y = %d, z = %d\n", p->x, p->y, p->z);
    printf("str = (%s)\n", p->str);
    print_array(p->ar, 5);
    printf("dval = %f\n", p->dval);
}

int main(void)
{
    struct Data mydata = { .x = 7, .dval = 1.4 }; // 'struct Data' yapÄ± tÃ¼rÃ¼nden deÄŸiÅŸkene buradaki gibi ilk deÄŸer verilebilir.

    print_data(&mydata);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **designated initializer** ile yapÄ± nesnelerine nasÄ±l ilk deÄŸer verildiÄŸi incelenebilir.
```C
#include <stdio.h>
#include <string.h>
#include <time.h>
#include "nutility.h"

struct Data {
    int x, y, z;
    char str[10];
    int ar[5];
    double dval;
};

// 'print_data' adÄ±lÄ± fonksiyon 'struct Data' tÃ¼rÃ¼nden bir yapÄ±nÄ±n elemanlarÄ±nÄ± yazdÄ±rmak iÃ§in kullanÄ±lÄ±yor.
void print_data(const struct Data* p)
{
    // AÅŸaÄŸÄ±daki statement'larda kullanÄ±lan '->' operatÃ¶rÃ¼ gelecek derste detaylÄ± incelenecektir.
    printf("x = %d, y = %d, z = %d\n", p->x, p->y, p->z);
    printf("str = (%s)\n", p->str);
    print_array(p->ar, 5);
    printf("dval = %f\n", p->dval);
}

int main(void)
{
    struct Data mydata = { 
        .x = 7,
        .ar = { [3] = 4, [1] = 4},
        .str = "furki",
        .dval = 1.4 
    };

    print_data(&mydata);
}
```


â—â—â— YapÄ± tÃ¼rÃ¼nden deÄŸiÅŸkenlere **designated initializer** ile ilk deÄŸer vermenin kodun okunabilirliÄŸini arttÄ±racaÄŸÄ± ve hata yapmayÄ± Ã¶nleyebileceÄŸi iÃ§in tavsiye edilmektedir.



**Designated initializer** ile yapÄ±lara ilk deÄŸer verilebilir. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda **designated initializer** ile yapÄ± nesnelerine nasÄ±l ilk deÄŸer verildiÄŸi incelenebilir.
```C
#include <stdio.h>
#include <string.h>
#include <time.h>
#include "nutility.h"

struct Person{
    int id;
    int age;
    double wage;
    char name[20];
    char surname[20];
};

int main(void)
{
    // Bir yapÄ±ya aÅŸaÄŸÄ±daki gibi ilk deÄŸer verildiÄŸinde hangi deÄŸerin hangi elemana karÅŸÄ±lÄ±k geldiÄŸini gÃ¶rmek zordur.
    struct Person1 = { 56, 45, 100, "muro", "anil" };

    // C99 standardÄ±ndan Ã¶nce bir yapÄ±nÄ±n Ã¼yelerinin birbirine karÄ±ÅŸmamasÄ± iÃ§in tanÄ±mÄ±n nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
    struct Person2 = { 
        /* id */ 56, 
        /* age */ 45, 
        /* wage */ 200, 
        /* name */ "rami", 
        /* surname */ "haydal" 
    };

    // C99 standardÄ± sonrasÄ±nda bir yapÄ±nÄ±n Ã¼yelerine ilk deÄŸer verirken karÄ±ÅŸÄ±klÄ±k olmamasÄ± iÃ§in aÅŸaÄŸÄ±daki gibi ilk deÄŸer verilebildiÄŸi incelenebilir.
    struct Person3 = {
        .id = 13123;
        .age = 23;
        .wage = 51.4;
        .name = "kally";
        .surname = "pusher";
    };
}
```


Ders sonu ...
