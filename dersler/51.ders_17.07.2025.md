# 51.Ders 17.07.2025 🕘

Derse 9(19:31)-10(19:58)-11(20:26)-8(21:28)-9(21:30)-8(22:11)-9(22:32) kişi katıldı.
---


## Bitsel Operatörler(Bitwise Operations)

❗❗❗ Bitsel işlemler daha çok işaretsiz tam sayılar üzerinde yapılıyor ama işaretli tam sayılar üzerinde bitsel işlem yapılamaz diye bir kural yoktur fakat bitsel işlemler çok büyük oranda işaretli tam sayılar üzerinde yapılmaktadır.


👇 Aşağıdaki programda kendi `nutility.h` başlık dosyamıza eklediğimiz `bprint` fonksiyonu ile kullanıcıdan alınacak `unsigned int` türünden bir sayının bitlerinin yazdırılışı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = 8795;

    printf("Bir tam sayi giriniz: ");
    scanf("%u", &x);

    bprint(x);
}
```


### `~` Bitwise Not Operator 

**Bitsel değil(`~`)** operatörü **uniry prefix** ve yan etkisi olmayan bir operatördür.


👇 Aşağıdaki programda **Bitsel değil(`~`)** operatörünün nasıl bir değer ürettiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    printf("Bir tam sayi giriniz: ");
    scanf("%u", &x);

    bprint(x);
    bprint(~x);
    printf("x = %u\n", x);

    bprint(~~x); // Bir tam sayının bitsel değilinin değili kendisidir.
    printf("x = %u\n", x);
}
```



👇 Aşağıdaki programda işaretsiz en büyük tam sayının elde edilme yollarından biri incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    printf("isaretsiz 'int' turunun alabilecegi en buyuk deger = %u\n", ~0u);
}
```


### `>>` and `<<` Bitwise Right Shift Operator and Bitwise Left Shift Operator 

Bu iki operatör **binary infix** ve yan etkisi olmayan operatörlerdir. </br>
Bitsel operatörlerin operantlarının türleri ondalıklı sayı olamaz sadece tam sayı olabilir.


#### `<<` Operatörünün İncelenişi


`x << y` ifadesinde, sol operandın bitleri kaydırılacak, sağ operand kaydırma işlemindeki pozisyon sayısını belirten operanttır. </br>
`17 << 3` ifadesi legaldir, sol operand **L-value** olmak zorunda değildir.


❗❗❗ Hem sola hem de sağa kaydırma işlemlerinde, sağ operandın işlemin yapılacağı tam sayı türünün bit sayısına eşit ya da bundan büyük olması ya da negatif değerde olması **tanımsız davranıştır(ub)**.



👇 Aşağıdaki programda **tanımsız davranış(ub)** olan bitsel sola kaydırma işlemi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int x = 1234;
    int y = 32;

    x << y; // Buradaki ifadedede 'ub' vardır çünkü 'int' türü 32 bit ve buradaki sola kaydırma işleminin sağ operandının değeri 32 değerine eşit olamaz.
}
```



👇 Aşağıdaki programda yukarıdaki ifadelere göre ilk bakışta **ub** olacağı düşünülen bitsel sola kaydırma işleminin neden **ub** olmadığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    short x = 1234;
    int y = 19;

    x << y; // Buradaki ifadede 'integral promotiom' olmasından dolayı 'ub' yoktur, 'x' değişkeninin türü 'short' olsa bile bu değişken işlem yapılırken 'int' türüne yükseltilir.
}
```


[19:35.20]
❗❗❗ Bitsel sola kaydırma işleminde işaretli türden negatif tam sayıların sola kaydırılması **tanımsız davranıştır(ub)**.


[19:36.30]
👇 Aşağıdaki programda "1" değerine sahip `unsigned int` türünden bir bir değişkenin değerinin her döngü adımında bir sola kaydırılması işlemi sonucunda nsıl bir sayıya dönüştüğü incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    unsigned x = 1; // Burada 'x' değişkeninin türünün 'unsigned int' olduğunu hatırla!

    while(x){
        bprint(x);
        x <<= 1; //Buradaki ifade 'x = x << 1' ifadesine denktir. 
    }
}
```



👇 Aşağıdaki programda bir tam sayıya sola kaydırma işlemi uygulandığında nasıl bir sayı elde edileceğini ve sayının sağ tarafından yapılan beslemenin hangi bitle yapılacağını görmek için incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = 235397u;

    printf("x = %u\n", x);

    unsigned int y = x << 5; 

    printf("x = %u\n", x);

    bprint(x);
    bprint(y);
}
```



👇 Aşağıdaki programda tüm bitleri "1" olan bir tam sayının beş bit sola kaydırma işlemi sonucundaki bitlerinin görünümü incelenebilir, sağa eklenen bitler 0 olacaktır. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = -1; // Bu kullanım C dilinde en çok kullanılan idiyomlardan biridir.

    bprint(x);
    bprint(x << 5);
}
```



👇 Aşağıdaki programda ilk başta "1" değerine sahip bir işaretsiz bir tam sayının döngü ile bitlerinin her adımda bir sola kaydırması sonucunda sayı sıfır değerine aship olana kadar ikinin kuvvetlerini değer olarak alacağı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    unsigned x = 1;

    while(x){
        printf("%u\n", x);
        x <<= 1;
    }
}
```



👇 Aşağıdaki programda `sizeof` operatörünün operandı olan ilk bakışta **ub** olan ifadenin tanımsız davranışa neden olmayacağı görülmelidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    size_t sz = sizeof(1 << 78); // Burada 'sizeof' operatörü işlem kodu üretmediği için burada 'ub' yoktur.
}
```


#### `>>` Operatörünün İncelenişi 

Bitsel sağa kaydırma işleminde soldan yapılacak **besleme(feeding)**, sol operand işaretsiz tam sayı ise "0" ile yapılacağı kesindir(her derleyici için geçerlidir).

Bitsel sağa kaydırma işleminde soldan yapılacak **besleme(feeding)**, sol operand işaretli pozitif bir tam sayı ise "0" ile yapılacağı kesindir(her derleyici için geçerlidir).

Bitsel sağa kaydırma işleminde soldan yapılacak **besleme(feeding)**, sol operand işaretli negatif bir tam sayı ise "0" ya da "1" ile yapılabilir(derleyiciye bağlıdır).




👇 Aşağıdaki programda sol operand işaretsiz bir tam sayı olduğunda bitsel sağa kaydırma işleminde sağdan eklenen bitlerin her derleyici için "0" olacağı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <limits.h>

int main(void)
{
    unsigned int x = UINT_MAX;
    bprint(x);
    bprint(x >> 5);
}
```



👇 Aşağıdaki programda sol operand işaretli pozitif bir tam sayı olduğunda bitsel sağa kaydırma işleminde sağdan eklenen bitlerin her derleyici için "0" olacağı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int x = 65535;
    bprint(x);
    bprint(x >> 3);
}
```



👇 Aşağıdaki programda sol operand işaretli negatif bir tam sayı olduğunda bitsel sağa kaydırma işleminde sağdan eklenen bitlerin ne olacağının derleyiciye bağlı olduğu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    int x = -1;

    bprint(x);
    bprint(x >> 2); // Burada soldan yapılacak besleme derleyiciye bağlıdır, bir derleyicide '1' ile bir başka derleyicide '0' ile besleme yapılabilir.
}
```



> ❔ 
> 
> Sorulan soru;
> İşaretli bir poz. sayiyi sayiyi sola kaydirdigimizda takip eden bit 1 ise nasil olur?
> 01011 << 1
>
> Cevap;
> 
> Aşağıdaki program üzerinden sorulan durum incelenebilir.
> 
> 
> 👇 Aşağıdaki programda işaretli `x` değişkeninin işaretinin korunacağı düşünülmesinin doğru olmayacağı görülmelidir, işlem sonucunda pozitif olan sayı negatif olmaktadır.
> ```C
> #define _CRT_SECURE_NO_WARNINGS
> 
> #include <stdio.h>
> #include <limits.h>
> #include "nutility.h"
> 
> int main(void)
> {
>     int x = 0b0000'1111'0101'0100'0000'1111'0101'0100;
>     
>     bprint(x);
>     printf("x = %d\n", x);
> 
>     x <<= 5;
>     bprint(x);
>     printf("x = %d\n", x);
> }
> ```




❗❗❗
Sola kaydırma işlemi iki ile çarpmaya eşdeğerdir fakat bu ikiyle çarpma işleminin sola kaydırma operandı ile yapılacağı anlamına gelmemektedir.
1 ile beslemeye **aricmetic feeding** deniliyor.
0 ile beslemeye **logic feeding** deniliyor.




👇 Aşağıdaki programda sola kaydırma işleminin ikiyle çarpmaya denk olduğunu görmek önemlidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = 17;

    printf("%u %u %u\n", x, x << 1, x << 2); // Buradaki kullanımda olduğu gibi bir sayının ikiyle çarpma işlemine tabi tutmak için bitsel sola kaydırma işleminin yapılmaması gerekir, derleyici zaten optimizasyonla çarpma işlemini hızlandırır.
}
```



👇 Aşağıdaki programda 32 bitlik sadece en sağ biti bir olan(bu işaretli en küçük tam sayı değeridir) tam sayının elde edilme yollarından biri(makro kullanımı ile) görülebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = (unsigned)INT_MIN;
    bprint(x);
}
```



👇 Aşağıdaki programda 32 bitlik sadece en sağ biti bir olan(bu işaretli en küçük tam sayı değeridir) tam sayının estetik bir biçimde elde edilme yolu(C idiom ile) görülebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = ~(~0u >> 1);
    bprint(x);
}
```


👇 Aşağıdaki programda sağa kaydırma(right shift) işlemiyle ikinin farklı kuvvetlerinin değerinin nasıl hesaplandığı incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void) {
    printf("isaretsiz 'int' turunun alabilecegi en buyuk  deger = %u\n", ~0u);

    unsigned int x = ~(~0u >> 1); // 2^31 sayısı elde ediliyor.

    printf("2^31 = %u\n", x);
    printf("2^10 = %u\n", x >> (31 - 10));
    printf("2^5 = %u\n", x >> (31 - 5));
    printf("2^12 = %u\n", x >> (31 - 12));

    printf("\n~~~~~~~~~~~~~~~~~~\n");

    for(size_t i = 31; i > 0; --i){
        printf("2^%d = %u\n", i, x >> (31 - i));
    }
}
```



👇 Aşağıdaki programda 32 bitlik sadece en sağ biti bir olan(bu işaretli en küçük tam sayı değeridir) tam sayının adım adım bir bit sağa kaydırılması sonucunda elde edilen sayılar incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    bprint(~(~0u >> 1));

    unsigned int x = ~(~0u >> 1);

    while(x){
        bprint(x);
        x >>= 1;
    }
}
```


❗❗❗ Mikroişlemcilerin komut setlerinde **bitsel ters çevirme(bitwise rotate)** işlemi vardır ama bu işlemin C dilinde bir operatörü yoktur. C dilini yeni öğrenenler **bitwise shift(bitsel kaydırma)** ile **bitwise rotate(bitsel döndürme)** işlemlerini birbirine karıştırma eğilimindeymiş.


###  `&` `|`  `^` Operators 

Bu iki operatör **binary infix** ve yan etkisi olmayan operatörlerdir. </br>
Bu operatörler iki değerin bitlerini karşılıklı olarak bitsel işleme sokmaktadır.
- Bitsel ve(`&`) operatörü 
- Bitsel veya(`|`) operatörü
- Bitsel özel veya(`^`) operatörü

Bu operatörlerin **kısa devre davranışı(short circuit behavior)** yoktur.


#### `&` Operatörünün İncelenişi


👇 Aşağıdaki programda `&` operatörünün kullanımı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned x, y;

    printf("iki tam sayi giriniz: ");
    scanf("%u%u", &x, &y);

    bprint(x);
    bprint(y);
    bprint(x & y);

    printf("x = %u\n", x);
    printf("y = %u\n", y);
}
```



👇 Aşağıdaki programda `&&` operatörü yerine `&` operatürünün kullanımından kaynaklanan hata durumu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned x, y;

    printf("iki tam sayi giriniz: ");
    scanf("%u%u", &x, &y);

    if(x && y)
        printf("dogru\n");
    else
        printf("yanlis\n");


    // Aşağıdaki if koğulunda '&&' yerine '&' operatörünün yanlışlıkla kullanımı görülmelidir. 
    if(x & y)
        printf("dogru\n");
    else
        printf("yanlis\n");
}
```



👇 Aşağıdaki programda `&` operatöründe etkisiz ve yutan eleman durumları incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned x, y;

    printf("iki tam sayi giriniz: ");
    scanf("%u%u", &x, &y);

    bprint(x);
    bprint(y);
    bprint(x & y);
}
```



❗❗❗ Bir tam sayıyı bir eksiği ile `&` işlemine sokarsak sayının en sağdaki ilk bir bitini sıfırlamış oluruz. </br>
❗❗❗ İkinin katı olan bir sayıyı kendisinin bir eksiği ile `&` işlemine tabi tutarsak sayıyı sıfırlamış oluruz. </br>
👇 Aşağıdaki programda bir tam sayının bir eksiğiyle bitsel ve işlemine sokulması sonucunda elde edilen sayının bitlerinin değeri incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned x;

    printf("bir tam sayi giriniz: ");
    scanf("%u", &x);

    bprint(x);
    bprint(x & (x - 1));    
}
```


#### `|` Operatörünün İncelenişi 


👇 Aşağıdaki programda `|` operatöründe etkisiz ve yutan eleman durumları incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned x;

    printf("bir tam sayi giriniz: ");
    scanf("%u", &x);

    bprint(x);
    bprint(y);
    bprint(x | y);
}
```



❗❗❗ Programcılar çoğunlukla operatör önceliği kurallarına hakim olsalar da aşağıdaki nedenlerden dolayı bir ifade de birden fazla operatör varsa öncelik parantezi kullanırlar;
1. Kodun daha kolay okunması için.
2. Hata yapma riskini azaltmak için.
Mesela `x << 3 > y` ifadesi `(x << 3) > y` ifadesine denktir ama okunması daha kolay olduğu için 



#### `^` Operatörünün İncelenişi 

İki bit birbirinden farklı ise sonuç true aynı ise sonuç false olacaktır.

Bu operatör(`^`) "**Exclusive Or(Özel Veya)**" sözcüklerinin kısaltmasından **exor** olarak adlandırılmaktadır, Necati Ergin bu operatörü Türkçeye "**Dışlayan Veya**" olarak çeviriyormuş.



👇 Aşağıdaki programda `^` operatöründe etkisiz ve yutan eleman durumları incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned x, y;

    printf("bir tam sayi giriniz: ");
    scanf("%u%u", &x, &y);

    bprint(x);
    bprint(y);
    bprint(x ^ y);
}
```



❗❗❗ 👇 Aşağıdaki programda bir tam syının kendisiyle `^` işlemine tabi tutarsak tüm bitlerin 0 olacağı görülebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned x = 131312;
    bprint(x ^ x);
}
```



Programlama dilinden bağımsız olarak yazılım mülakatlarının en klasik sorularından biri görülebilir. </br>
👇 Aşağıdaki programdaki dizide tek bir tam sayı eleman haricinde diğer tam sayı elemanlar ikizdir(o tam sayıdan sadece iki tane vardır), dizideki ikizi olmayan elemanı tespit ediniz.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    int ar[] = { 2, 7, 9, 5, 7, 8, -3, 2, 9, -3, 5 };

    unsigned int result = 0;

    for(size_t i = 0; i < ASIZE(ar); ++i){
        result ^= ar[i];
        bprint(result);
        (void)getchar(); // İnceleyebilmek için program burada durduruluyor.
    }

    printf("%u\n", rasult);
}
```



👇 Aşağıdaki programdan `x` ve `y` değişkenlerinin değerleri ne olursa olsun iki defa xor işlemine tabi tutulduğunda işlem uygulanan değişkenin ilk değerine döndüğü görülmelidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned x = 87234u;
    unsigned y = 9834543u;

    printf("x = %u", x);
    x ^= y;
    printf("x = %u", x);
    x ^= y;
    printf("x = %u", x);
    
}
```



📌 Bazı basit şifreleme algoritmalarında rastgele sayı üreten bir algoritmayı kullanarak dosyanın her bir byte değeri üretilen rastgele sayı zincirindeki bir değer ile sırayla xor işlemine tabi tutulur ve böylece şifrelenmiş olur, şifreyi çözmek için de aynı tohum değeri ile aynı rastgele sayı üreten algoritmanın değerlerinin sırasıyla dosyanın byte değerleriyle xor işlemine sokulması sonucunda şifre çözülmüş olur.



Mülaktlarda sorulan bir soru, iki tam sayı değişkeni üçüncü bir değişken kullanmadan takas ediniz biçimindedir. </br>
👇 Aşağıdaki program iki tam sayı değişkenin üçüncü bir değişken kullanılmadan nasıl takas edildiğini görmek için incelenebilir, bu işlemi programcılar genellikle **xor swap** olarak adlandırıyorlar.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned x, y;

    printf("bir tam sayi giriniz: ");
    scanf("%u%u", &x, &y);

    printf("x = %d   y = %d\n", x, y);

    x ^= y; // 'x = x ^ y'
    y ^= x; // 'y = y ^ x' ya da 'y = x ^ y'
    x ^= y; // 'x = x ^ y'

    printf("x = %d   y = %d\n", x, y);
}
```



👇 Aşağıdaki programda **xor swap** işleminin bir makro ile nasıl kullanıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

#define XORSWAP(a, b)   ((a) ^= (b), (b) ^= (a), (a) ^= (b))

int main(void)
{
    unsigned x, y;

    printf("bir tam sayi giriniz: ");
    scanf("%u%u", &x, &y);

    printf("x = %d y = %d\n", x, y);

    XORSWAP(x, y);

    printf("x = %d y = %d\n", x, y);
}
```



👇 Aşağıdaki programda aynı nesnenin **xor swap** işlemine tabi tutulması sonucunda ilgili tam sayı nesnesinin değerinin 0 olacağı gözlemlenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

#define XORSWAP(a, b)   ((a) ^= (b), (b) ^= (a), (a) ^= (b))

int main(void)
{
    int x = 10;
    int* p1 = &x;
    int* p2 = &x;

    XORSWAP(*p1, *p2); // Burada makroya geçilen iki nesne aynı nesne olduğu için ve tüm bitlerin aynı olması durumunda yapılacak xor işleminin sonucunda tüm bitler 0 olacağı için sayıyı sıfırlamış oluruz.

    printf("x = %d\n", x);
}
```


***
==================================================

✦✦✦✦✦ 21.02-21.21 birinci ara verildi. ✦✦✦✦✦

==================================================
***


## Bitsel Operatörler Hangi Amaçlarla Kullanılıyor


Bitsel operatörler aşağıdaki nedenlerle kullanılmasıyla sıklıkla karşılaşılmaktadır;
1. Bir tam sayının bir bitini belirlemek(**To set the bit**, **To turn the bit**)
2. Bir tam sayının bir bitini sıfırlamak(**To reset the bit**, **To clear the bit**)
3. Bir tam sayının bir bitini değiştirmek(**To tootgle the bit**, **To flip the bit**)
4. Bir tam sayının bir bitini sınamak yani 1 mi yoksa 0 mı olduğunu öğrenmek(**To get the bit**, **To test the bit**)


### Bir tam sayının bir bitini belirlemek(**To set the bit**, **To turn the bit**)

❗❗❗ Mesela bir tam sayının 5. bitini 1 yapmak için o sayıyı, sadece 5. biti 1 olan bir sayıyla **bitsel veya(bitwise or)** işlemine tabi tutmak yeterli olacaktır;
- `0010'0101'1110'0110'1100'1101'1110'1011` --> 5. bitini 1 yapmak istediğimiz tam sayının bit dizilimi.
- `0000'0000'0000'0000'0000'0000'0010'0000` --> Sadece tek bir biti 1 diğer bitleri 0 olan tam sayının bit dizilimi.
- `0010'0101'1110'0110'1100'1101'1100'1011` --> Yukarıdaki iki tam sayının **bitsel veya(bitwise or)** işlemine tabi tutulduktan sonra elde edilen sayı.


**Bitmask**: Bir biti 1 diğer bitleri 0 olan sayılara verilen addır.


[21.29:00]
👇 Aşağıdaki programda değeri 0 olan bir tam sayının istenilen herhangi bir bitinin nasıl 1 yapıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = 0;
    int n;

    printf("kacinci bit");
    scanf("%d", %n);

    bprint(x);
    bprint(x | (1 << n));
}
```


[21.30:20]
👇 Aşağıdaki programda ilk değeri 0 olan `unsigned int` türünden bir tam sayının sırayla tüm bitlerinin nasıl 1 yapıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <conio.h> // '_getchar' fonksiyonu için eklendi.
#include "nutility.h"

int main(void)
{
    unsigned int x = 0;

    for(int i = 0; i < sizeof(int) * 8; ++i){
        x |= (1 << i);
        bprint(x);
        (void)_getchar();
    }
}
```


### Bir tam sayının bir bitini sıfırlamak(**To reset the bit**, **To clear the bit**) 

❗❗❗ Mesela bir tam sayının 5. bitini 0 yapmak için o sayıyı, sadece 5. biti 0 olan bir sayıyla **bitsel ve(bitwise and)** işlemine tabi tutmak yeterli olacaktır;
- `0010'0101'1110'0110'1100'1101'1110'1011` --> 5. bitini 1 yapmak istediğimiz tam sayının bit dizilimi.
- `1111'1111'1111'1111'1111'1111'1101'1111` --> Sadece tek bir biti 0 diğer bitleri 1 olan tam sayının bit dizilimi, bu tam sayı `0000'0000'0000'0000'0000'0000'0010'0000'` tam sayısının bitsel değilidir.
- `0010'0101'1110'0110'1100'1101'1100'1011` --> Yukarıdaki iki tam sayının **bitsel ve(bitwise and)** işlemine tabi tutulduktan sonra elde edilen sayı.



👇 Aşağıdaki programda değeri işaretsiz bir tam sayının en büyük değeri olan bir tam sayının istenilen herhangi bir bitinin nasıl 0 yapıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <conio.h> // '_getchar' fonksiyonu için eklendi.
#include "nutility.h"

int main(void)
{
    unsigned int x = ~0u;
    int n;

    printf("kacinci bit");
    scanf("%d", %n);

    bprint(x);
    bprint(x & ~(1 << n));
}
```


[21.34:30]
👇 Aşağıdaki programda ilk değeri 0 olan `unsigned int` türünden bir tam sayının sırayla tüm bitlerinin nasıl 0 yapıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = ~0u;

    for(int i = 0; i < sizeof(int) * 8; ++i){
        x &= ~(1 << i);
        bprint(x);
        (void)_getchar();
    }
}
```

### Bir tam sayının bir bitini değiştirmek(**To tootgle the bit**, **To flip the bit**) 

Bir bit değerini değiştirme işlemi genel olrak **bitwise NOT** işlemi olarak bilinmektedir.

❗❗❗ Mesela bir tam sayının 5. bitini değiştirmek(0 ise 1, 1 ise 0 yapmak) için o sayıyı, sadece 5. biti 1 olan bir sayıyla **bitsel özelveya(bitwise exor)** işlemine tabi tutmak yeterli olacaktır;
- `0010'0101'1110'0110'1100'1101'1110'1011` --> 5. bitini değiştirmek istediğimiz tam sayının bit dizilimi.
- `0000'0000'0000'0000'0000'0000'0010'0000` --> Sadece tek bir biti 1 diğer bitleri 0 olan tam sayının bit dizilimi.
- `0010'0101'1110'0110'1100'1101'1100'1011` --> Yukarıdaki iki tam sayının **bitsel özelveya(bitwise exor)** işlemine tabi tutulduktan sonra elde edilen sayı.



👇 Aşağıdaki programda işaretsiz bir tam sayının sadece 5. bitinin nasıl değiştirildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = 0b0010'0101'1110'0110'1100'1101'1110'1011;

    bprint(x);

    bprint(x ^ (1 << 5)); // '1 << 5' bu ifadede değeri '1' olan 'R-value' varlığın işlem sırasında 'integral promotiom' ile 'int' türüne yükseltildiğini 
}
```


### Bir tam sayının bir bitini sınamak yani 1 mi yoksa 0 mı olduğunu öğrenmek(**To get the bit**, **To test the bit**) 

❗❗❗ Mesela bir tam sayının 5. bitini ne olduğunu öğrenmek için o sayıyı, sadece 5. biti 1 olan bir sayıyla **bitsel ve(bitwise and)** işlemine tabi tutmak yeterli olacaktır;
- `0010'0101'1110'0110'1100'1101'1110'1011` --> 5. bitini değiştirmek istediğimiz tam sayının bit dizilimi.
- `0000'0000'0000'0000'0000'0000'0010'0000` --> Sadece tek bir biti 1 diğer bitleri 0 olan tam sayının bit dizilimi.
- `0000'0000'0000'0000'0000'0000'0010'0000` --> Yukarıdaki iki tam sayının **bitsel ve(bitwise and)** işlemine tabi tutulduktan sonra elde edilen sayı.



👇 Aşağıdaki programda işaretsiz bir tam sayının bitlerinin ne olduğunun nasıl öğrenildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = 0b0010'0101'1110'0110'1100'1101'1110'1011;

    bprint(x);

    int n;

    printf("kacinci bit");
    scanf("%d", %n);

    if(x & (1 << n))
        printf("1\n");
    else
        printf("0\n");
}
```


## Bitsel Operatörlerdeki Dört Temel İşlemden Haraketle Daha Karşaşık İşlemlerin Yapılması 


Bitsel operatörlerin kullanım nedenlerinin hangi bitsel işlemlerle uygulandığını aşağıda özetleyelim, aşağıdaki dört temel işlem ile daha karmaşık işlemleri yapabiliriz;
1. Bir tam sayının bir bitini belirlemek(**To set the bit**, **To turn the bit**) için: `x |= (1 << n)` ifadesi kullanılır, buradaki `n` bir sabit tam sayı değeridir.
2. Bir tam sayının bir bitini sıfırlamak(**To reset the bit**, **To clear the bit**) için: `x &= ~(1 << n)` ifadesi kullanılır, buradaki `n` bir sabit tam sayı değeridir.
3. Bir tam sayının bir bitini değiştirmek(**To tootgle the bit**, **To flip the bit**) için: `x ^= ~(1 << n)` ifadesi kullanılır, buradaki `n` bir sabit tam sayı değeridir.
4. Bir tam sayının bir bitini sınamak yani 1 mi yoksa 0 mı olduğunu öğrenmek(**To get the bit**, **To test the bit**) için: `if(x &= (1 << n))` ifadesi kullanılır, buradaki `n` bir sabit tam sayı değeridir.



👇 Aşağıdaki programda bir tam sayının tek/çift sınamasının iki farklı biçimde nasıl yapıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int x = 5;

    if(x % 2 != 0)
        printf("tek sayi\n");

    if(x & 1)
        printf("tek sayi\n");
}
```



Mülakatlarda sık sorulan bir soru olarak, bir tam sayının bitlerini yazdıran bir fonksiyon yazınız. </br>
👇 Aşağıdaki programda bir tam sayının bitlerini yazdıran bir fonksiyon nasıl olabileceği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"


void bitprint(unsigned int x)
{
    // 'CHAR_BIT' object-like makrosu 'limits.h' başlık dosyasında bulunan ve sistemdeki 1 byte'ta bulunan bit sayısını tutmaktadır.
    for(int i = sizeof(int) * CHAR_BIT - 1; i >= 0; --i){
        putchar(x >> i & 1 ? '1' : '0');
    }
    putchar('\n');
}


void bitprint2(unsigned int x)
{
    unsigned int mask = ~(~0u >> 1);

    while(mask){
        putchar(mask & x ? '1' : '0');
        mask >>= 1; 
    }
    putchar("\n");
}


int main(void)
{
    unsigned x;
    printf("bir tam sayi giriniz: ");
    scanf("%zu", &x);

    bprint(x);
    bitprint(x); 
    bitprint2(x);
}
```



En çok yapılan işlemlerden biri bir tam sayının 1 olan bitlerini sayma işlemidir. </br>
Bu işlemi yapmak için **Kernighan Algorithm** algoritması var, bu algoritma çok zekice veçok hızlı çalışıyor.



❗❗❗ 👇 Aşağıdaki programda bir tam sayıdaki kaç bitin 1 değerinde olduğunun nasıl hesaplandığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

// Parametre olarak aldığı işaretsiz bir tam sayının kaç bitinin 1 olduğu bilgisini geriye döndüren fonksiyon.
void sbc1(unsigned int x)
{
    unsigned int mask = ~(~0u >> 1);
    int count = 0;

    while(mask){
        if(mask & x);
            ++count;
        mask >>= 1;
    }
}

// Parametre olarak aldığı işaretsiz bir tam sayının kaç bitinin 1 olduğu bilgisini geriye döndüren fonksiyon(Kernighan Algorithm kullanılıyor).
void sbc2(unsigned int x)
{
    int cnt = 0;

    while(x){
        ++cnt;
        x &= (x - 1); // Burada sayı kendisinin bir eksiği ile ve işlemine tabi tutulduğunda her döngü adımında sayının bitlerindeki bir tane 1 biti 0 olarak değişmektedir.
    }

    return cnt;
}


int main(void)
{
    unsigned x;
    printf("bir tam sayi giriniz: ");
    scanf("%zu", &x);

    bprint(x);
    
    printf("%d biti 1\n", sbc1(x));
    printf("%d biti 1\n", sbc2(x));
}
```



👇 Aşağıdaki programda maskelerin değerinin ne olduğu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

#define MASK1   (1 << 5) // Buradaki makronun değeri `0000'0000'0000'0000'0000'0000'0010'0000` olacaktır.
#define MASK2   (1 << 9) // Buradaki makronun değeri `0000'0000'0000'0000'0000'0010'0000'0000` olacaktır.

int main(void)
{
    unsigned int x = 0;

    // Aşağıdaki üç fonksiyon çağrısı ile makroların değerlerinin bitsel görünümü yazdırılmaktadır.
    bprint(MASK1);
    bprint(MASK2);
    bprint(MASK1 | MASK2);
}
```



👇 Aşağıdaki programda maskeler kullanılarak bir sayının bitlerinin nasıl 1 yapılabildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

#define MASK1   (1 << 5) // Buradaki makronun değeri `0000'0000'0000'0000'0000'0000'0010'0000` olacaktır.
#define MASK2   (1 << 9) // Buradaki makronun değeri `0000'0000'0000'0000'0000'0010'0000'0000` olacaktır.

int main(void)
{
    unsigned int x = 0;

    x |= (MASK1 | MASK2);

    bprint(x); // x değişkeninin değeri `0000'0000'0000'0000'0000'0010'0010'0000` olacaktır.
}
```



👇 Aşağıdaki programda, elinizde 16 bitlik tam sayı var ve ortadaki iki byte'ının elde edilmesi isteniyorsa bu byte'ların nasıl elde edilebileceği incelenebilir.  
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = 0b1010'0111'0011'0100;

    bprint(x << 4 >> 8); // Burada ilk önce sayı 4 bit sağa kaydırılıyor ve en yüksek anlamlı byte'ından kurtulunuyor, ardından 8 bit sağa kaydırılarak değeri öğrenilmek istenilen byte'lar en düşün anlamlı byte'lara alınmış oluyor.
}
```



👇 Aşağıdaki programda, elinizde 16 bitlik tam sayı var ve bu sayının en düşük anlamlı dört bitini almak istiyorsa bunun için nasıl bir işlem yapılması gerektiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = 8723423u;

    bprint(x);

    bprint(x & 15); // Burada sayı son dört biti bir olan sayı ile bitsel ve işlemine tabi tutulursa sonuç olarak sayının en düşük anlamlı dört biti elde edilmiş olur.
}
```


👇 Aşağıdaki programda, elinizde 16 bitlik tam sayı var ve bu sayının en düşük anlamlı dört bitini almak istiyorsa bunun için nasıl bir işlem yapılması gerektiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int main(void)
{
    unsigned int x = 1034509u;

    // Aşağıdaki fonksiyon çağrıları standart çıktı akımına aşağıdaki veriyi gönderecektir.
    // 00000000000011111100100100001101
    // 00000000000000000000000011111111
    // 00000000000000000000000000001101
    bprint(x);
    bprint((unsigned int)255);
    bprint(x & 255); // Burada işlemle sayının ilk byte'ı elde ediliyor.
}
```



> ❔ 
> 
> Sorulan soru;
> 
> Derleyicinin desteklemedigi durumlarda decimal yazilan sayinin binary halini okunabilrlik acisindan comment satirina yazmak bad practice msisidir?
> 
> Cevap;
>
> 2 tabanda yazmak yerine 16 tabanında yazmayı tercih etmek daha iyi bir yaklaşım olacaktır, 2 tabanı gösterini hem standard'ta yok hem de okunması zor, 16 tabanı daha kolay okunabiliyor.



👇 Aşağıdaki programda 32 bitlik tam sayının bitlerini lookup table kullanarak nasıl sayılabildiğinin inceleyebilmek için lookup table'ın elemanlarını oluşturacak program görülebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

int sbc(int x)
{
    int cnt = 0;

    while(x){
        ++cnt;
        x &= x - 1;
    }

    return cnt;
}

int main(void)
{
    int ary[256];
    
    for(int i = 0; i < 256; ++i){
        if(i && i % 16 == 0)
            printf("\n");
        printf("%d, ", sbc(i));
    }
}
```



👇 Aşağıdaki programda 32 bitlik tam sayının bitlerini lookup table kullanarak nasıl sayılabildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>
#include "nutility.h"

const int a[] = { 
    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,  
};

int main(void)
{
    unsigned int x;

    printf("tam sayi girin: ");
    scanf("%u", &x);

    bprint(x);
    printf("%d\n", a[x & 255] + a[x >> 8 & 255] + a[x >> 16 & 255] + a[x >> 24 & 255]); // Burada look-up table kullanılarak 'unsigned int' türünden bir tam sayının kaç bitinin bir olduğu hesaplanmış olacak.
}
```


✍️ Burada `nutility` adındaki kendi modülümüze rastgele ad ve soyad soyad üretecek ayrı ayrı iki fonksiyon ekliyoruz.
```C
// Yazılan 'nutility.h' dosyasına eklenenler.

#define SETBITCNT       (sbc_[(x) & 255] + sbc_[(x) >> 8 & 255] + sbc_[(x) >> 16 & 255] + sbc_[(x) >> 24 & 255])

extern const int sbc_[]; // Dizi adı "Set Bit Count" sözcüklerinden gelmektedir.
```


```C
// Yazılan 'nutility.c' dosyasına eklenenler.

const int sbc_[] = { 
    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,  
};
```


> ❔ 
> 
> Sorulan soru;
> 
> Bu diziyi calisma zamaninda olustursak, diger dosyalarla paylasma sansimiz olmuyor gibi degil mi hocam?
> 
> Cevap;
> 
> Şöyle olabilir `external` bir değişken kullanılabilir ve diğer kaynak dosyalar bu `external` değişken pointer değişkene erişir(bunun nasıl yapılacağı başka bir derste analtılabilir), program çalışmaya başladığında önce o pointer kendi değerini alır(yani look-up table'o o pointer gösterir) ve bu `external` pointer değişken vasıtası ile diğer kaynak dosyalar da o look-up tanle'a erişebilir. </br>
> Burada main fonskiyonu çalışmaya başladığında ilk iş olarak o dinamik dizinin oluşturulması gerekiyor, bunu yapmanın da yöntemleri var.


Ders sonu ...
