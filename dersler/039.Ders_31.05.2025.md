# 39.Ders 31.05.2025 ğŸ•˜

Derse 10(09:01)-12(09:04)-14(09:07)-15(09:15)-16(09:19)-17(09:25)-18(09:37)-17(10:00)-16(10:32)-15(10:34)-16(10:37)-15(10:54)-14(11:04)-13(11:06)-14(11:27)-16(11:51)-13(12:18)-14(12:27)-13(13:01) kiÅŸi katÄ±ldÄ±.
---


## Multi Dimensional Arrays Continues(Ã‡ok Boyutlu Diziler Devam)


ğŸ‘‡ AÅŸaÄŸÄ±daki programda elemanlarÄ± pointer olan ve olmayan dizilerle ilgili aÃ§Ä±klamalar incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    char s[10][20]; // 's' elemanlarÄ± 'char[20]' tÃ¼rÃ¼nden diziler olan iki boyutlu bir dizidir.
    char str[20]; // 'NULL' karakterle sonlanan en fazla 19 karakterli bir yazÄ± tutabilen bir dizi tanÄ±mÄ± bu ÅŸekilde yapÄ±lmaktadÄ±r.

    // AÅŸaÄŸÄ±daki iki dizi arasÄ±nda doÄŸrudan bir baÄŸlantÄ± yoktur.
    int a[10][10]; // 'a' elemanlarÄ± 'int[10]' tÃ¼rÃ¼nden diziler olan iki boyutlu bir dizidir.
    int* p[10]; // 'p' elemanlarÄ± 'int*' tÃ¼rÃ¼nden olan 10 elemanlÄ± bir dizidir.
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda elemanlarÄ± yazÄ± olan bir dizi bildiriminin nasÄ±l yapÄ±ldÄ±ÄŸÄ± gÃ¶rÃ¼lebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    char s[10][20] = { "umay", "tuana", "cengiz", "mete", "timucin", "uruk" };
}
```



â—â—â— En Ã§ok karÄ±ÅŸtÄ±rÄ±lan ve mÃ¼lakatlarda sÄ±k sorulan bir durum aÅŸaÄŸÄ±daki programdan gÃ¶rÃ¼lebilir. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda **string literal** ve pointer dizilerin farklarÄ± incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

void foo()
{
    char* p = "adsyad2"; // Burada iki tane nesne(object) vardÄ±r. Buradaki yazÄ± program Ã§alÄ±ÅŸmasÄ± boyunca bellekte duracaktÄ±r ve bu yazÄ± 'immutable' ve deÄŸiÅŸtirilemezdir. 'p' pointer deÄŸiÅŸken ise 'otomatic' Ã¶mÃ¼rlÃ¼dÃ¼r ve blok dÄ±ÅŸÄ±nda hayatÄ± sona erecektir.

    char str[20] = "adsyad1"; // Burada 'str' adÄ±nda tek bir nesne(object) vardÄ±r, ilgili 'block scope' dÄ±ÅŸÄ±nda 'str' nesnesinin Ã¶mrÃ¼ sonlanacaktÄ±r.
}

int main(void)
{
    char str[10] = "adsyad1"; // Burada 'str' adÄ±nda tek bir nesne(object) vardÄ±r.
    
    //char* p = "adsyad2"; // Buradaki atama iÅŸlemi C++ dilinde sÃ¶zdizim hatasÄ±dÄ±r(syntax error) Ã§Ã¼nkÃ¼ 'string literal' varlÄ±klar 'const char*' tÃ¼rÃ¼ kabul edilir ve Ã¶rtÃ¼lÃ¼ olarak 'char*' tÃ¼rÃ¼ne atanamaz.
    const char* p = "adsyad2"; // YukarÄ±daki aÃ§Ä±klamaya gÃ¶re buradaki gibi bir bildirim yapÄ±lmasÄ± daha doÄŸrudur.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda kullanÄ±lan elemanlarÄ± yazÄ± olan dizinin elemanlarÄ±nÄ±n deÄŸiÅŸtirilebilir durumda olduÄŸu incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    char str[10][20] = { "adsyad1", "adsyad2" }; // Buradaki 'str' dizisi elemanlarÄ± 'char[20]' tÃ¼rÃ¼nden olan diziler ve 'str' dizisinin elemanlarÄ± programÄ±n baÅŸÄ±ndan sonuna kadar kalan ve 'const' olan diziler deÄŸildir, burada 'otomatic storage duration' Ã¶mÃ¼rlÃ¼ olduklarÄ± iÃ§in kapsamlarÄ± dÄ±ÅŸÄ±nda bellekten silinecektir.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda mÃ¼lakatlarda iki boyutlu dizilerin kullanÄ±mÄ±nÄ± sÄ±namak iÃ§in sÄ±k sorulan bir soru gÃ¶rÃ¼lebilir. </br>
`a1`, `a2`, `a3` adlarÄ±yla tanÄ±mlanan dizilerin hangilerinde **sÃ¶zdizim hatasÄ±(syntax error)** vardÄ±r.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a1[][] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; // 'a1' iki boyutlu dizi tanÄ±mlamasÄ± geÃ§ersizdir Ã§Ã¼nkÃ¼ 'a1' iki boyutlu dizisinin tÃ¼rÃ¼ belirsiz, 'int[]' biÃ§iminde bir tÃ¼r yoktur!
    int a2[3][] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; // 'a2' iki boyutlu dizi tanÄ±mlamasÄ± geÃ§ersizdir Ã§Ã¼nkÃ¼ 'a2' iki boyutlu dizisinin tÃ¼rÃ¼ belirsiz, sadece eleman sayÄ±sÄ± '3' olarak bildirilmiÅŸ, 'int[]' biÃ§iminde bir tÃ¼r yoktur!
    int a3[][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; // Sadece bu satÄ±rdaki iki boyutlu dizi bildirimi geÃ§erli(lagel'dir). Buradaki gibi bir diziye ilk deÄŸer verilebilmektedir, 'a3' dizisi 4 elemanlÄ±dÄ±r.
    //int a3[][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 }, { 10 } }; // Bu satÄ±rdaki iki bouytlu dizi bildirimi bir Ã¼s satÄ±rdaki dizi bildirimiyle aynÄ±dÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program elemanlarÄ±nÄ±n tÃ¼rÃ¼ `int[20]` olan `s` adÄ±ndaki dizinin elemanlarÄ±nÄ±n nasÄ±l gezildiÄŸini anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    char s[][20] = { 
        "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
        "hakki", "haldun", "halime", "haluk", "handan", "hande", "handesu", "hasan", "helin", "hikmet",
        "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
        "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata", 
    };
    

    for(size_t i = 0; i < asize(s); ++i){
        //puts(s[i]);
        printf("%s ", s[i]);

        if (i != 0 && !(i % 5))
            putchar('\n');
    }
}
```



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programda elemanlarÄ± **string literal** olan ve olmayan dizi tanÄ±mlarÄ± incelenebilir, aradaki farkÄ±n Ã§ok iyi anlaÅŸÄ±lmasÄ± gerekmektedir.
```C
#include <stdio.h>
#include "nutility.h"

void foo(void)
{
    // AÅŸaÄŸÄ±daki dizideki yazÄ±lar deÄŸiÅŸtirilemez ve program boyunca bellekte kalacaktÄ±r. Bu dizinin elemanÄ± olan yazÄ±lar 'string literal'dir.
    char *p[] =  {  
        "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
        "hakki", "haldun", "halime", "haluk", "handan", "hande", "handesu", "hasan", "helin", "hikmet",
        "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
        "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata",  
    };

    // AÅŸaÄŸÄ±daki dizideki yazÄ±lar deÄŸiÅŸtirilebilir. Bu dizinin elemanÄ± olan yazÄ±lar 'string literal' deÄŸildir.
    char s[][20] = {  
        "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
        "hakki", "haldun", "halime", "haluk", "handan", "hande", "handesu", "hasan", "helin", "hikmet",
        "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
        "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata",  
    };
}

int main(void)
{
    for(size_t i = 0; i < asize(s); ++i){
        //puts(s[i]);
        printf("%s ", s[i]);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `s` adÄ±ndaki ve elemanlarÄ± `char[20]` olan dizinin elemanlarÄ±nÄ±n deÄŸiÅŸtirilebildiÄŸi incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    // AÅŸaÄŸÄ±daki dizideki yazÄ±lar deÄŸiÅŸtirilebilir. Bu dizinin elemanÄ± olan yazÄ±lar 'string literal' deÄŸildir bu nedenle de Ã¼zerlerinde deÄŸiÅŸiklikler yapÄ±labilir.
    char s[][20] = { 
        "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
        "hakki", "haldun", "halime", "haluk", "handan", "hande", "handesu", "hasan", "helin", "hikmet",
        "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
        "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata", 
    };
    
    for(size_t i = 0; i < asize(s); ++i){
        printf("%s ", s[i]);
    }

    for(size_t i = 0; i < asize(s); ++i){ 
        s[i][0] = toupper(s[i][0]); // Burada her yazÄ±nÄ±n ilk elemanÄ±nÄ±n ilk karakteri bÃ¼yÃ¼k harf yapÄ±lÄ±yor, dizinin elemanlarÄ± 'string literal' olmadÄ±ÄŸÄ± iÃ§in deÄŸiÅŸtirilebiliyor.
    }

    for(size_t i = 0; i < asize(s); ++i){
        printf("%s ", s[i]);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `s` adÄ±ndaki ve elemanlarÄ± `char[20]` olan dizinin elemanlarÄ±nÄ±n deÄŸiÅŸtirilebildiÄŸi incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"
#include <ctype.h>

// Parametre olarak alacaÄŸÄ± yazÄ±nÄ±n tÃ¼m elemanlarÄ±nÄ± bÃ¼yÃ¼k harf yapan fonksiyon.
void to_upper(char* p)
{
    for(size_t i = 0; p[i] != '\0'; ++i){
        p[i] = (char)toupper(p[i]);
    }
}

int main(void)
{
    // AÅŸaÄŸÄ±daki dizideki yazÄ±lar deÄŸiÅŸtirilebilir. Bu dizinin elemanÄ± olan yazÄ±lar 'string literal' deÄŸildir bu nedenle de Ã¼zerlerinde deÄŸiÅŸiklikler yapÄ±labilir.
    char s[][20] = { 
        "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
        "hakki", "haldun", "halime", "haluk", "handan", "hande", "handesu", "hasan", "helin", "hikmet",
        "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
        "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata", 
    };
    
    for(size_t i = 0; i < asize(s); ++i)
        printf("%s ", s[i]);
    
    for(size_t i = 0; i < asize(s); ++i){
        to_upper(s[i]);
    }

    for(size_t i = 0; i < asize(s); ++i){
        puts(s[i]);
        //printf("%s ", s[i]);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki `s` ve `ps` adlarÄ±yla bildirilen karakter dizileri Ã¼zerinde nasÄ±l iÅŸlemler yapÄ±lÄ±p yapÄ±lamayacaÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"
#include <ctype.h>

int main(void)
{
    char s[][20] = {
        "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
        "hakki", "haldun", "halime", "haluk", "handan", "hande", "handesu", "hasan", "helin", "hikmet",
    };
    
    char* ps[20] = {
        "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
        "hakki", "haldun", "halime", "haluk", "handan", "hande", "handesu", "hasan", "helin", "hikmet",
    };


    puts(s[3]);
    s[3][3] = '!'; // Buradaki iÅŸlem legal ve doÄŸrudur, herhangi bir soruna neden olmaz.
    puts(s[3]);


    putchar(p[4][5]);


    puts(ps[3]);
    ps[3][3] = '!'; // Bu atama legal ama 'ub' durumuna neden olur Ã§Ã¼nkÃ¼ 'string literal' varlÄ±k deÄŸiÅŸtirilmeye Ã§alÄ±ÅŸÄ±lÄ±yor.
    puts(ps[3]);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda elemanlarÄ± `char[20]` olan bir dizinin elemanlarÄ±nÄ± yazdÄ±ran ve tesr Ã§eviren fonksiyonlarÄ±n nasÄ±l yazÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <ctype.h>
#include <string.h>

//void print_names_v1(const char p[][20], size_t size) // Buradaki gibi bir kullanÄ±m ile aÅŸaÄŸÄ±daki kullanÄ±m aynÄ±dÄ±r.
void print_names_v1(const char (*p)[20], size_t size)
{
    for(size_t i = 0; i < size; ++i){
        printf("%s ", p[i]);
    }
    printf("~~~~~~~v1~~~~~~");
}


// 'void print_names_v2(const char p[][20], size_t size)' bu ÅŸekilde de fonksiyon tanÄ±mÄ± yapÄ±labilir ve aÅŸaÄŸÄ±daki ile aynÄ± anlama gelecektir.
void print_names_v2(const char (*p)[20], size_t size)
{
    while(size--)
        printf("%s ", *p++);

    printf("~~~~~~v2~~~~~~~");
}

// C standart kÃ¼tÃ¼phanesinde bir yazÄ±yÄ± ters Ã§eviren bir fonksiyon yok, 
char* my_strrev(char* p)
{
    size_t len = strlen(p);

    for(size_t i = 0; i < len / 2; ++i){
        char temp = p[i];
        p[i] = p[len - 1 - i];
        p[len - 1 - i] = temp;
    }

    return p;
}

int main(void)
{
    char s[][20] = {
        "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
        "hakki", "haldun", "halime", "haluk", "handan", "hande", "handesu", "hasan", "helin", "hikmet",
        "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
        "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata", 
    };
    
    print_names_v2(s, asize(s)); // Buradaki kod 'print_names_v2(&s[0], asize(s));' kodu ile denktir.

    for(size_t i = 0; i < asize(s); ++i){
        my_strrev(s[i]);
    }

    print_names_v2(s, asize());
}
```


>â”
> 
> Sorulan soru; 
> 
> print names'te dizinin ilk elemanini degil de kendisinin adresini tutan bir pointer yazamaz myidik? `print_names(&s)` olacak sekilde?
> 
> Cevap;
> 
> ğŸ‘‡ AÅŸaÄŸÄ±daki programda burada sorulan sorudaki gibi bir bir `print_names` fonksiyonu nasÄ±l yazÄ±labilir incelenebilir.
> ```C
> #include <stdio.h>
> #include "nutility.h"
> #include <ctype.h>
> 
> void print_names(char (*p)[40][20])
> {
>     for(int i = 0; i < 40; ++i){
>         puts((*p)[i]);
>     }
> }
> 
> int main(void)
> {
>     char s[][20] = {
>         "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
>         "hakki", "haldun", "halime", "haluk", "handan", "hande", "handesu", "hasan", "helin", "hikmet",
>         "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
>         "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata", 
>     };
>     
>     char str1[20];
>     char str2[20];
>     // &str1  char[20]      char(*)[20] 
>     // &str2  char[50][20]  char(*)[50][20]
>     
>     print_names(&s);
> }
> ```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda C++ dilinde olan kullanÄ±ÅŸlÄ± **Type Deduction** mekanizmasÄ±nÄ±n kullanÄ±lÄ±ÅŸÄ± incelenebilir. 
```C++
#include <stdio.h>
#include "nutility.h"
#include <ctype.h>

int main(void)
{
    auto x = 10; // Burada 'x' deÄŸiÅŸkeninin tÃ¼rÃ¼ 'int' tÃ¼rÃ¼dÃ¼r. 'auto' anahtar sÃ¶zcÃ¼ÄŸÃ¼ ile derleyicinin deÄŸiÅŸkenin tÃ¼rÃ¼nÃ¼ tespit etmesi saÄŸlanmaktadÄ±r.

    char s1[10] = { 0 };
    auto p1 = &s1; // Burada 'p1' deÄŸiÅŸkeninin tÃ¼rÃ¼ 'char(*p)[10]' tÃ¼rÃ¼dÃ¼r.

    char s2[10][20] = { 0 };
    auto p2 = &s2; // Burada 'p2' deÄŸiÅŸkeninin tÃ¼rÃ¼ 'char(*p)[10][20]' tÃ¼rÃ¼dÃ¼r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **lexicographical compare** algoritmasÄ±na gÃ¶re yazÄ±larÄ±n sÄ±ralanmasÄ± iÅŸlemini yapan program incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"
#include <ctype.h>

void print_names(const char (*p)[20], size_t size)
{
    while(size--)
        printf("%s ", *p++);

    printf("~~~~~~~~~~~~~");
}

// Ä°ki yazÄ±yÄ± deÄŸiÅŸtokuÅŸ eden fonksiyon
// p1: Ä°lk yazÄ±nÄ±n adresi
// p2: Ä°kinci yazÄ±nÄ±n adresi
void swap_names(char* p1, char* p2)
{
    char temp[20];
    strcpy(temp, s1);
    strcpy(s1, s2);
    strcpy(s2, temp);
}

int main(void)
{
    char a[][20] = { "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", "hakki", "haldun" };

    print_names(s, asize(s));

    // AÅŸaÄŸÄ±daki iÃ§ iÃ§e dÃ¶ngÃ¼ yapÄ±sÄ± 'lexicographical compare' algoritmasÄ±na gÃ¶re sÄ±ralama yapmaktadÄ±r.
    for(size_t i = 0; i < asize(s) - 1; ++i){
        for(size_t k = 0; k < asize(s) - 1 - i; ++k){
            if(strcmp(s[k], s[k + 1]) > 0){
                swap_names(s[k], s[k + 1]);
            }
        }
    }

    print_names(s, asize(s));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **lexicographical compare** algoritmasÄ±na gÃ¶re yazÄ±larÄ±n sÄ±ralanmasÄ± iÅŸlemini yapan program incelenebilir(burada yazÄ± sÄ±ralama yapan kod kÄ±smÄ± fonksiyona alÄ±ndÄ±).
```C
#include <stdio.h>
#include "nutility.h"
#include <ctype.h>

void print_names(const char (*p)[20], size_t size)
{
    while(size--)
        printf("%s ", *p++);

    printf("~~~~~~~~~~~~~");
}

// Ä°ki yazÄ±yÄ± deÄŸiÅŸtokuÅŸ eden fonksiyon
void swap_names(char* p1, char* p2)
{
    char temp[20];
    strcpy(temp, s1);
    strcpy(s1, s2);
    strcpy(s2, temp);
}

// Bir karakter dizisindeki elemanlarÄ± 'lexicographical compare' algoritmasÄ±na gÃ¶re 'booble sorth' algoritmasÄ±na gÃ¶re sÄ±ralayan fonksiyon
void sort_names(char (*p)[20], size_t size)
{
    // AÅŸaÄŸÄ±daki iÃ§ iÃ§e dÃ¶ngÃ¼ yazÄ±larÄ± 'lexicographical compare' algoritmasÄ±na gÃ¶re sÄ±ralamaktadÄ±r.
    for(size_t i = 0; i < asize(s) - 1; ++i){
        for(size_t k = 0; k < asize(s) - 1 - i; ++k){
            if(strcmp(s[k], s[k + 1]) > 0){
                swap_names(s[k], s[k + 1]);
            }
        }
    }
}

int main(void)
{
    char a[][20] = { "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", "hakki", "haldun" };

    print_names(s, asize(s));
    sort_names(s, asize(s));
    print_names(s, asize(s));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "_Neden Ã§ok boyutlu dizi kullanÄ±lÄ±r?_" sorusunun iyi anlaÅŸÄ±lmasÄ± iÃ§in yazÄ±lan program incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"
#include <string.h>

int main(void)
{
    // 40 okul var her okulda 10 sÄ±nÄ±f var her sÄ±nÄ±fta 20 Ã¶ÄŸrenci var, bu Ã¶ÄŸrencilerin adlarÄ±nÄ± nasÄ±l tutarÄ±z, bu veri buradaki gibi tanÄ±mlanan 'a' dizisinde tutulabilir.
    char a[40][10][20][20];
}
```



ğŸ§­ Åu anda Ã§ok boyutlu diziler de bitmiÅŸ durumda, pointer'lar ile iliÅŸkili olan zor konu zincirinin sonuna geldik, bu zor konularÄ±n listesi aÅŸaÄŸÄ±daki gibidir;
- String Literal
- Pointer Arrays
- Pointer to Pointer
- Void Pointer
- Fuction Pointer
- Multi Dimensional Array


## YazÄ±larla Ä°lgili Ä°ÅŸlemler 

ğŸ“Œ Programlama dilinden baÄŸÄ±msÄ±z olarak yazÄ±dan sayÄ±ya ve sayÄ±dan yazÄ±ya dÃ¶nÃ¼ÅŸÃ¼m iÅŸlemi Ã§ok ihtiyaÃ§ duyulan bir iÅŸlem olduÄŸu iÃ§in programlama dilleri bu iÅŸlemler iÃ§in standart fonksiyonlar saÄŸlamaktadÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda standat giriÅŸ akÄ±mÄ±ndan okunan yazÄ± formatÄ±ndaki sayÄ±nÄ±n nasÄ±l hatalÄ± ÅŸekilde tam sayÄ±ya Ã§evrildiÄŸi incelenebilir, bu iÅŸlemi yapmak iÃ§in C standart kÃ¼tÃ¼phenesinde adlarÄ± "**ato**" ile baÅŸlayan fonksiyonlar mevcut, bu fonksiyonlar kullanÄ±labilir.
```C
#include <stdio.h>
#include "nutility.h"
#include <string.h>

int main(void)
{
    char str[40];
    
    printf("bir yazi girin: ");
    //scanf("%s", &str);
    sgets(str);
    printf("[%s]", str);

    int x = 0;

    for(int i = 0; str[i] != '\0'; ++i){
        x = x * 10 + str[i] - 0;
    }

    printf("x = %d", x);
}
```


### AdlarÄ± `ato` Ä°le BaÅŸlayan Fonksiyonlar 

ğŸ“Œ "**ato**" kÄ±saltmasÄ± "**Alphabetic To**" sÃ¶zcÃ¼klerinden gelmektedir.

ğŸ§­ `stdlib.h` standart kÃ¼tÃ¼phanesinde olan baÅŸlÄ±k dosyasÄ±ndaki yazÄ±larÄ± sayÄ±lara Ã§evirme iÅŸlemini yapan fonksiyonlarÄ±n bazÄ±larÄ± aÅŸaÄŸÄ±daki gibidir;
- `atoi` --> "**Alphabetic To int**" sÃ¶zcÃ¼klerinin kÄ±saltmasÄ± olan bu fonksiyon yazÄ±dan `int` tÃ¼rÃ¼ne Ã§evirme iÅŸlemini yapmak iÃ§in kullanÄ±lÄ±r.
- `atol` --> "**Alphabetic To long**" sÃ¶zcÃ¼klerinin kÄ±saltmasÄ± olan bu fonksiyon yazÄ±dan `long` tÃ¼rÃ¼ne Ã§evirme iÅŸlemini yapmak iÃ§in kullanÄ±lÄ±r.
- `atoll` --> "**Alphabetic To long long**" sÃ¶zcÃ¼klerinin kÄ±saltmasÄ± olan bu fonksiyon yazÄ±dan `long long` tÃ¼rÃ¼ne Ã§evirme iÅŸlemini yapmak iÃ§in kullanÄ±lÄ±r. 
- `atof` --> "**Alphabetic To float**" sÃ¶zcÃ¼klerinin kÄ±saltmasÄ± olan bu fonksiyon yazÄ±dan `float` tÃ¼rÃ¼ne Ã§evirme iÅŸlemini yapmak iÃ§in kullanÄ±lÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**ato**" kÄ±saltmasÄ±yla baÅŸlayan fonksiyonlarÄ±n **prototype**'leri incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"
#include <string.h>
#include <stdlib.h> // Bu dosyada yazÄ±yÄ± sayÄ±ya Ã§eviren fonksiyonlar bulunmaktadÄ±r.

// int atoi(const char*);
// long atol(const char*);
// long long atoll(const char*);
// float atof(const char*);
// double atof(const char*);
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda standart giriÅŸ akÄ±mÄ±ndan okunan yazÄ±nÄ±n `atoi` fonksiyonu ile nasÄ±l `int` tÃ¼rÃ¼ne Ã§evrildiÄŸi incelenebilir, iÃ§inde tam sayÄ± olan karmaÅŸÄ±k yazÄ±lar girip denemeler yapÄ±larak incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"
#include <string.h>
#include <stdlib.h> // Bu dosyada yazÄ±yÄ± sayÄ±ya Ã§eviren fonksiyonlar bulunmaktadÄ±r.

#define SIZE 100

int main(void)
{
    char str[SIZE];

    printf("bir yazi girin: ");
    sgets(str);
    printf("[%s]\n", str);

    int x = atoi(str);

    printf("sayi = %d\n", x);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `atoi` ve `atof` fonksiyonlarÄ±nÄ±n kullanÄ±mlarÄ± incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"
#include <string.h>
#include <stdlib.h> // Bu dosyada yazÄ±yÄ± sayÄ±ya Ã§eviren fonksiyonlar bulunmaktadÄ±r.

#define SIZE 100

int main(void)
{
    char str[SIZE];

    printf("bir yazi girin: ");
    sgets(str);
    printf("[%s]\n", str);

    int i = atoi(str);
    double d = atof(str);

    printf("i = %d\n", i);
    printf("d = %f\n", d);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `atoi` ve `atoll` fonksiyonlarÄ±nÄ±n kullanÄ±mlarÄ± incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"
#include <string.h>
#include <stdlib.h> // Bu dosyada yazÄ±yÄ± sayÄ±ya Ã§eviren fonksiyonlar bulunmaktadÄ±r.

#define SIZE 100

int main(void)
{
    char str[SIZE];

    printf("bir yazi girin: ");
    sgets(str);
    printf("[%s]\n", str);

    int i = atoi(str);
    long long lval = atoll(str);

    printf("i = %d\n", i);
    printf("lval = %lld\n", lval);
}
```


### AdlarÄ± `ato` Ä°le BaÅŸlayan FonksiyonlarÄ±nÄ±n ZayÄ±f OlduÄŸu Durumlar 

`ato` fonksiyonlarÄ± kendilerine argÃ¼man olarak geÃ§ilen yazÄ±lar geÃ§erli bir tam sayÄ± deÄŸilse geriye `0` deÄŸerini dÃ¶ndÃ¼rÃ¼yor ama yazÄ± sÄ±fÄ±r rakamÄ± olduÄŸunda da geriye `0` deÄŸeri dÃ¶nÃ¼yor, bu bir sorun. </br>
`ato` fonksiyonlarÄ± kendilerine argÃ¼man olaran `"12317ad"` gibi bir yazÄ± geÃ§ildiÄŸinde geriye `12317` deÄŸeri mi dÃ¶ndÃ¼rÃ¼r ama yazÄ±nÄ±n kaÃ§ karakterinin kullanÄ±ldÄ±ÄŸÄ± bilgisini vermeyecektir, bu bilgi bazÄ± durumlarda Ã§ok Ã¶nemlidir ama bu deÄŸeri `atoi` fonksiyonu geriye dÃ¶ndÃ¼rmÃ¼yor. </br>
`ato` fonksiyonlarÄ± kendilerine argÃ¼man olaran `"0x76124"` gibi bir yazÄ± geÃ§ildiÄŸinde geriye `0` deÄŸeri mi dÃ¶ndÃ¼rÃ¼r, burada hex sayÄ± tabanÄ±nÄ±n tanÄ±nmadÄ±ÄŸÄ± gÃ¶rÃ¼lebilir. </br>
`ato` fonksiyonlarÄ± kendilerine argÃ¼man olaran `"0432"` gibi bir yazÄ± geÃ§ildiÄŸinde geriye `432` deÄŸeri mi dÃ¶ndÃ¼rÃ¼r, burada octal sayÄ± tabanÄ±nÄ±n tanÄ±nmadÄ±ÄŸÄ± gÃ¶rÃ¼lebilir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `atoi` fonksiyonunun zayÄ±flÄ±klarÄ±nÄ± anlamak yukarÄ±da anlatÄ±lan zaaflara neden olacak yazÄ± girdileri ile incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"
#include <string.h>
#include <stdlib.h> // Bu dosyada yazÄ±yÄ± sayÄ±ya Ã§eviren fonksiyonlar bulunmaktadÄ±r.

#define SIZE 100

int main(void)
{
    char str[SIZE];

    printf("bir yazi girin: ");
    sgets(str);
    printf("[%s]\n", str);

    int i = atoi(str); // 
    printf("i = %d\n", i);
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 11.05-11.27 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


>â”
> 
> Sorulan soru; 
> 
> 2 sorum vardi
> 1- `char* s[]` gibi pointer tutan dizileri `char str[20]` gibi bir dizinin adresini de tutabilir, bÃ¶ylece karakterleri degiÅŸtirilebilir, hatta karÄ±ÅŸÄ±k olarak da tutulabilir degil mi?
> 
> `char * s[] = {str, "Mustafa"}` gibi
> 
> Cevap;
> 
> 
> ğŸ‘‡ AÅŸaÄŸÄ±daki programda yazÄ±larÄ±n pointer ile kullanÄ±lmasÄ±yla ilgili Ã¶nemli bazÄ± durumlar incelenebilir.
> ```C
> #include <stdio.h>
> #include "nutility.h"
> #include <string.h>
> #include <stdlib.h> // Bu dosyada yazÄ±yÄ± sayÄ±ya Ã§eviren fonksiyonlar bulunmaktadÄ±r.
> 
> #define SIZE 100
> 
> int main(void)
> {
>     // AÅŸaÄŸÄ±daki 'str' ile baÅŸlayan varlÄ±klar 'string literal' deÄŸildir, dilin kuralÄ± olarak kolaylÄ±k olmasÄ± iÃ§in yazÄ± tÃ¼rÃ¼nden dizilerde bu ÅŸekilde ilk deÄŸer vermeye izin veriliyor.
>     char str1[SIZE] = "turgut";
>     char str2[SIZE] = "kerim";
>     char str3[SIZE] = "tansel";
>     char str4[SIZE] = "osman";
> 
>     // AÅŸaÄŸÄ±daki 'p' deÄŸiÅŸkeninin elemanlarÄ± 'char*' tÃ¼rÃ¼nden olan yazÄ±lardÄ±r ve bu yazÄ±lar 'string literal' olmadÄ±ÄŸÄ± iÃ§in deÄŸiÅŸtirilebilirler. 
>     char* p[] = { str1, str2, str3, str4 };
> 
>     for(int i = 0; i < 4; ++i){
>         printf("%s", p[i]);
>     }
>     printf("\n");
> 
>     for(int i = 0; i < 4; ++i){
>         strcat(p[i], "can"); // Burada 'string literal' olmayan yazÄ±larÄ±n sonuna 'can' sÃ¶zcÃ¼ÄŸÃ¼ ekleniyor(buradaki 'can' yazÄ±sÄ± bir 'string literal'dir.)
>     }
> 
>     for(int i = 0; i < 4; ++i){
>         printf("%s", p[i]);
>     }
>     printf("\n");
> }
> ```
> 
> 
> 
> ğŸ‘‡ AÅŸaÄŸÄ±daki programda yazÄ±larÄ±n pointer ile kullanÄ±lmasÄ±yla ilgili Ã¶nemli bazÄ± durumlar incelenebilir.
> ```C
> #include <stdio.h>
> #include "nutility.h"
> #include <ctype.h>
> 
> void print_names(const char (*p)[20], size_t size)
> {
>     while(size--)
>         printf("%s ", *p++);
> 
>     printf("~~~~~~~~~~~~~");
> }
> 
> int main(void)
> {
>     char s[][20] = {
>         "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
>         "hakki", "haldun", "halime", "haluk", "handan", "hande", "handesu", "hasan", "helin", "hikmet",
>         "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
>         "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata", 
>      };
> 
>     print_names(s, asize(s));
> 
>     char* p[asize(s)];
> 
>     for(size_t i = 0; i < asize(p); ++i){
>         p[i] = s[i];
>     }
>     
>     for(size_t i = 0; i < asize(p) - 1; ++i){
>         for(size_t k = 0; k < asize(p) - 1 - i; ++k){
>             if(strcmp(p[k], p[k + 1]) > 0){
>                 char* ptemp = p[k];
>                 p[k] = p[k + 1];
>                 p[k + 1] = ptemp;
>             }
>         }
>     }
> 
>     for(size_t i = 0; i < asize(p); ++i){
>         printf("%s ", s[i]);
>     }
> 
>     printf("\n");
>     printf("\n");
> 
>     for(size_t i = 0; i < asize(p); ++i){
>         printf("%s ", p[i]);
>     }
> }
> ```


>â”
> 
> Sorulan soru; 
> 
> Gecen hafta func pointer dereference ederek de cagiribiliriz demistiniz, ama bende Ã§aliÅŸmadÄ±. Bir de sadece yildiz opt ile deref ettigimizde parametre gecememis olmazmiyiz fonk cagri opt kullanmadigimiz icin?
> 
> `void foo(int);`
> `void (*fptr)(int) = &foo;`
> `*foo; // function call gerceklesir mi?`
> 
> Cevap;
> 
> ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir **function pointer** deÄŸiÅŸken Ã¼zerinden fonksiyon Ã§aÄŸrÄ±sÄ±nÄ±n nasÄ±l doÄŸru ÅŸekilde yapÄ±labileceÄŸi incelenebilir.
> ```C
> #include <stdio.h>
> #include "nutility.h"
> #include <ctype.h>
> 
> void foo()
> {
>     printf("foo called!\n");
> }
> 
> int main(void)
> {
>     void (*fp)(void) = &foo;
> 
>     *fp; // Bu ÅŸekilde fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±lmÄ±yor sadece dereferencing iÅŸlemi yapÄ±lÄ±yor.
> 
>     (*fp)(); // Burada 'fp' function-pointer deÄŸiÅŸken Ã¼zerinden 'foo' fonksiyonuna Ã§aÄŸrÄ± yapÄ±lmaktadÄ±r.
> }
> ```


ğŸ§  `ato` Ã¶n ekiyle baÅŸlayan fonksiyonlarÄ±nÄ±n eksik yanlarÄ±;
- `ato` fonksiyonlarÄ± `0` dÃ¶ndÃ¼ÄŸÃ¼nde yazÄ± geÃ§erli bir sayÄ± olmadÄ±ÄŸÄ± iÃ§in mi `0` dÃ¶nÃ¼yor yoksa sayÄ± gerÃ§ekten `0` sayÄ±sÄ± mÄ± belli olmamaktadÄ±r.
- `ato` fonksiyonlarÄ± kullanÄ±ldÄ±ÄŸÄ±nda yazÄ±nÄ±n ne kadarÄ±nÄ±n sayÄ± olduÄŸu bilgisi belirlenemiyor.
- `ato` fonksiyonlarÄ± kullanÄ±ldÄ±ÄŸÄ±nda **hexedecimal**, **octal** sayÄ±lar alÄ±namamaktadÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda kullanÄ±cÄ±dan belirli bir formatta alÄ±nan yazÄ± formatÄ±ndaki tarih verisinin nasÄ±l gÃ¼n, ay, yÄ±l olarak tam sayÄ±ya dÃ¶nÃ¼ÅŸtÃ¼rÃ¼ldÃ¼ÄŸÃ¼ incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    char date[40];

    printf("bir tarih girin(gg-aa-yyyy): ");
    scanf("%s", date);

    int day = atoi(date);
    int mon = atoi(date + 3); // Buradaki pointer aritmetiÄŸinde yazÄ±daki '-' karakteri dikkate alÄ±nmtadÄ±r. 
    int year = atoi(date + 6); // Buradaki pointer aritmetiÄŸinde yazÄ±daki '-' karakteri dikkate alÄ±nmtadÄ±r.

    printf("day = %d", day);
    printf("mon = %d", day);
    printf("year = %d", day);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `atoi` fonksiyonuyla taÅŸma durumunun tespit edilemediÄŸi durum incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    char str[40];

    printf("bir sayi girin: ");
    scanf("%s", str);

    // 'int' tÃ¼rÃ¼nÃ¼n kapsamÄ±nÄ± aÅŸan sayÄ±larda hata oluÅŸacaktÄ±r.
    int ival = atoi(str);
    ptrintf("ival = %d\n", ival);

    
    long long llval = atoll(str);
    ptrintf("ival = %lld\n", llval);
}
```


## AdlarÄ± `strto` Ä°le BaÅŸlayan Fonksiyonlar 

ğŸ“Œ "**strto**" kÄ±saltmasÄ± "**String To**" sÃ¶zcÃ¼klerinden gelmektedir.

ğŸ§­ `stdlib.h` standart kÃ¼tÃ¼phanesinde olan baÅŸlÄ±k dosyasÄ±ndaki yazÄ±larÄ± sayÄ±lara Ã§evirme iÅŸlemini yapan fonksiyonlarÄ±n bazÄ±larÄ± aÅŸaÄŸÄ±daki gibidir;
- `strtoi` --> "**String To int**" sÃ¶zcÃ¼klerinin kÄ±saltmasÄ± olan bu fonksiyon yazÄ±dan `int` tÃ¼rÃ¼ne Ã§evirme iÅŸlemini yapmak iÃ§in kullanÄ±lÄ±r.
- `strtol` --> "**String To long**" sÃ¶zcÃ¼klerinin kÄ±saltmasÄ± olan bu fonksiyon yazÄ±dan `long` tÃ¼rÃ¼ne Ã§evirme iÅŸlemini yapmak iÃ§in kullanÄ±lÄ±r.
- `strtoll` --> "**String To long long**" sÃ¶zcÃ¼klerinin kÄ±saltmasÄ± olan bu fonksiyon yazÄ±dan `long long` tÃ¼rÃ¼ne Ã§evirme iÅŸlemini yapmak iÃ§in kullanÄ±lÄ±r.
- `strtof` --> "**String To float**" sÃ¶zcÃ¼klerinin kÄ±saltmasÄ± olan bu fonksiyon yazÄ±dan `float` tÃ¼rÃ¼ne Ã§evirme iÅŸlemini yapmak iÃ§in kullanÄ±lÄ±r.
- `strtod` --> "**String To double**" sÃ¶zcÃ¼klerinin kÄ±saltmasÄ± olan bu fonksiyon yazÄ±dan `double` tÃ¼rÃ¼ne Ã§evirme iÅŸlemini yapmak iÃ§in kullanÄ±lÄ±r.
- `strtold` --> "**String To long double**" sÃ¶zcÃ¼klerinin kÄ±saltmasÄ± olan bu fonksiyon yazÄ±dan `long double` tÃ¼rÃ¼ne Ã§evirme iÅŸlemini yapmak iÃ§in kullanÄ±lÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strtol` adÄ±ndaki yazÄ±yÄ± `double` tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼ren fonksiyonun kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

// p    : `long` tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lecek olan yazÄ±nÄ±n adresi
// endp : SayÄ±ya dÃ¶nÃ¼ÅŸÃ¼m yapÄ±lma iÅŸleminin bittiÄŸi adresten sonra sayÄ±ya dahil olmayan karakter varsa o karakterin adresi. 
// base : Hangi sayÄ± tabanÄ±nda dÃ¶nÃ¼ÅŸÃ¼m yapÄ±lacaÄŸÄ± bilgisi(2, 4, 8, 10, 16 vb. deÄŸerlerini alabilir) 
//long strtol(const char* p, char** endp, int base);

int main(void)
{
    char str[] = "2442532cavit";
    char* p;

    long lval = strtol(str, &p, 10); // 'p' deÄŸiÅŸkeni ilk baÅŸta Ã§Ã¶p deÄŸerdedir ama 'strtol' fonksiyonu Ã§alÄ±ÅŸtÄ±kran sonra bu gÃ¶stericinin deÄŸeri yazÄ±daki sayÄ±lardan sonraki adresi gÃ¶sterir.

    printf("deger = %ld\n", lval);
    putd(p);
    printf("index = %d\n", p - str);
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strtol` adÄ±ndaki yazÄ±yÄ± `double` tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼ren fonksiyonun kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>

// p    : `long` tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lecek olan yazÄ±nÄ±n adresi
// endp : SayÄ±ya dÃ¶nÃ¼ÅŸÃ¼m yapÄ±lma iÅŸleminin bittiÄŸi adresten sonra sayÄ±ya dahil olmayan karakter varsa o karakterin adresi. 
// base : Hangi sayÄ± tabanÄ±nda dÃ¶nÃ¼ÅŸÃ¼m yapÄ±lacaÄŸÄ± bilgisi(2, 4, 8, 10, 16 vb. deÄŸerlerini alabilir) 
//long strtol(const char* p, char** endp, int base);

int main(void)
{
    char str[] = "24acavit";
    char* p;

    long lval = strtol(str, &p, 16);

    printf("deger = %ld\n", lval);
    putd(p);
    printf("index = %d\n", p - str);
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strtol` adÄ±ndaki yazÄ±yÄ± `double` tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼ren fonksiyonun kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>

// p    : `long` tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lecek olan yazÄ±nÄ±n adresi
// endp : SayÄ±ya dÃ¶nÃ¼ÅŸÃ¼m yapÄ±lma iÅŸleminin bittiÄŸi adresten sonra sayÄ±ya dahil olmayan karakter varsa o karakterin adresi. 
// base : Hangi sayÄ± tabanÄ±nda dÃ¶nÃ¼ÅŸÃ¼m yapÄ±lacaÄŸÄ± bilgisi(2, 4, 8, 10, 16 vb. deÄŸerlerini alabilir) 
//long strtol(const char* p, char** endp, int base);

int main(void)
{
    char str[] = "101110010123neco";
    char* p;

    long lval = strtol(str, &p, 2);

    printf("deger = %ld\n", lval);
    putd(p);
    printf("index = %d\n", p - str);
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strtol` fonksiyonu ile yazÄ±yÄ± `double` tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rÃ¼rken ikinci parametreye `NULL` deÄŸer geldiÄŸi durum incelenebilir, burada ikinci deÄŸerin kullanÄ±lmayacaÄŸÄ± belirtilmiÅŸ oluyor.
```C
#include <stdio.h>
#include <stdlib.h>

// p    : `long` tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lecek olan yazÄ±nÄ±n adresi
// endp : SayÄ±ya dÃ¶nÃ¼ÅŸÃ¼m yapÄ±lma iÅŸleminin bittiÄŸi adresten sonra sayÄ±ya dahil olmayan karakter varsa o karakterin adresi. 
// base : Hangi sayÄ± tabanÄ±nda dÃ¶nÃ¼ÅŸÃ¼m yapÄ±lacaÄŸÄ± bilgisi(2, 4, 8, 10, 16 vb. deÄŸerlerini alabilir) 
//long strtol(const char* p, char** endp, int base);

int main(void)
{
    char str[] = "2343243neco";

    long lval = strtol(str, NULL, 2);

    printf("lval = %d\n", lval);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strtol` fonksiyonu ile yazÄ±yÄ± `double` tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rÃ¼rken son parametreye `0` deÄŸer geÃ§ilirse fonksiyon sayÄ±nÄ±n tabanÄ±nÄ± kendisi tespit etmeye Ã§alÄ±ÅŸacaktÄ±r.
```C
#include <stdio.h>
#include <stdlib.h>

// p    : `long` tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lecek olan yazÄ±nÄ±n adresi
// endp : SayÄ±ya dÃ¶nÃ¼ÅŸÃ¼m yapÄ±lma iÅŸleminin bittiÄŸi adresten sonra sayÄ±ya dahil olmayan karakter varsa o karakterin adresi. 
// base : Hangi sayÄ± tabanÄ±nda dÃ¶nÃ¼ÅŸÃ¼m yapÄ±lacaÄŸÄ± bilgisi(2, 4, 8, 10, 16 vb. deÄŸerlerini alabilir) 
//long strtol(const char* p, char** endp, int base);

int main(void)
{
    char str[] = "123"; // "0123", "0x123" deÄŸerleri de verilebilir.

    long lval = strtol(str, NULL, 0); // Burada son argÃ¼man '0' olduÄŸunda sayÄ±nÄ±n hangi tabanda olduÄŸunu fonksiyon kendisi tespit edecektir.

    printf("lval = %d\n", lval);
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.17-12.25 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


## Formated Input/Output(FormatlÄ± GiriÅŸ/Ã‡Ä±kÄ±ÅŸ)

ğŸ§  `printf` ve `scanf` fonksiyonlarÄ±nÄ±n adlarÄ±nÄ±n sonundaki "**f**" harfi "**formated**" sÃ¶zcÃ¼ÄŸÃ¼nden gelmektedir, `printf` ve `scanf` fonksiyonlarÄ±nÄ±n birden fazla tÃ¼rÃ¼ vardÄ±r, bunlar;
- `printf` fonksiyonu standart Ã§Ä±kÄ±ÅŸ akÄ±mÄ±na formatlÄ± olarak yazdÄ±rmak iÃ§in kullanÄ±lÄ±r.
- `sprintf` fonksiyonu belleÄŸe(yani bir `char` diziye) formatlÄ± olarak yazdÄ±rmak iÃ§in kullanÄ±lÄ±r.
- `fprintf` fonksiyonu dosyaya formatlÄ± olarak yazdÄ±rmak iÃ§in kullanÄ±lÄ±r.
- `scanf` fonksiyonu standart giriÅŸ akÄ±mÄ±ndan formatlÄ± olarak okumak iÃ§in kullanÄ±lÄ±r.
- `sscanf` fonksiyonu bellekten(yani bir `char` diziden) formatlÄ± olarak okumak iÃ§in kullanÄ±lÄ±r.
- `fscanf` fonksiyonu dosyadan formatlÄ± olarak okumak iÃ§in kullanÄ±lÄ±r.


ğŸš€ **In-Memory**: Bellek Ã¼zerinde yapÄ±lan okuma/yazma iÅŸlemlerine verilen genel bir programlama terimidir.

ğŸš€ **BelleÄŸe yazmak nedir**: Burada okuma/yazma iÅŸlemleri yazÄ±lar Ã¼zerinde yapÄ±ldÄ±ÄŸÄ± iÃ§in bellekte yer kaplayan karakter dizisi olan nesneler(object) Ã¼zerinden yapÄ±lan okuma/yazma iÅŸlemleri bellekte yapÄ±lan iÅŸlemlerdir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `sprintf` fonksiyonunun kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>

// 'printf' ve 'sprintf' fonksiyonlarÄ±nÄ±n prototipleri aÅŸaÄŸÄ±daki gibidir;
// int printf(const char* pfm, ...);
// int sprintf(char* p, const char* pfm, ...); // Bu fonksiyonun ilk parametresine geÃ§ilen nesnenin adresine deÄŸer yazdÄ±rmak iÃ§in kullanÄ±lÄ±r.

int main(void)
{
    int x = 5;
    double d = 3.43543534;
    char str[] = "emre";

    printf("%d %f %s\n", x, d, str);

    char s[100];

    sprintf(s, "%d %f %s\n", x, d, str); // Buradaki 'sprintf' fonksiyon Ã§aÄŸrÄ±sÄ±

    prinf("(%s)\n", s);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `sprintf` fonksiyonunun kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int day, mon, year;
    
    printf("gun ay yil degerlerini tam sayi olarak giriniz: ");
    scanf("%d%d%d", &day, &mon, &year);

    char str[40]; // '02-05-1995'

    sprintf(str, "%02d-%02d-%d", day, mon, year); // Bu satÄ±rda kullanÄ±cÄ±dan alÄ±nan tarihbilgisi 'str' nesnesine yazÄ±lmaktadÄ±r.

    printf("[%s]", str);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `sprintf` fonksiyonunun kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int day = 2, mon = 5, year = 2013;
    int idx = 34;
    char name[20] = "caner";
    
    char filename[100];

    sprintf(filename, "%s_%02d_%02d_%d_%03d.txt", name, day, mon, year, idx); // Burada belirli bir kurala gÃ¶re dosya adÄ± oluÅŸturulup 'filename' adÄ±ndaki nesneye yazdÄ±rÄ±lÄ±yor, buradaki gibi iÅŸlemler Ã¼retimde de sÄ±k kullanÄ±lmaktadÄ±r.

    printf("[%s]", filename);
}
```


ğŸ“Œ `sprintf` Ã¼retimde en Ã§ok kullanÄ±lan fonksiyonlardan biridir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `sprintf` fonksiyonundan geriye dÃ¶nen yazÄ±nÄ±n uzunluk deÄŸerini nasÄ±l kullanÄ±labildiÄŸi incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int x;

    printf("bir tam sayi girin:");
    scanf("%d", &x);

    char str[100];

    int len = sprintf(str, "%d", x);
    printf("[%s]", str);

    str[len] = '!';
    str[len + 1] = '\0';
    printf("[%s]\n", str);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `sscanf` fonksiyonu ile **in-memory read** iÅŸleminin nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int x, y, z;
    char str[] = "8341 454 965";
    printf("uc tam sayi girin:");

    sscanf(str, "%d%d%d", &x, &y, &z);

    printf("x = %d\n", x);
    printf("x = %d\n", y);
    printf("x = %d\n", z);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `sscanf` fonksiyonu ile **in-memory read** iÅŸleminin nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    char str[] = "2.454yaser 2423";

    double d;
    char name[20];
    int ival;
    
    sscanf(str, "%lf%s%d", &d, name, &ival);

    printf("%f  %s  %d\n", d, name, ival);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `sscanf` fonksiyonu ile **in-memory read** iÅŸlemiyle hatalÄ± bir veri okunmata Ã§alÄ±ÅŸÄ±ldÄ±ÄŸÄ±nda nasÄ±l bir durum oluÅŸtuÄŸu incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    char str[] = "45 ali 342";

    int x, y, z;

    int n = sscanf(str, "%d%d%d", &x, &y, &z); // Burada sadece 'x' deÄŸiÅŸkenine deÄŸer atanabileceÄŸi iÃ§in 'n' deÄŸiÅŸkeninin deÄŸeri '1' olacaktÄ±r.

    printf("n = %d\n", n);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `sscanf` fonksiyonu ile **in-memory read** iÅŸlemiyle hatalÄ± bir veri okunmata Ã§alÄ±ÅŸÄ±ldÄ±ÄŸÄ±nda nasÄ±l bir durum oluÅŸtuÄŸu incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    //char str[40] = "";
    char str[40];
    str[0] = '\0';

    int x, y, z;
    
    int n = sscanf(str, "%d%d%d", &x, &y, &z); // Burada 'str' yazÄ±sÄ± boÅŸ dizi olduÄŸu iÃ§in 'sscanf' fonksiyonu geriye '-1' deÄŸerini dÃ¶ndÃ¼rÃ¼r.

    printf("n = %d\n", n);
}
```


Ders sonu ...
