# 34.Ders 11.05.2025 ğŸ•˜

Derse 08(09:02)-10(09:05)-11(09:20)-12(09:41)-11(10:03)-11(10:23)-12(10:41)-13(11:23)-13(12:00)-12(12:37)-12(12:45) kiÅŸi katÄ±ldÄ±.
---



â—â—â— **string literal** ile ilgili akÄ±lda kalmasÄ± gereken en Ã¶nemli bilgiler ÅŸu ÅŸekildedir;
- **string literal**'in static Ã¶mÃ¼rlÃ¼ olmasÄ±
- Immutable olmalarÄ±(deÄŸiÅŸtirilme giriÅŸimleri **ub** durumuna neden olacaktÄ±r) 
- Ã–zdeÅŸ **string literal** tanÄ±mlamalarÄ± C standardÄ±nda **Implemantation Specified** olarak belirtiliyor ve derleyiciler Ã–zdeÅŸ **string literal** varlÄ±klarÄ± bellekte tek bir nesne olarak tutabileceÄŸi gibi farklÄ± nesneler olarak ta tutabilir ve her derleyici her seferinde farklÄ± bir yolu seÃ§ebilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strcpy` fonksiyonu ile bir karakter dizisinin belirli bir indeksinden sonrasÄ±na boÅŸ dizi kopyalanmasÄ± iÅŸlemi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int main(void)
{
    char str[100] = "necati ergin";

    puts(str);
    strcpy(str + 6, ""); // Burada 'str' karakter dizisinin 6 indeksli elemanÄ±ndna itibaren boÅŸ dizi koptalanÄ±yor(karakter dizisinin son elemanÄ±nÄ± gÃ¶steren boÅŸ eleman Ã¶ne Ã§ekilerek yazÄ± kÄ±saltÄ±lÄ±yor)
    puts(str);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir yazÄ±nÄ±n nasÄ±l kÄ±saltÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int main(void)
{
    char str[100] = "ad soyad";
    
    puts(str);

    str[6] = '\0'; // Buradaki kod ile bir alt satÄ±rdaki kod aynÄ± iÅŸi yapmaktadÄ±r.
    //strcpy(str + 6, "");
    
    puts(str);
}
```



â—â—â— `sizeof` derleme zamanÄ±yla(compile-time) ilgilidir, `strlen` fonksiyonu Ã§alÄ±ÅŸma zamanÄ±yla(run-time) ilgilidir. `sizeof` operatÃ¶rÃ¼ iÅŸlem kodu Ã¼retmez.


## Pointer Arrays(GÃ¶sterici Dizileri) 

Bir dizinin elemanlarÄ± herhangi bir tÃ¼rden olabildiÄŸine gÃ¶re bir dizinin elemanlarÄ± pointer tÃ¼rÃ¼nden de olabilir, ve gÃ¶sterici dizileri Ã§ok sÄ±k kullanÄ±lmaktadÄ±r. </br>
Bir **pointer array** elemanlarÄ± gÃ¶sterici olan bir dizidir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda pointer tÃ¼rÃ¼nden dizi tanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int a[10]; // 'a'nÄ±n tÃ¼rÃ¼ 'int[10]'
    int* ar[10]; // 'ar'nin tÃ¼rÃ¼ 'int*[10]'
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `int*[10]` tÃ¼rÃ¼nden bir dizinin elemanlarÄ±nÄ±n nasÄ±l kullanÄ±labileceÄŸi incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 1, y = 2, z= 3;

    int* ary[10];

    ary[0] = &x;
    ary[1] = &y;
    ary[2] = &z;

    *ary[0] = 999; // buradaki ifade '*(ary[0])' ifadesi ile denktir.
    printf("y = %d", y);

    ++*ary[2]; // buradaki ifade '(++(*(ary[2])))' ifadesi ile denktir.
    printf("z = %d", z);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program **pointer aritmetiÄŸi** ile **pointer dizileri** arasÄ±ndaki iliÅŸkiyi anlamak iÃ§in incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[] = { 10, 20, 30, 40 };
    int b[] = { 13, 23, 33, 43 };
    int c[] = { 90, 92, 94, 96 };

    print_array(b, 4);

    // 'p' bir pointer dizisidir.
    int* p[] = { a, b, c };

    ++p[1]; // Burada 'p[1]' ifadesinin deÄŸeri 'b' dizisinin ilk elemanÄ±nÄ±n adresidir('p[1]' ifadesinin deÄŸeri '&b[0]'), 'p' dizisinin ikinci pointer'Ä±nÄ±n gÃ¶sterdiÄŸi adres 'b' dizisinin ikinci elemanÄ± olacak ÅŸekilde gÃ¼ncelleniyor.
    ++*p[1]; // Burada 'p[1]' ifadesinin deÄŸeri bir Ã¶nceki statement'tan dolayÄ± 'b' dizisinin ikinci elemanÄ±nÄ±n adresidir, '*' operatÃ¶r ile bu adresteki nesnenin deÄŸerine eriÅŸilip deÄŸeri bir arttÄ±rÄ±lÄ±yor ve bu iÅŸlem sonucunda 'b' dizisinin ikinci elemanÄ± '23' deÄŸerinden '24' deÄŸerine Ã§evriliyor.

    print_array(b, 4);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir pointer dizisinin elemanlarÄ±nÄ±n yazdÄ±rÄ±lÄ±ÅŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int x = 5, y = 10, z = 15, t = 20;

    int* p[] { &x, &y, &z, &t };

    for(int i = 0; i < 4; ++i){
        printf("%p  ", p[i]);
    }
    printf("\n");

    // YukarÄ±daki dÃ¶ngÃ¼ ile aynÄ± Ã§Ä±ktÄ±yÄ± Ã¼retecek dÃ¶ngÃ¼ aÅŸaÄŸÄ±dadÄ±r
    for(int i = 0; i < 4; ++i){
        printf("%p  ", p + i);
    }
    printf("\n");

    printf("%p %p %p %p \n", &x, &y, &z, &t);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir pointer dizisinin elemanlarÄ±yla yapÄ±lan iÅŸlemler incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int x = 5, y = 10, z = 15, t = 20;

    printf("%p %p %p %p \n", &x, &y, &z, &t);

    int* p[] { &x, &y, &z, &t };

    for(int i = 0; i < 4; ++i){
        printf("%d\n", *p[i]); // GÃ¶stericinin gÃ¶sterdiÄŸi adresteki deÄŸer yazdÄ±rÄ±lÄ±yor. 
    }
    printf("~~~~~~~~~~~~\n");

    for(int i = 0; i < 4; ++i){
        ++*p[i]; // GÃ¶stericinin gÃ¶sterdiÄŸi adresteki deÄŸer bir arttÄ±rÄ±lÄ±yor. 
    }
    printf("~~~~~~~~~~~~\n");

    for(int i = 0; i < 4; ++i){
        printf("%d\n", *p[i]); // GÃ¶stericinin gÃ¶sterdiÄŸi adresteki deÄŸer yazdÄ±rÄ±lÄ±yor. 
    }
    printf("~~~~~~~~~~~~\n");

    printf("%p %p %p %p \n", &x, &y, &z, &t);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda elemanlarÄ± `int*` tÃ¼rÃ¼nden olan bir diziye farklÄ± adreslerin atanÄ±ÅŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int* foo(void);

int main(void)
{
    int x = 5;
    int ar[10] = { 0 };
    int* ptr = NULL;

    int* p[4];

    p[0] = &x; // 'p' dizisinin ilk elemanÄ±na 'int' tÃ¼rÃ¼nden 'x' deÄŸiÅŸkeninin adresi atanÄ±yor.
    p[1] = ar; // 'p' dizisinin ikinci elemanÄ±na 'array decay' ile elde edilen 'ar' isimli 'int' tÃ¼rÃ¼nden dizinin ilk elemanÄ±nÄ±n adresi atanÄ±yor.
    p[2] = foo(); // 'p' dizisinin Ã¼Ã§Ã¼ncÃ¼ elemanÄ±na 'foo()' fonksiyonunun geri dÃ¶nÃ¼ÅŸenden gelen 'int*' tÃ¼rÃ¼nden deÄŸer atanÄ±yor.
    p[3] = ptr; // 'p' dizisinin dÃ¶rdÃ¼ncÃ¼ elemanÄ±na 'ptr' deÄŸiÅŸkeninin deÄŸeri atanÄ±yor.
    p[4] = NULL; // 'p' dizisinin beÅŸinci elemanÄ±na 'NULL Pointer' deÄŸer atanÄ±yor.
}
```



â—â—â— Bu programdaki kullanÄ±m Ã¶nemlidir, iyi anlaÅŸÄ±lmalÄ±dÄ±r. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir pointer dizisinin ilk deÄŸer verme iÅŸleminde nasÄ±l bir iÅŸleyiÅŸ olduÄŸu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int x = 10, y = 20, z = 30;

int main(void)
{
    int a[20] = { 1, 4, 3, 2 }; // Buradaki 'a' adlÄ± 'int' tÃ¼rÃ¼nden dizinin ilk deÄŸer atanmayan elemanlarÄ± 'a' deÄŸiÅŸkeninin static Ã¶mÃ¼rlÃ¼ ya da otomatic Ã¶mÃ¼rlÃ¼ olmasÄ±ndan baÄŸÄ±msÄ±z olarak '0' deÄŸerini alacaktÄ±r.
    int* pa[5] = { &x, &y, &z }; // Burada beÅŸ elemanlÄ± 'pa' dizisinin 3 ve 4 indisli elemanlarÄ±nÄ±n deÄŸeri 'NULL' olacaktÄ±r, bu dilin standardÄ±nÄ±n saÄŸladÄ±ÄŸÄ± bir kesinliktir, bu derleyiciden derleyiciye aynÄ± olarak geÃ§erlidir.
    
    if(pa[3] == NULL)
        printf("dogru");
    else
        printf("yanlis");
    
    if(!pa[4])
        printf("dogru");
    else
        printf("yanlis");
}
```



â—â—â— Bu programdaki kullanÄ±m Ã¶nemlidir, iyi anlaÅŸÄ±lmalÄ±dÄ±r. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda C standardÄ±nda **const pointer to int**, C++ standardÄ±nda **top level const** olarak adlandÄ±rÄ±lan tÃ¼rlerin kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int x = 10, y = 20, z = 30;

int main(void)
{
    int i = 22532;

    int* const pa[5] = { &x, &y, &z }; // Burada beÅŸ elemanlÄ± 'pa' dizisinin elemanlarÄ±nÄ±n adres deÄŸerlerinin sabit olduÄŸu bildiriliyor. C standardÄ±nda 'const pointer to int', C++ standardÄ±nda 'top level const' olarak adlandÄ±rÄ±lÄ±r.
    
    pa[2] = &i; // Buradaki kod illegal'dir, senteks hatasÄ± oluÅŸur.
    *pa[2] = 777; // Buradaki kod legal'dir.

    printf("z = %d\n", z);
}
```



â—â—â— Bu programdaki kullanÄ±m Ã¶nemlidir, iyi anlaÅŸÄ±lmalÄ±dÄ±r. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda C standardÄ±nda **pointer to const int**, C++ standardÄ±nda **low level const** olarak adlandÄ±rÄ±lan tÃ¼rlerin kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int x = 10, y = 20, z = 30;

int main(void)
{
    int i = 22532;

    const int* pa[5] = { &x, &y, &z }; // Burada beÅŸ elemanlÄ± 'pa' dizisinin elemanlarÄ±nÄ±n adres deÄŸerindeki nesnelerin deÄŸerinin sabit olduÄŸu bildiriliyor. 
    //int const * pa[5] = { &x, &y, &z }; // Buradaki bildirim ile yukarÄ±daki bildirim denktir.
    
    int ival = 35;

    pa[1] = &ival; // Buradaki kod legal'dir
    *p[2] = 888; // Buradaki kod illegal'dir, senteks hatasÄ± oluÅŸur.
}
```



â—â—â— Bu programdaki kullanÄ±m Ã¶nemlidir, iyi anlaÅŸÄ±lmalÄ±dÄ±r. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda C standardÄ±nda **const pointer to const int** olarak adlandÄ±rÄ±lan tÃ¼rlerin kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int x = 10, y = 20, z = 30;

int main(void)
{
    int i = 22532;

    const int* const pa[5] = { &x, &y, &z }; // C standardÄ±nda 'const pointer to const int' olarak adlandÄ±rÄ±lan deÄŸiÅŸken bildirimi.
    
    int ival = 35;

    pa[1] = &ival; // Buradaki kod illegal'dir, senteks hatasÄ± oluÅŸur.
    *p[1] = 888; // Buradaki kod illegal'dir, senteks hatasÄ± oluÅŸur.
}
```


âš ï¸ Pointer dizisi olarak en Ã§ok `char* array[n];` ÅŸeklinde tanÄ±mlanan karakter dizileri kullanÄ±lÄ±r.

ğŸ“Œ MantÄ±ksal iliÅŸki iÃ§indeki verileri birarada tutmak iÃ§in diziler kullanÄ±lÄ±r. 



â—â—â— En kritik bilgilerden biri. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda elemanlarÄ± `char*` tÃ¼rÃ¼nden olan pointer dizilerin kullanÄ±mÄ± incelenebilir. ElemanlarÄ± mantÄ±ksal iliÅŸki iÃ§inde olan ve elemanlarÄ±nÄ±n deÄŸerleri deÄŸiÅŸmeyen dizilere **lookup table** denilmektedir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    // AÅŸaÄŸÄ±daki bildirim C dilinde legal C++ dilinde illegal'dir Ã§Ã¼nkÃ¼ 'string literal' varlÄ±klar 'const char*' tÃ¼rÃ¼ndendir, burada 'const char*' dizi deÄŸerleri olan bir dizinin 'const char*' tÃ¼rÃ¼nden tanÄ±mlanmasÄ± doÄŸru olacaktÄ±r.
    char* weekdays[] = { "pazartesi", "sali", "carsamba", "persembe", "cuma", "cumartesi", "pazar" };

    const char * weekdays2[] = { "pazartesi", "sali", "carsamba", "persembe", "cuma", "cumartesi", "pazar" };
    char const * weekdays3[] = { "pazartesi", "sali", "carsamba", "persembe", "cuma", "cumartesi", "pazar" };

    *weekdays[2] = 't'; // Buradaki iÅŸlem hem C dilinde hem de C++ dilinde 'string literal' bir varlÄ±ÄŸÄ±n deÄŸeri deÄŸiÅŸtirilmek istendiÄŸi iÃ§in 'ub' durumuna neden olacaktÄ±r.
}
```


â—â—â— En kritik bilgilerden biri. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki program **otomatic storage duration** bir char pointer dizi deÄŸiÅŸkenin bellekte kalmasÄ±nÄ± ve bu deÄŸiÅŸkenin deÄŸerleri olan **string literal** varlÄ±klarÄ±n Ã¶mÃ¼rlerinin ne olduÄŸunu iyi anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    {
        char* weekdays[] = { "pazartesi", "sali", "carsamba", "cuma", "cumartesi", "pazar" };
    }

    // Process'in akÄ±ÅŸÄ± buraya geldiÄŸinde 'weekdays' adÄ±ndaki deÄŸiÅŸken bellekten silinecektir ama 'weekdays' dizisinin elemanlarÄ± olan 'string literal' varlÄ±klar process'in Ã¶mrÃ¼ boyunca kadar bellekte kalmaya devam edecektir.
}
```


>â”
> 
> Sorulan soru; 
>
> Bunlar dizi olduÄŸu iÃ§in ramde ard arda durmasÄ± gerekiyor deÄŸil mi?
> 
> Cevap;
> 
> HayÄ±r tabiki, bu derste buraya gelene kadar bununla ilgili aÃ§Ä±klamalar yapÄ±ldÄ±.
> 
> ğŸ‘‡ AÅŸaÄŸÄ±daki programda burada sorulan durumla ilgili 'p' pointer disizinin nasÄ±l oluÅŸturulduÄŸu detaylÄ± incelenebilir.
> ```C
> #define _CRT_SECURE_NO_WARNINGS
> 
> #include <stdio.h>
> 
> int main(void)
> {
>     int a[5];
>     int b[5];
>     int c[5];
>     int d[5];
> 
>     int* p[] = { a, b, c, d }; // Buradaki 'p' pointer dizisinin kendi 'int' tÃ¼rÃ¼nden adres tutan elemanlarÄ±nÄ±n adresleri bellekte sÄ±ralÄ±dÄ±r ve 'a', 'b', 'c', 'd' dizilerinin kendi elemanlarÄ± bellekte ardÄ±ÅŸÄ±ktÄ±r ama 'a', 'b', 'c', 'd' dizilerinin hepsi bellekte ardÄ±ÅŸÄ±k olmasÄ±nÄ±n bir kesinliÄŸi yoktur.
> }
> ```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **lookup table** kullanÄ±mÄ± incelenebilir.
- **Lookup table** programlamada Ã§ok sÄ±k kullanÄ±lan veri yapÄ±sÄ±dÄ±r, deÄŸerleri sabit olan ve gerektiÄŸinde kullanabilmek iÃ§in birbiriyle iliÅŸkili verilerin tutulmasÄ± iÃ§in kullanÄ±lan veri yapÄ±sÄ±dÄ±r.
- â— **Lookup table** kullanÄ±ldÄ±ÄŸÄ±nda bu deÄŸiÅŸkenler sonradan deÄŸiÅŸtirilmeye karÅŸÄ± korunmasÄ± iÃ§in **const** olarak tanÄ±mlanmasÄ± doÄŸru olacaktÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    const int primes[] = { 0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 };
    const char* const weekdays[] = { "pazartesi", "sali", "carsamba", "persembe", "cuma", "cumartesi", "pazar" };

    weekdays[2] = "birgun"; // Burada sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur, sÃ¶zdizim hatasÄ±nÄ±n(syntax error) nedeni "weekdays" dizisinin elemanlarÄ±nÄ±n deÄŸerlerinin 'const' olarak bildirilmiÅŸ olmasÄ±dÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda haftanÄ±n gÃ¼nlerini bir **lookup table**'dan alarak nasÄ±l kullanÄ±ldÄ±ÄŸÄ± incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    const char* const weekdays[] = { "pazartesi", "sali", "carsamba", "persembe", "cuma", "cumartesi", "pazar" };

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile 'weekdays' dizisinin elemanlarÄ±nÄ±n adresleri yazdÄ±rÄ±lmaktadÄ±r.
    for(int i = 0; i < 7; ++i){
        printf("%s\n", weekdays[i]);
    }

    printf("\n~~~~~~~~~~~~~~~~~~~~~~\n");

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile 'weekdays' dizisinin elemanlarÄ±nÄ±n adresleri yazdÄ±rÄ±lmaktadÄ±r.
    for(int i = 0; i < 7; ++i){
        printf("%p\n", weekdays[i]);
    }
}
```



ğŸ‘‡ â—â—â— AÅŸaÄŸÄ±daki programda **lookup table**'larda en Ã§ok kullanÄ±lan 0 indeksli dizi elemanÄ±nÄ±n boÅŸ deÄŸer verilmesi ve bu ÅŸekilde 1 indeksli elemandan itibaren daha kullanÄ±labilir bir **lookup table** bildirilmiÅŸ olur. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    const char* const weekdays[] = { "", "pazartesi", "sali", "carsamba", "persembe", "cuma", "cumartesi", "pazar" };

    int day_idx;

    printf("haftanin kacinci gunu: ");
    scanf("%d", &day_idx);
    printf("haftanin %d. gunu %s\n", day_idx, weekdays[day_idx]);
}
```



ğŸ‘‡ â—â—â— AÅŸaÄŸÄ±daki programda elemanlarÄ± `char*` tÃ¼rÃ¼nden olan gÃ¶sterici dizisiyle ilgili `sizeof` kullanÄ±mlarÄ±nda Ã¼retilecek olan deÄŸerler incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    char* p[8];

    printf("%zu/n", sizeof(p)); // 32 bitlik bir sistem iÃ§in standart Ã§Ä±ktÄ± akÄ±mÄ±na '32/n' deÄŸeri gÃ¶nderilir.
    printf("%zu/n", sizeof(p[0])); // 32 bitlik bir sistem iÃ§in standart Ã§Ä±ktÄ± akÄ±mÄ±na '4/n' deÄŸeri gÃ¶nderilir.
    printf("%zu/n", sizeof(*p[0])); // Standart Ã§Ä±ktÄ± akÄ±mÄ±na '1/n' deÄŸeri gÃ¶nderilir.
    printf("%zu/n", sizeof(p) / sizeof(p[0])); // Standart Ã§Ä±ktÄ± akÄ±mÄ±na '8/n' deÄŸeri gÃ¶nderilir ve buradaki ifade herhengi bir dizinin uzunluÄŸunu verecektir.
}
```


[10:29:00-10:45:00]
ğŸ‘‡ AÅŸaÄŸÄ±daki programda haftanÄ±n gÃ¼nlerini tutan pointer dizinin nasÄ±l kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    const char* const weekdays[] = { "pazartesi", "sali", "carsamba", "persembe", "cuma", "cumartesi", "pazar" };
    char dayname[20];

    printf("haftanin hangi gunu: ");
    scanf("%s", dayname);

    size_t i;
    
    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ 'weekdays' dizisinin boyutu kadar dÃ¶necektir, 'asize' bir 'function like makro'dur ve 'nutility.h' dosyasÄ±nda bildirilmiÅŸtir.
    for(i = 0; i < asize(weekdays); ++i){
        if(!strcmp(dayname, weekdays[i])) // Burada 'strcmp' fonksiyonu iki argÃ¼manÄ±n eÅŸitliÄŸini sÄ±nar ve eÄŸer eÅŸitlik tespitedilirse geriye '0' deÄŸeri dÃ¶nÃ¼leceÄŸi iÃ§in dÃ¶ngÃ¼den Ã§Ä±kÄ±lacaktÄ±r, ve bu bilgi kullanÄ±larak girilen yazÄ±nÄ±n haftanÄ±n bir gÃ¼nÃ¼ne karÅŸÄ±lÄ±k gelip gelmediÄŸi anlaÅŸÄ±lÄ±yor.
            break;
    }

    // YukarÄ±daki dÃ¶ngÃ¼nÃ¼n aÅŸaÄŸÄ±daki gibi yazÄ±lmasÄ± C dilinde daha yaygÄ±ndÄ±r ve bu kullanÄ±m C dilinde idiomatic kullanÄ±mdÄ±r.
    //for(i = 0; i < asize(weekdays) && strcmp(dayname, weekdays[i]); ++i)
    //; // null statement

    if(i < asize(weekdays))
        printf("%s haftanin %d. gunu.\n", dayname, i + 1);
    else
        printf("%s gecerli bir gun ismi degil.\n", dayname);
}
```



Buradan itibaren bir saat boyunca daha Ã¶nceden Ã¶ÄŸrenilenleri pekiÅŸtirmek iÃ§in sorular sorulacak;




ğŸ‘‡ AÅŸaÄŸÄ±daki programda adlarÄ±n listesinin tutulduÄŸu bir pointer dizinin gezilerek elemanlarÄ±nÄ±n farklÄ± ÅŸekillerde standar Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderiliÅŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

char* p[] = { 
    "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
    "hakki", "haldun", "halime", "haluk", "handan", "hande", "handesu", "hasan", "helin", "hikmet",
    "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
    "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata", // Buradaki en son ',' token'Ä±na 'trailing comma' denmektedir.
};

int main(void)
{
    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile 'p' pointer dizisindeki yazÄ±lar yazdÄ±rÄ±lÄ±yor.
    for (size_t i = 0; i < asize(p); ++i) {
        if (i && i % 5 == 0) // Her baÅŸ iÅŸlem sonrasÄ± yeni satÄ±ra geÃ§ilsin.
            printf("\n");

        printf("%s ", p[i]);
    }

    printf("\n~~~~~~~~~~~~~~\n");

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile 'p' pointer dizisindeki yazÄ±larÄ±n ilk karakterleri yazdÄ±rÄ±lÄ±yor. 
    for (size_t i = 0;  i < asize(p); ++i) {
        if (i && i % 5 == 0) // Her baÅŸ iÅŸlem sonrasÄ± yeni satÄ±ra geÃ§ilsin.
            printf("\n");

        printf("%c ", *p[i]);
        // printf("%c ", p[i][0]); // Buradaki kod ile yukarÄ±daki kod birbirine denktir.
    }

    printf("\n~~~~~~~~~~~~~~\n");

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile 'p' pointer dizisindeki yazÄ±larÄ±n son karakterleri yazdÄ±rÄ±lÄ±yor. 
    for (size_t i = 0;  i < asize(p); ++i) {
        if (i && i % 5 == 0) // Her baÅŸ iÅŸlem sonrasÄ± yeni satÄ±ra geÃ§ilsin.
            printf("\n");

        // AÅŸaÄŸÄ±daki iÅŸlemlerde yazÄ± boÅŸ yazÄ± olursa hata oluÅŸacaktÄ±r.
        printf("%c ", p[i][strlen(p[i]) - 1]); // YazÄ±nÄ±n son elemanÄ±na eriÅŸip karakteri yazdÄ±rÄ±lÄ±yor.
        //putchar(p[i][strlen(p[i]) - 1]); // YazÄ±nÄ±n son elemanÄ±na eriÅŸip karakteri yazdÄ±rÄ±lÄ±yor. Buradaki kullanÄ±m yukarÄ±daki statement ile aynÄ± iÅŸi yapmaktadÄ±r.
    }
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 11.00-11.23 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir dizi bildiriminin nasÄ±l yapÄ±lamayacaÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    char arr[] = "test";
    int x[strlen(arr)]; // Bu dizi bildirimi geÃ§ersizdir Ã§Ã¼nkÃ¼ dizi uzunluÄŸunu belirten 'strlen(arr)' ifadesi sabit ifadesi deÄŸildir, dizilerin eleman sayÄ±larÄ±nÄ± belirten ifadelerin 'const' olmalarÄ± gerekiyor.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda adlar dizisindeki adlar ve yanlarÄ±na karakter sayÄ±sÄ±nÄ±n nasÄ±l yazÄ±lacaÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

char* p[] = {  
    "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
    "hakki", "haldun", "halime", "haluk", "handan", "hande", "handesu", "hasan", "helin", "hikmet",
    "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
    "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata", // Buradaki en son ',' token'Ä±na 'trailing comma' denmektedir.
};

int main(void)
{
    for(size_t i = 0; i < asize(p); ++i)
        printf("%-19s   %zu\n", p[i], strlen(p[i]));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir karakter dizisindeki iÃ§inde belirli bir karakter geÃ§en elemanlarÄ±n nasÄ±l bulunabileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

char* p[] = {  
    "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
    "hakki", "haldun", "halime", "haluk", "handan", "hande", "handesu", "hasan", "helin", "hikmet",
    "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
    "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata", // Buradaki en son ',' token'Ä±na 'trailing comma' denmektedir.
};

int main(void)
{
    int c;

    printf("icinde hangi karakter olanlar: ");
    c = getchar();

    for(size_t i = 0; i < asize(p); ++i)
        if(strchr(p[i], c))
            printf("%s ", p[i]);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir karakter dizisindeki herhangi bir karakter n defa geÃ§en elemanlarÄ±n tespit edilmesi iÃ§in nasÄ±l bir program yazÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

char* p[] = {  
    "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
    "hakki", "haldun", "halime", "haluk", "handan", "hande", "handesu", "hasan", "helin", "hikmet",
    "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
    "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata", // Buradaki en son ',' token'Ä±na 'trailing comma' denmektedir.
};

int count(const char* ptr, int c)
{
    int cnt = 0;

    while(*ptr){
        if(*ptr == c)
            ++cnt;
        ++ptr;
    }

    return cnt;
}

int main(void)
{
    int c;
    printf("hangi karakter: ");
    c = getchar();

    int n;
    printf("kac tane: ");
    scanf("%d", &n);

    for(size_t i = 0; i < asize(p); ++i)
        if(count(p[i], c) == n)
            printf("%s ", p[i]);
}
```




ğŸ“– Ã–dev-1
ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki `p` dizisinin pointerlerÄ±nÄ±n gÃ¶sterdiÄŸi adlardan tÃ¼m elemanlarÄ± eÅŸsiz olan elemanlarÄ± yazdÄ±ran programÄ± yazÄ±nÄ±z.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

char* p[] = {  
    "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
    "hakki", "haldun", "halime", "haluk", "handan", "hande", "handesu", "hasan", "helin", "hikmet",
    "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
    "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata", // Buradaki en son ',' token'Ä±na 'trailing comma' denmektedir.
};


int main(void)
{
    int c;

    printf("hangi karakter: ");
    c = getchar();
    int n;

    printf("kac tane: ");
    scanf("%d", &n);

    for(size_t i = 0; i < asize(p); ++i)
        // if(???)
        // printf("%s ", p[i]);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir karakter dizisindeki elemanlardan ilk harfi ile son harfi aynÄ± olanlarÄ±n nasÄ±l yazdÄ±rÄ±lacaÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

char* p[] = {  
    "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
    "hakki", "haldun", "halime", "haluk", "handan", "hande", "handesu", "hasan", "helin", "hikmet",
    "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
    "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata", // Buradaki en son ',' token'Ä±na 'trailing comma' denmektedir.
};


int main(void)
{
    for(size_t i = 0; i < asize(p); ++i)
        if(p[i][0] == p[i][strlen(p[i]) - 1])
            printf("%s ", p[i]);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iÃ§inde kullanÄ±cÄ±dan alÄ±nan yazÄ± deÄŸeri geÃ§en karakter dizisindeki elemanlarÄ±n nasÄ±l yazdÄ±rÄ±lacaÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

char* p[] = {  
    "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
    "hakki", "haldun", "halime", "haluk", "handan", "hande", "handesu", "hasan", "helin", "hikmet",
    "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
    "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata", // Buradaki en son ',' token'Ä±na 'trailing comma' denmektedir.
};


int main(void)
{
    char entrt[20];
    printf("bir yazi girin: ");
    scanf("%s", entrt);

    for(size_t i = 0; i < asize(p); ++i)
        if(strstr(p[i], entrt)) // 'strstr' fonksiyonu bir yazÄ± iÃ§inde bir yazÄ±nÄ±n geÃ§ip geÃ§mediÄŸini sÄ±namak iÃ§in kullanÄ±lÄ±yor.
            printf("%s\n", p[i]);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iÃ§inde girilen karakterlerden herhangi biri geÃ§en yazÄ±larÄ±n nasÄ±l yazdÄ±rÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

char* p[] = {  
    "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
    "hakki", "haldun", "halime", "haluk", "handan", "hande", "handesu", "hasan", "helin", "hikmet",
    "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
    "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata", // Buradaki en son ',' token'Ä±na 'trailing comma' denmektedir.
};

int main(void)
{
    char entrt[20];
    printf("bir yazi girin: ");
    scanf("%s", entrt);

    for(size_t i = 0; i < asize(p); ++i)
        if(strpbrk(p[i], entrt)) // 'strpbrk' fonksiyonu bir yazÄ± iÃ§inde birden fazla sayÄ±daki karakterden herhangi birinin geÃ§ip geÃ§mediÄŸini sÄ±namak iÃ§in kullanÄ±lÄ±yor.
            printf("%s ", p[i]);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir karakter dizisinin elemanlarÄ±nÄ±n kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe doÄŸru "booble-sort" sÄ±ralama algotirmasÄ±yla nasÄ±l sÄ±ralandÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

const char* p[] = {  
    "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
    "hakki", "haldun", "halime", "haluk", "handan", "hande", "handesu", "hasan", "helin", "hikmet",
    "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
    "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata", // Buradaki en son ',' token'Ä±na 'trailing comma' denmektedir.
};

int main(void)
{
    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile karakter dizisinin tÃ¼m elemanlarÄ±nÄ±n ilk hali alt alta yazdÄ±rÄ±lÄ±yor.
    for (size_t i = 0; i < asize(p); ++i)
        printf("%s ", p[i]);

    // 'booble-sort' sÄ±ralama dÃ¶ngÃ¼ kodu aÅŸaÄŸÄ±dai gibidir.
    for (size_t i = 0; i < asize(p) - 1; ++i) {
        for (size_t k = 0; k < asize(p) - 1 - i; ++k) {
            if (strcmp(p[k], p[k + 1]) > 0) { // 'strcmp' fonksiyonu iki yazÄ±yÄ± kÄ±yaslar ve geriye pozitif, 0 ya da negatif deÄŸer dÃ¶ndÃ¼rÃ¼r.
                const char* ptemp = p[k];
                p[k] = p[k + 1];
                p[k + 1] = ptemp;
            }
        }
    }

    printf("\nsiralama bitti\n");
    (void)getchar();

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile karakter dizisinin tÃ¼m elemanlarÄ±nÄ±n son hali alt alta yazdÄ±rÄ±lÄ±yor.
    for (size_t i = 0; i < asize(p); ++i)
        printf("%s ", p[i]);
    }
```



ğŸŒŸ GÃ¼nÃ¼n en zor sorusu, ayrÄ±ca milakatlarda sorulan bir soru;
- Bir karakter dizisindeki elemanlarÄ±n ilk Ã¶nce yazÄ±daki karakter sayÄ±larÄ± ufak olandan bÃ¼yÃ¼k olana doÄŸru sÄ±ralanmalÄ± ve eÅŸit karakterli yazÄ±larÄ±n da kendi aralarÄ±nda alfabetik olarak kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe doÄŸru sÄ±ralanmalÄ±dÄ±r. Bu iÅŸlemi yapan sÄ±ralama programÄ±nÄ± yazabilmek iÃ§in hangi durumda elemanlarÄ±n takas edilmesi gerektiÄŸine karar verilmesi gerekiyor.
- ğŸ‘‡ AÅŸaÄŸÄ±daki programda yukarÄ±da istenen sÄ±ralamanÄ±n nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

char* p[] = {  
    "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
    "hakki", "haldun", "halime", "haluk", "handan", "hande", "handesu", "hasan", "helin", "hikmet",
    "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
    "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata", // Buradaki en son ',' token'Ä±na 'trailing comma' denmektedir.  
};

int main(void)
{
    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile karakter dizisinin tÃ¼m elemanlarÄ±nÄ±n ilk hali alt alta yazdÄ±rÄ±lÄ±yor.
    for(size_t i = 0; i < asize(p); ++i)
        printf("%s", p[i]);

    // booble-sort 
    for(size_t i = 0; i < asize(p) - 1; ++i){
        for(size_t k = 0; k < asize(p) - 1 - i; ++k){
            size_t len1 = strlen(p[k]);
            size_t len2 = strlen(p[k + 1]);

            if((len1 > len2) || (len1 == len2 && strcmp(p[k], p[k + 1]) > 0)){
                const char* ptemp = p[k];
                p[k] = p[k + 1];
                p[k + 1] = ptemp;
            }
        }   
    }

    printf("siralama bitti");
    (void)getchar();

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile karakter dizisinin tÃ¼m elemanlarÄ±nÄ±n son hali alt alta yazdÄ±rÄ±lÄ±yor.
    for(size_t i = 0; i < asize(p); ++i)
        printf("%s ", p[i]);
}
```


BazÄ± C kodlarÄ±nda pointer dizilerin son elemanlarÄ±nÄ±n Ã¶zellikle `NULL` yapÄ±ldÄ±ÄŸÄ± gÃ¶rÃ¼lecektir bunun nedeni bu diziler dolaÅŸÄ±lÄ±rken en son `NULL` dizi elemanÄ±na gelindiÄŸinde diziyi dolaÅŸma iÅŸleminin sonlandÄ±rÄ±labilmesidir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir karakter dizisinin son elemanÄ±nÄ±n `NULL` yapÄ±larak nasÄ±l kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

char* p[] = {  
    "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
    "hakki", "haldun", "halime", "haluk", "handan", "hande", "handesu", "hasan", "helin", "hikmet",
    "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
    "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata", NULL 
};

int main(void)
{
    int i = 0;
    
    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ 'p' dizisinin son elemanÄ± 'NULL pointer' olduÄŸu iÃ§in bu ÅŸekilde yazÄ±labilmiÅŸtir.
    while(p[i])
        puts(p[i++]);
}
```



ğŸ‘‡â—â—â— AÅŸaÄŸÄ±daki programda bir karakter dizisinin kÄ±rk elemanlÄ± bir pointer dizisinin aralarÄ±nda virgÃ¼l bulunmasÄ± gereken herhangi iki elemanÄ± arasÄ±nda olmasÄ± gereken virgÃ¼l unutulduÄŸunda aralarÄ±nda virgÃ¼l unutulan iki yazÄ±nÄ±n derleyici tarafÄ±ndan tek bir yazÄ± olarak yorumlanacaÄŸÄ± ve bu pointer dizisi dÃ¶ngÃ¼ ile dolaÅŸÄ±ldÄ±ÄŸÄ±nda son elemanÄ± `NULL` pointer olacaÄŸÄ± iÃ§in bu elemanÄ±n deÄŸerine eriÅŸileceÄŸi bir durumun "**ub**"ye neden olacaÄŸÄ± gÃ¶rÃ¼lmelidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

int main(void)
{
    char* p[] = {  
        "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
        "hakki", "haldun", "halime", "haluk", "handan" "hande", "handesu", "hasan", "helin", "hikmet",
        "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
        "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata", // Burada iki yazÄ± arasÄ±nda olmasÄ± gereken ',' token'Ä± unutulmuÅŸtur.
    };
    
    for(size_t i = 0; i < asize(p); ++i){
        printf("%s", p[i]); // Burada NULL pointer dereference edilirse bu durum 'ub'ye neden olacaktÄ±r.
        getchar(); // 'getchar' fonksiyonu kullanÄ±cÄ±dan bir karakter bekleyen geriye ecco vermeyen(yani standart Ã§Ä±ktÄ±ya herhengi bir ÅŸey gÃ¶ndermeyen bir fonksiyondur)
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir karakter dizisinin ilk elemanÄ±nÄ±n boÅŸ yazÄ± yapÄ±ldÄ±ÄŸÄ± durum incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutiliy.h"


int main(void)
{
    const char* pmons[] = {
        "", // Ä°lk elemanÄ±n boÅŸ yazÄ± verilmesinin nedeni, deÄŸeri indeks deÄŸeriyle yÄ±lÄ±n ayÄ±nÄ±n aynÄ± deÄŸere karÅŸÄ±lÄ±k gelmesi iÃ§indir. 
        "ocak",
        "subat",
        "mart",
        "nisan",
        "mayis",
        "haziran",
        "temmuz",
        "aguston",
        "eylul",
        "ekim",
        "kasim",
        "aralik",
    };
    
    int mon = 5;

    printf("%s", pmons[mon]);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda kullanÄ±cÄ±dan alÄ±nan sayÄ±sal bir tarih bilgisinin nasÄ±l daha detaylÄ± bir tarih olarak yazdÄ±rÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutiliy.h"

// 'Sakamuto algoritmasÄ±' girilen tarihten haftanÄ±n kaÃ§Ä±ncÄ± gÃ¼nÃ¼ olduÄŸunu tespiteder.
// Sadece 1900'den sonraki tarihler iÃ§in geÃ§erlidir.
int day_of_the_week(int d, int m, int y)  
{
    static const int t[] = { 0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4 };

    if(m < 3)
        y -= 1;
    
    return ((y + y / 4 - y / 100 + y / 400 + t[m - 1] + d) % 7);
}

void print_date(int d, int m, int y)
{
    static const char* const weekdays[] = { "pazar", "pazartesi", "sali", "carsamba", "persembe", "cuma", "cumartesi" };
    static const char* const pmons[] = {
        "",
        "ocak",
        "subat",
        "mart",
        "nisan",
        "mayis",
        "haziran",
        "temmuz",
        "aguston",
        "eylul",
        "ekim",
        "kasim",
        "aralik",
    };

    printf("%02d %s %d %s\n", d, pmons[m], y, weekdays[day_of_the_week(d, m, y)]);
}

int main(void)
{
    printf("bir tarih giriniz: ");
    int day, mon, year;
    scanf("%d%d%d", &day, &mon, &year);

    print_date(day, mon, year);
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.16-12.26 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**lookup table**" olarak kullanÄ±lacak olan bir dizinin bir kÄ±sÄ±t yoksa nasÄ±l bildirilmesi gerektiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutiliy.h"

void foo(void)
{
    // AÅŸaÄŸÄ±daki 'mdays' dizisi 'lookup table' olarak kullanÄ±lacaÄŸÄ± iÃ§in bu dizinin deÄŸiÅŸtirilmesini Ã¶nlemek iÃ§in 'const' bildiriliyor ve 'foo' fonksiyonu her Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ±nda yeniden oluÅŸturulmamasÄ± iÃ§in de 'static' Ã¶mÃ¼rlÃ¼ yapÄ±lÄ±yor
    static const int mdays[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; // YÄ±lÄ±n aylarÄ±nÄ±n kaÃ§ gÃ¼n olduÄŸunu tutan dizi.
}

int main(void)
{

}
```


â—â—â— C ve C++ dillerini kullanan programcÄ±larda en Ã§ok karÅŸÄ±laÅŸÄ±lan profil: Dili Ã¶ÄŸrenmeye Ã¶nem vermemiÅŸ sadece iÅŸini gÃ¶recek kadar dili Ã¶ÄŸrenmiÅŸ kiÅŸiler, bÃ¶yle kiÅŸilerin bu gÃ¼Ã§lÃ¼ dillerde kod yazmalarÄ± yaptÄ±klarÄ± hatalarÄ±n farkÄ±nda olmama ihtimalleri yÃ¼ksek olduÄŸu iÃ§in tehlikelidir, verin ile ilgili kafalarÄ±nda bir farkÄ±ndalÄ±k yok, "**ub**" nedir pek fikirleri yok. </br>
â—â—â— C ve C++ dillerinin Ã¶ÄŸrenilmesi kolay deÄŸildir, mesela C++ dilinde uzmanlaÅŸmak iÃ§in dolu dolu dÃ¶rt beÅŸ sene harcanmasÄ± gerekecektir, C++ dili zorluklarla beÅŸ etme konusunda sÄ±kÄ±ntÄ± yaÅŸayacak kiÅŸiler iÃ§in uygun bir dil deÄŸildir. </br>
â—â—â— C ve C++ dilleri ciddi uzmanlÄ±k gerektiren dillerdir, bu dillerde program yazabilmek iÃ§in bu diller hakkÄ±nda derin bilgiye sahip olmak gerekiyor.


## Pointer To Pointer(GÃ¶sterici GÃ¶steren GÃ¶stericiler) 

Pointer deÄŸiÅŸkenler baÅŸka pointer deÄŸiÅŸkenlerin adreslerini tutabilir, bu pointer deÄŸiÅŸkenler **Pointer To Pointer** olarak adlandÄ±rÄ±lÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bazÄ± "**pointer to pointer**" ifadelerin tÃ¼rleri incelenebilir.
```C

int main(void)
{
    int i = 20;
    int* p = &i; // 'p' deÄŸiÅŸeninin tÃ¼rÃ¼ 'int*'.

    // '&p' ifadesinin tÃ¼rÃ¼ ne diye sorulacak olursa 'int* *' olacaktÄ±r.

    int* ip = NULL;
    double* dp = NULL;
    char* cp = NULL;

    &ip; // Buradaki ifadenin tÃ¼rÃ¼ 'int* *'
    &dp; // Buradaki ifadenin tÃ¼rÃ¼ 'double* *'
    &cp; // Buradaki ifadenin tÃ¼rÃ¼ 'char* *'
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**pointer to pointer**" deÄŸiÅŸkenlerle ilgili bazÄ± temel durumlar incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 5;
    int* p = &x;
    int** ptr = &p; // Buradaki 'ptr' deÄŸiÅŸkenine 'pointer to pointer to int' denilmektedir.

    // p'nin deÄŸeri x'in adresidir.
    // p x'i gÃ¶steriyor.
    // *p --> x
    // p ifadesinin tÃ¼rÃ¼ 'int *'
    // *p ifadesinin tÃ¼rÃ¼ 'int'

    // ptr'nin deÄŸeri p'nin adresi.
    // ptr p'yi gÃ¶steriyor.
    // *ptr --> p
    // ptr ifadesinin tÃ¼rÃ¼ 'int**'
    // *ptr ifadesinin tÃ¼rÃ¼ 'int*'
    // **ptr ifadesinin tÃ¼rÃ¼ 'int'

    printf("x    = %d\n", x);
    printf("&x   = %p\n", &x);
    printf("p    = %p\n", p);
    printf("&p   = %p\n", &p);
    printf("ptr  = %p\n", ptr);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**pointer to pointer**" deÄŸiÅŸkenlerle ilgili bazÄ± temel durumlar incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 5;
    int y = 5;
    int* p1 = &x;
    int* p2 = &y;
    int** ptr = &p1;


    // ptr = &p2; // Burada tÃ¼r uyuÅŸmazlÄ±ÄŸÄ± yoktur.
    // *ptr = &y; // Burada tÃ¼r uyuÅŸmazlÄ±ÄŸÄ± yoktur.
    // **ptr = x; // Burada tÃ¼r uyuÅŸmazlÄ±ÄŸÄ± yoktur. '**ptr' ifadesi '*(*ptr)' ifadesine denktir. '**ptr' ifadesi ile '*p1' aynÄ± anlama gelmektedir.

    printf("x = %d\n", x);

    **ptr = 679;

    printf("x = %d\n", x);

    ++**ptr; // Buradaki ifade '(++(*(*ptr)))' ifadesi ile denktir.

    printf("x = %d\n", x);
}
```



ğŸ˜± MÃ¼lakatlarda Ã§ok sÄ±k kullanÄ±lan standart olmayan ve kullanÄ±mÄ± hoÅŸ olmayan bir tanÄ±mlama "**double pointer**" terimidir, bu terim standarda uygun bir terim deÄŸildir.


>â”
> 
> Sorulan soru; 
> 
> Bir de bu isin double ile alakasi yok. bu zinciri sonsuza kadar gÃ¶tÃ¼remez miyim?
> int***** seklinde
> 
> Cevap;
> 
> - `int*` gibi bir tÃ¼r her C programÄ±nda gÃ¶rÃ¼lecektir.
> - `int**` gibi bir tÃ¼r C programlarÄ±nÄ±n %80 ya da %90 oranÄ±nda kullanÄ±lÄ±r.
> - `int***` gibi bir tÃ¼r C programlarÄ±nÄ±n %5 ya da %10 oranÄ±nda kullanÄ±lÄ±r.
> - `int****` gibi bir tÃ¼r C programlarÄ±nÄ±n %1 ya da %0.5 oranÄ±nda kullanÄ±lÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki program Ã§oklu `*` operatÃ¶rÃ¼nÃ¼n kullanÄ±mÄ± iÃ§in gerekli kodun dÃ¶ngÃ¼ ile yazdÄ±rÄ±lmasÄ±nÄ± saÄŸlamaktadÄ±r.
```C
#include  <stdio.h>

int main(void)
{
    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile Ã§oklu '*' operatÃ¶rÃ¼ kullanÄ±mÄ± ÅŸeklinde tÃ¼rler elde edilebilir.
    for(int i = 1; i <= 30; ++i){
        printf("int");
        int n = i;
        while(n--)
            putchar('*');
        printf(" p%d = &p%d;\n", i, i - 1);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã§oklu `*` operatÃ¶rÃ¼nÃ¼n Ã§oklu ve apsÃ¼rt kullanÄ±mÄ± incelenebilir.
```C
#include  <stdio.h>

int main(void)
{
    int x = 99;

    int* p1 = &x;
    int** p2 = &p1;
    int*** p3 = &p2;
    int**** p4 = &p3;
    int***** p5 = &p4;
    int****** p6 = &p5;
    int******* p7 = &p6;
    int******** p8 = &p7;
    int********* p9 = &p8;
    int********** p10 = &p9;
    int*********** p11 = &p10;
    int************ p12 = &p11;
    int************* p13 = &p12;
    int************** p14 = &p13;
    int*************** p15 = &p14;
    int**************** p16 = &p15;
    int***************** p17 = &p16;
    int****************** p18 = &p17;
    int******************* p19 = &p18;
    int******************** p20 = &p19;
    int********************* p21 = &p20;
    int********************** p22 = &p21;
    int*********************** p23 = &p22;
    int************************ p24 = &p23;
    int************************* p25 = &p24;
    int************************** p26 = &p25;
    int*************************** p27 = &p26;
    int**************************** p28 = &p27;
    int***************************** p29 = &p28;
    int****************************** p30 = &p29;

    printf("x = %d\n", x);

    ++******************************p30;

    printf("x = %d\n", x);
}
```


Ders sonu ...
