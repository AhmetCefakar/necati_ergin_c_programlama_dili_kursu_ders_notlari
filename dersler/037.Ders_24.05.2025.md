# 37.Ders 24.05.2025 ğŸ•˜

Derse 12(09:01)-13(09:04)-14(09:08)-15(09:16)-16(09:20)-14(09:38)-15(09:47)-16(10:08)-17(10:52)-17(11:39)-18(11:48)-18(12:00)-17(12:30) kiÅŸi katÄ±ldÄ±.
---


## Function Pointers

C ve C++ gibi programlama dillerinin en gÃ¼Ã§lÃ¼ araÃ§larÄ±ndan biri bir fonksiyona bir fonksiyonun gÃ¶nderilebiliyor olmasÄ±dÄ±r. </br>
Bu mekanizmaya "**Callback**" deniyor ve bir fonksiyonun baÅŸka bir fonksiyona gÃ¶nderdiÄŸi fonksiyonlara "**Callback Function**" deniliyor. </br>
Pointer'lar **object pointers** ve **function pointers** olarak ikiye ayrÄ±lÄ±yor.

C dilinin en Ã¶nemli araÃ§larÄ±ndan biri fonksiyonlarÄ±n adresleri ile yapÄ±labilen iÅŸlemlerdir, fonksiyonlarÄ±n adresleri **function pointer** tÃ¼rÃ¼nden deÄŸiÅŸkenlerde tutulabiliyor.

Fonksiyon adresleri nasÄ±l bir ifade, farklÄ± parametrik yapÄ±daki fonksiyonlarÄ±n adresleri farklÄ± tÃ¼rdendir.
- `int foo(int, int);` fonksiyonunun tÃ¼rÃ¼ `int (int, int)` ve adresinin tÃ¼rÃ¼ `int (*)(int, int)`.
- `int bar(double, int, long);` fonksiyonunun tÃ¼rÃ¼ `int (double, int, long)` ve adresinin tÃ¼rÃ¼ `int (*)(double, int, long)`.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir **function pointer** tÃ¼rÃ¼nden deÄŸiÅŸken nasÄ±l bildirilir ve kullanÄ±lÄ±r incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

int foo(int, int);
int bar(int, int);
int baz(int, int);

int main(void)
{
    int (*fp)(int, int) = &foo; // 'fp' adÄ±ndaki 'int (*)(int, int)' tÃ¼rÃ¼ndeki bir 'function pointer' deÄŸiÅŸkene 'foo' fonksiyonunun adresiyle ilk deÄŸer veriliyor.

    fp = &bar;

    fp = &baz;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **array to pointer conversion** iÅŸleminin nasÄ±l olduÄŸu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

int foo(int, int);
int bar(int, int);
int baz(int, int);

int main(void)
{
    int ar[10] = { 0 };

    int* ptr = ar; // Burada 'ar' dizisi 'array to pointer conversion' ile dizinin ilk elemanÄ±nÄ±n adresine dÃ¶nÃ¼ÅŸÃ¼m yapÄ±lÄ±r(yani derleyici 'ar' ifadesini '&ar[0]' ifadesine Ã§eviriyor).
    // int* ptr = &ar[0]; // Buradaki statement ile yukarÄ±daki statement denktir.
}
```



**Function to Pointer Conversion(Fonksiyondan Fonksiyon Adresine DÃ¶nÃ¼ÅŸÃ¼m)**:  Bir ifade iÃ§inde fonksiyon adÄ± kullanÄ±lÄ±rsa fonksiyon adÄ± Ã¶rtÃ¼lÃ¼ olarak fonksiyonun adresi tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **function to pointer conversion** iÅŸleminin nasÄ±l olduÄŸu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

int foo(int, int);
int bar(int, int);
int baz(int, int);

int main(void)
{
    // AÅŸaÄŸÄ±daki iki fonksiyon gÃ¶stericisi deÄŸiÅŸkenin ilk deÄŸer verme sÃ¶zdizimi(syntax) birbirine denktir.
    int (*fp)(int) = &foo;
    //int (*fp)(int) = foo;

    // AÅŸaÄŸÄ±daki iki atama iÅŸlemi de birbirine denktir.
    fp = &bar;
    fp = bar;

    // AÅŸaÄŸÄ±daki iki atama iÅŸlemi de birbirine denktir
    fp = &baz;
    fp = baz;
}
```


>â”
> 
> Sorulan soru; 
> 
> Bir degiskenin adresinde degisken tipine gore 1 byte, 4 byte, 8 byte degeri bulunuyordu. Bir fonk. adresinde ne boyutta ne tutuluyor?
> 
> Cevap;
> 
> **Object pointers** deÄŸiÅŸkenler Ã§alÄ±ÅŸacaklarÄ± donanÄ±m mimarisine gÃ¶re hangi tÃ¼rden deÄŸiÅŸkenin ares deÄŸerini tutuyor olursa olsun hep aynÄ± byte deÄŸerine sahiptir, 32 bit'lik donanÄ±mlarda 4-byte ve 64 bit'lik donanÄ±mlarda 8-byte.
>
> Fakat **funciton pointers** deÄŸiÅŸkenler ile **object pointers** deÄŸiÅŸkenler aynÄ± byte'lÄ±k alan kaplamak zorunda deÄŸildir. **Object pointers** deÄŸiÅŸkenler 4-byte iken **funciton pointers** deÄŸiÅŸkenler 8-byte yer kaplayabilir. 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir **funciton pointers** deÄŸiÅŸkenin bellekte kapladÄ±ÄŸÄ± alanÄ±n nasÄ±l Ã¶ÄŸrenildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

int foo(int, int);
int bar(int, int);
int baz(int, int);

int main(void)
{
    printf("sizeof(&foo) = %zu\n", sizeof(&foo));
}
```


>â”
> 
> Sorulan soru; 
> 
> Fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸeri ya da parametre deÄŸiÅŸkenleri deÄŸiÅŸtirildiÄŸinde de yine **funciton pointer** boyutu aynÄ± kalÄ±r mÄ±?
> 
> Cevap;
> 
> Evet ayÄ±nÄ± kalÄ±r, **funciton pointer** deÄŸiÅŸkenlerin kapladÄ±ÄŸÄ± byte alanÄ±, fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸeri ya da kaÃ§ tane parametresinin olduÄŸuyla ilgili deÄŸildir. Yani hangi fonksiyon olursa olsun o fonksiyonun adresi aynÄ± bÃ¼yÃ¼klÃ¼kte byte alanÄ±nda tutulacaktÄ±r.



â—â—â— Bir dil ne kadar dÃ¼ÅŸÃ¼k seviyeli olursa olsun en nihayetinde bir soyutlamadÄ±r ve o programlama dilini kullanan programcÄ±yÄ± belirli seviyelerde donanÄ±mdan soyutlar. 
- **Function pointer** deÄŸiÅŸkenleri ya da **fonksiyon adresleri** ÅŸÃ¶yle dÃ¼ÅŸÃ¼nÃ¼lmelidir: FonksiyonlarÄ±n derlenmiÅŸ kodu Ã§alÄ±ÅŸma zamanÄ±nda bir yer kaplamaktadÄ±r yani bir fonksiyonun derlenmiÅŸ kodu demek o fonksiyon Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ±nda yÃ¼rÃ¼tÃ¼lecek makine komutlarÄ± demektir. 
- Bir fonksiyonun programÄ±n Ã§alÄ±ÅŸma zamanÄ±nda Ã§aÄŸÄ±rÄ±lmasÄ± iÃ§in fonksiyonun makine komutlarÄ±nÄ±n bellekte bir yere yÃ¼klenmesi gerekiyor, iÅŸte fonksiyonun adresi o fonksiyon Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ±nda Ã§alÄ±ÅŸtÄ±rÄ±lacak olan makine komutlarÄ±nÄ± iÃ§eren bellek adresidir.


### Fonksiyon Ã‡aÄŸrÄ± OperatÃ¶rÃ¼(Function Call Operator) 

Fonksiyon Ã‡aÄŸrÄ± OperatÃ¶rÃ¼nÃ¼n operandÄ± bir fonksiyonun fonksiyon adresidir. </br>
Fonksiyon Ã‡aÄŸrÄ± OperatÃ¶rÃ¼nÃ¼n operandÄ± bir fonksiyon adÄ± olmak zorunda deÄŸildir.

â— Fonksiyon Ã‡aÄŸrÄ±sÄ± bir operatÃ¶r marifetiyle yapÄ±lÄ±yor, bir fonksiyon adÄ± fonksiyon Ã§aÄŸrÄ± operatÃ¶rÃ¼nÃ¼n(`()` operatÃ¶rÃ¼) operandÄ± yapÄ±ldÄ±ÄŸÄ±nda derleyici programÄ±n akÄ±ÅŸÄ±nÄ± o fonksiyonun kodunun Ã§alÄ±ÅŸtÄ±rmasÄ±na yÃ¶nlendiren bir kod oluÅŸturuyor, fonksiyon Ã§aÄŸrÄ±larÄ± bu ÅŸekilde yapÄ±lÄ±yor. GerÃ§ekte fonksiyon Ã§aÄŸrÄ± operatÃ¶rÃ¼nÃ¼n operandÄ± bir fonksiyon adresidir, `FONKSÄ°YON_ADI()` ya da `FONKSÄ°YON_ADRESÄ°()` ÅŸeklinde yapÄ±lan bir fonksiyon Ã§aÄŸrÄ±larÄ± aynÄ± anlama geliyor. Fonksiyon Ã§aÄŸrÄ± operatÃ¶rÃ¼nÃ¼n operandÄ±nÄ±n bir fonksiyon adÄ± olmasÄ± gerekmiyor, fonksiyon adresi olan herhengi bir ifade olabilir. O zaman bir **function pointer** deÄŸiÅŸkenin deÄŸeri bir fonksiyon adresi olduÄŸuna gÃ¶re fonksiyon Ã§aÄŸrÄ± operatÃ¶rÃ¼nÃ¼n operandÄ± bir **function pointer variable** da olabilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda kursun baÅŸÄ±ndan beri kullanÄ±lan fonksiyon Ã§aÄŸÄ±rma sÃ¶zdizimi(syntax) incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int foo(int x)
{
    printf("foo(int x) called x = %d\n", x);

    return x * x;
}

int main(void)
{
    int i = foo(3); // Kursun baÅŸÄ±ndan beri bir fonksiyonu Ã§aÄŸÄ±rmak iÃ§in kullanÄ±lan yÃ¶ntem bu ÅŸekildeydi.

    printf("i = %d\n", x);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir **function pointer** Ã¼zerinden nasÄ±l fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±ldÄ±ÄŸÄ± gÃ¶rÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int foo(int x)
{
    printf("foo(int x) called x = %d\n", x);

    return x * x;
}

int main(void)
{
    int (*fp)(int) = &foo;

    int x = fp(5); // Burada 'fp' adÄ±ndaki 'function pointer' Ã¼zerinden nasÄ±l fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±lacaÄŸÄ± gÃ¶rÃ¼lebilir.

    printf("x = %d\n", x);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda fonksiyon adreslerinin tÃ¼rÃ¼ aynÄ± olan(bu programda adres tÃ¼rleri `void (*)(void)` olan fonksiyonlar) fonksiyonlarÄ±n tek bir **function pointer** deÄŸiÅŸken Ã¼zerinden nasÄ±l Ã§aÄŸÄ±rÄ±labildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

void foo1(void)
{
    printf("foo1 called!\n");
}

void foo2(void)
{
    printf("foo2 called!\n");
}

void foo3(void)
{
    printf("foo3 called!\n");
}

void foo4(void)
{
    printf("foo4 called!\n");
}


int main(void)
{
    void (*fp)(void) = &foo1;

    fp(); // Burada 'foo1' fonksiyonu Ã§aÄŸÄ±rÄ±lacaktÄ±r.

    fp = &foo2;
    fp(); // Burada 'foo2' fonksiyonu Ã§aÄŸÄ±rÄ±lacaktÄ±r.


    fp = &foo3;
    fp(); // Burada 'foo3' fonksiyonu Ã§aÄŸÄ±rÄ±lacaktÄ±r.


    fp = &foo4;
    fp(); // Burada 'foo4' fonksiyonu Ã§aÄŸÄ±rÄ±lacaktÄ±r.
}
```

>â”
> 
> Sorulan soru; 
> 
> fp' yi tanimlarken void (*fp) pointer kullanmaniz bu fonksiyonlarin geri donus degerlerinin void olmasindan dolayi mi, yoksa bu bir generic void* pointer mi?
> 
> 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir fonksiyonun davranÄ±ÅŸÄ±nÄ±n o fonksiyona Ã§aÄŸrÄ± yapan kodun nasÄ±l belirleyebileceÄŸi incelenebilir. `foo` fonksiyonu dÄ±ÅŸarÄ±dan fonksiyon adresi alÄ±yor ve bu da `foo` fonksiyonuna Ã§aÄŸrÄ± yapan kodun gÃ¶nderdiÄŸi fonksiyon adresine gÃ¶re `foo` fonksiyonuna farklÄ± iÅŸlemler yaptÄ±rabileceÄŸi anlamÄ±na geliyor.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

void foo1(void)
{
    printf("foo1 called!\n");
}

void foo2(void)
{
    printf("foo2 called!\n");
}

void foo3(void)
{
    printf("foo3 called!\n");
}

void foo4(void)
{
    printf("foo4 called!\n");
}

// AÅŸaÄŸÄ±daki 'foo' adlÄ± fonksiyon parametre olarak bir fonksiyonun adresi alÄ±yor.
void foo(void (*fp)(void))
{
    printf("foo called!\n");
    printf("foo is calling a function that is sent\n");
    fp(); // 'fp' fonksiyon adresi deÄŸeri Ã¼zerinden fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±lÄ±yor.
    // some code here...
}

int main(void)
{
    foo(&foo1);
    printf("\n");

    foo(&foo2);
    printf("\n");

    foo(&foo3);
    printf("\n");

    foo(&foo4);
    printf("\n");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **function pointer** deÄŸiÅŸkenlerin en temel olarak kullanÄ±ldÄ±ÄŸÄ± yÃ¶ntem incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>

int func(int c)
{
    for(int i = 0; i < 128; ++i){
        if(isupper(i)){
            printf("%c", i);
        }
    }
    primtf("\n");

    for(int i = 0; i < 128; ++i){
        if(islower(i)){
            printf("%c", i);
        }
    }
    primtf("\n");

    for(int i = 0; i < 128; ++i){
        if(isdigit(i)){
            printf("%c", i);
        }
    }
    primtf("\n");

    printf("~~~~~~~~~~~~~~~~~\n");
}

// AÅŸaÄŸÄ±daki 'print_chars' fonksiyonu dÄ±ÅŸarÄ±dan 'int (*)(int)' tÃ¼rÃ¼nden fonksiyon adresi almaktadÄ±r ve ardÄ±ndan ASCII karakterlerinden gÃ¶nderilen adresteki test fonksiyonuna gÃ¶re mantÄ±ksal true deÄŸer dÃ¶nen karakterleri standar Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶ndermektedir.
void print_chars(int (*fp)(int)){
    for(int i = 0; i < 128; ++i){
        if(fp(i)){
            printf("%c", i);
        }
    }
    primtf("\n");
}

int main(void)
{
    print_chars(&isupper);
    print_chars(&islower);
    print_chars(&isdigit);
    print_chars(&isalnum);
    print_chars(&ispunct);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda fonksiyon adresi alan bir fonksiyonun en sÄ±k kullanÄ±ldÄ±ÄŸÄ± senaryo incelenebilir, bu kullanÄ±m gerek gÃ¶mÃ¼lÃ¼ sistem programlama alanÄ±nda gerek sistem programlama alanÄ±nda gerekse de uygulama programlarÄ± geliÅŸtirmede sÄ±kÃ§a kullanÄ±lmaktadÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>

void print_chars(const char* p, int (*fp)(int)){

    printf("%s\n", p);
    for(int i = 0; i < 128 ; ++i){
        if(fp(i)){
            printf("%c", i);
        }
    }
    primtf("\n");
}

int main(void)
{
    print_chars("isupper ", &isupper);
    print_chars("islower ", &islower);
    print_chars("isdigit ", &isdigit);
    print_chars("isalnum ", &isalnum);
    print_chars("ispunct ", &ispunct);
}
```

Generik programlama yaparken en sÄ±k kullanÄ±lan yÃ¶ntemlerde biri **function pointer** kullanÄ±lmasÄ±dÄ±r, **function pointer** kullanÄ±mÄ± ile bir fonksiyonun Ã§aÄŸÄ±rdÄ±ÄŸÄ± fonksiyon(lar) aynÄ± fonksiyonun Ã§aÄŸrÄ±larÄ±nda farklÄ± yapÄ±labilir.


>â”
> 
> Sorulan soru; 
> 
> switch statement int param aliyordu fonk adresi de alabiliyor mu hocam?
> 
> Cevap;
> 
> Soru yanluÅŸ sorulmuÅŸ, switch statement **parameter** almaz bir fonksiyon **parameter** alÄ±r, switch statement **expression(ifade)** alÄ±r, bir switch statement'Ä±n alacaÄŸÄ± ifade **function pointer** olamaz.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir fonksiyonun hangi bicimlerde Ã§aÄŸrÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>

void foo(void)
{
    printf("foo() function called!\n");
}

int main(void)
{
    // Bir fonksiyon aÅŸaÄŸÄ±daki gibi farklÄ± ÅŸekillerde Ã§aÄŸrÄ±labilir;
    foo(); // 'foo' fonksiyonuna Ã§aÄŸrÄ± yapÄ±lÄ±yor.
    (&foo)(); // 'foo' fonksiyonuna Ã§aÄŸrÄ± yapÄ±lÄ±yor. Burada '&foo' ifadesinin Ã¶ncelik parantezine alÄ±nmasÄ±nÄ±n nedeni fonksiyon Ã§aÄŸrÄ± operatÃ¶rÃ¼nÃ¼n Ã¶nceliÄŸinin adres operatÃ¶rÃ¼nden('&' operatÃ¶rÃ¼) yÃ¼ksek olmasÄ±dÄ±r.
    (*foo)(); // 

    void(*fptr)(void) = &foo;
    fptr(); // 'foo' fonksiyonuna Ã§aÄŸrÄ± yapÄ±lÄ±yor.
    (*fptr)(); // 'foo' fonksiyonuna Ã§aÄŸrÄ± yapÄ±lÄ±yor. Burada '*fptr' ifadesinin Ã¶ncelik parantezine alÄ±nmasÄ±nÄ±n nedeni fonksiyon Ã§aÄŸrÄ± operatÃ¶rÃ¼nÃ¼n Ã¶nceliÄŸinin dereferencing operatÃ¶rÃ¼nden('*' operatÃ¶rÃ¼) yÃ¼ksek olmasÄ±dÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir fonksiyonun adresi(yani **function pointer**) 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>

void foo(void)
{
    printf("foo() function called!\n");
}

int main(void)
{
    void(*fptr)(void) = &foo;
    fptr();
    (*foo)(); // Bu ÅŸekilde fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±lÄ±yorsa programcÄ±nÄ±n doÄŸrudan fonkisyon adÄ± Ã¼zerinden deÄŸil de bir fonksiyonun pointer'Ä± Ã¼zerinden fonksiyon Ã§aÄŸrÄ±sÄ±nÄ±n yapÄ±ldÄŸÄ± vurgulanmÄ±ÅŸ olur.
    (&foo)();
}
```


"(*foo)();" ve "(&foo)();" 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir fonkisyonun Ã§aÄŸrÄ±sÄ±nÄ±n **function pointer** Ã¼zerinden yapÄ±ldÄ±ÄŸÄ±nÄ± vurgulamak iÃ§in nasÄ±l fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>

void foo(int (*fp)(int))
{
    int x = fp(4); // 'Function pointer' adÄ± Ã¼zerinden fonksiyon Ã§aÄŸrÄ±sÄ±nÄ±n nasÄ±l yapÄ±labileceÄŸi incelenebilir.
    int y = (*fp)(4); // Burada fonksiyon gÃ¶stericisi Ã¼zerinden fonksiyon Ã§aÄŸrÄ±sÄ±nÄ±n yapÄ±ldÄ±ÄŸÄ± vurgulanmaktadÄ±r.
}

int main(void)
{

}
```


>â”
> 
> Sorulan soru; 
> 
> Degiskenlerin adreslerini fonksiyonlara gonderdigimizde degerlerine erisip degistirebiliyorduk. fonk. pointer gonderdigimizde de fonk.un kullandigi degerlere ulasip degerlerini degistirebiliyor muyuz? 
> Bunun argumanlarina ulasabilir miyiz?
> 
> Cevap;
> 
> Bir **function pointer** nesne Ã¼zerinden ne o gÃ¶stericide tutulan fonksiyonun deÄŸerlerine eriÅŸilebilir iÅŸlem yapÄ±labilir ne de gÃ¶sterilen fonksiyonun argÃ¼manlarÄ±na eriÅŸilip bir deÄŸiÅŸiklik yapÄ±labilir. Sadece adresi bilinen bir fonksiyona Ã§aÄŸrÄ± yapÄ±labilir.
>
> ğŸ‘‡ AÅŸaÄŸÄ±daki programda `foo` fonksiyonu dÄ±ÅŸarÄ±dan alacaÄŸÄ± `fp` parametresini sadece adresi gÃ¶nderilen fonksiyona Ã§aÄŸrÄ± yapmak iÃ§in kullanabilir, bu anlaÅŸÄ±lmalÄ±dÄ±r.
> ```C
> #define _CRT_SECURE_NO_WARNINGS
> 
> #include <stdio.h>
> #include <ctype.h>
> 
> void foo(int (*fp)(int))
> {
>     int x = fp(4);
>     int y = (*fp)(4);
> }
> 
> int main(void)
> {
>     int x = 19;
>     int* ptr = &x;
> 
>     *ptr = 2343423; // 'object pointer' deÄŸiÅŸkenlerin adresleri Ã¼zerinden o adresteki nesnelerin deÄŸerleri deÄŸiÅŸtirilebilir.
> }
> ```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **function pointer**'larla ilgili karmaÅŸÄ±k kullanÄ±mlar incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>
#include <stirng.h>

void foo(const char*, const char*);
void bar(const char*, const char*);
void baz(const char*, const char*);

void f1(int (*p1)(const char*, const char*)); // 'f1' fonksiyonu dÄ±ÅŸarÄ±dan 'int (*)(const char*, const char*)' tÃ¼rÃ¼nde tek bir parametre almaktadÄ±r.
void f2(int (*p1)(const char*, const char*), int (*p2)(const char*, const char*)); // 'f2' fonksiyonu dÄ±ÅŸarÄ±dan 'int (*)(const char*, const char*)' tÃ¼rÃ¼nde iki adet parametre almaktadÄ±r.

// C dilinin sÃ¶zdiziminde(syntax) geriye 'int (*)(const char*, const char*)' tÃ¼rÃ¼nden fonksiyon adresi dÃ¶ndÃ¼ren 'f3' adÄ±nda bir fonksiyon aÅŸaÄŸÄ±daki gibi tanÄ±mlanmaktadÄ±r.
int (*f3(void)) (const char*, const char*)
{
    return &foo;
}

// C dilinin sÃ¶zdiziminde(syntax) geriye 'int (*)(const char*, const char*)' tÃ¼rÃ¼nden fonksiyon adresi dÃ¶ndÃ¼ren ve 'int (*)(const char*, const char*)' bir parametre alan bir fonksiyon aÅŸaÄŸÄ±daki gibi tanÄ±mlanmaktadÄ±r.
int (*f4(int (*fp)(const char*, const char*)))(const char*, const char*)
{
    return &fp;
}

int main(void)
{
    int (*fp)(const char*, const char*) = &strcmp; // Burada bildirilen ve ilk deÄŸer atanan 'fp' adlÄ± fonksiyon pointer deÄŸiÅŸkeni 'int (*)(const char*, const char*)' tÃ¼rÃ¼nden fonksiyonlarÄ±n adreslerini alabilir.
    int (**fptr)(const char*, const char*) = &fp; // Burada bildirilen ve ilk deÄŸer atanan 'fptr' adlÄ± deÄŸiÅŸken bir 'object pointer'dÄ±r. 'fptr' gÃ¶stericisi 'int (*)(const char*, const char*)' tÃ¼rÃ¼nden bir fonksiyonun adresini tutmaktadÄ±r.

    // '*fptr' demek 'fp' demektir! 

    int (*ar[4])(const char*, const char*) = { &foo, &bar, &baz, &strcmp }; // Funciton pointer deÄŸerler tutan 'ar' adÄ±ndaki 4 elemanlÄ± dizi deÄŸiÅŸkeninin bildirilip ilk deÄŸer verilmesi iÅŸlemi.s
    //int (*ar[])(const char*, const char*) = { &foo, &bar, &baz, &strcmp }; // Funciton pointer tutan 'ar' adÄ±ndaki 4 elemanlÄ± dizi deÄŸiÅŸkeninin bildirilip ilk deÄŸer verilmesi iÅŸlemi.s
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `typedef` bildirimi ile karmaÅŸÄ±k fonksiyon gÃ¶stericisi deÄŸiÅŸkenlerin nasÄ±l sade olarak yazÄ±labildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>
#include <stirng.h>

typedef int(*Fcmp)(const char*, const char*); // Burada 'Fcmp' adÄ±nda 'int (*)(const char*, const char*)' tÃ¼rÃ¼nÃ¼ temsil edecek bir 'tÃ¼r eÅŸ ad' bildirimi yapÄ±lmÄ±ÅŸtÄ±r.

void foo(const char*, const char*);
void bar(const char*, const char*);
void baz(const char*, const char*);

//void f1(int (*p1)(const char*, const char*));
void f1(Fcmp p1);

//void f2(int (*p1)(const char*, const char*), int (*p2)(const char*, const char*));
void f2(Fcmp p1, Fcmp p2);

// int (*f3(void)) (const char*, const char*)
Fcmp f3()
{
    return &foo;
}

// int (*f4(int (*fp)(const char*, const char*)))(const char*, const char*)
Fcmp f4(Fcmp f)
{
    return &f;
}

int main(void)
{
    //int (*fp)(const char*, const char*) = &strcmp;
    Fcmp fp = &strcmp;
    
    //int (**fptr)(const char*, const char*) = &fp;
    Fcmp* fptr = &fp;

    //int (*ar[4])(const char*, const char*) = { &foo, &bar, &baz, &strcmp }; // Funciton pointer tutan 'ar' adÄ±ndaki 4 elemanlÄ± dizi.
    //int (*ar[])(const char*, const char*) = { &foo, &bar, &baz, &strcmp }; // Funciton pointer tutan 'ar' adÄ±ndaki 4 elemanlÄ± dizi.
    Fcmp 
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **booble sort** algoritmasÄ±yla sÄ±ralama iÅŸlemi yapan `sort` adÄ±nda bir fonksiyonun **gerÃ§ekleÅŸtiriminin(implementation)** nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>
#include "nutility.h"

// AÅŸaÄŸÄ±daki 'booble sort' algoritmasÄ±yla sÄ±ralama iÅŸlemi yapan fonksiyonda sÄ±ralama kriteri sabittir. Kriteri dÄ±ÅŸarÄ±dan fonksiyon olarak alan C dilinin standardÄ±nda olan 'qsort' fonksiyonu vardÄ±r, biz de 'qsort' fonksiyonu gibi sÄ±ralama yÃ¶ntemini dÄ±ÅŸarÄ±dan alan sÄ±ralama fonksiyonu yazabiliriz.
void sort(int* p, int size)
{
    for(int i = 0; i < size - 1; ++i){
        for(int k = 0; k < size - 1 - i; ++k){
            if(p[k] > p[k + 1]){
                swap(p + k, p + k + 1);
            }
        }
    }
}

int main(void)
{
    
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda C dilinin standardÄ±nda olan $O(n) lon(n)$ algoritma karmaÅŸÄ±klÄ±ÄŸÄ±ndaki generic `qsort` fonksiyonunun bir benzeri oaln $O(n^2)$ algoritma karmaÅŸÄ±klÄ±ÄŸÄ±ndaki generic `gbsort` fonksiyonu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>
#include "nutility.h"

#define SIZE 100

// "Generic Booble Sort" fonksiyonu aÅŸaÄŸÄ±daki gibidir.
// vpa      : SÄ±ralama yapÄ±lacak dizinin adresi.
// size     : Dizinin eleman sayÄ±sÄ± deÄŸeri.
// sz       : Dizinin tek bir elemanÄ±nÄ±n kaÃ§ byte yer kapladÄ±ÄŸÄ± bilgisi.
// fpcomp   : SÄ±ralama kriteri iÅŸleminde Ã§aÄŸrÄ±lacak fonksiyon pointer tÃ¼rÃ¼nden deÄŸiÅŸken.
void gbsort(void* vpa, size_t size, size_t sz, int (*fpcomp)(const void *, const void *))
{
    char* pa = (char*)vpa;

    for(size_t i = 0; i < size - 1; ++i){
        for(size_t k = 0; k < size - 1 - i; ++k){
            if(fpcomp(pa + k * sz, pa + (k + 1) * sz) > 0){
                gswap(pa + k * sz, pa + (k + 1) * sz, sz);
            }
        }
    }
}

// "int compara" fonksiyonu aÅŸaÄŸÄ±daki gibidir.
int icmp(const void* vp1, const void* vp2)
{
    if(*(const int*)vp1 > *(const int*)vp2){
        return 1;
    }
    else if(*(const int*)vp1 < *(const int*)vp2){
        return -1;
    }

    return 0;
}

// "double compara" fonksiyonu aÅŸaÄŸÄ±daki gibidir.
int dcmp(const void* vp1, const void* vp2)
{
    if(*(const double*)vp1 > *(const double*)vp2){
        return 1;
    }
    else if(*(const double*)vp1 < *(const double*)vp2){
        return -1;
    }

    return 0;
}

int main(void)
{
    int a[SIZE];
    
    randomize();
    set_array_random(a, SIZE);
    print_array(a, SIZE);

    // AÅŸaÄŸÄ±daki Ã¼Ã§ 'gbsort' fonksiyon Ã§aÄŸrÄ±sÄ± aynÄ± anlama gelmektedir.
    gbsort(a, SIZE, sizeof(int), &icmp);
    //gbsort(a, SIZE, sizeof(*a), &icmp);
    //gbsort(a, SIZE, sizeof(a[0]), &icmp);

    print_array(a, SIZE);

    double ar[] = { 1.1, 34.5, 2.4, 5.4, 31.6, 7.9, 9.1 };
    gbsort(ar, asize(ar), sizeof(*ar), &dcmp);
    
    for(size_t i = 0; i < sizeof(ar); ++i){
        printf("%f", ar[i]);
    }
}
```


### `qsort` Fonksiyonu 

Bu fonksiyon `stdlib.h` baÅŸlÄ±k dosyasÄ±nda bulunuyor, bu kÃ¼tÃ¼phene biraz garip, bir Ã§ok deÄŸiÅŸik alanda hizmet veren fonksiyonlar bu baÅŸlÄ±k dosyasÄ±nda bulunuyor. </br>
`stdlib.h` baÅŸlÄ±k dosyasÄ±nda birden fazla farklÄ± alanla ilgili fonksiyonlar bulunuyor ve genel bir destek kÃ¼tÃ¼phanesi olarak kullanÄ±lÄ±yor.


ğŸ§­ `stdlib.h` baÅŸlÄ±k dosyasÄ±nda bulunan bazÄ± fonksiyonlar aÅŸaÄŸÄ±daki gibidir;
- `exit` fonksiyonu programÄ± sonlandÄ±rmaktadÄ±r.
- `abort` fonksiyonu programÄ± sonlandÄ±rmaktadÄ±r.
- `rand` fonksiyonu rastgele sayÄ± Ã¼retimiyle ilgili olarak kullanÄ±lmaktadÄ±r.
- `srand` fonksiyonu rastgele sayÄ± Ã¼retimiyle ilgili olarak kullanÄ±lmaktadÄ±r. 
- `atoi` fonksiyonu sayÄ±lar ve yazÄ±lar arasÄ±nda dÃ¶nÃ¼ÅŸÃ¼m yapmak iÃ§in kullanÄ±lÄ±r.
- `atof` fonksiyonu sayÄ±lar ve yazÄ±lar arasÄ±nda dÃ¶nÃ¼ÅŸÃ¼m yapmak iÃ§in kullanÄ±lÄ±r.
- `malloc` fonksiyonu dinamik bellek yÃ¶netiminde kullanÄ±lÄ±yor.
- `calloc` fonksiyonu dinamik bellek yÃ¶netiminde kullanÄ±lÄ±yor.
- `realloc` fonksiyonu dinamik bellek yÃ¶netiminde kullanÄ±lÄ±yor.
- `free` fonksiyonu dinamik bellek yÃ¶netiminde kullanÄ±lÄ±yor.   
- `qsort` fonksiyonu genel olarak sÄ±ralama yapmak iÃ§in kullanÄ±lmaktadÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `qsort` fonksiyonunun bildirimi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>

void qsort(void* vpa, size_t size, size_t sz, int (*fp)(const void *, const void *));

int main(void)
{

}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `qsort` fonksiyonuna Ã§aÄŸrÄ± yapÄ±larak `int` tÃ¼rÃ¼nden elemanlarÄ± olan bir dizinin nasÄ±l kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe doÄŸru sÄ±ralanabileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include "nutility.h"

#define SIZE 100

// KÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe doÄŸru sÄ±ralama yapmak iÃ§in kullanÄ±lan fonksiyon
int icmp(const void* vp1, const void* vp2)
{
    if(*(const int*)vp1 > *(const int*)vp2){
        return 1;
    }
    else if(*(const int*)vp1 < *(const int*)vp2){
        return -1;
    }

    return 0;
}

int main(void)
{
    int a[SIZE];
    
    randomize();
    set_array_random(a, SIZE);
    print_array(a, SIZE);

    qsort(a, SIZE, sizeof(int), &icmp);
    print_array(a, SIZE);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `qsort` fonksiyonuna Ã§aÄŸrÄ± yapÄ±larak `int` tÃ¼rÃ¼nden elemanlarÄ± olan bir dizinin nasÄ±l bÃ¼yÃ¼kten kÃ¼Ã§Ã¼ÄŸe doÄŸru sÄ±ralanabileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

#define SIZE 100

// BÃ¼yÃ¼kten kÃ¼Ã§Ã¼ÄŸe doÄŸru sÄ±ralama yapÄ±lmasÄ± iÃ§in kullanÄ±lan fonksiyon
int icmp(const void* vp1, const void* vp2)
{
    if(*(const int*)vp1 < *(const int*)vp2){
        return 1;
    }
    else if(*(const int*)vp1 > *(const int*)vp2){
        return -1;
    }

    return 0;
}

int main(void)
{
    int a[SIZE];
    
    randomize();
    set_array_random(a, SIZE);
    print_array(a, SIZE);

    qsort(a, SIZE, sizeof(int), &icmp);
    print_array(a, SIZE);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `qsort` fonksiyonuna Ã§aÄŸrÄ± yapÄ±larak `int` tÃ¼rÃ¼nden elemanlarÄ± olan bir dizinin nasÄ±l kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe doÄŸru sÄ±ralanabileceÄŸi incelenebilir ama `icmp` fonksiyonunda iÅŸaretli tam sayÄ±larda taÅŸma oluÅŸabilme durumu var bu da "**ub**" durumuna neden olacaktÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include "nutility.h"

#define SIZE 100

// KÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe doÄŸru sÄ±ralama yapÄ±lmasÄ± iÃ§in kullanÄ±lan fonksiyon ama burada iÅŸaretli tam sayÄ±larda taÅŸma olabilir.
// Mesela 'vp1' deÄŸiÅŸkeninin deÄŸeri '2,147,483,647' ve 'vp2' deÄŸiÅŸkeninin deÄŸeri '-2,147,483,648' ise yapÄ±lacak Ã§Ä±karma iÅŸlemi taÅŸmaya neden olacaktÄ±r.
int icmp(const void* vp1, const void* vp2)
{
    return *(const int*)vp1 - *(const int*)vp2;
}

int main(void)
{
    int a[SIZE];
    
    randomize();
    set_array_random(a, SIZE);
    print_array(a, SIZE);

    qsort(a, SIZE, sizeof(int), &icmp);
    print_array(a, SIZE);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda tÃ¼rden baÄŸÄ±msÄ±z olarak `gprint_array` adlÄ± bir fonksiyonun nasÄ±l yazÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

#define SIZE 10

int gprint_array(const void* vp, size_t size, size_t sz, void (*fprint)(const void*))
{
    for(size_t i = 0; i < size; ++i){
        fprint((const char *)vp + i *sz);
    }
    putchar('\n');
}

void myprint(const void* p)
{
    printf("%p \n", *(const int*)p);
}

int main(void)
{
    int a[SIZE];
    
    randomize();
    set_array_random(a, SIZE);
    gprint_array(a, SIZE, sizeof(int), &myprint);
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 11.05-11.26 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***

### `binary` Fonksiyonu 

SÄ±ralanmmÄ±ÅŸ bir dizide bir deÄŸeri arayan `stdlib.h` baÅŸlÄ±k dosyasÄ±nda bulunan generic bir fonksiyondur. </br>
SÄ±ralanmÄ±ÅŸ bir dizide arama yapmak iÃ§in kullanÄ±lmaktadÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `bsearch` fonksiyonu kullanÄ±larak sÄ±ralÄ± bir dizide bir deÄŸerin nasÄ±l aranabileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

#define SIZE 200

// KÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe doÄŸru sÄ±ralama yapÄ±lmasÄ± iÃ§in kullanÄ±lan fonksiyon ama burada iÅŸaretli tam sayÄ±larda taÅŸma olabilir.
int icmp(const void* vp1, const void* vp2)
{
    return 
        *(const int*)vp1 > *(const int*)vp2 ? 1 :
        *(const int*)vp1 < *(const int*)vp2 ? -1 : 0;
}

int main(void)
{
    int a[SIZE];
    
    randomize();
    set_array_random(a, SIZE);
    print_array(a, SIZE);

    qsort(a, SIZE, sizeof(*a), &icmp); // Burada 'qsort(a, SIZE, sizeof(*a), icmp);' olarak ta fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±labilirdi, bu durumda 'icmp' fonksiyonu adÄ± Ã¶rtÃ¼lÃ¼ olarak adrese dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼rdÃ¼.
    print_array(a, SIZE);

    int key;
    printf("aramacak degeri giriniz: ");
    scanf("%d", &key);

    int* p = (int*)bsearch(&key, a, SIZE, sizeof(*a), &icmp); 

    if(p != NULL){
        printf("bulundu %d index = %d \n", *p, p - a);
    }
    else{
        printf("bulunamadi\n");
    }
}
```

âš¡ Åu ana kadar bir fonksiyonun adresini parametre olarak alan ve generic olan iki tane standart C fonksiyonu Ã¶ÄŸrendik, bunlar `qsort` ve `bsearch` fonksiyonlarÄ±.



ğŸ“– Ã–dev-1:
- ğŸ‘‡ AÅŸaÄŸÄ±daki soru C mÃ¼lakatlarÄ±nda sorulan aslÄ±nda zor olmayan ama Ã§Ã¶zÃ¼lÃ¼rken biraz zorlanÄ±lan bir soru.
- ElemanlarÄ± `char *` tÃ¼rÃ¼nden olan bir diziyi `qsort` fonksiyonunu kullanarak sÄ±ralayÄ±nÄ±z(burada `qsort` fonksiyonuna gÃ¶nderilecek olan callback fonksiyonun doÄŸru yazÄ±lÄ±p yazÄ±lamadÄ±ÄŸÄ± sÄ±nanmaktadÄ±r). 
- Bu iÅŸlemi yaparken dizideki yazÄ±lar kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe doÄŸru sÄ±ralanmalÄ±dÄ±r.
- YazacaÄŸÄ±nÄ±z callback fonksiyonda `strcmp` fonksiyonunu Ã§aÄŸÄ±rabilirsiniz.
- YazÄ±lacak programda tÃ¼r uyumsuzluÄŸu ya da tek bir uyarÄ± iletisi olmamalÄ±dÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

#define SIZE 200

int main(void)
{
    char* p[] = {
        "refika", "remeysa", "rupen", "saadet", "sabriye", "sade", "sadegul", "sadettin", "sadi", "sadiye", 
        "hakki", "haldun", "halime", "haluk", "handan", "hande", "handesu", "hasan", "helin", "hikmet",
        "necmiye", "nedim", "nefes", "nevsin", "nihal", "nihat", "nisan", "niyazi", "nurdan", "nuri",
        "ali", "alican", "alparslan", "anil", "arda", "asim", "askin", "aslican", "aslihan", "ata",
    };

    for(size_t i = 0; asize(p); ++i){
        printf("%s \n", p[i]);
    }
    
    // Burada dizinin sÄ±ralanmasÄ± iÅŸlemleri yapÄ±lÄ±yor.
    //for(size_t i = 0; asize(p) - 1; ++i){
    //    for(size_t k = 0; asize(k) - 1 - i; ++k){
    //        if(strcmp(p[k], p[k + 1]) > 0){
    //            char* temp = p[k];
    //            p[k] = p[k + 1];
    //            p[k + 1] = temp;
    //        }
    //    }
    //}

    // qsort ile diziyi sÄ±ralayÄ±nÄ±z ... (yazÄ±lar kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe sÄ±ralayÄ±nÄ±z)
    // yazacaÄŸÄ±nÄ±z callback fonksiyonda 'strcmp' fonksiyonunu Ã§aÄŸÄ±rabilirsiniz.
    // tÃ¼r uyumsuzluÄŸu ya da tek bir uyarÄ± iletisi olmamalÄ±. 

    (void)getchar();

    for(size_t i = 0; asize(p); ++i){
        printf("%s \n", p[i]);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda fonksiyon bildirimlerinde olduÄŸu gibi fonksiyon pointer'larÄ±nda da parametre parantezinin iÃ§ini boÅŸ bÄ±rakmakla parametre parantezinin iÃ§inde `void` yazmanÄ±n farklÄ± olduÄŸu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

void bom(); // Burada fonksiyonun parametreleri hakkÄ±nda bilgi verilmemiÅŸ, C dilinde 'implicit int' uygulanacaktÄ±r.
void foo(void);
void bar(int);
void baz(double, double);

int main(void)
{
    // Buradaki 'fp1' fonksiyon gÃ¶stericisinin bildirimi 'void (*)()' tÃ¼rÃ¼nden bir fonksiyonu gÃ¶sterecek ÅŸekilde yapÄ±lmÄ±ÅŸtÄ±r. 
    // Bu fonksiyon gÃ¶stericisi parametre parantezinin iÃ§inin boÅŸ bÄ±rakÄ±lmasÄ± fonksiyon parametresi olmayan bir fonksiyonun parametresini tuttuÄŸu anlamÄ±na gelmiyor.
    // 'fp1' fonksiyon gÃ¶stericisi herhangi bir parametrik yapÄ±da(herhangi sayÄ±da herhangi tÃ¼rde parametrelere sahip) olan fonksiyonlarÄ±n adreslerini tutabilir. 
    void (*fp1)(); 
    
    // Buradaki 'fp2' fonksiyon gÃ¶stericisinin bildirimi 'void (*)(void)' tÃ¼rÃ¼nden bir fonksiyonu gÃ¶sterecek ÅŸekilde yapÄ±lmÄ±ÅŸtÄ±r.
    void (*fp2)(void) = &foo; 
    
    fp2 = &bar; // Buradaki atama iÅŸlemi doÄŸru deÄŸildir.

    // AÅŸaÄŸÄ±daki 'fp1' pointer deÄŸiÅŸkene yapÄ±lan atamalarÄ±n hepsi legaldir, bunun nedeni 'fp1' gÃ¶stericisinin gÃ¶stereceÄŸi fonksiyonlarÄ±n parametrik yapÄ±sÄ±yla ilgili bilgi verilmemiÅŸ olmasÄ±dÄ±r.
    fp1 = &foo;
    fp1 = &bar;
    fp1 = &baz;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir karakter test fonksiyonunun adresini dÃ¶ndÃ¼ren `get_test_func` adlÄ± fonksiyonun nasÄ±l tanÄ±mlandÄ±ÄŸÄ± incelenebilir, bu fonksiyonun geri dÃ¶nÃ¼ÅŸ tÃ¼rÃ¼ `int (*)(int)` ÅŸeklinde olan bir fonksiyon adresidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include "nutility.h"

// AÅŸaÄŸÄ±daki 'get_test_func' fonksiyonu geriye 'int (*)(int)' tÃ¼rÃ¼nÃ¼ dÃ¶ndÃ¼rmektedir.
int (*get_test_func(void))(int)
{
    return &isupper;
}

int main(void)
{
    int (*fp)(int) = get_test_func();

    if(fp('A'))
        printf("evet dogru\n");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda geriye bir test fonksiyonunun adresini dÃ¶ndÃ¼ren bir fonksiyona yapÄ±lan Ã§aÄŸrÄ±dan geriye dÃ¶nen fonksiyon adresi kullanÄ±larak nasÄ±l fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±ldÄ±ÄŸÄ± incelenebilir. Biraz kafa karÄ±ÅŸtÄ±rÄ±cÄ± gelebilir, mantÄ±ÄŸÄ±nÄ± gÃ¶rÃ¼nce zihninde basitleÅŸecektir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "nutility.h"

// AÅŸaÄŸÄ±daki 'get_test_func' fonksiyonu geriye 'int (*)(int)' tÃ¼rÃ¼nÃ¼ dÃ¶ndÃ¼rmektedir.
int (*get_test_func(void))(int)
{
    return &isupper;
}

int main(void)
{
    // AÅŸaÄŸÄ±daki gibi bir kullanÄ±m legal ve kullanÄ±ÅŸlÄ±dÄ±r. Burada 'get_test_func()' fonksiyon Ã§aÄŸrÄ±sÄ± geriye fonksiyon adresi dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ iÃ§in o fonksiyon adresi Ã¼zerinden yeni bir fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±lÄ±yor.
    if(get_test_func()('A')){
        printf("evet dogru\n");
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `typedef` bildirimi kullanÄ±larak nasÄ±l, bir fonksiyondan geriye dÃ¶ndÃ¼rÃ¼len **funciton pointer** deÄŸerin daha sade olarak yazÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "nutility.h"

typedef int (*Fptest)(int); // 'int (*)(int)' tÃ¼rÃ¼nde bildirilen 'Fptest' deÄŸiÅŸkeni.

// AÅŸaÄŸÄ±daki 'get_test_func' fonksiyonu geriye 'int (*)(int)' tÃ¼rÃ¼nÃ¼ dÃ¶ndÃ¼rmektedir.
Fptest get_test_func(void)
{
    return &isupper;
}

int main(void)
{
    Fptest fp = get_test_func();

    // AÅŸaÄŸÄ±daki gibi bir kullanÄ±m legal ve kullanÄ±ÅŸlÄ±dÄ±r.
    if(fp('D')
        printf("evet dogru\n");
    else
        printf("hayir dogru degil\n");
}
```

## Function Pointers Arrays 


ElemanlarÄ± "**Function Pointer**" olan dizilere "**Function Pointer Array**" deniliyor. </br>
"**Function Pointer Array**" nadir kullanÄ±lan bir araÃ§ deÄŸildir, Ã¼retim ortamÄ±nda sÄ±klÄ±kla kullanÄ±lmaktadÄ±r ve iyi bilinmelidir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `fpa` adÄ±ndaki **function pointer array** deÄŸiÅŸkenin nasÄ±l tanÄ±mlandÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "nutility.h"

int f1(int x) { return x + 1; }
int f2(int x) { return x + 2; }
int f3(int x) { return x + 3; }
int f4(int x) { return x + 4; }
int f5(int x) { return x + 5; }

int main(void)
{
    int (*fpa[5])(int) = { &f1, &f2, &f3, &f4, &f5 };
    // int (*fpa[5])(int) = { f1, f2, f3, f4, f5 }; // Buradaki gibi bir tanÄ±mlama da yapÄ±labilir, bunun nedeni fonksiyon adlarÄ±nÄ±n fonksiyon adresine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmesidir.

    int val = fpa[3](20); // Burada ilk defa '[]' operatÃ¶rÃ¼nden sonra '()' operatÃ¶rÃ¼nÃ¼n kullanÄ±mÄ±nÄ± gÃ¶rmÃ¼ÅŸ oluyoruz. Burada 'fpa' dizisinin 3 indisli elemanÄ± olan fonksiyona '20' deÄŸeriyle fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±lmaktadÄ±r.

    printf("val = %d\n", val);
}
```


â—â—â— **Function pointer array** deÄŸiÅŸkenler sÄ±klÄ±kla "**Jump Table**" yapÄ±larÄ±nda kullanÄ±lmaktadÄ±r. </br>
**Lookup Table**: Bir veri sonucunu yeniden hesaplamak yerine sabit zamanda almak iÃ§in kullanÄ±lÄ±r. Mesela faktoriyel deÄŸerlerini bir kere hesaplayÄ±t bir **lookup table** iÃ§inde saklayabiliriz. </br>
**Jump Table**: Sabit zamanda farklÄ± kod bloklarÄ±na atlayabilmek iÃ§in fonksiyon adreslerini ya da etiketleri(label) tutmak iÃ§in kullanÄ±lÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **Function pointer array**'in **Jump Table** olarak kullanÄ±larak kullanÄ±cÄ±dan alÄ±nan iki `int` deÄŸerin istenilen iÅŸleme sokulup sonucunun standart Ã§Ä±ktÄ±ya gÃ¶nderilmesi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "nutility.h"

int sum(int x, int y) { return x + y}
int subtract(int x, int y) { return x - y}
int multiply(int x, int y) { return x * y}
int division(int x, int y) { return x / y}
int mod(int x, int y) { return x % y}

typedef int (*op_type)(int, int); 

int main(void)
{
    int x, y;

    printf("iki tam sayi girin:");
    scanf("%d%d", &x, &y);

    printf("islemi saciniz;\n");
    printf("[1] toplama\n",
        "[2] cikarma\n",
        "[3] carpma\n",
        "[4] bolme\n",
        "[5] mod\n");

    int option;
    scanf("%d", &option);

    op_type f_ar[] = { &sum, &subtract, &multiply, &division, &mod }; // 'f_ar' adÄ±ndaki 'Lookup Table' olarak kullanÄ±lacak olan 'function pointer array' deÄŸiÅŸkenin bildirilmesi ve ilk deÄŸer verilmesi iÅŸlemi.

    printf("%d\n", f_ar[option - 1](x, y));
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.20-12.32 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


### **Function Pointer Array** DeÄŸiÅŸkenler Hangi Temalarda KullanÄ±lÄ±yor

**Function Pointer Array** yapÄ±larÄ± aÅŸaÄŸÄ±daki durumlarda kullanÄ±labilir;
1. BazÄ± fonksiyonlarÄ±n adreslerini tutup gerekli olduÄŸunda o fonksiyonlardan birine programÄ±n akÄ±ÅŸÄ±nÄ± yÃ¶nlendirmek iÃ§in **jump table** olarak kullanÄ±lÄ±r.
2. Bir iÅŸlemin farklÄ± farklÄ± basamaklarÄ±nÄ± gerÃ§ekleÅŸtiren fonksiyonlar var ve bu fonksiyonlarÄ±n arka arkaya Ã§aÄŸÄ±rÄ±lmasÄ± gerekiyor, bunu yapmak iÃ§in bir dÃ¶ngÃ¼ kurulduktan sonra "**function pointer array**" elemanÄ± olan tÃ¼m fonksiyonlara sÄ±rasÄ±yla Ã§aÄŸrÄ± yapÄ±labilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**function pointer array**" bir deÄŸiÅŸkenin elemanlarÄ± olan tÃ¼m fonksiyonlara nasÄ±l sÄ±rayla Ã§aÄŸrÄ± yapÄ±ldÄ±ÄŸÄ± incelenebilir, buradaki program 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "nutility.h"

int sum(int x, int y) { return x + y}
int subtract(int x, int y) { return x - y}
int multiply(int x, int y) { return x * y}
int division(int x, int y) { return x / y}
int mod(int x, int y) { return x % y}

typedef int (*op_type)(int, int); 

int main(void)
{
    int x, y;

    printf("iki tam sayi girin:");
    scanf("%d%d", &x, &y);

    const op_type f_ar[] = { &sum, &subtract, &multiply, &division, &mod };

    for(size_t i = 0; i < asize(f_ar);++i){
        printf("%d\n", f_ar[i](x, y));
    }
}
```



**Mapping**: Ä°ki tane farklÄ± varlÄ±ÄŸÄ± birbirine eÅŸleme iÅŸlemine verilen addÄ±r, **mapping** yapmanÄ±n en kolay yolu iki tane dizi oluÅŸturmak ve o iki diziyi birbiriyle iliÅŸkilendirmektir. C++ dilinin standart kÃ¼tÃ¼phenesinde **mapping** terimi sÄ±klÄ±kla karÅŸÄ±mÄ±za Ã§Ä±kacaktÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**function pointer array**" bir deÄŸiÅŸkenin elemanlarÄ± olan tÃ¼m fonksiyonlara nasÄ±l sÄ±rayla Ã§aÄŸrÄ± yapÄ±ldÄ±ÄŸÄ± ve bu Ã§aÄŸrÄ±larda **mapping** kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "nutility.h"

int sum(int x, int y) { return x + y}
int subtract(int x, int y) { return x - y}
int multiply(int x, int y) { return x * y}
int division(int x, int y) { return x / y}
int mod(int x, int y) { return x % y}

typedef int (*op_type)(int, int); 

int main(void)
{
    int x, y;

    printf("iki tam sayi girin:");
    scanf("%d%d", &x, &y);

    // AÅŸaÄŸÄ±daki 'f_ar' ve 'ops' dizileri birbirine 'map' edilmiÅŸtir yani iliÅŸkilendirilmiÅŸtir.
    const op_type f_ar[]    = { &sum,      &subtract, &multiply, &division, &mod };
    const char* const ops[] = { "toplama", "cikarma", "carpma",  "bolme",   "mod" };

    for(size_t i = 0; i < asize(f_ar);++i){
        printf("%s  %d\n", ops[i], f_ar[i](x, y));
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda kullanÄ±lan yapÄ± C mÃ¼lakatlarÄ±nda sÄ±klÄ±kla sorulmaktadÄ±r.</br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda **jump table** ve **mapping** yapÄ±sÄ± kullanÄ±larak nasÄ±l C standardÄ±nda olan test fonkiyonlarÄ±na Ã§aÄŸrÄ± yapÄ±labildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "nutility.h"

typedef int (*fptest)(int);

int main()
{
    int ch;
    char fname_entry[20];

    // AÅŸaÄŸÄ±daki 'fp_ar' ve 'fnames' dizileri birbirine 'map' edilmiÅŸtir yani iliÅŸkilendirilmiÅŸtir. 'fp_ar' deÄŸiÅŸkeni 'jump table' Ã¶zelliktedir.
    const fptest fp_ar[] = { &isupper, &islower, &isalpha, &isdigit, &isalnum, &isxdigit, &ispunct, &isspace, &isblank, &isprint, &isgraph, &iscntrl };
    const char* const fnames[] = { "isupper", "islower", "isalpha", "isdigit", "isalnum", "isxdigit", "ispunct", "isspace", "isblank", "isprint", "isgraph", "iscntrl" };

    printf("bir karakter girin: ");
    ch = getchar();

    printf("hangi test fonkisyonu cagirilsin: ");
    scanf("%s", fname_entry);

    int i;

    for(i = 0; i < asize(fnames); ++i){
        if(!strcmp(fnames[i], fname_entry)){
            break;
        }
    }

    if(i == asize(fnames)){
        printf("istedigin fonksiyon bulunamadi!\n");
    }
    else if(fp_ar[i](ch)){
        printf("%c karakter icin %s testi sonucu dogru\n", ch, fname_entry);
    }
    else{
        printf("%c karakter icin %s testi sonucu yanlis\n", ch, fname_entry);
    }
}
```


>â”
> 
> Sorulan soru; 
> 
> Mapping kullanmadan kullanicidan aldigimiz "isupper" yazisini map kullanmadan, baska bir sekilde kodumuzda ayni isimle func call'a convert etme sansimiz var midir acaba?
> 
> Cevap;
> 
> HayÄ±r bu ÅŸekilde bir iÅŸlem yapÄ±lamaz, bu durumda elde olacak ÅŸey yazÄ± adresidir, yazÄ± adresi baÅŸka fonksiyon adresi baÅŸkadÄ±r, en fazla dÄ±ÅŸarÄ±dan alÄ±nan yazÄ± adresi bir mapping ile fonksiyon adresine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lerek bir ÅŸeyler yapÄ±labilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda fonksiyon adreslerini tutan bir dizinin oyunlarda en sÄ±k kullanÄ±m yaklaÅŸÄ±mlarÄ±ndan biri olan bazÄ± iÅŸlemlerin yapÄ±lmasÄ±nÄ±n nasÄ±l **function pointer array** ile yapÄ±labildiÄŸi incelenebilir, buradaki program yarÄ±m kaldÄ±.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "nutility.h"

// AÅŸaÄŸÄ±daki fonksiyonlar animasyonlara baÄŸlÄ± da olabilir.
void play(void) { printf("kedi oynuyor") }
void meow(void) { printf("kedi miyavliyor") }
void jump(void) { printf("kedi zipliyor") }
void eat(void) { printf("kedi mama yiyor") }
void sleep(void) { printf("kedi uyuyor") }

typedef void (*cat_action)(void);

int main()
{
    cat_action ct_act[] = { &play, &meow, &jump, &eat, &sleep};
}
```


Ders sonu ...
