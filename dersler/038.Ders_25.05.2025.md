# 38.Ders 25.05.2025 ğŸ•˜

Derse 6(09:01)-8(09:02)-9(09:05)-10(09:08)-9(09:12)-11(09:34)-11(10:01)-12(10:15)-12(11:21)-13(12:16)-13(12:45) kiÅŸi katÄ±ldÄ±.
---

## Function Pointers Array Devam

### Function Pointer Ä°le SÄ±k KullanÄ±lan YÃ¶ntemler 

#### En SÄ±k KullanÄ±lan Ä°lk YÃ¶ntem

C dilindeki kÃ¼tÃ¼phenelerde Ã§ok sÄ±k kullanÄ±lan bir Ã¶rÃ¼ntÃ¼ mevcut, bu Ã¶rÃ¼ntÃ¼ ÅŸu ÅŸekilde: Bir C kÃ¼tÃ¼phenesinin saÄŸlamÄ±ÅŸ olduÄŸu bir fonksiyonun(burada `func` adÄ±ndaki fonksiyon olsun) varsayÄ±lan davranÄ±ÅŸÄ± kÃ¼tÃ¼phanenin bÃ¼nyesinde bulunan baÅŸka bir fonksiyonu(burada `foo` adÄ±ndaki fonksiyon olsun) Ã§aÄŸÄ±rmak olsun, fakat kÃ¼tÃ¼phene ayrÄ± bir fonksiyon ile bu Ã§aÄŸÄ±rÄ±lan fonksiyonun Ã§aÄŸÄ±rdÄ±ÄŸÄ± diÄŸer fonksiyonu deÄŸiÅŸtirmek iÃ§in bir baÅŸka fonksiyon(burada `set_func` adÄ±ndaki fonksiyon olsun) sunabilir ve bir deÄŸiÅŸiklik yapÄ±ldÄ±ÄŸÄ±nda geriye alÄ±nabilir.

âš ï¸ AÅŸaÄŸÄ±da kodlarda gÃ¶rÃ¼lebilecek olan programlama yaklaÅŸÄ±mÄ± C++ standart kÃ¼tÃ¼phanesinde de Ã§ok sÄ±k kullanÄ±lÄ±yor, Ã¼Ã§Ã¼ncÃ¼ taraf kÃ¼tÃ¼phaneler de bu yaklaÅŸÄ±mÄ± Ã§ok sÄ±k kullanmaktadÄ±r.


âœï¸ AÅŸaÄŸÄ±daki Ã¼Ã§ farklÄ± dosyaya(`main.c`, `neco.h`, `neco.c`) daÄŸÄ±lmÄ±ÅŸ ÅŸekilde Ã¼Ã§Ã¼ncÃ¼ taraf kÃ¼tÃ¼phenelerde sÄ±klÄ±kla kullanÄ±lan yukarÄ±da aÃ§Ä±klanan yaklaÅŸÄ±mÄ±n basit ÅŸekilde nasÄ±l uygulandÄ±ÄŸÄ±nÄ± anlamak iÃ§in incelenebilir.

ğŸ‘‡ AÅŸaÄŸÄ±daki kodlar `neco.h` dosyasÄ±ndadÄ±r.
```C

typedef void (*fptr)(void);

// VarsayÄ±lan davramÄ±ÅŸ 'foo' adlÄ± fonksiyonun Ã§aÄŸÄ±rÄ±lmasÄ±dÄ±r. 
void func(void);

fptr set_func(fptr);
```


ğŸ‘‡ AÅŸaÄŸÄ±daki kodlar `neco.c` dosyasÄ±ndadÄ±r.
```C

// AÅŸaÄŸÄ±daki 'foo' fonksiyonu ve 'gf' fonksiyon gÃ¶stericisinin 'static' bildirilmesinin nedeni bu varlÄ±klarÄ±n 'neco.c' dosyasÄ± dÄ±ÅŸÄ±ndan kullanÄ±lmasÄ±nÄ± engellemek iÃ§indir, bu konu Ã¼Ã§-dÃ¶rt hafta sonra ayrÄ±ntÄ±lÄ± olarak iÅŸlenecektir.
// Burada kullanÄ±lan 'static' anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n iÅŸlevi yerel deÄŸiÅŸkenelerin 'static' olarak bildirildiÄŸindeki iÅŸlevinden farklÄ±dÄ±r!
static void foo(void)
{
    printf("foo() called!\n");
}

static fptr gf = &foo;  // Buradaki 'gf' adÄ±ndaki deÄŸiÅŸken 'static' olarak tanÄ±mlanarak dÄ±ÅŸ kaynak dosyalardan kullanÄ±ma kapatÄ±lmÄ±ÅŸtÄ±r.

// C kÃ¼tÃ¼phenesinden dÄ±ÅŸarÄ±ya aÃ§Ä±lan ve global fonksiyon pointer'Ä± Ã¼zerinden fonksiyon Ã§aÄŸrÄ±sÄ± yapan 'func' fonksiyonu
void func(void)
{
    // ...

    gf();
}

// C kÃ¼tÃ¼phenesinden dÄ±ÅŸarÄ±ya aÃ§Ä±lan ve 'func' fonksiyonunun davranÄ±ÅŸÄ±nÄ± deÄŸiÅŸtirmek iÃ§in kullanÄ±lan 'set_func' fonksiyonu, geriye dÃ¶nÃ¼ÅŸ deÄŸeri 'gf' deÄŸiÅŸkeninin deÄŸeri olan fonksiyon adresidir, bu geriye dÃ¶nÃ¼ÅŸ deÄŸeri 'func' fonksiyonunun davranÄ±ÅŸÄ±nÄ±n ilk haline dÃ¶ndÃ¼rÃ¼lebilmesi iÃ§in kullanÄ±lÄ±yor.
fptr set_func(fptr f)
{
    fptr fp = gf;
    gf = f;
    return fp;
}
```


ğŸ‘‡ AÅŸaÄŸÄ±da `main.c` dosyasÄ±nÄ±n iÃ§eriÄŸi gÃ¶rÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "neco.h"

void bar(void)
{
    printf("bar() called!\n");
}

int main(void)
{
    func(); // 'foo()' Ã§aÄŸrÄ±lÄ±r.
    fptr f = set_func(&bar);
    func(); // 'bar()' Ã§aÄŸrÄ±lÄ±r.

    set_func(f);
    func(); // 'foo()' Ã§aÄŸrÄ±lÄ±r.
}
```


#### En SÄ±k KullanÄ±lan Ä°kinci YÃ¶ntem 

Kuyruk ya da **stack veri yapÄ±sÄ±** ile tutulan fonksiyonlarÄ±n belirli bir sÄ±rayla Ã§aÄŸrÄ±lmasÄ± yaklaÅŸÄ±mÄ± yÃ¶ntemi.


ğŸ‘‡ AÅŸaÄŸÄ±daki kodlar `neco.h` dosyasÄ±ndadÄ±r.
```C
typedef void (*fptr)(void);

// VarsayÄ±lan davramÄ±ÅŸ 'foo' adlÄ± fonksiyonun Ã§aÄŸÄ±rÄ±lmasÄ±dÄ±r. 
void func(void);

fptr set_func(fptr);
```


ğŸ‘‡ AÅŸaÄŸÄ±daki kodlar `neco.c` dosyasÄ±ndadÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include "neco.h"
#include <stdio.h>

#define MAX_REG_NUMBER 10

static fptr ga[MAX_REG_NUMBER]; // 'ga' deÄŸiÅŸkeni bir 'fonksiyon pointer' dizisidir.
static int ga_idx = 0;

void reg_func(fptr f)
{
    if(ga_idx == MAX_REG_NUMBER){
        return;
    }

    ga[ga_idx++] = f;
}

void func(void)
{
    // Kuyruk yapÄ±sÄ±na gÃ¶re 'ga' dizisindeki fonksiyonlarÄ±n Ã§aÄŸÄ±rÄ±lmasÄ± iÅŸlemi
    //for(int i = 0; i < ga_idx; ++i){
    //    ga[i]();
    //}

    // Stack yapÄ±sÄ±na gÃ¶re 'ga' dizisindeki fonksiyonlarÄ±n Ã§aÄŸÄ±rÄ±lmasÄ± iÅŸlemi
    for(int i = ga_idx - 1; i >= 0; --i){
        ga[i]();    
    }
}
```


ğŸ‘‡ AÅŸaÄŸÄ±da `main.c` dosyasÄ±nÄ±n iÃ§eriÄŸi gÃ¶rÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include "neco.h"
#include <stdio.>

void f1(void) { printf("f1 called!\n"); }
void f2(void) { printf("f1 called!\n"); }
void f3(void) { printf("f1 called!\n"); }
void f4(void) { printf("f1 called!\n"); }

int main(void)
{
    reg_func(f1);
    reg_func(f2);
    reg_func(f3);
    reg_func(f4);

    func();
}
```


## Multi Dimensional Arrays(Ã‡ok Boyutlu Diziler) 

â—â—â— Bu konuda en gÃ¼zel cÃ¼mle ÅŸudur "BaÅŸlÄ±k **Ã‡ok Boyutlu Diziler**, C dilinde Ã§ok boyutlu dizi yoktur". ElemanÄ± dizi olan dizilere Ã§ok boyutlu diziler denilmektedir, her ne kadar Ã§ok boyutlu dizi dense de gerÃ§ekte donanÄ±m Ã¼zerinde tek boyutlu dizi olarak tutulmaktadÄ±r.

Bu konunun yanlÄ±ÅŸ anlaÅŸÄ±lma ihtimali yÃ¼ksek, bu nedenden dolayÄ± iyi Ã§alÄ±ÅŸÄ±lmalÄ±dÄ±r.</br>
DiÄŸer programlama dillerinde **Matrix** ya da **Multi Dimensional Array** denilen diziler esasÄ±nda elemanlarÄ± dizi olan dizilerdir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda bazÄ± tek boyutlu dizilerin ve elemanlarÄ±nÄ±n tÃ¼rlerinin ne olduÄŸu incelenebilir, buradaki bilgilerin iyi bilinmesi gerekiyor ki konunun sonraki kÄ±sÄ±mlarÄ± iyi anlaÅŸÄ±labilsin.
```C
int main(void)
{
    int ary1[10]; // 'ary1' dizisinin elemanlarÄ±nÄ±n tÃ¼rÃ¼ 'int', 'ary1' nesnesinin(deÄŸiÅŸkeninin) tÃ¼rÃ¼ 'int[5]' tÃ¼rÃ¼dÃ¼r.
    double ary2[20]; // 'ary2' dizisinin elemanlarÄ±nÄ±n tÃ¼rÃ¼ 'double', 'ary2' nesnesinin(deÄŸiÅŸkeninin) tÃ¼rÃ¼ 'double[20]' tÃ¼rÃ¼dÃ¼r.
    int* ary3[7]; // 'ary3' dizisinin elemanlarÄ±nÄ±n tÃ¼rÃ¼ 'int*'. 'ary3' nesnesinin(deÄŸiÅŸkeninin) tÃ¼rÃ¼ 'int*[7]' tÃ¼rÃ¼dÃ¼r.
    int (*ary4[6])(int); // 'ary4' dizisinin elemanlarÄ±nÄ±n tÃ¼rÃ¼ 'int (*)(int)'. 'ary4' nesnesinin(deÄŸiÅŸkeninin) tÃ¼rÃ¼ 'int (*[6])(int)' tÃ¼rÃ¼dÃ¼r.
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki boyutlu bir dizinin nasÄ±l tanÄ±mlandÄ±ÄŸÄ± incelenebilir.
```C
int main(void)
{
    int a1[5];

    // ElamanlarÄ± 'a1'in tÃ¼rÃ¼nden olan yani elemanlarÄ±nÄ±n tÃ¼rÃ¼ 'int[5]' tÃ¼rÃ¼ olan yani her elemanÄ± 5 elemanlÄ± bir 'int' dizi adÄ± olan adÄ± 'x' olan 20 elemanlÄ± bir dizi tanÄ±mÄ± aÅŸaÄŸÄ±daki gibidir.
    int x[20][5];
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda tek boyutlu, iki boyutlu ve Ã¼Ã§ boyutlu dizilerle ilgili durumlar incelenebilir.
```C
int main(void)
{
    int a[5];
    int b[20][5]; // Burada 'b' dizisi elemanlarÄ± beÅŸ elemanlÄ± dizi olan 20 elemanlÄ± dizidir.

    a[2]; // Buradaki ifadenin tÃ¼rÃ¼ 'int' tÃ¼rÃ¼dÃ¼r.
    b[13]; // Buradaki ifadenin tÃ¼rÃ¼ 'int[5]' tÃ¼rÃ¼dÃ¼r.

    // AÅŸaÄŸÄ±daki iÅŸlemler anlayamayan bir programcÄ± Ã§ok boyutlu diziler konusunun diÄŸer kÄ±sÄ±mlarÄ±nÄ± zaten anlayamayacaktÄ±r!
    int* p = a; // Burada sÃ¶zdizim hatasÄ±(syntax error) olmamasÄ±nÄ±n nedeni 'array to pointer conversion' iÅŸleminden dolayÄ± 'a' dizi adÄ±nÄ±n '&a[0]' ifadesine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmesidir.
    int* p = b[3]; // Burada sÃ¶zdizim hatasÄ±(syntax error) olmamasÄ±nÄ±n nedeni 'array to pointer conversion' iÅŸleminden dolayÄ± 'b[3]' dizi adÄ±nÄ±n '&b[3][0]' ifadesine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmesidir.

    int c[10][20][5]; // Burada bildirilen 'c' dizisi, elemanlarÄ± 'int[20][5]' olan 10 elemanlÄ± dizidir.
}
```


â—â—â— Bir dizinin tÃ¼rÃ¼ ne olursa olsun(burada dizinin boyutunun ne olduÄŸunun Ã¶nemi olmadÄ±ÄŸÄ± vurgulanÄ±yor) o dizinin elemanlarÄ± bellekte ardÄ±ÅŸÄ±k olarak sÄ±ralanacaktÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki `int b[4][5];` bildirimindeki `b` nesnesi program Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda bellekte sÄ±ralÄ± olacak ÅŸekilde dizilecektir, bu kÄ±smÄ± anlamak iÃ§in gÃ¶rsel olarak konuyu anlatan kaynaklar araÅŸtÄ±rÄ±labilir.
```C
int main(void)
{
    int a[5];
    int b[4][5]; // Burada 'b' dizisi elemanlarÄ± beÅŸ elemanlÄ± dizi olan 4 elemanlÄ± dizidir ve 32 bitlik mimaride bellekte sÄ±ralÄ± olarak '4 * 5 * 4 byte' alan kaplayacaktÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bazÄ± Ã§ok boyutlu dizilerin nasÄ±l tanÄ±mlanabileceÄŸi incelenebilir.
```C
int main(void)
{
    // ElemanlarÄ± 'double[4]' tÃ¼rÃ¼nden olan 10 elemanlÄ± bir dizi aÅŸaÄŸÄ±daki gibi tanÄ±mlanabilir.
    double ary1[10][4];

    // ElemanlarÄ± 'int* [5]' tÃ¼rÃ¼nden olan 21 elemanlÄ± bir dizi aÅŸaÄŸÄ±daki gibi tanÄ±mlanabilir.
    int* ary2[21][5];
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã§ok boyutlu dizilerde bazÄ± ifadelerin bellekte kaplayacaÄŸÄ± byte deÄŸerinin ne olacaÄŸÄ± incelenebilir(32 bitlik sistemde).
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int a[4][8] = { 0 };

    printf("sizeof(a) = %zu\n", sizeof(a)); // Burada standart Ã§Ä±ktÄ± akÄ±mÄ±na 'sizeof(a) = 128' deÄŸeri gÃ¶nderilir. 128 deÄŸeri ÅŸu hesaplamadan geliyor => '4 * 8 * sizeof(int)'
    printf("sizeof(a[0]) = %zu\n", sizeof(a[0])); // Burada standart Ã§Ä±ktÄ± akÄ±mÄ±na 'sizeof(a[0]) = 32' deÄŸeri gÃ¶nderilir. 32 deÄŸeri ÅŸu hesaplamadan geliyor => '8 * sizeof(int)'
    printf("sizeof(a[0][0]) = %zu\n", sizeof(a[0][0])); // Burada standart Ã§Ä±ktÄ± akÄ±mÄ±na 'sizeof(a[0][0]) = 4' deÄŸeri gÃ¶nderilir. 4 deÄŸeri ÅŸu hesaplamadan geliyor => 'sizeof(int)'
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã¶nceden yazÄ±lmÄ±ÅŸ olan `randomize`, `set_array_random`, `print_array` adlÄ± `nutility.h` baÅŸlÄ±k dosyasÄ±nda bulunan fonksiyonlarÄ±n Ã§ok boyutlu bir dizide nasÄ±l kullanÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[4][8] = { 0 };

    randomize();
    set_array_random(a[2], 8);
    print_array(a[2], 8);
}
```

### Multi Dimensional Arrays Initialization(Ã‡ok Boyutlu Dizilere Ä°lk DeÄŸer Verilmesi) 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki boyutlu bir diziye nasÄ±l ilk deÄŸer verildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[5][4] = { 
        {1, 2, 3, 1},
        {9, 0, 3, 2},
        {4, 9, 1, 0},
        {5, 6, 3, 7},
        {4, 2, 9, 4},
    };

    for(int i = 0; i < 5; ++i){
        for(int k = 0; k < 4; ++k){
            printf("%d ", a[i][k]);
        }
        printf("\n");
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki boyutlu bir diziye ilk deÄŸer verirken deÄŸer verilmeyen dizi elemanlarÄ±nÄ±n ilk deÄŸerinin 0 olacaÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[5][4] = { 
        {1, 2, 3, 1},
        {9, 0, },
        {4, 9, 1, 0},
        {5,},
        {4, 9, 4},
    };

    for(int i = 0; i < 5; ++i){
        for(int k = 0; k < 4; ++k){
            printf("%d ", a[i][k]);
        }
        printf("\n");
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki boyutlu bir diziye ilk deÄŸer verirken deÄŸer verilmeyen dizi elemanlarÄ±nÄ±n ilk deÄŸerinin 0 olacaÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
     int a[5][4] = { 
        {1, 2, 3, 1},
        {9, 0, 3, 2},
        {4, 9, 1, 0},
    };

    for(int i = 0; i < 5; ++i){
        for(int k = 0; k < 4; ++k){
            printf("%d ", a[i][k]);
        }
        printf("\n");
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki boyutlu bir diziye ilk deÄŸer verirken gÃ¶ze garip gelen bir yÃ¶ntemle nasÄ±l dizinin elemanlarÄ±na ilk deÄŸer verileceÄŸi incelenebilir. Buradaki ilk deÄŸer verme **sÃ¶zdiziminin(syntax)** kullanÄ±lmasÄ± kodun niyetini belirtmediÄŸi iÃ§in Ã§ok tercih edilmemelidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    // AÅŸaÄŸÄ±daki kullanÄ±m legal'dir ama kullanÄ±mÄ± aÃ§Ä±k deÄŸildir yani okunaklÄ± deÄŸil(hangi deÄŸer dizinin hangi elemanÄ± belli deÄŸil).
    int a[5][4] = { 
        1, 2, 3, 1, 9, 0, 3, 2, 4, 9, 1, 0,
    };

    for(int i = 0; i < 5; ++i){
        for(int k = 0; k < 4; ++k){
            printf("%d ", a[i][k]);
        }
        printf("\n");
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda C diline C99 standardÄ± ile eklenen "**Designated Initializer**" sÃ¶zdizimi(syntax) ile tek boyutlu bir diziye nasÄ±l ilk deÄŸer verildiÄŸi incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a1[10]= { [3] = 5, [7] = 2, [1] = 6 };

    int a2[]= { [3] = 5, [7] = 2, [1] = 6 }; // Buradaki gibi dizinin eleman sayÄ±sÄ± verilmeden de 'Designated Initializer' yÃ¶ntemiyle dizi tanÄ±mlanabilir.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã§ok boyutlu bir dizide "**Designated Initializer**" sÃ¶zdizimiyle(syntax) nasÄ±l ilk deÄŸer verildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
     int a[5][4] = { 
        [3] = {1, 2, 3, 1},
    };

    for(int i = 0; i < 5; ++i){
        for(int k = 0; k < 4; ++k){
            printf("%d ", a[i][k]);
        }
        printf("\n");
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã§ok boyutlu bir dizide "**Designated Initializer**" sÃ¶zdizimiyle(syntax) nasÄ±l ilk deÄŸer verildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
     int a[5][4] = { 
        [3] = {1, 2, 3, 1},
        [1] = { [2] = 7 }
    };

    for(int i = 0; i < 5; ++i){
        for(int k = 0; k < 5; ++k){
            printf("%d ", a[i][k]);
        }
        printf("\n");
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã§ok boyutlu bir dizide ilk deÄŸer verilmediÄŸinde ne olacaÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
     int ary1[5][4]; // Burada 'ary1' dizisi yaÅŸamÄ±na 'indetermined value(garbage value)' ile baÅŸlayacaktÄ±r.
     static int ary2[5][4]; // Burada 'ary2' dizisi yaÅŸamÄ±na tÃ¼m elemanlarÄ± '0' deÄŸerinde baÅŸlar.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda C dilini yeni Ã¶ÄŸrenenlerin Ã§ok sÄ±k yaptÄ±ÄŸÄ± Ã§ok boyutlu dizilerle ilgili hatalÄ± bir durum incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[4][5] = { 0 };

    int* p = a; // Buradaki ilk deÄŸer verme sÃ¶zdizimi hatasÄ±(syntax error), hatalÄ± olmasÄ±nÄ±n nedeni 'a' deÄŸiÅŸkeninin 'array decay' ile '&a[0]' ifadesine Ã§evrilmesidir, bu ifade 'int(*)[5]' tÃ¼rÃ¼ndedir ve tÃ¼r uyuÅŸmazlÄ±ÄŸÄ±ndan dolayÄ± buradaki atama iÅŸlemi doÄŸru deÄŸildir. C++ dilinde sÃ¶zdizim hatasÄ±dÄ±r(syntax error), C dilinde derleyiciler uyarÄ± verir.

    int* p1 = a[0]; // Buradaki ilk deÄŸer verme iÅŸlemi doÄŸrudur, 'a[0]' ifadesi 'array decay' ile '&a[0][0]' ifadesine Ã§evrilir.

    // ptr, a'nÄ±n elemanÄ±nÄ±n gÃ¶sterecek bir pointer olsun
    // a'nÄ±n ilk elemanÄ±nÄ± gÃ¶steriyor olsun.
    int(*ptr)[5] = a; // Buradaki atama iÅŸlemi doÄŸrudur.
}
```



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programda tek boyutlu bir dizinin adÄ± Ã¼zerinden oluÅŸturulan ifadelerin tÃ¼rlerinin ne olacaÄŸÄ± incelenebilir. Buradaki bilgilerin bilinmesi Ã¶nemlidir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[5] = { 10, 20, 30, 40, 50 };

    int (*p)[5] = &a; // Buradaki 'p' gÃ¶stericisinin tÃ¼rÃ¼ 'int(*)[5]' tÃ¼rÃ¼dÃ¼r.

    // 'a' deÄŸiÅŸkeninin tÃ¼rÃ¼ 'int[5]' tÃ¼rÃ¼dÃ¼r.
    // 'a' ifadesinin tÃ¼rÃ¼ 'array decay'den dolayÄ± 'a' ifadesi '&a[0]' ifadesine Ã§evrileceÄŸinden ve bu ifadenin de tÃ¼rÃ¼nÃ¼n 'int*' olmasÄ±ndan dolayÄ± 'int*' tÃ¼rÃ¼dÃ¼r.
    // '&a' ifadesinin tÃ¼rÃ¼ 'int (*)[5]' tÃ¼rÃ¼dÃ¼r.

    // '*p' ifadesi 'a' ifadesine eÅŸittir ve '*p' ifadesi Ã¼zerinden 'a' dizisi gezilebilir. 
    for(int i = 0; i < 5; ++i){
        printf("%d ", (*p)[i]); // Burada '*p' ifadesinin paranteze alÄ±nmasÄ±nÄ±n nedeni '[]' operatÃ¶rÃ¼nÃ¼n 'dereferencing' operatÃ¶tÃ¼nden daha yÃ¼ksek Ã¶nceliÄŸe sahip olmasÄ±dÄ±r, '*p[i]' bÃ¶yle yazarsak derleyici '*(p + i)' olarak yorumlayacaktÄ±r ama biz bunu istemiyoruz ve bu 'ub' durumuna neden olur.
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `int` tÃ¼rÃ¼nden elemanlarÄ± olan tek boyutlu bir dizinin kendi adÄ± ile oluÅŸturulan ifadelerin tÃ¼rleri ve bellek boyutlarÄ±nÄ±n ne olacaÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[4] = { 10, 20, 30, 40 };

    printf("%p  %p  %p\n", a, a + 1, a + 2);

    printf("%p  %p  %p\n", &a, &a + 1, &a + 2);

    /*
    
    'a' ifadesi '&a[0]' ifadesine denktir ve bellek boyutu 'sizeof(int)'
    '&a' ifadesi 'int (*)[4]' ifadesine denktir ve bellek boyutu 'sizeof(a)'
    
    */
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki boyutlu bir dizinin adresi Ã¼zerinden oluÅŸturulan ifadelerde pointer aritmetiÄŸinin nasÄ±l olduÄŸu incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[10][4];

    for(int i = 0; i < 10; ++i){
        printf("%p  %p\n", &a[0] + i, a + i); // Ä°ki ifade de aynÄ± adrese karÅŸÄ±lÄ±k gelmektedir.
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki boyutlu bir dizinin adresi Ã¼zerinden oluÅŸturulan ifadelerde pointer aritmetiÄŸinin nasÄ±l olduÄŸu incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[10][4];
    int (*ptr)[4] = a; // Buradaki 'a' ifadesi 'array to pointer conversion' nedeniyle 

    for(int i = 0; i < 10; ++i){
        printf("%p  %p  %p\n", &a[0] + i, a + i, ptr); // ÃœÃ§ ifade de aynÄ± adrese karÅŸÄ±lÄ±k gelmektedir.
        ++ptr;
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki boyutlu bir dizinin adÄ± Ã¼zerinden pointer deÄŸiÅŸkenlere nasÄ±l deÄŸer atanabileceÄŸi incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[10][4];
    int (*p1)[4] = a; // 'p1' adÄ±ndaki gÃ¶stericinin tÃ¼rÃ¼ 'int(*)[4]' tÃ¼rÃ¼dÃ¼r.
    int (*p2)[4] = &a[0]; // 

    // 'a' dizisini ilk elemanÄ±nÄ±n ilk elemanÄ±nÄ±n adresinin nasÄ±l tutulacaÄŸÄ± aÅŸaÄŸÄ±dan incelenebilir.
    int* ptr = a[0][0];
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki boyutlu bir dizinin adÄ± Ã¼zerinden oluÅŸturulan ifadelerin nasÄ±l kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[10][4] = { { 2, 5, 7, 9 } };

    int* p1 = &a[0][0];
    printf("%d\n", *p1);

    int* p2 = a[0]; // Burada 'array decay' iÅŸleminden dolayÄ± 'p2' deÄŸiÅŸkenine '&a[0][0]' deÄŸeri ilk deÄŸer olarak veriliyor ve buradaki ilklendirme iÅŸlemi doÄŸrudur.
    printf("%d\n", *p2);

    int* p3 = a; // Buradaki ilk deÄŸer verme deyimi(statement) doÄŸru bir kullanÄ±m deÄŸildir Ã§Ã¼nkÃ¼ 'a' deÄŸiÅŸkeninin tÃ¼rÃ¼ 'int (*)[4]' tÃ¼rÃ¼dÃ¼r ve 'int*' tÃ¼rÃ¼ne Ã¶rtÃ¼lÃ¼ olarak tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapÄ±lmak isteniyor. C++ dilinde burada sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.
}
```



> Derse katÄ±lanlardan biri ÅŸu ÅŸeklide yorum yaptÄ± => "Yani sayisal degerler ve hafizadaki konumlanma ayni ama tÃ¼rler mi farkli sadece", bu cÃ¼mleyle ifade edilen dÃ¼ÅŸÃ¼nce doÄŸrudur.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki boyutlu bir dizinin adÄ± Ã¼zerinden oluÅŸturulan ifadelerin tÃ¼rlerinin ne olacaÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[10][4] = { { 2, 5, 7, 9, } };

    printf("%p\n", &a); // '&a' ifadesinin tÃ¼rÃ¼ 'int (*)[10][4]' tÃ¼rÃ¼dÃ¼r.
    printf("%p\n", a); // 'a' ifadesi 'arrat decay' ile '&a[0]' ifadesine Ã§evrilir ve tÃ¼rÃ¼ 'int (*)[4]' tÃ¼rÃ¼dÃ¼r.
    printf("%p\n", &a[0]); // '&a[0]' ifadesinin tÃ¼rÃ¼ 'int (*)[4]' tÃ¼rÃ¼dÃ¼r.
    printf("%p\n", &a[0][0]); // '&a[0][0]' ifadesinin tÃ¼rÃ¼ 'int*' tÃ¼rÃ¼dÃ¼r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki boyutlu dizinin elemanlarÄ±na nasÄ±l eriÅŸildiÄŸi ve iÅŸlem yapÄ±ldÄ±ÄŸÄ± incelenebilir. Buradaki programÄ± on kiÅŸiden dokuzu anlayamÄ±yormuÅŸ.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[5][4] = { 
        {1, 1, 1, 1},
        {2, 2, 2, 2},
        {3, 3, 3, 3},
        {4, 4, 4, 4},
        {5, 5, 5, 5},
    };

    ++**a; // Bu ifade '++(*(*a))' bu ifadeye denktir ve bu ifade 'a' dizisinin ilk elemanÄ±nÄ±n ilk elemanÄ±na eriÅŸir ve o nesnenin deÄŸerini bir arttÄ±rÄ±r.
    
    for(int i = 0; i < 5; ++i){
        for(int k = 0; k < 4; ++k)
            printf("%d", a[i][k]);

        printf("\n");
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki boyutlu dizinin elemanlarÄ±na nasÄ±l eriÅŸildiÄŸi ve iÅŸlem yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[5][4] = { 
        {1, 1, 1, 1},
        {2, 2, 2, 2},
        {3, 3, 3, 3},
        {4, 4, 4, 4},
        {5, 5, 5, 5},
    };

    int (*p)[4] = a;
    
    ++**p;
    
    for(int i = 0; i < 5; ++i){
        for(int k = 0; k < 4; ++k)
            printf("%d", a[i][k]);

        printf("\n");
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki boyutlu dizinin elemanlarÄ±na nasÄ±l eriÅŸildiÄŸi ve iÅŸlem yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[5][4] = { 
        {1, 1, 1, 1},
        {2, 2, 2, 2},
        {3, 3, 3, 3},
        {4, 4, 4, 4},
        {5, 5, 5, 5},
    };

    int (*p)[4] = a;
    
    ++p; // Bu pointer aritmetiÄŸi iÅŸlemiyle 'p' gÃ¶stericisi 'a' dizisinin ikinci elemanÄ±nÄ±n adresini iÅŸaret edecektir.
    ++**p; // Burada 'p'nin gÃ¶sterdiÄŸi dizinin ilk elemanÄ±nÄ±n deÄŸeri bir arttÄ±rÄ±lÄ±yor.
    
    for(int i = 0; i < 5; ++i){
        for(int k = 0; k < 4; ++k)
            printf("%d", a[i][k]);

        printf("\n");
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki boyutlu dizinin elemanlarÄ±na nasÄ±l eriÅŸildiÄŸi ve iÅŸlem yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[5][4] = { 
        {1, 1, 1, 1},
        {2, 2, 2, 2},
        {3, 3, 3, 3},
        {4, 4, 4, 4},
        {5, 5, 5, 5},
    };

    int (*p)[4] = a;
    
    ++p; // Bu pointer aritmetiÄŸi iÅŸlemiyle 'p' gÃ¶stericisi 'a' dizisinin ikinci elemanÄ±nÄ±n adresini iÅŸaret edecektir.
    ++(*p)[2]; 

    for(int i = 0; i < 5; ++i){
        for(int k = 0; k < 4; ++k)
            printf("%d", a[i][k]);

        printf("\n");
    }
}
```


>â”
> 
> Sorulan soru; 
> 
> *p yi ifadede kullandigimda errray decay olmasini bekliyorum sanki
> 
> Cevap;
> 
> Evet Ã¶yle oluyor zaten.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki boyutlu dizinin elemanlarÄ±na nasÄ±l eriÅŸildiÄŸi ve iÅŸlem yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[5][4] = { 
        {1, 1, 1, 1},
        {2, 2, 2, 2},
        {3, 3, 3, 3},
        {4, 4, 4, 4},
        {5, 5, 5, 5},
    };

    // AÅŸaÄŸÄ±daki Ã¼Ã§ ilk deÄŸer verme iÅŸlemi de aynÄ± anlama gelmektedir.  
    int* p1 = &a[0][0];
    int* p2 = a[0];
    int* p3 = (int*)a; // Burada aÃ§Ä±k ÅŸekilde 'int(*)[4]' tÃ¼rÃ¼nden 'int*' tÃ¼rÃ¼ne tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapÄ±lÄ±yor, buradaki iÅŸlem legal ve 'wellform'dur.
    
    // AÅŸaÄŸÄ±daki pointer iÅŸlemlerinin hepsi aynÄ± iÅŸlemi yapmaktadÄ±r ve yapÄ±lan iÅŸlem ise 'a' dizisinin ilk elemanÄ±nÄ±n ilk elemanÄ±nÄ±n deÄŸerinin bir arttÄ±rÄ±lmasÄ±dÄ±r.
    ++*p1;
    ++*p2;
    ++*p3;

    for(int i = 0; i < 5; ++i){
        for(int k = 0; k < 4; ++k)
            printf("%d", a[i][k]);

        printf("\n");
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki boyutlu bir dizinin tek boyutlu diziymiÅŸ gibi kullanÄ±labileceÄŸi incelenebilir(bunun nedeni kaÃ§ boyutlu olursa olsun dizi elemanlarÄ±nÄ±n hepsinin bellekte sÄ±ralÄ± olarak bulunmasÄ±dÄ±r).
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[5][4] = { 
        {1, 1, 1, 1},
        {2, 2, 2, 2},
        {3, 3, 3, 3},
        {4, 4, 4, 4},
        {5, 5, 5, 5},
    };
    
    int* p = &a[0][0];
    int n = 5 * 4;

    while(n--){
        printf("%d", *p++);
        (void)getchar();
    }
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 11.02-11.24 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


Neden bir diziyi bir fonksiyona geÃ§iyoruz diye dÃ¼ÅŸÃ¼nÃ¼lÃ¼rse, bunun yapÄ±lmasÄ±nÄ±n nedeni dizi Ã¼zerinde iÅŸlem yapmak iÃ§indir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã§ok boyutlu dizilerin kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

// 'int (*p)[4]' bir tÃ¼rdÃ¼r ve bu tÃ¼rdeki '[4]' kÄ±smÄ± eleman sayÄ±sÄ± deÄŸildir, tÃ¼r bilgisinin bir bileÅŸenidir.
void print_m(const int (*p)[4], int size)
{
    for(int i = 0; i < size; ++i){
        for(int k = 0; k < size; ++k){
            printf("%d ", p[i][k]);
        }
        printf("\n");
    }
}

int main(void)
{
    int ary[5][4] = { 
        {1, 1, 1, 1},
        {2, 2, 2, 2},
        {3, 3, 3, 3},
        {4, 4, 4, 4},
        {1, 1, 1, 1},
    };

    // AÅŸaÄŸÄ±daki iki fonksiyon Ã§aÄŸrÄ±sÄ± da birbirine denktir.
    print_m(ary, 5); // 'ary' dizisinin ilk elemanÄ±nÄ±n adresi 'print_m' fonksiyonuna geÃ§iliyor.
    printf("~~~~~~~~~~~~~~~~~~~~/n");
    print_m(&ary[0], 5); // 'ary' dizisinin ilk elemanÄ±nÄ±n adresi 'print_m' fonksiyonuna geÃ§iliyor.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã§ok boyutlu dizilerin kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

// 'int (*p)[4]' bir tÃ¼rdÃ¼r ve bu tÃ¼rdeki '[4]' kÄ±smÄ± eleman sayÄ±sÄ± deÄŸildir, tÃ¼r bilgisinin bir bileÅŸenidir.
void print_m(const int (*p)[4], int size)
{
    ptintf("sizepf(p) = %zu\n", sizepf(p));
    ptintf("sizepf(*p) = %zu\n", sizepf(*p));

    for(int i = 0; i < size; ++i){
        for(int k = 0; k < size; ++k){
            printf("%d ", p[i][k]);
        }
        printf("\n");
    }
}

int main(void)
{
    int a[5][4] = { 
        {1, 1, 1, 1},
        {2, 2, 2, 2},
        {3, 3, 3, 3},
        {4, 4, 4, 4},
        {1, 1, 1, 1},
    };

    int (*p)[4] = a;

    ptintf("sizepf(p) = %zu\n", sizepf(p)); // Burada 32 bit sistemde standar Ã§Ä±ktÄ±ya 'sizepf(p) = 4\n' gÃ¶nderilir Ã§Ã¼nkÃ¼ 'p' ifadesi 'int (*)[4]' tÃ¼rÃ¼nden bir pointer deÄŸiÅŸlendir.
    ptintf("sizepf(*p) = %zu\n", sizepf(*p)); // Burada 32 bit sistemde standar Ã§Ä±ktÄ±ya 'sizepf(p) = 16\n' gÃ¶nderilir Ã§Ã¼nkÃ¼ '*p' ifadesi 'int[4]' tÃ¼rÃ¼nden bir dizidir.
    ptintf("sizepf(**p) = %zu\n", sizepf(**p)); // Burada 32 bit sistemde standar Ã§Ä±ktÄ±ya 'sizepf(p) = 4\n' gÃ¶nderilir Ã§Ã¼nkÃ¼ '**p' ifadesi 'int' tÃ¼rÃ¼nden bir dizidir.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã§ok boyutlu dizilerin kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

// 'int (*p)[4]' bir tÃ¼rdÃ¼r ve bu tÃ¼rdeki '[4]' kÄ±smÄ± eleman sayÄ±sÄ± deÄŸildir, tÃ¼r bilgisinin bir bileÅŸenidir.
void print_m(const int (*p)[4], int size)
{
    for(int i = 0; i < size; ++i){
        for(int k = 0; k < size; ++k){
            printf("%d ", p[i][k]);
        }
        printf("\n");
    }
    printf("~~~~~~~~~~~~~~~~~~~~/n");
}

int main(void)
{
    int a[5][4] = { 
        {1, 1, 1, 1},
        {2, 2, 2, 2},
        {3, 3, 3, 3},
        {4, 4, 4, 4},
        {1, 1, 1, 1},
    };

    int (*p)[4] = a;

    // AÅŸaÄŸÄ±daki Ã¼Ã§ fonksiyon Ã§aÄŸrÄ±sÄ± aynÄ± anlama gelmektedir ve bu Ã¼Ã§ Ã§aÄŸrÄ±da herhengi bir hata yoktur.
    print_m(a, 5);
    print_m(&a[0], 5);
    print_m(p, 5);

    // AÅŸaÄŸÄ±daki iki fonksiyon Ã§aÄŸrÄ±larÄ±sÄ±nda fonksiyona geÃ§ilen pointer adreslerinin tÃ¼rÃ¼ fonksiyonun parametre tÃ¼rÃ¼yle uyuÅŸmamaktadÄ±r.
    // AÅŸaÄŸÄ±daki iki fonksiyon Ã§aÄŸrÄ±sÄ± iÃ§in C dilinde derleyici uyarÄ± verecektir ama C++ dilinde sÃ¶zdizim hatasÄ±dÄ±r(syntax error), uyarÄ±yÄ± kaldÄ±rmak ya da sÃ¶zdizim hatasÄ±nÄ±(syntax error) Ã¶nlemek iÃ§in aÃ§Ä±k ÅŸekilde tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapÄ±lmalÄ±dÄ±r.
    // AÅŸaÄŸÄ±daki iki fonksiyon Ã§aÄŸrÄ±sÄ±nda tÃ¼r uyuÅŸmazlÄ±ÄŸÄ± olsa da fiziksel adresler aynÄ± olduÄŸu iÃ§in C dilinde doÄŸru ÅŸekilde Ã§alÄ±ÅŸacaktÄ±r!
    print_m(&a[0][0], 5);
    print_m(&a, 5); // Bu kod C++ dilinde sÃ¶zdizim hatasÄ±dÄ±r(syntax error) ama C dilinde derleyici sadece uyarÄ± verecektir.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã§ok boyutlu dizilerin kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

// 'int (*p)[4]' bir tÃ¼rdÃ¼r ve bu tÃ¼rdeki '[4]' kÄ±smÄ± eleman sayÄ±sÄ± deÄŸildir, tÃ¼r bilgisinin bir bileÅŸenidir.
void print_m(const int (*p)[4], int size)
{
    for(int i = 0; i < size; ++i){
        for(int k = 0; k < size; ++k){
            printf("%d ", p[i][k]);
        }
        printf("\n");
    }
    printf("~~~~~~~~~~~~~~~~~~~~/n");
}

int main(void)
{
    int a[5][4] = {
        {1, 1, 1, 1},
        {2, 2, 2, 2},
        {3, 3, 3, 3},
        {4, 4, 4, 4},
        {1, 1, 1, 1},
    };

    int* p = &a[0][0];

    print_m((int(*)[4])p, 5); // Burada 'p' object pointer deÄŸiÅŸkeni tÃ¼r deÄŸiÅŸtirme operatÃ¶rÃ¼ ile fonksiyonun parametre tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼yor, burada uyarÄ± iletisi ya da sÃ¶zdizim hatasÄ±(syntax error) oluÅŸmayacaktÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã§ok boyutlu dizilerin kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

// 'int (*p)[4]' bir tÃ¼rdÃ¼r ve bu tÃ¼rdeki '[4]' kÄ±smÄ± eleman sayÄ±sÄ± deÄŸildir, tÃ¼r bilgisinin bir bileÅŸenidir.
//void print_m(const int (*p)[4], int size)
//{
//    for(int i = 0; i < size; ++i){
//        for(int k = 0; k < size; ++k){
//            printf("%d ", p[i][k]);
//        }
//        printf("\n");
//    }
//    printf("~~~~~~~~~~~~~~~~~~~~/n");
//}

void print_m(const int (*p)[4], int size)
{
    // '*p' demek 'p[0]' demektir.
    //++p; // Burada 'a' dizisinin ikinci 'int[4]' tÃ¼rÃ¼nden elemanÄ±nÄ±n adresi iÅŸaret edilir duruma gelecektir.

    while(size--){
        for(int i = 0; i < 4; ++i){
            printf("%d ", (*p)[i]); // Buradaki '(*p)[i]' ifadesi ile 'p' pointer parametrenin iÅŸaret ettiÄŸi 'int(*)[4]' tÃ¼rÃ¼nden nesnenin elemanlarÄ±na sÄ±rasÄ±yla eriÅŸiliyor.
        }

        ++p;
        printf("\n");
    }

    printf("~~~~~~~~~~~~~~~~~~~\n");
}

int main(void)
{
    int a[5][4] = { 
        {1, 1, 1, 1},
        {2, 2, 2, 2},
        {3, 3, 3, 3},
        {4, 4, 4, 4},
        {1, 1, 1, 1},
    };

    print_m(a, 5);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã§ok boyutlu dizilerin kullanÄ±ldÄ±ÄŸÄ± `print_m` fonksiyonlarÄ±nÄ±nÄ±n hepsi aynÄ± iÅŸi yapmaktadÄ±r, bunun bu zamana kadar alÄ±nan derslerden dolayÄ± kolayca anlaÅŸÄ±lÄ±yor olmasÄ± gerekir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

// 'int (*p)[4]' bir tÃ¼rdÃ¼r ve bu tÃ¼rdeki '[4]' kÄ±smÄ± eleman sayÄ±sÄ± deÄŸildir, tÃ¼r bilgisinin bir bileÅŸenidir.
//void print_m(const int (*p)[4], int size)
//{
//    for(int i = 0; i < size; ++i){
//        for(int k = 0; k < size; ++k){
//            printf("%d ", p[i][k]);
//        }
//        printf("\n");
//    }
//    printf("~~~~~~~~~~~~~~~~~~~~/n");
//}

void print_m_v1(const int (*p)[4], int size)
{
    for(int i = 0; i < size; ++i){
        print_array(*p, 4);
        ++p;
        printf("\n");
    }

    printf("~~~~~~~~~~~~~~~~~~~\n");
}

void print_m_v2(const int (*p)[4], int size)
{
    while(size--)
        print_array(*p++, 4);
    
    printf("~~~~~~~~~~~~~~~~~~~\n");
}

int main(void)
{
    int a[5][4] = { 
        {1, 1, 1, 1},
        {2, 2, 2, 2},
        {3, 3, 3, 3},
        {4, 4, 4, 4},
        {1, 1, 1, 1},
    };

    print_m(a, 5);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã§ok boyutlu dizileri yeni Ã¶ÄŸrenenlerin zorlandÄ±ÄŸÄ± Ã§ok boyutlu dizilerin tÃ¼rlerinin anlaÅŸÄ±labilmesi iÃ§in incelenebilir. </br>
Birbirine benzer iÅŸlemleri farklÄ± dizi tÃ¼rleri iÃ§in yapan kodlarÄ± da birbirine benzer olan fonksiyonlarÄ±n tanÄ±mlarÄ± ve bu fonksiyonlara yapÄ±lan Ã§aÄŸrÄ±lar incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

// AÅŸaÄŸÄ±daki fonksiyonun adÄ± "Print Ramdom Matrisks" sÃ¶zcÃ¼klerinden gelmektedir.
// AÅŸaÄŸÄ±daki fonksiyon 'int(*)[8]' tÃ¼rÃ¼nden pointer olarak aldÄ±ÄŸÄ± parametredeki dizinin elemanlarÄ±nÄ± standar Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶ndermektedir.
void print_rm8(const int (*p)[8], int size)
{
    for(int i = 0; i < size; ++i){
        for(int k = 0; k < 8; ++k)
            printf("%d", p[i][k]);
        printf("\n");
    }
    printf("~~~~~~~~~~~~~~~~\n");
}

// AÅŸaÄŸÄ±daki fonksiyonun adÄ± "Set Ramdom Matrisks" sÃ¶zcÃ¼klerinden gelmektedir.
// AÅŸaÄŸÄ±daki fonksiyon 'int(*)[8]' tÃ¼rÃ¼nden pointer olarak aldÄ±ÄŸÄ± parametredeki dizinin elemanlarÄ±na rastgele deÄŸerler atamaktadÄ±r.
void set_rm8(int (*p)[8], int size)
{
    for(int i = 0; i < size; ++i){
        for(int k = 0; k < 8; ++k)
            p[i][k] = rand() % 10;
    }
}


// AÅŸaÄŸÄ±daki fonksiyonun adÄ± "Print Ramdom Matrisks" sÃ¶zcÃ¼klerinden gelmektedir.
// AÅŸaÄŸÄ±daki fonksiyon 'int(*)[5]' tÃ¼rÃ¼nden pointer olarak aldÄ±ÄŸÄ± parametredeki dizinin elemanlarÄ±nÄ± standar Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶ndermektedir.
void print_rm5(const int (*p)[5], int size)
{
    for(int i = 0; i < size; ++i){
        for(int k = 0; k < 5; ++k)
            printf("%d", p[i][k]);
        printf("\n");
    }
    printf("~~~~~~~~~~~~~~~~\n");
}

// AÅŸaÄŸÄ±daki fonksiyonun adÄ± "Set Ramdom Matrisks" sÃ¶zcÃ¼klerinden gelmektedir.
// AÅŸaÄŸÄ±daki fonksiyon 'int(*)[5]' tÃ¼rÃ¼nden pointer olarak aldÄ±ÄŸÄ± parametredeki dizinin elemanlarÄ±na rastgele deÄŸerler atamaktadÄ±r.
void set_rm5(int (*p)[5], int size)
{
    for(int i = 0; i < size; ++i){
        for(int k = 0; k < 5; ++k)
            p[i][k] = rand() % 10;
    }
}



// AÅŸaÄŸÄ±daki fonksiyonun adÄ± "Print Ramdom Matrisks" sÃ¶zcÃ¼klerinden gelmektedir.
// AÅŸaÄŸÄ±daki fonksiyon 'int(*)[10]' tÃ¼rÃ¼nden pointer olarak aldÄ±ÄŸÄ± parametredeki dizinin elemanlarÄ±nÄ± standar Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶ndermektedir.
void print_rm10(const int (*p)[10], int size)
{
    for(int i = 0; i < size; ++i){
        for(int k = 0; k < 10; ++k)
            printf("%d", p[i][k]);
        printf("\n");
    }
    printf("~~~~~~~~~~~~~~~~\n");
}

// AÅŸaÄŸÄ±daki fonksiyonun adÄ± "Set Ramdom Matrisks" sÃ¶zcÃ¼klerinden gelmektedir.
// AÅŸaÄŸÄ±daki fonksiyon 'int(*)[10]' tÃ¼rÃ¼nden pointer olarak aldÄ±ÄŸÄ± parametredeki dizinin elemanlarÄ±na rastgele deÄŸerler atamaktadÄ±r.
void set_rm10(int (*p)[10], int size)
{
    for(int i = 0; i < size; ++i){
        for(int k = 0; k < 10; ++k)
            p[i][k] = rand() % 10;
    }
}

int main(void)
{
    // AÅŸaÄŸÄ±daki dÃ¶rt dizi dizi bildirilmiÅŸtir ve Ã¼Ã§ farklÄ± dizi tÃ¼rÃ¼ vardÄ±r, 'a' ve 'd' dizilerinin elemanlarÄ±nÄ±n tÃ¼rÃ¼('int[8]' tÃ¼rÃ¼) aynÄ±dÄ±r. 
    int a[4][8]; // 'a' dizisi'int[4][8]' tÃ¼rÃ¼ndedir ve elemanlarÄ± 'int[8]' tÃ¼rÃ¼nden olan 4 elemanlÄ± bir dizidir. Bu dizi 'int x[32]' dizisiymiÅŸ gibi kullanÄ±labilir.
    int b[10][5]; // 'b' dizisi'int[10][5]' tÃ¼rÃ¼ndedir ve elemanlarÄ± 'int[5]' tÃ¼rÃ¼nden olan 10 elemanlÄ± bir dizidir. Bu dizi 'int x[50]' dizisiymiÅŸ gibi kullanÄ±labilir.
    int c[6][10]; // 'c' dizisi 'int[6][10]' tÃ¼rÃ¼ndedir ve elemanlarÄ± 'int[10]' tÃ¼rÃ¼nden olan 6 elemanlÄ± bir dizidir. Bu dizi 'int x[60]' dizisiymiÅŸ gibi kullanÄ±labilir.
    int d[5][8]; // 'd' dizisi 'int[5][8]' tÃ¼rÃ¼ndedir ve elemanlarÄ± 'int[8]' tÃ¼rÃ¼nden olan 5 elemanlÄ± bir dizidir. Bu dizi 'int x[40]' dizisiymiÅŸ gibi kullanÄ±labilir.

    randomize();
    
    set_rm8(a, 4);
    set_rm8(d, 4);
    print_rm8(a, 4);
    print_rm8(d, 4);


    set_rm5(b, 10);
    print_rm5(b, 10);


    set_rm10(c, 6);
    print_rm10(c, 6);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir Ã¶nceki programda yazÄ±lmÄ±ÅŸ olan fonksiyonlarÄ± genel(generic) olarak nasÄ±l yazÄ±labileceÄŸi incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

// Temel elemanlarÄ±nÄ±n tÃ¼rÃ¼ 'int' tÃ¼rÃ¼nden olan iki boyutlu bir dizinin elemanlarÄ±na rastgele deÄŸer atayan fonksiyon.
void set_matrix(int* p, int row, int col)
{
    for(int i = 0; i < row; ++i){
        for(int k = 0; k < col; ++k)
             p[i * col + k] = rand() % 10;
    }
}

// Temel elemanlarÄ±nÄ±n tÃ¼rÃ¼ 'int' tÃ¼rÃ¼nden olan iki boyutlu bir dizinin elemanlarÄ±nÄ± 'standard output'a gÃ¶nderen fonksiyon.
void print_matrix(const int* p, int row, int col)
{
    for(int i = 0; i < row; ++i){
        for(int k = 0; k < col; ++k)
            printf("%d", p[i * col + k]);
        printf("\n"); 
    }

    printf("~~~~~~~~~~~~~~~~\n");
}

int main(void)
{
    // AÅŸaÄŸÄ±daki dÃ¶rt dizi dizi bildirilmiÅŸtir ve Ã¼Ã§ farklÄ± dizi tÃ¼rÃ¼ vardÄ±r, 'a' ve 'd' dizilerinin elemanlarÄ±nÄ±n tÃ¼rÃ¼('int[8]' tÃ¼rÃ¼) aynÄ±dÄ±r. 
    int a[4][8]; // 'a' dizisi'int[4][8]' tÃ¼rÃ¼ndedir ve elemanlarÄ± 'int[8]' tÃ¼rÃ¼nden olan 4 elemanlÄ± bir dizidir. Bu dizi 'int x[32]' dizisiymiÅŸ gibi kullanÄ±labilir.
    int b[10][5]; // 'b' dizisi'int[10][5]' tÃ¼rÃ¼ndedir ve elemanlarÄ± 'int[5]' tÃ¼rÃ¼nden olan 10 elemanlÄ± bir dizidir. Bu dizi 'int y[50]' dizisiymiÅŸ gibi kullanÄ±labilir.
    int c[6][10]; // 'c' dizisi 'int[6][10]' tÃ¼rÃ¼ndedir ve elemanlarÄ± 'int[10]' tÃ¼rÃ¼nden olan 6 elemanlÄ± bir dizidir. Bu dizi 'int z[60]' dizisiymiÅŸ gibi kullanÄ±labilir.
    int d[5][8]; // 'd' dizisi 'int[5][8]' tÃ¼rÃ¼ndedir ve elemanlarÄ± 'int[8]' tÃ¼rÃ¼nden olan 5 elemanlÄ± bir dizidir. Bu dizi 'int t[40]' dizisiymiÅŸ gibi kullanÄ±labilir.

    randomize();
    
    // AÅŸaÄŸÄ±daki fonksiyon Ã§aÄŸrÄ±larÄ±nda C++ dilinde senteks hatasÄ± ve C dilinde derleyici uyarÄ± iletisi verecektir.
    set_matrix(a, 4, 8);
    set_matrix(b, 10, 5);
    set_matrix(c, 6, 10);
    set_matrix(d, 5, 8);

    print_matrix(a, 4, 8);
    print_matrix(b, 10, 5);
    print_matrix(c, 6, 10);
    print_matrix(d, 5, 8);


    // AÅŸaÄŸÄ±daki fonksiyon Ã§aÄŸrÄ±larÄ±nda C derleyicisi uyarÄ± iletisi vermeyecektir Ã§Ã¼nkÃ¼ 'a[0]' ifadesi 'array decay' iel '&a[0][0]' ifadesine Ã§evrilecektir ve '&a[0][0]' ifadesinin tÃ¼rÃ¼ 'int*' tÃ¼rÃ¼dÃ¼r.
    set_matrix(a[0], 4, 8);
    set_matrix(b[0], 10, 5);
    set_matrix(c[0], 6, 10);
    set_matrix(d[0], 5, 8);
    
    print_matrix(a[0], 4, 8);
    print_matrix(b[0], 10, 5);
    print_matrix(c[0], 6, 10);
    print_matrix(d[0], 5, 8);


    // AÅŸaÄŸÄ±daki fonksiyon Ã§aÄŸrÄ±larÄ±nda C derleyicisi uyarÄ± iletisi vermeyecektir Ã§Ã¼nkÃ¼ '&a[0][0]' ifadesinin tÃ¼rÃ¼ 'int*' tÃ¼rÃ¼dÃ¼r.
    set_matrix(&a[0][0], 4, 8);
    set_matrix(&b[0][0], 10, 5);
    set_matrix(&c[0][0], 6, 10);
    set_matrix(&d[0][0], 5, 8);
    
    print_matrix(&a[0][0], 4, 8);
    print_matrix(&b[0][0], 10, 5);
    print_matrix(&c[0][0], 6, 10);
    print_matrix(&d[0][0], 5, 8);


    // AÅŸaÄŸÄ±daki fonksiyon Ã§aÄŸrÄ±larÄ±nda C derleyicisi uyarÄ± iletisi ve C++ dili sÃ¶zdizim hatasÄ±(syntax error) vermeyecektir Ã§Ã¼nkÃ¼ tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapÄ±lÄ±yor.
    set_matrix((int*)a, 4, 8);
    set_matrix((int*)b, 10, 5);
    set_matrix((int*)c, 6, 10);
    set_matrix((int*)d, 5, 8);

    print_matrix((int*)a, 4, 8);
    print_matrix((int*)b, 10, 5);
    print_matrix((int*)c, 6, 10);
    print_matrix((int*)d, 5, 8);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir Ã¶nceki programda yazÄ±lmÄ±ÅŸ olan fonksiyonlarÄ± genel(generic) olarak nasÄ±l yazÄ±labileceÄŸi incelenebilir ama buradaki yÃ¶ntemde tÃ¼r bilgisi kaybedildiÄŸi iÃ§in kullanÄ±mda **ub** durumlarÄ± oluÅŸabilmektedir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

// AÅŸaÄŸÄ±daki gibi 'void*' tÃ¼rÃ¼nden parametre alan fonksiyon tanÄ±mlandÄ±ÄŸÄ±nda tÃ¼r bilgisi ortadan kaldÄ±rÄ±ldÄ±ÄŸÄ± iÃ§in sÃ¶zdizim kontrolÃ¼(syntax control) zorlaÅŸacaktÄ±r Ã§Ã¼nkÃ¼ tÃ¼r bilgisini ortadan kaldÄ±rmÄ±ÅŸ olduk.
void set_matrix(void* vp, int row, int col)
{
    int* p = (int*)vp;

    for(int i = 0; i < row; ++i){
        for(int k = 0; k < col; ++k)
             p[i * col + k] = rand() % 10;
    }
}

// AÅŸaÄŸÄ±daki gibi 'void*' tÃ¼rÃ¼nden parametre alan fonksiyon tanÄ±mlandÄ±ÄŸÄ±nda tÃ¼r bilgisi ortadan kaldÄ±rÄ±ldÄ±ÄŸÄ± iÃ§in sÃ¶zdizim kontrolÃ¼(syntax control) zorlaÅŸacaktÄ±r Ã§Ã¼nkÃ¼ tÃ¼r bilgisini ortadan kaldÄ±rmÄ±ÅŸ olduk.
void print_matrix(const void* vp, int row, int col)
{
    const int* p = (const int*)vp;

    for(int i = 0; i < row; ++i){
        for(int k = 0; k < col; ++k)
            printf("%d", p[i * col + k]);
        printf("\n"); 
    }

    printf("~~~~~~~~~~~~~~~~\n");
}


int main(void)
{
    // AÅŸaÄŸÄ±daki dÃ¶rt dizi dizi bildirilmiÅŸtir ve Ã¼Ã§ farklÄ± dizi tÃ¼rÃ¼ vardÄ±r, 'a' ve 'd' dizilerinin elemanlarÄ±nÄ±n tÃ¼rÃ¼('int[8]' tÃ¼rÃ¼) aynÄ±dÄ±r. 
    int a[4][8]; // 'a' dizisi'int[4][8]' tÃ¼rÃ¼ndedir ve elemanlarÄ± 'int[8]' tÃ¼rÃ¼nden olan 4 elemanlÄ± bir dizidir. Bu dizi 'int x[32]' dizisiymiÅŸ gibi kullanÄ±labilir.
    int b[10][5]; // 'b' dizisi'int[10][5]' tÃ¼rÃ¼ndedir ve elemanlarÄ± 'int[5]' tÃ¼rÃ¼nden olan 10 elemanlÄ± bir dizidir. Bu dizi 'int y[50]' dizisiymiÅŸ gibi kullanÄ±labilir.
    int c[6][10]; // 'c' dizisi 'int[6][10]' tÃ¼rÃ¼ndedir ve elemanlarÄ± 'int[10]' tÃ¼rÃ¼nden olan 6 elemanlÄ± bir dizidir. Bu dizi 'int z[60]' dizisiymiÅŸ gibi kullanÄ±labilir.
    int d[5][8]; // 'd' dizisi 'int[5][8]' tÃ¼rÃ¼ndedir ve elemanlarÄ± 'int[8]' tÃ¼rÃ¼nden olan 5 elemanlÄ± bir dizidir. Bu dizi 'int t[40]' dizisiymiÅŸ gibi kullanÄ±labilir.

    randomize();
    
    // AÅŸaÄŸÄ±daki iÅŸlemlerde C++ senteks hatasÄ± C derleyicileri de uyarÄ± iletisi verecektir.
    set_matrix(a, 4, 8);
    set_matrix(b, 10, 5);
    set_matrix(c, 6, 10);
    set_matrix(d, 5, 8);

    print_matrix(a, 4, 8);
    print_matrix(b, 10, 5);
    print_matrix(c, 6, 10);
    print_matrix(d, 5, 8);


    // 'set_matrix' fonksiyonuna aÅŸaÄŸÄ±daki gibi 'int[10]' tÃ¼rÃ¼nden dizinin adresi bilerek ya da bilmeyerek gÃ¶nderilebilir ama bu 'ub' durumuna neden olacaktÄ±r.
    int ary_x[10];
    set_matrix(ary_x, 5, 2);
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.16-12.25 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


ğŸ‘‡ AÅŸaÄŸÄ±daki programda yukarÄ±daki programlarda iki boyutlu diziler(matrix) ile ilgili kullanÄ±lan fonksiyonlarÄ±n nasÄ±l Ã¶niÅŸlemci programa yazdÄ±rtÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

#define gsmf(s) void set_rm##s(int (*p)[s], int size) \
{   \
    for(int i = 0; i < size; ++i){  \
        for(int k = 0; k < s; ++k)  \
            p[i][k] = rand() % 10;  \
    }   \
}

#define gpmf(s) void print_matrix##s(const int (*p)[s], int size) \
{   \
    for(int i = 0; i < size; ++i){   \
        for(int k = 0; k < s; ++k)   \
            printf("%d", p[i][k]);   \
        printf("\n");  \
    }  \
    printf("~~~~~~~~~~~~~~~~\n");  \
}

// AÅŸaÄŸÄ±da 'function like macro' kullanÄ±mÄ±yla Ã¶niÅŸlemci programa altÄ± farklÄ± fonksiyon yazdÄ±rÄ±lmaktadÄ±r.
gsmf(5)
gsmf(8)
gsmf(10)

gpmf(5);
gpmf(8);
gpmf(10);


int main(void)
{
    // AÅŸaÄŸÄ±daki dÃ¶rt dizi dizi bildirilmiÅŸtir ve Ã¼Ã§ farklÄ± dizi tÃ¼rÃ¼ vardÄ±r, 'a' ve 'd' dizilerinin elemanlarÄ±nÄ±n tÃ¼rÃ¼('int[8]' tÃ¼rÃ¼) aynÄ±dÄ±r. 
    int a[4][8]; // 'a' dizisi'int[4][8]' tÃ¼rÃ¼ndedir ve elemanlarÄ± 'int[8]' tÃ¼rÃ¼nden olan 4 elemanlÄ± bir dizidir. Bu dizi 'int x[32]' dizisiymiÅŸ gibi kullanÄ±labilir.
    int b[10][5]; // 'b' dizisi'int[10][5]' tÃ¼rÃ¼ndedir ve elemanlarÄ± 'int[5]' tÃ¼rÃ¼nden olan 10 elemanlÄ± bir dizidir. Bu dizi 'int y[50]' dizisiymiÅŸ gibi kullanÄ±labilir.
    int c[6][10]; // 'c' dizisi 'int[6][10]' tÃ¼rÃ¼ndedir ve elemanlarÄ± 'int[10]' tÃ¼rÃ¼nden olan 6 elemanlÄ± bir dizidir. Bu dizi 'int z[60]' dizisiymiÅŸ gibi kullanÄ±labilir.
    int d[5][8]; // 'd' dizisi 'int[5][8]' tÃ¼rÃ¼ndedir ve elemanlarÄ± 'int[8]' tÃ¼rÃ¼nden olan 5 elemanlÄ± bir dizidir. Bu dizi 'int t[40]' dizisiymiÅŸ gibi kullanÄ±labilir.

    randomize();

    set_matrix8(a, 4);
    set_matrix5(b, 10);
    set_matrix10(c, 6);
    set_matrix8(d, 5);

    print_matrix8(a, 4);
    print_matrix5(b, 10);
    print_matrix10(c, 6);
    print_matrix8(d, 5);
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki iki fonksiyon bildirimi birbirine denktir.
- `void foo1(int* p, int size);`
- `void foo1(int p[], int size);`

ğŸ‘‡ AÅŸaÄŸÄ±daki iki fonksiyon bildirimi birbirine denktir.
- `void foo2(int** p, int size);`
- `void foo2(int* p[], int size);`

ğŸ‘‡ AÅŸaÄŸÄ±daki iki fonksiyon bildirimi birbirine denktir.
- `void foo3(int (*p)[10], int size);`
- `void foo3(int p[][10], int size);`


ğŸ§  `int ary[5][10][20];` olarak `ary` adÄ±nda bir Ã¼Ã§ boyutlu dizi tanÄ±mlanabilir, `ary` dizisi `int[5][10][20]` tÃ¼rÃ¼ndendir, `ary` dizisinin elemanlarÄ± `int[10][20]` tÃ¼rÃ¼ndendir, `ary` dizisinin elemanlarÄ±nÄ±n elemanlarÄ± `int[20]` tÃ¼rÃ¼ndendir, `ary` dizisinin elemanlarÄ±nÄ±n elemanlarÄ±nÄ±n elemanlarÄ± `int` tÃ¼rÃ¼ndendir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda tanÄ±mlanan `print_array10` adlÄ± fonksiyonun sadece `int (*)[10]` tÃ¼rleri iÃ§in kullanÄ±labileceÄŸi gÃ¶rÃ¼lmelidir, bu bilgi C++ dilinde daha Ã¶nemli olacaktÄ±r.
```C
#include <stdio.h>

// AÅŸaÄŸÄ±daki 'print_array10' fonksiyonu sadece 10 elemanlÄ±, elemanlarÄ± 'int' tÃ¼rÃ¼nden olan diziler iÃ§in kullanÄ±labilir.
void print_array10(const int (*p)[10])
{
    for(int i = 0; i < 10; ++i){
        printf("%d  ", (*p)[i]);
        //printf("%d  ", p[0][i]); // Bu kullanÄ±m yukarÄ±daki kod ile aynÄ±dÄ±r.
    }
}

int main(void)
{
    int a[10] = { 0 };

    print_array10(&a);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda tanÄ±mlanan `print_array10` adlÄ± fonksiyonun sadece `int (*)[10]` tÃ¼rleri iÃ§in kullanÄ±labileceÄŸi gÃ¶rÃ¼lmelidir, bu bilgi C++ dilinde daha Ã¶nemli olacaktÄ±r.
```C
#include <stdio.h>

void print_array10(const int (*p)[10])
{
    const int* ptr = *p;

    for(int i = 0; i < 10; ++i){
        printf("%d  ", ptr[i]);
    }
}

int main(void)
{
    int a[10] = { 0 };

    print_array10(&a);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda tanÄ±mlanan `print_array10` adlÄ± fonksiyonun sadece `int (*)[10]` tÃ¼rleri iÃ§in kullanÄ±labileceÄŸi gÃ¶rÃ¼lmelidir, bu bilgi C++ dilinde daha Ã¶nemli olacaktÄ±r.
```C
#include <stdio.h>
#include "nutility.h"

void print_array10(const int (*p)[10])
{
    // AÅŸaÄŸÄ±daki 'nutility.h' baÅŸlÄ±k dosyasÄ±nda bulunan 'print_array' fonksiyonuna yapÄ±lan Ã§aÄŸrÄ±lar birbirine denktir.
    print_array(*p, 10);

    print_array(&(*p)[0], 10);
}

int main(void)
{
    int a[10] = { 0 };

    print_array10(&a);
}
```


>â”
> 
> Sorulan soru; 
> 
> AslÄ±nda yeni bir kavram Ã¶ÄŸrendik eskiye yÃ¶nelik, tek boyutlu a dizisini &a ile de kullanÄ±p bir fonksiyona rahatÃ§a geÃ§ebiliriz.
> 
> Cevap;
> 
> Kesinlikle evet.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda C dilinde dizi yazdÄ±rabilecek ilginÃ§ bir **function-like makro** kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

#define gpa(s) void print_array##s(const int (*pa)[s]){ \
    for(int i = 0; i < s; ++i) \
        printf("%d  ", (*pa)[i]); \
    primtf("\n"); \
}

gpa(5);
gpa(10);

int main(void)
{
    int ary1[] = { 1, 5, 7, 3, 9 };
    int ary2[10] = { 0 };

    print_array5(&ary1);
    print_array10(&ary2);
}
```


Ders sonu ...
