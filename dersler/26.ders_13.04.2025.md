# 26.Ders 13.04.2025 ğŸ•˜

Derse 12(09:04)-15(09:40)-15(10:15)-17(11:01)-15(12:13)-13(12:45)-13(12:59) kiÅŸi katÄ±ldÄ±.
---


## Strings in C Continue(C dilinde YazÄ±lar Devam)


ğŸ‘‡ AÅŸaÄŸÄ±daki program girilen bir yazÄ±da kaÃ§ farklÄ± sÃ¶zcÃ¼k olduÄŸu bilgisini Ã§Ä±ktÄ± olarak vermektedir, burada sÃ¶zcÃ¼kleri ayÄ±rmak iÃ§in sadece boÅŸluk karakterleri kabul edilmiÅŸtir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <ctype.h>

#define SIZE 200

#define OUTWORD 0
#define INWORD 1

int main(void)
{
    char str[SIZE];

    printf("bir yazi giriniz: ");
    sgets(str);
    printf("girilen yazi: (%s)\n", str);

    int word_flag = OUTWORD;
    int word_count = 0;

    for(int i = 0; str[i] != '\0'; ++i){
        if(isspace(str[i]))
            word_flag = OUTWORD;
        else if(word_flag == OUTWORD){
            ++word_count;
            word_flag = INWORD;
        }
    }
    
    printf("girilen yazida toplamda %d sÃ¶zcÃ¼k vardir.", word_count);
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki program girilen bir yazÄ±da kaÃ§ melime olduÄŸunu sadece boÅŸluÄŸa bakarak deÄŸil de nokta, virgÃ¼l, Ã¼nlem vb. karakterler(bu karakterler noktalama karakterleridir, Ä°ngilizce olarak "**punctuation characters**" deniliyor) girildiÄŸinde de sÃ¶zcÃ¼kleri sayÄ±p bu bilgiyi Ã§Ä±ktÄ± olarak verecektir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <ctype.h>

#define SIZE 200

#define OUTWORD 0
#define INWORD 1

int is_sep(int ch)
{
    return isspace(ch) || ispunct(ch); 
}

int main(void)
{
    char str[SIZE];

    printf("bir yazi giriniz: ");
    sgets(str);
    printf("girilen yazi: (%s)\n", str);

    int word_flag = OUTWORD;
    int word_count = 0;

    for(int i = 0; str[i] != '\0'; ++i){
        if(is_sep(str[i]))
            word_flag = OUTWORD;
        else if(word_flag == OUTWORD){
            ++word_count;
            word_flag = INWORD;
        }
    }
    
    printf("girilen yazida toplamda %d sÃ¶zcÃ¼k vardir.", word_count);
}
```


ğŸ‘†â— YukarÄ±daki programda kullanÄ±lan `is_sep` fonksiyon kullanÄ±mÄ± belirli bir duruma gÃ¶re belirli bir iÅŸlemin yapÄ±lmasÄ±nÄ± saÄŸlamaktadÄ±r, bu tÃ¼r kullanÄ±mlara "**state machine**" deniliyor, yukarÄ±daki kullanÄ±mda Ã§ok basit bir "**state machine**" kullanÄ±mÄ± olduÄŸu sÃ¶ylenebilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki program girilen yazÄ± tÃ¼rÃ¼ndeki bir sayÄ±yÄ± tam sayÄ± tÃ¼rÃ¼ne Ã§evirmektedir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <ctype.h>

#define SIZE 200

int main(void)
{
    char str[SIZE];

    printf("sayi olarak bir yazi giriniz: ");
    sgets(str);
    printf("girilen yazi: (%s)\n", str);

    int i = 0;
    int is_negative = 0;

    if(str[0] == '-'){
        ++i;
        is_negative = 1;
    }

    int result = 0;
    
    for(; str[i] != '\0'; ++i){
        result = result * 10 + (str[i] - '0');
    }

    if(is_negative)
        result = -result;

    printf("tam sayi: %d\n", result);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program girilen bir rakamÄ± yazÄ±ya Ã§evirmektedir, burada dikkat edilecek nokta sayÄ±nÄ±n basamak deÄŸerlerinin her seferinde birler basamaÄŸÄ±nÄ± elde ettiÄŸimiz iÃ§in sayÄ±yÄ± yazÄ±ya Ã§evirirken tersten yazdÄ±rmak gerekecektir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <ctype.h>

#define SIZE 200

int main(void)
{
    char str[SIZE];
    int number;

    printf("bir tam sayi giriniz: ");
    scanf("%d", &number);

    int is_negative = 0; // Bu deÄŸiÅŸken boolean deÄŸer tutan bayrak deÄŸiÅŸkendir.

    if(number < 0){
        is_negative = 1;
        number = -number;
    }

    int i = 0;

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile kullanÄ±cÄ±dan alÄ±nan tam sayÄ± deÄŸeri yazÄ±ya Ã§evriliyor.
    do{
        str[i++] = (number % 10) + '0'; // Buradaki iÅŸlemde sayÄ±nÄ±n birler basamaÄŸÄ± ile '0' karakterinin sayÄ±sal deÄŸeri toplanarak sayÄ±nÄ±n karakter olarak sayÄ±sal deÄŸeri elde ediliyor, kullanÄ±lan karakter kodlamasÄ± ne olursa olsun rakamlar 0-9 sÄ±ralÄ± olduÄŸu kesin olduÄŸu iÃ§in bu iÅŸlem yapÄ±labiliyor.
        number /= 10;
    }while(number);
    
    if(is_negative){
        str[i++] = '-';
    }

    str[i] = '\0'; // Dizi sonu elemanÄ± ekleniyor, yoksa 'ub' oluÅŸmasÄ±na neden olabilir.
    
    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼de yazÄ± ters Ã§evrilmektedir.
    for(int j = 0; j < i / 2; ++j){
        char temp = str[j];
        str[j] = str[i - 1 - j];
        str[i - 1 - j] = temp;
    }

    printf("yazi = (%s)\n", str);
}
```


 Bayrak deÄŸiÅŸkenlerin adlandÄ±rmalarÄ±nda iki tane **convension** mevcut, bunlar;
1. Ä°simler **someoneword_flag** ÅŸeklinde tanÄ±mlanabilir.
2. Ä°simler **is_** ile baÅŸlayÄ±p neyle ilgiliyse onun bilgisinin eklenmesi ÅŸeklinde adlandÄ±rmaktÄ±r.


## Pointers (Kursun Ä°kinci YarÄ±sÄ±nÄ±n baÅŸlangÄ±cÄ±) 

â—â—â— **Pointer** demen adres demektir. C ya da C++ diliyle ilgili bir konuÅŸmada **pointer** sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n geÃ§tiÄŸi yerler **adres** olarak dÃ¼ÅŸÃ¼nÃ¼lÃ¼rse bir anlam farklÄ±lÄ±ÄŸÄ± oluÅŸmaz.

Programlama dillerinin bÃ¼yÃ¼k bir Ã§oÄŸunluÄŸunda adres dilin **sÃ¶zdiziminin(syntax)** bir bileÅŸeni deÄŸildir, **adres** donanÄ±ma yakÄ±n bir kavramdÄ±r.

C esas olarak bir sistem programlama dili olduÄŸu iÃ§in yani donanÄ±ma yakÄ±n uygulamalarÄ±n geliÅŸtirilmesinde kullanÄ±lan bir dil olduÄŸu iÃ§in C dilinde **adres** kavramÄ±nÄ±n olmasÄ± gerekli ve iyidir, bir dilde **pointer** kavramÄ±nÄ±n olmasÄ± donanÄ±m seviyesinde iÅŸlem yapÄ±labilmesini saÄŸlÄ±yor.

â— Uygulama programcÄ±lÄ±ÄŸÄ± tarafÄ±nda kullanÄ±lan dillerde **pointer** kavramÄ±nÄ±n olmasÄ± dili zorlaÅŸtÄ±racaktÄ±r bu nedenle bu alanda kullanÄ±lan dillerde **pointer** kavramÄ± bulunmaz.

Adres kavramÄ± donanÄ±ma yakÄ±n bir kavramdÄ±r, C dili donanÄ±ma yakÄ±n iÅŸlemlerin yapÄ±lmasÄ±nda kullanÄ±lan bir dil olduÄŸu iÃ§in adresler Ã¼zerinde iÅŸlem yapabilmeyi gerektirir.

DeÄŸiÅŸkenlerin adreslerini deÄŸiÅŸkenlerde tutacaÄŸÄ±z, fonksiyonlarÄ±n adreslerini fonksiyonlara gÃ¶ndereceÄŸiz, hatta dizilerde adresleri tutacaÄŸÄ±mÄ±z kodlar yazacaÄŸÄ±z.

âš ï¸ **Pointer** konusunda anlatÄ±lacaklar Ã§oÄŸunlukla C++ dili iÃ§in de geÃ§erlidir bu nedenle aynÄ± zamanda C++ ta Ã¶ÄŸrenilmektedir.



ğŸ§­ C dili **adresleri(Pointers)** iki ana Ã¶beÄŸe ayÄ±rmaktadÄ±r; 
1. **Object pointers**: Nesnelerin adresleri.
2. **Function pointers**: FonksiyonlarÄ±n adresleri. Kursun en Ã¶nemli konularÄ±ndan biridir.

â—â—â— "_DeÄŸiÅŸken adresi ne demek?_" sonusunu cevabÄ± ÅŸu olacaktÄ±r: Runtime'da o deÄŸiÅŸkenin bellekte nerede tutuluyor bilgisidir fakat bu adres Ã¼zerinde Ã§alÄ±ÅŸÄ±lan sisteme gÃ¶re gerÃ§ek fiziksel adres olabilir ya da sanal adres olabilir ama nihayetinde o adres bilgisiyle ilgili **object** Ã¼zerinde iÅŸlemler yapÄ±labiliyor. Bir iÅŸletim istemi Ã¼zerinde Ã§alÄ±ÅŸan programlar genellikle sanal adresleri bilir, bunun bÃ¶yle olmasÄ±nÄ±n nedeni gÃ¼venliktir.


â—â—â— Her ifadenin bir tÃ¼rÃ¼ vardÄ±r, her ifadenin bir deÄŸeri vardÄ±r(istisna olarak **void** tÃ¼rÃ¼nden ifadelerin deÄŸeri yoktur). Bir kod parÃ§asÄ±na **ifade(expression)** diyebilmek iÃ§in o kod parÃ§asÄ±nÄ±n tÃ¼rÃ¼ olmalÄ± ve bir deÄŸeri(**void** de olabilir) olmalÄ±.



ğŸ§  Basic type tÃ¼rleri aÅŸaÄŸÄ±daki gibi 15 tanedir ve her bir tÃ¼r iÃ§in ayrÄ± bir **pointer(adresi)** tÃ¼rÃ¼ vardÄ±r;
1. 1 byte tÃ¼rler
    - `_Bool`
    - `char`
    - `signed char`
    - `unsigned char`
2. `short` tam sayÄ± tÃ¼rleri
    - `short`
    - `unsigned short`
3. `int` tam sayÄ± tÃ¼rleri
    - `int`
    - `unsigned int`
4. `long` tam sayÄ± tÃ¼rleri
    - `long`
    - `unsigned long`
5. `long long` tam sayÄ± tÃ¼rleri
    - `long long`
    - `unsigned long long` 
6. OndalÄ±klÄ± sayÄ± tÃ¼rleri
    - `float`
    - `double`
    - `long double`


ğŸ§­ Bir tÃ¼rÃ¼n **pointer**'Ä±nÄ± kullanmak istediÄŸimizde tÃ¼rÃ¼n sonuna **asterisk(*)** karakterinin eklenmesi yeterlidir, aÅŸaÄŸÄ±da temel tÃ¼rlerin pointer olarak kullanÄ±mlarÄ± yer almaktadÄ±r;
- `_Bool`               -->     `_Bool*`
- `char`                -->     `char*`
- `signed char`         -->     `signed char*`
- `unsigned char`       -->     `unsigned char*`
- `short`               -->     `short*`
- `unsigned short`      -->     `unsigned short*`
- `int`                 -->     `int*`
- `unsigned int`        -->     `unsigned int*`
- `long`                -->     `long*`
- `unsigned long`       -->     `unsigned long*`
- `long long`           -->     `long long*`
- `unsigned long long`  -->     `unsigned long long*`
- `float`               -->     `float*`
- `double`              -->     `double*`
- `long double`         -->     `long double*`



â—â—â— **Pointer** ile **pointer deÄŸiÅŸken** bibirinden farklÄ± kavramlardÄ±r. 
1. **Pointer** denildiÄŸinde herhangi bir adres **ifadesinden(expression)** bahsedilmektedir bu ifade **R-value** ya da **L-value** olabilir.  
2. **pointer deÄŸiÅŸken** denildiÄŸinde sadece **L-value** olan deÄŸiÅŸkenlerden bahsedilmektedir.


ğŸ‘‡ AÅŸaÄŸÄ±daki program C ve C++ **sÃ¶zdizimine(syntax)** gÃ¶re primitive tÃ¼rlerin adresini tutacak olan bir pointer deÄŸiÅŸken nasÄ±l tanÄ±mlanÄ±r bunu anlamak iÃ§in incelenebilir.
```C
int main(void)
{
    int x = 10;
    double dval = 2.56;

    int* ptr1; // Buradaki 'ptr1'in tÃ¼rÃ¼ formal ÅŸekilde 'pointer to int' olarak ifade edilmektedir.
    int *ptr2;
    double* ptrd1; // Buradaki 'ptrd1'in tÃ¼rÃ¼ formal ÅŸekilde 'pointer to double' olarak ifade edilmektedir.
}
```



â—â—â— Bildirimlerde kullanÄ±lan **asterisk**, **square brackets** Ã¶ÄŸelerine(varlÄ±klarÄ±na) **declerator** deniliyor, bu varlÄ±klar deÄŸiÅŸkenlerin tÃ¼rÃ¼nÃ¼ anlatmaya yÃ¶nelikse onlara **declerator** deniliyor. 

Pointer bildirimlerinde **asterisk(*)** token'Ä±nÄ±n nerede kullanÄ±ldÄ±ÄŸÄ± Ã¶nemli deÄŸildir, mesela `int* prt;` ve `int *prt;` kullanÄ±mlarÄ± aynÄ± anlama gelmektedir.

â—â—â—**Comma seperator** ile deÄŸiÅŸken bildirimlerinde aÅŸaÄŸÄ±daki durumlara dikkat etmek gerekiyor;
- NasÄ±l `int ary[10], y, z;` bildiriminde sadece "ary" deÄŸiÅŸkeni diziyse diÄŸer iki deÄŸiÅŸken `int` tÃ¼rÃ¼ndedir. 
- `int* p1, p2, p3;` birldirimi ile `int *p1, p2, p3;` bildirimi aynÄ±dÄ±r ve burada sadece "p1" int* tÃ¼Ã¼rndedir diÄŸer iki deÄŸiÅŸken int tÃ¼rÃ¼ndedir.
- `int x, *p, y, *ary1[10], ary2[23];` buradaki bildirimde 



â—â—â— Pointer deÄŸiÅŸkenlerin storage ihtiyacÄ± ne kadardÄ±r diye dÃ¼ÅŸÃ¼nÃ¼ldÃ¼ÄŸÃ¼nde bir **pointer** hangi **Object** tÃ¼rÃ¼nÃ¼n adresini tutuyor olursa olsun kaplayacaklarÄ± bellek adresinin boyutu programÄ±n derlendiÄŸi donanÄ±m mimarisine gÃ¶re deÄŸiÅŸmektedir, mesela 32 bit mimaride 4 byte, 64 bit mimride 8 byte olacaktÄ±r.

â—â—â— **Object pointer** sizeof deÄŸeri(storage deÄŸeri) sabit bir deÄŸerdir, tam sayÄ±, floating sayÄ±, ileride gÃ¶rÃ¼lecek olan **user defined** tÃ¼rlerin bellekte kapladÄ±ÄŸÄ± alan sabit bir deÄŸer olacaktÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda temel tÃ¼rlerin pointer tÃ¼rlerinin ne kadar yer kapladÄ±ÄŸÄ± bilgisi incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    printf("sizeof(_Bool) = %zu\n", sizeof(_Bool));
    printf("sizeof(_Bool*) = %zu\n", sizeof(_Bool*));

    printf("sizeof(char) = %zu\n", sizeof(char));
    printf("sizeof(char*) = %zu\n", sizeof(char*));

    printf("sizeof(short) = %zu\n", sizeof(short));
    printf("sizeof(short*) = %zu\n", sizeof(short*));

    printf("sizeof(int) = %zu\n", sizeof(int));
    printf("sizeof(int*) = %zu\n", sizeof(int*));

    printf("sizeof(long) = %zu\n", sizeof(long));
    printf("sizeof(long*) = %zu\n", sizeof(long*));

    printf("sizeof(long long) = %zu\n", sizeof(long long));
    printf("sizeof(long long*) = %zu\n", sizeof(long long*));

    printf("sizeof(float) = %zu\n", sizeof(float));
    printf("sizeof(float*) = %zu\n", sizeof(float*));

    printf("sizeof(double) = %zu\n", sizeof(double));
    printf("sizeof(double*) = %zu\n", sizeof(double*));

    printf("sizeof(long double) = %zu\n", sizeof(long double));
    printf("sizeof(long double*) = %zu\n", sizeof(long double*));

   return 0; 
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda pointer deÄŸiÅŸkenlerin bildirimlerine gÃ¶re Ã¶mÃ¼r ve kapsamlarÄ±nÄ±n nasÄ±l olacaÄŸÄ± incelenebilir.
```C

int *gb; // static Ã¶mÃ¼rlÃ¼ global deÄŸiÅŸken.

void foo(int *p)
{
    int* ip; // otamatic Ã¶mÃ¼rlÃ¼ local deÄŸiÅŸken.
    static char* cp; // static Ã¶mÃ¼rlÃ¼ local deÄŸiÅŸken.
}
```


âš ï¸ Ä°leriki on ders boyunca **pointer** konusuyla ilgili konular iÅŸlenecek.


âš ï¸ Dinamik Ã¶mÃ¼r ve dinamik Ã¶mÃ¼rlÃ¼ nesneler dolaylÄ± olarak **pointer** konusuyla ilgili olduÄŸu iÃ§in bu konu tamamen Ã¶ÄŸrenildikten sonra gelinecek konulardÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bazÄ± **ifadelerin(expression)** tÃ¼rleri ve value kategorilerinin ne olduÄŸu incelenebilir.
```C
#include <stdio.h>

int foo(void);

int main(void)
{
    int x = 5;
    int a[5] = { 0 };

    // AÅŸaÄŸÄ±daki yorum satÄ±rlarÄ±nda bazÄ± ifadelerin tÃ¼rleri ve value kategorileri yazÄ±lmÄ±ÅŸtÄ±r.
    // 34       --> int type, R-value 
    // x        --> int type, L-value
    // x + 17   --> int type, R-value
    // a[4]     --> int type, L-value
    // foo()    --> int type, R-value
    
    // YukarÄ±daki ifadelerin tÃ¼rleri gibi, pointer'lar ile oluÅŸturulan ifadelerin de tÃ¼rleri ve value kategorileri vardÄ±r ve bu ifadeye gÃ¶re deÄŸiÅŸebilir.
}
```



ğŸ‘‡ **Pointer** deÄŸiÅŸkenlere de diÄŸer deÄŸiÅŸkenler gibi iki farklÄ± ÅŸekilde yani **initialization** ya da **assignment** yÃ¶ntemleriyle deÄŸer verilebiliyor. 
```C
#include <stdio.h>

int main(void)
{
    int* p = expr;
    
    p = ;
}
```

### Pointer Operators 

AÅŸaÄŸÄ±daki operatÃ¶rler 

- `&` **address of operator**
- `*` **dereferencing operator**(**indirection operator** ama standardÄ±n kullandÄ±ÄŸÄ± ad deÄŸildir)
- `[]` **subscript operator**(**Index operator** ama standardÄ±n kullandÄ±ÄŸÄ± ad deÄŸildir)
- `->` **Member selection operator**(**arraw operator** ama standardÄ±n kullandÄ±ÄŸÄ± ad deÄŸildir)

â— BazÄ± operatÃ¶rler aynÄ± **token**'dÄ±r ve gÃ¶sterimi aynÄ±dÄ±r ama farklÄ± bir operatÃ¶r olarak yorumlanÄ±rlar, bu tÃ¼re dahil olan operatÃ¶rler: `+`, `-`, `&`, `*` operatÃ¶rleridir.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.41-11.01 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***

#### Address Of Operator(`&` Operator)

"**Address Of Operator(`&` operator)**" operatÃ¶rÃ¼, **unery** ve **prefix** yani tek operand alan Ã¶n ek konumunda kullanÄ±lan bir operatÃ¶rdÃ¼r.

"**Address Of Operator(`&` operator)**" operatÃ¶rÃ¼, operandÄ± olan ifadeler **L-value expression** olmalÄ±dÄ±r.


â—â—â— Bir ifadenin value kategorisinin ne olduÄŸu bilinmiyorsa o ilfadenin Ã¶nÃ¼ne `&` operatÃ¶rÃ¼ eklendiÄŸinde **sÃ¶zdizim hatasÄ±(syntax error)** oluÅŸuyorsa o ifadenin **R-value** olduÄŸu anlaÅŸÄ±lÄ±r, eÄŸer hata vermiyorsa ifadenin kategorisi **L-value** olduÄŸu anlaÅŸÄ±lÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programdan **`&` operator** ile oluÅŸturulan ifadelerin tÃ¼rlerinin ne olacaÄŸÄ± incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 5;
    double y = 5.;
    
    &(x + 3); // Bu ifade 'R-value expression' olduÄŸu iÃ§in sÃ¶zdizim hatasÄ±(syntax error) oluÅŸacaktÄ±r.
    &x; // Bu ifadenin tÃ¼rÃ¼ 'int*' tÃ¼rÃ¼dÃ¼r.
    &y; // Bu ifadenin tÃ¼rÃ¼ 'double*' tÃ¼rÃ¼dÃ¼r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan bazÄ± tÃ¼rlerin C++ dilinde tÃ¼rlerinin ne olduÄŸu gÃ¶rÃ¼lebilir, buradaki kullanÄ±m sadece bilgi olmasÄ± iÃ§in paylaÅŸÄ±ldÄ±, C dili Ã¶ÄŸreniminde dikkate alÄ±nmayabilir.
```Cpp
#include <iostream>
#include <typeinfo>

int main(void)
{
    double x = 5.;
    int y = 5;
    
    std::count<< typid(&x).name() << '\n'; // burada 'double *' Ã§Ä±ktÄ±sÄ± Ã¼retilir
    std::count<< typid(&y).name() << '\n'; // burada 'int *' Ã§Ä±ktÄ±sÄ± Ã¼retilir
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan pointer deÄŸiÅŸkenlerde ilk deÄŸer verme ve deÄŸer atama iÅŸlemlerinin nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 5;
    int y = 10;

    int* p = &x; // p deÄŸiÅŸkenine 'x' deÄŸiÅŸkeninin adresi ile ilk deÄŸer veriliyor.

    p = &y; // p deÄŸiÅŸkenine 'y' deÄŸiÅŸkeninin adresini atÄ±yoruz.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan pointer deÄŸiÅŸkenlere nasÄ±l deÄŸer atanabileceÄŸi incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 10;
    int y = 20;

    printf("x = %d\n", x);
    x = y; // Burada 'y' deÄŸiÅŸkeninin deÄŸeri 'x' deÄŸiÅŸkeninin deÄŸerine atanÄ±yor.
    printf("x = %d\n", x);

    // AÅŸaÄŸÄ±daki pointer tÃ¼rleri 'x' deÄŸiÅŸkenin adresini saklayacaktÄ±r.
    int* p1 = &x; // Bir 'int *' tÃ¼rÃ¼nden pointer deÄŸiÅŸkene 'x' deÄŸiÅŸkeninin adresi ile ilk deÄŸer veriliyor.
    int* p2 = p1; // Bir 'int *' tÃ¼rÃ¼nden pointer deÄŸiÅŸken baÅŸka bir pointer deÄŸiÅŸkende tutulan deÄŸer ile ilk deÄŸer veriliyor.
    int* p3; // Bir 'int *' tÃ¼rÃ¼nden pointer deÄŸiÅŸken bildirimi(decleration) yapÄ±lÄ±yor.

    p3 = p1; // Bir 'int *' tÃ¼rÃ¼nden pointer deÄŸiÅŸkennin deÄŸeri baÅŸka bir 'int *' tÃ¼rÃ¼nden pointer deÄŸiÅŸkene atanÄ±yor.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan C diline Ã¶zgÃ¼ olarak **pointer** deÄŸiÅŸkenlerin gÃ¶sterdikleri adresin ne olduÄŸunun nasÄ±l ifade edildiÄŸi incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 10;

    // "'p' deÄŸiÅŸkeninin deÄŸeri 'x'in adresidir." ÅŸeklinde bir tanÄ±mlama kullanÄ±lÄ±yor.
    // Idiomatic olarak "'p' deÄŸiÅŸkeni 'x'i gÃ¶steriyor(iÅŸaret ediyor)." ÅŸeklinde bir tanÄ±mlama kullanÄ±lÄ±yor.
    // Idiomatic olarak "'p' points to 'x'." ÅŸeklinde bir tanÄ±mlama kullanÄ±lÄ±yor.
    int* p = &x;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan bir adres deÄŸerinin "_printf_" fonksiyonu ile nasÄ±l standard Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderilebileceÄŸi incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 130;
    int* ptr = &x;

    printf("x'in adresi     = %p\n", &x);
    printf("ptr'nin degeri  = %p\n", ptr);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan bir adres deÄŸerinin nasÄ±l deÄŸiÅŸtirildiÄŸi incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 130;
    int y = 930;
    int* ptr = &x;

    printf("x'in adresi     = %p\n", &x);
    printf("y'in adresi     = %p\n", &y);
    printf("ptr'nin degeri  = %p\n", ptr);

    ptr = &y; // Burada 'ptr' deÄŸiÅŸkenindeki adres veriyi 'y'nin adresi olarak deÄŸiÅŸtiriliyor.

    printf("ptr'nin degeri = %p\n", ptr);
}
```



â— Bir iÅŸletim sistemi altÄ±nda Ã§alÄ±ÅŸan programlarda kullanÄ±lan pointer'larda tutulan adres verileri sanal adres oluyor gerÃ§ek fiziksel adresler olmuyor, bunun bÃ¶yle olmasÄ±nÄ±n nedeni gÃ¼venlik amaÃ§lÄ±dÄ±r. Bir program bir iÅŸletim sistemi Ã¼zerinde Ã§alÄ±ÅŸacaÄŸÄ± zaman bu programÄ± process olarak yÃ¼kleyen programlara "**Loader Program**" denilmektedir. 

âš ï¸ C ve C++ dilerinde bir nesnenin adresinin kendi belirlediÄŸimiz bir bellek alanÄ±nda oluÅŸturulmasÄ±nÄ± saÄŸlayabilecek bir yapÄ± mevcut deÄŸildir.

â—â—â— C ve C++ dilerinde bir nesnenin adresinin deÄŸiÅŸtirilmesi ÅŸeklinde bir iÅŸlem mevcut deÄŸildir, oluÅŸturulan nesnelerin program Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda yer alacaklarÄ± adreslerin belirlenmesi iÅŸlemi C ve C++ dilleriyle yapÄ±lmamaktadÄ±r. 



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan 
```C
#include <stdio.h>

int main(void)
{
    int x = 130;
    int y = 140;

    &x; // Buradaki '&x' ifadesi 'R-value' Ã¶zelliktedir ve bu ifade 'x' deÄŸiÅŸkeninin adresinin deÄŸeridir.
    &x = &y; // Burada sÃ¶zdizim hatasÄ±(syntax error) vardÄ±r 
    &(&x); // Burada sÃ¶zdizim hatasÄ±(syntax error) vardÄ±r, operatÃ¶r inceliÄŸi saÄŸdan sola doÄŸrudur, burada & operatÃ¶rÃ¼ne R-value tÃ¼rÃ¼nde olan '&x' ifadesi operand olarak verildiÄŸi iÃ§in hata vardÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan 
```C
#include <stdio.h>

int main(void)
{
    int x = 130;
    int y = 140;

    int* ptr = &x; // Buradaki ifadedeki 'ptr' pointer deÄŸiÅŸkenine 'x' deÄŸiÅŸkeninin adresi atanÄ±yor ve 'ptr' deÄŸiÅŸkeni program Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda bellekte yer kaplayacaktÄ±r yani 'object' durumundadÄ±r.
}
```


âš ï¸ Kursun ilerleyen derslerindeki(15-20 saat sonraki derlerde) Ã¶nemli bir konu "**pointer to pointer**" konusudur, bu konuda pointerlarÄ±n adresleriyle ilgilenilecektir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan `int` tÃ¼rÃ¼nden deÄŸiÅŸken ve onun adresini tutan `int *` tÃ¼rÃ¼nden bir gÃ¶stericinin deÄŸerlerinin ve adreslerinin ne olduÄŸu incelenebilir. 
```C
#include <stdio.h>

int main(void)
{
    int x = 130;
    int y = 930;
    int* ptr = &x;

    printf("x'in adresi = %p\n", &x);
    printf("y'in adresi = %p\n", &y);
    printf("ptr'nin degeri = %p\n", ptr);
    printf("ptr'nin adresi = %p\n", &ptr);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **array decay** ile bir pointer deÄŸiÅŸkene bir dizi adresinin nasÄ±l atandÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int ary[] = { 2, 6, 7, 3 };
    int* ptr = ary; // Buradaki adres deÄŸeri atama iÅŸleminde 'array decay' kuralÄ±ndan faydalanÄ±lÄ±yor ve dizinin adÄ± derleyici tarafÄ±ndan dizinin ilk elemanÄ±nÄ±n adresine Ã§evriliyor.
    //int* ptr = &ary[0]; // Buradaki adres deÄŸeri atama iÅŸleminde aÃ§Ä±k ÅŸeklilde dizinin ilk elemanÄ±nÄ±n adresi atanmaktadÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda dizi tÃ¼rlerinden deÄŸiÅŸkenlerin pointer ile kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int a[] = { 2, 6, 7, 3 };
    int b[] = { 2, 6, 7, 3 };
    int* ptr = a;

    printf("a dizisinin ilk elamaninin adresi  :  %p\n", a);
    printf("a dizisinin ilk elamaninin adresi  :  %p\n", &a[0]);
    printf("ptr degiskeninin degeri            :  %p\n", ptr);

    ptr = b; // 'array decay' Ã¶zelliÄŸinden faydalanÄ±larak 'b' dizisinin adresi 'ptr' pointer'Ä±na atanÄ±yor.
    ptr = &b[0]; // 'b' dizisinin ilk elemanÄ±nÄ±n adresi 'ptr' pointer deÄŸiÅŸkenine atanÄ±yor, yukarÄ±daki atama iÅŸlemi yapÄ±ldÄ±ÄŸÄ±nda derleyici o atama ifadesini(expression) buradakine Ã§evirmektedir.
}
```



â—â—â— Pointer deÄŸiÅŸkene neler atanabilir; 
1. Bir deÄŸiÅŸkenin adresi atanabilir(`int* ptr = &value;` gibi bir iÅŸlem yapÄ±labilir).
2. Bir pointer deÄŸiÅŸken atanabilir(`ptr = ptrx;` gibi bir iÅŸlem yapÄ±labilir).
3. Bir dizi deÄŸiÅŸkeni atanabilir(`ptr = b;` gibi bir iÅŸlem yapÄ±labilir).
4. Bir dizi deÄŸiÅŸkeninin ilk elemanÄ±nÄ±n adresi atanabilir(`ptr = &b[0];` gibi bir iÅŸlem yapÄ±labilir).



â—Bir dizi adÄ±nÄ± atama operatÃ¶rÃ¼nÃ¼n sol operandÄ± olarak kullanamayÄ±z bunun nedeni derleyicinin dizi adlarÄ±nÄ± **array decay** Ã¶zelliÄŸini uygulayÄ±p dizinin ilk elemanÄ±nÄ±n adresine Ã§evrilmesinden dolayÄ±dÄ±r. 
```C
#include <stdio.h>

int main(void)
{
    int a[] = { 2, 6, 7, 3 };

    a = 23; // Burada sÃ¶zdizim hatasÄ±(syntax error) alÄ±nacaktÄ±r, bunun nedeni 'array decay' davranÄ±ÅŸÄ±nÄ± derleyicinin uygulamasÄ±dÄ±r, ilgili program satÄ±rÄ± '&a[0] = 23;' gibiymiÅŸ gibi yorumlanÄ±r.
}
```



ğŸ‘‡ C dilinde farklÄ± adres tÃ¼rleri arasÄ±nda **Ã¶rtÃ¼lÃ¼(implicit)** dÃ¶nÃ¼ÅŸÃ¼m vardÄ±r ama C++ dilinde bÃ¶yle bir dÃ¶nÃ¼ÅŸÃ¼m yapÄ±lmaz ve **sÃ¶zdizim hatasÄ±(syntax error)** oluÅŸur. 
```C
#include <stdio.h>

int main(void)
{
    double dx = 4.1;
    int* ptr = &dx; // Buradaki gibi bir kullanÄ±m mantÄ±ken yanlÄ±ÅŸ olsa da C dilinde 'legal' bir kullanÄ±mdÄ±r ve sÃ¶zdizim hatasÄ±(syntax error) oluÅŸmaz ama C++ dilinde sÃ¶zdizim hatasÄ±dÄ±r(syntax error).
}
```


â—â—â—YukarÄ±daki programdan da anlaÅŸÄ±lacaÄŸÄ± Ã¼zere C++ dili **Ã¶rtÃ¼lÃ¼(implicity)** dÃ¶nÃ¼ÅŸÃ¼mlerde C diline gÃ¶re daha katÄ±dÄ±r. C ve C++ dillerini karÅŸÄ±laÅŸtÄ±ran makalelerde aÅŸaÄŸÄ±daki tanÄ±mlamalarÄ± sÄ±k gÃ¶rebiliriz;
- C'de weak type control(C dilindeki farklÄ± tÃ¼rden deÄŸerler Ã¶rtÃ¼lÃ¼ olarak birbirine atanabiliyor, bu tÃ¼r atamalar mantÄ±ken doÄŸru deÄŸildir ama C dilinin standardÄ± bu atamalarÄ± legal kabuleder).
- C++ strict type control(C++ dilinde farklÄ± tÃ¼rden deÄŸerler Ã¶rtÃ¼lÃ¼ olarak birbirine Ã§oÄŸu zaman atanamaz ve **sÃ¶zdizim hatasÄ±(syntax error)** oluÅŸur).



ğŸ‘‡ AÅŸaÄŸÄ±daki programda C dilinde bir `int *` tÃ¼rÃ¼nden bir deÄŸiÅŸkene `int` tÃ¼rÃ¼nden atanma iÅŸleminin **legal** olduÄŸu(bu durum mantÄ±ken yanlÄ±ÅŸtÄ±r, bÃ¶yle kod yazÄ±lmamalÄ±dÄ±r) incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 4345;

    int* ptr = x; // C dilinde buradaki kullanÄ±m mantÄ±ken doÄŸru deÄŸildir ama 'legal'dir, derleyici Ã¶rtÃ¼lÃ¼ tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapmaktadÄ±r. C++ dilinde sÃ¶zdizim hatasÄ±dÄ±r(syntax error).
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `int` tÃ¼rÃ¼nden bir deÄŸiÅŸkene `int *` tÃ¼rÃ¼nden bir deÄŸer atamanÄ±n C dilinde **legal** olduÄŸu(bu durum mantÄ±ken yanlÄ±ÅŸtÄ±r, bÃ¶yle kod yazÄ±lmamalÄ±dÄ±r) incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 4345;
    int* ptr = &x;
    int ival;

    ival = ptr; // C dilinde buradaki kullanÄ±m mantÄ±ken doÄŸru deÄŸildir ama 'legal' bir kullanÄ±mdÄ±r, derleyici Ã¶rtÃ¼lÃ¼ tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapmaktadÄ±r. C++ dilinde sÃ¶zdizim hatasÄ±dÄ±r(syntax error).
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.02-12.13 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


â—â—â— Bildirimlerde bildirilen tÃ¼rÃ¼ nitelemekte kullanÄ±lan karakterler(asterisk, square brackets etc.) operatÃ¶r deÄŸildir, bu karakterler teknik aÃ§Ä±dan **declerator** olarak nitelendirilmektedi, **declerator** terimi yerine  **sÃ¶zdizim bileÅŸeni(syntax component)** de denilebilir.


ğŸ‘‡ AÅŸaÄŸÄ±daki program **asterisk**, **square brackets** gibi token'larÄ±n bildirimlerde operatÃ¶r gÃ¶revinde olmadÄ±ÄŸÄ±nÄ± sadece ifadeler(expression) iÃ§erisinde kullanÄ±ldÄ±klarÄ± zaman operatÃ¶r olduklarÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int* ptr; // Buradaki 'asterisk(*)' token'Ä± operatÃ¶r deÄŸildir decleratÃ¶r durumundadÄ±r.
    int ary[10]; // Buradaki 'square brackets([...])' token'larÄ± operatÃ¶r deÄŸildir decleratÃ¶r durumundadÄ±r.

    ptr = ary; // Burada 'array decay' iÅŸlemi ile 'ary' dizisinin ilk elemanÄ±nÄ±n adresi 'ptr' pointer deÄŸiÅŸkenine atanÄ±yor.

    ary[2] = 67; // Buradaki 'square brackets([...])' token'larÄ± operatÃ¶r durumunundadÄ±r.
    *ptr = 
}
```


#### Dereferencing Operand(`*` Operand) (Ä°Ã§erik OperatÃ¶rÃ¼) 


Bu operatÃ¶r **adres operatÃ¶rÃ¼(`&`)** gibi 2. Ã¶ncelik seviyesinde ve bu seviyedeki operatÃ¶r Ã¶ncelik seviyesi saÄŸdan soladÄ±r.

â—â—â— **Dereferencing Operand(iÃ§erik operatÃ¶rÃ¼)** bir **Unary Prefix** operatÃ¶rdÃ¼r ve operandÄ±nÄ±n deÄŸeri adres olmalÄ±dÄ±r.

ğŸ‘‡ AÅŸaÄŸÄ±daki program **dereferencing operand(iÃ§erik operatÃ¶rÃ¼)** operandÄ± adres olmadÄ±ÄŸÄ±nda alÄ±nacak hatayÄ± anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 10;

    *x; // Burada sÃ¶zdizim hatasÄ±(syntax error) oluÅŸacaktÄ±r Ã§Ã¼nkÃ¼ '*' operatÃ¶rÃ¼nÃ¼n operandÄ± bir adres deÄŸil.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program **dereferencing operand(iÃ§erik operatÃ¶rÃ¼)** hangi durumlarda geÃ§erli(legal) olduÄŸu incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 10;
    int a[5] = { 0 };
    int* ptr = &x;

    // AÅŸaÄŸÄ±daki Ã¼Ã§ ifade de legal ve kullanÄ±lmalarÄ± mantÄ±ken doÄŸrudur.
    *&x; // Burada 'x' bir object(nesne), '&x' ifadesi 'x' nesnesinin adres deÄŸeridir bu nedenle '*&x' ifadesi geÃ§erlidir(legal).
    *ptr; // Burada 'ptr' bir nesnedir(object) ve Ã¶zel olarak bir pointer nesnesidir, bu nedenle '*ptr' ifadesi geÃ§erlidir(legal).
    *a; // Burada 'a' bir dizi adÄ±dÄ±r ve 'array decay' uygulandÄ±ÄŸÄ±nda dizinin ilk elemanÄ±nÄ±n adresine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lecektir, bu nedenle '*a' ifadesi geÃ§erlidir(legal).
}
```



â—â—â— **Dereferencing operand(iÃ§erik operatÃ¶rÃ¼)** operandÄ± o adresteki **nesneye(object)** eriÅŸim saÄŸlar. **_*address_** ÅŸeklindeki bir ifade o adresteki **nesnenin(object)** kendisidir. 


ğŸ‘‡ AÅŸaÄŸÄ±daki program **_*address_** ÅŸeklindeki bir ifadenin ne anlama geldiÄŸini anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 10;
    int a[5] = { 0 };
    int* ptr = &x;

    printf("x = %d\n", x);

    *&x = 999; // Burada 'x' deÄŸiÅŸkeninin deÄŸeri '999' yapÄ±lÄ±yor.

    printf("x = %d\n", x);
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki program **_*address_** ÅŸeklindeki bir ifadenin ne anlama geldiÄŸini anlamak iÃ§in incelenebilir, burada **Obfuscation** amaÃ§Ä±yla kullanÄ±labilecek karÄ±ÅŸÄ±k bir ifade mevcuttur.
```C
#include <stdio.h>

int main(void)
{
    int x = 10;
    int a[5] = { 0 };
    int* ptr = &x;

    printf("x = %d\n", x);

    ++*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&x; // Legal bir kullanÄ±m ve bir mantÄ±k hatasÄ± yoktur ama kullanÄ±mÄ± kafa karÄ±ÅŸtÄ±rÄ±cÄ± olacaktÄ±r yani 'Obfuscation' amaÃ§lÄ± kullanÄ±labilir.

    printf("x = %d\n", x);
}
```


ğŸ‘‡ Bir dizi bildirimi `int ary[10];` ÅŸeklindeyse, dizi adÄ± Ã¼zerinden `*ary` oluÅŸturulan bir ifade dizinin ilk elemanÄ±na eriÅŸim saÄŸlayacaktÄ±r, bu durum aÅŸaÄŸÄ±dan incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 10;
    int ary[10] = { 0 };
    int* ptr = &x;

    ary[0] = 123;

    printf("x = %d\n", ary);

    *a = 123; // Burada ifade yukarÄ±da kullanÄ±lan 'ary[0] = 123' ifadesiyle aynÄ± anlama gelmektedir.

    printf("x = %d\n", ary);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program bir dizinin ilk elemanÄ±nÄ±n deÄŸerinin **dereferencing(`*`)** operatÃ¶rÃ¼ ile nasÄ±l deÄŸiÅŸtirildiÄŸini anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int a[5] = { 10, 20, 30, 40, 50 };

    print_array(a, 5);

    *a = 123;

    print_array(a, 5);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program bir **nesnenin(object)** referansÄ±nÄ± tutan pointer tÃ¼rÃ¼ndeki bir deÄŸiÅŸken ve **dereferencing(`*`)** operatÃ¶rÃ¼ ile nasÄ±l deÄŸiÅŸtirilebileceÄŸini anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 5;
    int* ptr = &x;

    printf("x = %d\n", x);

    ++*ptr;
    //++(*ptr); // Buradaki ifade ile bir yukarÄ± satÄ±rdaki ifade aynÄ± anlama gelmektedir.

    printf("x = %d\n", x);

    *ptr = 3333;

    printf("x = %d\n", x);
}
```



â—â—â— **Pointee**: Pointer deÄŸiÅŸkeninin gÃ¶sterdiÄŸi nesneye verilen addÄ±r. Meselam `int* ptr = &x;` ÅŸeklinde bir pointer deÄŸiÅŸken bildirimi olduÄŸunda `*ptr` ifadesi **pointee** olarak adlandÄ±rÄ±lacaktÄ±r, internette inceleme yaparken bu terim karÅŸÄ±mÄ±za Ã§Ä±kabilir. 



ğŸ‘‡ AÅŸaÄŸÄ±daki program **pointer** ve **pointee** mavramlarÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 10;
    int y = 10;
    int z = 10;

    printf("x = %d, y = %d, z = %d", x, y, z);

    int* ptr = &x;
        *ptr = 9999; // Burada 'x' deÄŸiÅŸkeninin deÄŸeri '9999' yapÄ±lÄ±yor. Burada 'pointee' nesne 'x' nesnesidir.
    ptr = &y;
        *ptr = 9999; // Burada 'y' deÄŸiÅŸkeninin deÄŸeri '9999' yapÄ±lÄ±yor. Burada 'pointee' nesne 'y' nesnesidir.
    ptr = &z;
        *ptr = 9999; // Burada 'z' deÄŸiÅŸkeninin deÄŸeri '9999' yapÄ±lÄ±yor. Burada 'pointee' nesne 'z' nesnesidir.

    printf("x = %d, y = %d, z = %d", x, y, z);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program **dereferencing(`*`)** operatÃ¶rÃ¼ ile aynÄ± **nesnenin(object)** deÄŸerinin nasÄ±l farklÄ± **ifadeler(expression)** ile deÄŸiÅŸtirilebileceÄŸi incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 10;
    int* p1 = &x, * p2 = p1, * p3 = p2; // Buradaki 'int' tÃ¼rÃ¼nden pointer bildirimlerinde deÄŸikenlerin hepsi 'x' deÄŸiÅŸkeninin adresine tutmaktadÄ±r.

    printf("x = %d", x);

    ++*p1; // 'x' deÄŸiÅŸkeninin(ya da nesnesinin) deÄŸeri bir arttÄ±rÄ±lÄ±yor.
    ++*p2; // 'x' deÄŸiÅŸkeninin(ya da nesnesinin) deÄŸeri bir arttÄ±rÄ±lÄ±yor.
    ++*p3; // 'x' deÄŸiÅŸkeninin(ya da nesnesinin) deÄŸeri bir arttÄ±rÄ±lÄ±yor.

    printf("x = %d", x);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program **dereferencing(`*`)** operatÃ¶rÃ¼ ile aynÄ± **nesnenin(object)** deÄŸerinin nasÄ±l farklÄ± **ifadeler(expression)** ile deÄŸiÅŸtirilebileceÄŸi incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 10;
    int* p1 = &x;
    int* p2 = p1;
    int* p3 = p2;

    printf("x = %d", x);

    ++*p1;
    printf("x = %d", x);

    ++*p2;
    printf("x = %d", x);

    ++*p3;
    printf("x = %d", x);
}
```



â—â—â— Bir deÄŸiÅŸkene eriÅŸmek iÃ§in tek yÃ¶ntem o deÄŸiÅŸkenin adÄ±nÄ± kullanmak deÄŸildir, pointer deÄŸiÅŸkenler ile de bir deÄŸiÅŸkene eriÅŸilebilir. 



ğŸ‘‡ AÅŸaÄŸÄ±daki program pointer deÄŸiÅŸkenlerde tutulan adres deÄŸerleri Ã¼zerinden **dereferencing(`*`)** operatÃ¶rÃ¼ ile o nesnelerin deÄŸiÅŸkenleri kullanÄ±lmadan nasÄ±l deÄŸerlerinin deÄŸiÅŸtirilebileceÄŸini anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 10, * p1 = &x;
    int y = 50, * p2 = &y;

    printf("x = %d", x);

    *p1 = *p2; // Burada 'y' deÄŸiÅŸkeninin deÄŸeri 'x' deÄŸiÅŸkenine atanÄ±yor.

    printf("x = %d", x);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program x ye y deÄŸiÅŸkenlerinin deÄŸerlerinin pointer kullanÄ±larak nasÄ±l takas edilebileceÄŸini anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 10;
    int y = 50;
    int* p1 = &x;
    int* p2 = &y;

    printf("x = %d, y = %d", x, y);

    int tamp = *p1;
    *p1 = *p2;
    *p2 = temp;

    printf("x = %d, y = %d", x, y);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program dizi deÄŸiÅŸkenlerinin adlarÄ± Ã¼zerinden yapÄ±lan pointer iÅŸlemlerinin nasÄ±l gerÃ§ekleÅŸtiÄŸini anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int a[] = { 1, 2, 3 };
    int b[] = { -1, -2, -3 };

    print_array(a, 3);
    print_array(b, 3);

    *a = *b; // Buradaki statatement ile 'b' dizisinin ilk elemanÄ±nÄ±n deÄŸeri 'a' dizisinin ilk elemanÄ±na atanmaktadÄ±r.
    a[0] = b[0]; // Buradaki statatement yukarÄ±daki statatement ile aynÄ± anlama gelmektedir.

    print_array(a, 3);
    print_array(b, 3);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program iki **nesnenin(object)** deÄŸerlerinin Ã¼Ã§ farklÄ± `int *` tÃ¼rÃ¼nden gÃ¶sterici deÄŸiÅŸken kullanÄ±larak nasÄ±l takas edildiÄŸi incelenerek 
```C
#include <stdio.h>

int main(void)
{
    int x = 10, * p1 = &x;
    int y = 20, * p2 = &y;

    printf("x = %d, y = %d\n", x, y);

    printf("*p1 = %d, *p2 = %d\n", *p1, *p2);

    // AÅŸaÄŸÄ±daki Ã¼Ã§ statement ile p1 ve p2 pointer deÄŸiÅŸkenlerinin deÄŸerleri deÄŸiÅŸtirilmiÅŸ oluyor.
    int* ptemp = p1;
    p1 = p2;
    p2 = ptemp;

    printf("*p1 = %d, *p2 = %d\n", *p1, *p2);

    *p1 = *p2; // Buradaki iÅŸlem 'y = x' iÅŸlemiyle denktir.

    printf("x = %d, y = %d\n", x, y);
}
```


Ders sonu ...
