# 63.Ek Ders
---


## `scanf` Fonksiyonunun KullanÄ±mÄ±

`scanf` fonksiyonunun kullanÄ±mÄ±nÄ± detaylÄ± gÃ¶rmedik, belirli bir yere kadar bu fonksiyonu inceledik ama o seviyeden sonra bu fonksiyonun kullanÄ±m detaylarÄ±na hakimiyet kiÅŸinin C diliyle ilgili bilinÃ§ dÃ¼zeyi yÃ¼kseldiÄŸi iÃ§in kendisine bÄ±rakÄ±lmÄ±ÅŸtÄ±r(kursta Ã¶nerilen kaynak kitaplardan ve internetten bulunacak kaliteli kaynaklardan Ã¶ÄŸrenileblir).

Bu baÅŸlÄ±k altÄ±nda `scanf` fonksiyonunun kullanÄ±mÄ±yla ilgili bir iki noktaya deÄŸineceÄŸiz.

`scanf` fonksiyonu baÅŸarÄ±lÄ± biÃ§imde deÄŸer atamasÄ± yapabildiÄŸi nesne sayÄ±sÄ±nÄ± geriye dÃ¶ndÃ¼rÃ¼r, eÄŸer standart input'ta herhangi bir karakter olmadÄ±ÄŸÄ± iÃ§in baÅŸarÄ±sÄ±z olmuÅŸsa geri dÃ¶nÃ¼ÅŸ deÄŸeri hada kodu olarak `EOF` deÄŸeri olur. </br>
Bu durum sadece `scanf` iÃ§in deÄŸil `sscanf`, `fscanf` gibi tÃ¼m `scanf` tÃ¼revi fonksiyonlar iÃ§in geÃ§erlidir. </br>
`scanf` fonksiyonunun "**Scanset**" denilen bir Ã¶zelliÄŸi daha vardÄ±r, `scanf` tÃ¼revi fonksiyonlar sadece belirli karakterleri kabul edecek biÃ§imde kullanÄ±labilir, iki farklÄ± imkan var, biri sadece belirli karakterlere izin vermek, diÄŸeri de belirli karakterlerin dÄ±ÅŸÄ±ndaki karakterlere izin vermektir. </br>
**Formatting specifier** kullanÄ±mÄ±ndan Ã¶nce "**Scanset**" Ã¶zelliÄŸi kullanÄ±labilir, aÅŸaÄŸÄ±daki programlarda bu kullanÄ±m incelenebilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã¶nceden de bildiÄŸimiz dÃ¼z `scanf` kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    char str[100] = "";

    printf("bir yazi girin: ");
    scanf("%s", str);

    printf("[%s]\n", str);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `scanf` fonksiyonunun sadece belirli karakterlere izin verecek biÃ§imde **scanset** Ã¶zelliÄŸiyle birlikte kullanÄ±mÄ± incelenebilir. </br>
ProgramÄ± Ã§alÄ±ÅŸtÄ±rÄ±p kendin inceleme yapmalÄ±sÄ±n.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    char str[100] = "";

    printf("bir yazi girin: ");
    scanf("%[abcde ]s", str); // Burada 'scanf' fonksiyonu sadece 'abcde ' karakterlerini standart giriÅŸten okuyabilecek biÃ§ime 'scanset' Ã¶zelliÄŸiyle birlikte kullanÄ±lÄ±yor.

    printf("[%s]\n", str);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `scanf` fonksiyonunun sadece belirli karakterler dÄ±ÅŸÄ±ndaki karakterlere izin verecek biÃ§imde **scanset** Ã¶zelliÄŸiyle birlikte kullanÄ±mÄ± incelenebilir. </br>
ProgramÄ± Ã§alÄ±ÅŸtÄ±rÄ±p kendin inceleme yapmalÄ±sÄ±n.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    char str[100] = "";

    printf("bir yazi girin: ");
    scanf("%[^abcde\n]s", str); // Burada 'scanf' fonksiyonu sadece 'abcde\n' karakterleri dÄ±ÅŸÄ±ndaki karakterleri standart giriÅŸten okuyabilecek biÃ§ime 'scanset' Ã¶zelliÄŸiyle birlikte kullanÄ±lÄ±yor.

    printf("[%s]\n", str);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `scanf` fonksiyonunun sadece sayÄ± karakterlerine izin verecek biÃ§imde **scanset** Ã¶zelliÄŸiyle birlikte kullanÄ±mÄ± incelenebilir. </br>
ProgramÄ± Ã§alÄ±ÅŸtÄ±rÄ±p kendin inceleme yapmalÄ±sÄ±n.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    char str[100] = "";

    printf("bir yazi girin: ");
    scanf("%[0123456789]s", str); // Burada 'scanf' fonksiyonu sadece sayÄ± karakterlerini standart giriÅŸten okuyabilecek biÃ§ime 'scanset' Ã¶zelliÄŸiyle birlikte kullanÄ±lÄ±yor.

    printf("[%s]\n", str);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `scanf` fonksiyonunun yeni satÄ±r karakterini gÃ¶rene kadar olan tÃ¼m karakterleri standar input'tan okuyacak biÃ§imde **scanset** Ã¶zelliÄŸiyle birlikte kullanÄ±mÄ± incelenebilir. </br>
Bu kullanÄ±m ile `scanf` fonksiyonu ile sadece ilk **whitespace** karaktere kadar olan kÄ±smÄ± okuma Ã¶zelliÄŸi deÄŸiÅŸtirilmiÅŸ olur. </br>
ProgramÄ± Ã§alÄ±ÅŸtÄ±rÄ±p kendin inceleme yapmalÄ±sÄ±n.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    char str[100] = "";

    printf("bir yazi girin: ");
    scanf("%[^\n]s", str); // Burada 'scanf' fonksiyonu standart giriÅŸten tam bir satÄ±rÄ± okuyacak biÃ§imde 'scanset' Ã¶zelliÄŸiyle birlikte kullanÄ±lÄ±yor.

    printf("[%s]\n", str);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `scanf` fonksiyonunun okuyacaÄŸÄ± bir tÃ¼rÃ¼(karakter kÃ¼mesi) gÃ¶zardÄ± edecek biÃ§imde **scanset** Ã¶zelliÄŸiyle birlikte kullanÄ±mÄ± incelenebilir. </br>
Mesela standar giriÅŸte `12312314timur` biÃ§iminde giriÅŸ yapÄ±ldÄ±, yukarÄ±daki durumda sadece `timur` karakterleri dikkate alÄ±nacaktÄ±r. </br> 
ProgramÄ± Ã§alÄ±ÅŸtÄ±rÄ±p kendin inceleme yapmalÄ±sÄ±n.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    char str[100] = "";

    printf("bir yazi girin: ");
    scanf("%*d%s", str); // Burada 'scanf' fonksiyonu standart input'tan gelecek ilk tam sayÄ± bilgisini gÃ¶rmezden gelecek biÃ§ime 'scanset' Ã¶zelliÄŸiyle birlikte kullanÄ±lÄ±yor.

    printf("str = (%s)\n", str);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `scanf` fonksiyonunun okuduÄŸu karakterlerin bazÄ±larÄ±nÄ± gÃ¶rmezden gelecek biÃ§imde **scanset** Ã¶zelliÄŸiyle birlikte kullanÄ±mÄ± incelenebilir. </br>
ProgramÄ± Ã§alÄ±ÅŸtÄ±rÄ±p kendin inceleme yapmalÄ±sÄ±n.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    int d, m, y;
    
    // Ã–nceden de aÅŸina olunan bir kullanÄ±m.
    printf("bir tarih girin: ");
    scanf("%d%d%d", &d, &m, &y); // '23 5 1854' giriÅŸimde nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ± incelenebilir.

    printf("%02d/%02d/%d\n", d, m, y);

    printf("\n~~~~~~~~~~~~~~\n");

    // Ã–nceden de aÅŸina olunmayan bir kullanÄ±m.
    printf("bir tarih girin: ");
    scanf("%d-%d-%d", &d, &m, &y); // '23-5-1854' giriÅŸimde nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ± incelenebilir. Burada '-' karakteri buffer'dan Ã§Ä±kartÄ±lacak ama dikkate alÄ±nmayacaktÄ±r.

    printf("%02d/%02d/%d\n", d, m, y);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `scanf` fonksiyonunun okuduÄŸu karakterlerin bazÄ±larÄ±nÄ± gÃ¶rmezden gelecek biÃ§imde(`%*c` kullanÄ±mÄ±yla) **scanset** Ã¶zelliÄŸiyle birlikte kullanÄ±mÄ± incelenebilir. </br>
ProgramÄ± Ã§alÄ±ÅŸtÄ±rÄ±p kendin inceleme yapmalÄ±sÄ±n.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    int d, m, y;
    
    // Ã–nceden de aÅŸina olunmayan bir kullanÄ±m.
    printf("bir tarih girin: ");
    scanf("%d%*c%d%*c%d", &d, &m, &y); // '23-5|2249' giriÅŸimde nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ± incelenebilir. Burada '-' ve '|' karakterleri buffer'dan Ã§Ä±kartÄ±lacak ama dikkate alÄ±nmayacaktÄ±r.

    printf("%02d/%02d/%d\n", d, m, y);
}
```


## `printf` Fonksiyonunun KullanÄ±mÄ± 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `printf` fonksiyonunun bazÄ± kullanÄ±mlarÄ± incelenebilir. </br>
ProgramÄ± Ã§alÄ±ÅŸtÄ±rÄ±p kendin inceleme yapmalÄ±sÄ±n.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    int x = 7651;
    int w = 23;

    printf("[%d]\n", x);
    printf("[%12d]\n", x); // Burada 'yazma alanÄ± geniÅŸliÄŸi(output-with)' deÄŸeri 12 karakter olacak biÃ§imde saÄŸa dayalÄ± ayarlanmÄ±ÅŸtÄ±r.
    printf("[%-12d]\n", x); // Burada 'yazma alanÄ± geniÅŸliÄŸi(output-with)' deÄŸeri 12 karakter olacak biÃ§imde sola dayalÄ± ayarlanmÄ±ÅŸtÄ±r.
    printf("[%*d]\n", w, x); // Burada 'yazma alanÄ± geniÅŸliÄŸi(output-with)' deÄŸeri deÄŸiÅŸken olacak biÃ§imde 'w' nesnesinin deÄŸerine baÄŸlanarak saÄŸa dayalÄ± ayarlanmÄ±ÅŸtÄ±r.
    printf("[%-*d]\n", w, x); // Burada 'yazma alanÄ± geniÅŸliÄŸi(output-with)' deÄŸeri deÄŸiÅŸken olacak biÃ§imde 'w' nesnesinin deÄŸerine baÄŸlanarak sola dayalÄ± ayarlanmÄ±ÅŸtÄ±r.

}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `printf` fonksiyonunun **yazma alanÄ± geniÅŸliÄŸi(output-with)** deÄŸerinin deÄŸiÅŸken olarak nasÄ±l faydalÄ± biÃ§imde kullanÄ±labileceÄŸi incelenebilir. </br>
ProgramÄ± Ã§alÄ±ÅŸtÄ±rÄ±p kendin inceleme yapmalÄ±sÄ±n.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    for(int i = 0; i < 20; ++i) {
        printf("%*sNECATI\n", i, ""); // Burada dÃ¶ngÃ¼nÃ¼n 'i' deÄŸerine gÃ¶re yazÄ±m formatÄ±nÄ±n 'yazma alanÄ± geniÅŸliÄŸi(output-with)' deÄŸerinin nasÄ±l deÄŸiÅŸken olacak biÃ§imde kullanÄ±mÄ± incelenebilir.
    }
}
```


## `system` Fonksiyonunun KullanÄ±mÄ± 

`system` fonksiyonu `stdlib.h` baÅŸlÄ±k dosyasÄ±nda bulunan geri dÃ¶nÃ¼ÅŸ deÄŸeri bir tam sayÄ± olan, C standardÄ± geri dÃ¶nÃ¼ÅŸ deÄŸerinin neasÄ±l yorumlanacaÄŸÄ± konusunda net bir ÅŸey sÃ¶ylemiyor ama Ã§oÄŸunlukla baÅŸarÄ±lÄ± durumda "0" baÅŸarÄ±sÄ±zlÄ±k durumunda "non-zero" deÄŸer dÃ¶nen bir sistem fonksiyonudur. </br>
Bu fonksiyona `NULL` deÄŸer geÃ§ilmediÄŸi sÃ¼rece kendisine verilecek ilgili iÅŸletim sisteminin **CLI** komutlarÄ±nÄ± Ã§alÄ±ÅŸtÄ±rmak iÃ§in kullanÄ±lmaktadÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `system` fonksiyonunun kullanÄ±mÄ± incelenebilir. </br>
ProgramÄ±n Ã¼zerinde Ã§alÄ±ÅŸan sistemin komut yorumlayÄ±sÄ±nÄ±n olmasÄ± gerekmektedir. </br>
ProgramÄ± Ã§alÄ±ÅŸtÄ±rÄ±p kendin inceleme yapmalÄ±sÄ±n.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>


int main(void)
{
    int system_chack = system(NULL); // Bu fonksiyona 'NULL' deÄŸer geÃ§ilirse ilgili sistemde komut yorumlayÄ±cÄ±sÄ±nÄ±n olup olmadÄ±ÄŸÄ± Ã¶ÄŸrenilebilmektedir.

    if(system_chack) {
        printf("evet komut yorumlayicisi var!\n");

        // Windows iÅŸletim sistemi iÃ§in geÃ§erli olan CLI komutlarÄ± Ã§alÄ±ÅŸtÄ±rÄ±lacaktÄ±r.
        system("dir"); // ilgili dizini yazdÄ±ran komut.
        system("pause"); // KullanÄ±cÄ±dan bir tuÅŸa basmasÄ±nÄ± beklemek iÃ§in kullanÄ±lan komut.
        system("cls"); // EkranÄ± silmek iÃ§in kullanÄ±lan komut.
    }
    else {
        printf("hayir komut yorumlayicisi yok!\n");
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `system` fonksiyonuyla kullanÄ±cÄ±dan alÄ±nacak CLI komutlarÄ±nÄ±n Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ± gÃ¼zel bir kullanÄ±m incelenebilir. </br>
ProgramÄ± Ã§alÄ±ÅŸtÄ±rÄ±p kendin inceleme yapmalÄ±sÄ±n.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


void clear_input_buffer(void)
{
    int c;

    while((c = getchar()) != '\n' && c != EOF)
        ; // null statement
}


int main(void)
{
    char entry[100];

    for(;;) {
        printf("enter your command > ");
        (void)scanf("%[^\n]s", entry); // '\n' harici tÃ¼m karakterler dikkate alÄ±nacak ve 'entry' nesnesine atanacak.

        if(!strcmp(entry, "finito"))
            break;

        system(entry);
        clear_input_buffer();
    }
}
```


## `#include` Ã–niÅŸlemci Komutu KullanÄ±mÄ± 

Bu baÅŸlÄ±k altÄ±nda `#include` Ã¶niÅŸlemci komutunun ne olduÄŸuyla ilgili kullanÄ±mÄ± inceleyeceÄŸiz.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda sÄ±radan olarak bir iki boyutlu dizinin standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderimi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "nutility.h"

int main(void)
{
    int ary[][4] = {
        { 1, 3, 6, 7 },
        { 1, 3, 6, 7 },
        { 1, 4, 6, 3 },
        { 1, 8, 6, 2 },
        { 1, 4, 6, 1 },
    };

    for(size_t i = 0; i < asize(ary); ++i) {
        for(int k = 0; k < 4; ++k) {
            printf("%d ",ary[i][k]);
        }
        printf(""\n);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `#include` Ã¶niÅŸlemci komutunun bir kopyala yapÄ±ÅŸtÄ±r konutu olduÄŸu gÃ¶rÃ¼lmelidir.
```C
/*
 
    'init.txt' dosyasÄ±nÄ± iÃ§eriÄŸi aÅŸaÄŸÄ±daki gibi olsun ve bu dosya programÄ±n Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ± dosyanÄ±nn bulunduÄŸu dizinde bulunsun.

    { 1, 3, 6, 7 },
    { 1, 3, 6, 7 },
    { 1, 4, 6, 3 },
    { 1, 8, 6, 2 },
    { 1, 4, 6, 1 },

*/

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "nutility.h"

int main(void)
{
    int ary[][4] = {
        #include "init.txt"
    };

    for(size_t i = 0; i < asize(ary); ++i) {
        for(int k = 0; k < 4; ++k) {
            printf("%d ",ary[i][k]);
        }
        printf(""\n);
    }
}
```



## `X macro` KullanÄ±mÄ± 

**X** adÄ±nÄ±n kullanÄ±lma nedeni bir zorunluluk deÄŸil sadece herkes bu adÄ± tercih etmesinden kaynaklanmaktadÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `X macro` kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>

// AÅŸaÄŸÄ±daki gibi 'XCOLORS' adÄ±nda bir makro kullanÄ±larak tek bir yerden deÄŸerleri yÃ¶neterek birden Ã§ok farklÄ± yerdeki kullanÄ±mÄ±n nasÄ±l yÃ¶netilebileceÄŸi incelenebilir.
#define XCOLORS \
x(WHITE) \
X(GRAY) \
X(BLUE) \
X(RED) \
X(BLACK) \


// AÅŸaÄŸÄ±daki 'X macro' kullanÄ±mÄ±nÄ±n nasÄ±l aÃ§Ä±lacaÄŸÄ±nÄ± kullanÄ±lacak editÃ¶r vasÄ±tasÄ±yla gÃ¶rÃ¼lmesi faydalÄ± olacaktÄ±r.
enum Color {
#define X(a) a,
    XCOLORS
#undef X
};


// AÅŸaÄŸÄ±daki 'X macro' kullanÄ±mÄ±nÄ±n nasÄ±l aÃ§Ä±lacaÄŸÄ±nÄ± kullanÄ±lacak editÃ¶r vasÄ±tasÄ±yla gÃ¶rÃ¼lmesi faydalÄ± olacaktÄ±r.
#define X(a) #a,
const char *pcolors[] = { XCOLORS };
#undef X


// AÅŸaÄŸÄ±daki 'X macro' kullanÄ±mÄ±nÄ±n nasÄ±l aÃ§Ä±lacaÄŸÄ±nÄ± kullanÄ±lacak editÃ¶r vasÄ±tasÄ±yla gÃ¶rÃ¼lmesi faydalÄ± olacaktÄ±r.
void foo(enum Color c)
{
#define X(a) case a:printf("%s", #a); break;
    switch (c) {
        XCOLORS
#undef X
    default: printf("invalid color.\n");
    }
}
```


## Generic Selection AracÄ± 

C11 standardÄ± ile dile getirilen `_Generic` 

**Generic Selection** macro'larda kullanÄ±lan bir araÃ§, C stanadrdÄ± illa bu araÃ§Ä± macro'larda kullanÄ±lacaÄŸÄ±nÄ± sÃ¶ylemiyor ama Ã§oÄŸunlukla macro'larda kullanÄ±lÄ±yor ve standart kÃ¼tÃ¼phane de C11 standardÄ±ndan sonra bazÄ± macro'larda `_Generic` kullanÄ±yor.

ğŸ‘‡ AÅŸaÄŸÄ±dan temel 
```C
_Generic(expr,
    int : max_int,
    float: max_float,
    long: max_long,
    double: max_double,
    default: max_nec
)
```


C dilinde bir Ã§ok modern programlama dilinde olan **function overloading** aracÄ± dilin ufak tutulmasÄ± adÄ±na mevcut deÄŸildir, C dilinde tÃ¼m fonksiyonlarÄ±n adlarÄ± farklÄ± olmak zorundadÄ±r. </br>
C11 ile dile eklenen **Generic Selection** aracÄ± sanki **function overloading** aracÄ± gibi bir kullanÄ±m etkisi saÄŸlamaktadÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `get_max` adÄ±nda bir **Generic Selection** tanÄ±mlanmÄ±ÅŸ ve bu tanÄ±m Ã¼zerinden farklÄ± tÃ¼rlerde bÃ¼yÃ¼klÃ¼k karÅŸÄ±laÅŸtÄ±rmasÄ±nÄ±n nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


#define get_max(a, b) _Generic((a), \
        int: max_int, \
        long: max_long, \
        float: max_float, \
        double: max_double \
    )(a, b)


static inline int max_int(int x, int y)
{
    return x > y ? x : y;
}

static inline long max_long(long x, long y)
{
    return x > y ? x : y;
}

static inline float max_float(float x, float y)
{
    return x > y ? x : y;
}

static inline double max_double(double x, double y)
{
    return x > y ? x : y;
}

int main(void)
{
    int max = get_max(11, 453);
    
    printf("max: %d", max);

    return 0;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "cppreference.org" sitesindeki **Generic Selection** aracÄ±nÄ±n kullanÄ±mÄ±nÄ± gÃ¶steren bir kullanÄ±m incelenebilir.
```C
#include <math.h>
#include <stdio.h>

// Possible implementation of tgmath.h macro cbrt
#define cbrt(X) _Generic((X),   \
            long double: cbrtl, \
                defoult: cbrt,  \
                  float: cbrtf  \
            )(X)

int main(void)
{
    cbrt(23.5);
    cbrt(23.5f);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `tgmath.h` baÅŸlÄ±k dosyasÄ±ndaki matematik fonksiyonlarÄ±n **over-loading** yapÄ±sÄ±nÄ±n **Generic Selection** aracÄ±yla oluÅŸturulmuÅŸtur ve bu yapÄ± incelenebilir.
```C
#include <math.h>
#include <stdio.h>
#include <tgmath.h> // BaÅŸlÄ±k dosyasÄ±nÄ±n adÄ± 'Type generic math' sÃ¶zcÃ¼klerinden gelmektedir.

int main(void)
{
    // AÅŸaÄŸÄ±da kullanÄ±lan 'sqrt' fonksiyonlarÄ±nÄ±n hangi tÃ¼r iÃ§in Ã§alÄ±ÅŸacaÄŸÄ± 'Generic Selection' ile 'over-loading' yapÄ±sÄ±nda Ã§alÄ±ÅŸacaktÄ±r.
    printf("%f\n", sqrt(3.2F));
    printf("%lf\n", sqrt(4));
    printf("%lf", sqrt(3.2));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **Generic Selection** aracÄ±nÄ±n **conversion specifier** oluÅŸturmak iÃ§in nasÄ±l kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>

// 'Generic Selection' bildirimi
#define printf_dec_format(x)    _Generic((x), \
    char                        : "%c", \
    signed char                 : "%hhd", \
    unsigned char               : "%hhu", \
    signed short                : "%hd", \
    unsigned short              : "%hu", \
    signed int                  : "%d", \
    unsigned int                : "%u", \
    long int                    : "%ld", \
    unsigned long int           : "%lu", \
    long long int               : "%lld", \
    unsigned long long int      : "%llu", \
    float                       : "%f", \
    double                      : "%f", \
    long double                 : "%Lf", \
    char *                      : "%s", \
    void *                      : "%p")


// Function-like macro bildirimleri
#define print(x)    printf(printf_dec_format(x), x)
#define println(x)  printf(printf_dec_format(x), x), printf("\n");

int main(void)
{
    println('b');
    println((char)'A');
    println(6868);
    println(23.531);
}
```


â­ SektÃ¶rde tek baÅŸÄ±na C dili Ã§ok kabul gÃ¶rmÃ¼yor her ne kadar sadece C dilini kullanarak Ã¼retim yapan ÅŸirketler(Ã¶deme sistemleri alanÄ±nda Ã§alÄ±ÅŸan firmalar, gÃ¶mÃ¼lÃ¼ sistemler alanÄ±nda Ã§alÄ±ÅŸan firmalar) olsa da. </br>
SektÃ¶rdeki genel beklenti C ve C++ programlama dillerinin ikisine de programcÄ±nÄ±n hakim olmasÄ± yÃ¶nÃ¼ndedir, C dilini Ã¶ÄŸrenen kiÅŸilerin Ã§oÄŸunlukla C++ dilini de Ã¶ÄŸrenmesi gerekecektir. </br>
C++ dili Ã§ok daha bÃ¼yÃ¼k bir dildir, C++ dili ne kadar erken Ã¶ÄŸrenmeye baÅŸlanÄ±rsa o kadar iyi olacaktÄ±r ve kiÅŸiye o kadar Ã§ok kapÄ± aÃ§Ä±lacaktÄ±r, C++ dilinin kullanÄ±m alanÄ± C diline gÃ¶re Ã§ok daha geniÅŸtir.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 20.49-21.10 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


## C++ iÃ§indeki C

C++ dili C dilinden bÃ¼yÃ¼k Ã¶lÃ§Ã¼de farklÄ± ayrÄ± bir programlama dilidir. 

Ä°ki dilin ortak Ã¶zellikleri
- Ä°ki dilin standardÄ± bir comite tarafÄ±ndan belirlenmektedir ve bu diller bir kurum ya d abir ÅŸirketin malÄ± deÄŸildir, tamamen o dilde uzmanlaÅŸmÄ±ÅŸ gÃ¶nÃ¼llÃ¼lerden oluÅŸan kiÅŸilerin ortak olarak aldÄ±klarÄ± kararlarla geliÅŸen dillerdir.
- Bu dillerde geliÅŸtirme yapmak iÃ§in herhangi bir kuruma Ã¶deme yapÄ±lmasÄ± gerekmemektedir.

C++ dilinin iÃ§inde bir C Ã§ekirdeÄŸi vardÄ±r(bu kÄ±sÄ±m Ã¶nemlidir), C++ dilinin iÃ§indeki C dili bu kursta Ã¶ÄŸrenilen C diline oldukÃ§a benzerdir ama tamamen de aynÄ± deÄŸildir. </br>
Bu kurs boyunca C dilini Ã¶ÄŸrendik ama aynÄ± zamanda C++ dilini de Ã¶ÄŸrendik diyebiliriz Ã§Ã¼nkÃ¼ C++ dilinin iÃ§inde bir C dili var. </br>
C++ dilinin iÃ§inde C ile ayrÄ± programlama dili olan C dili arasÄ±nda bazÄ± uyumsuzluklar var yani kural farklÄ±lÄ±klarÄ± var, bu kural farklÄ±lÄ±klarÄ±nÄ± C++ dilini Ã¶ÄŸrenmeye geÃ§iÅŸte bilmek gerekiyor. </br>

Neden C++ iÃ§indeki C ile C dili arasÄ±nda farklÄ±lÄ±k var;
- C dilinde tÃ¼r kontrolÃ¼ zayÄ±ftÄ±r Ã§Ã¼nkÃ¼ farklÄ± farklÄ± sistemler iÃ§in kolaylÄ±kla bir C derleyicisi oluÅŸturulabilmesi istenmiÅŸti, ayrÄ±ca bu nedenden dolayÄ± da C dili kÃ¼Ã§Ã¼k bir dil olarak tutulmaktadÄ±r. C++ dili endÃ¼striyel alanda kullanÄ±lan dillerin en bÃ¼yÃ¼ÄŸÃ¼ olduÄŸu sÃ¶ylenebilie ve bundan dolayÄ± da gÃ¼Ã§lÃ¼ bir tÃ¼r kontrol yapÄ±sÄ± vardÄ±r. Her iki dil de static tÃ¼r kavramÄ±na sahiptir ama C dilinde tÃ¼r kontrolÃ¼ gevÅŸekken C++ dilinde tÃ¼r kontrolÃ¼ katÄ±dÄ±r. Bu durum iki dilin birbirine karÅŸÄ± uyumsuz olmasÄ±na neden olmaktadÄ±r.
- C dilindeki kurallarÄ±n C++ dilinde olan C dilinde olmayan C++ dilinin modern araÃ§larÄ±yla tam olarak uyum saÄŸlamamasÄ±, bu uyumu saÄŸlayabilmek iÃ§in bazÄ± yerlerde kural deÄŸiÅŸikliklerine ihtiyaÃ§ olmuÅŸtur(burada tÃ¼m uyumsuzluklara deÄŸinilmedi).


C dilinin standart kÃ¼tÃ¼phenesi tamamÄ±yla C++ dilinin standart kÃ¼tÃ¼phanesinin bir bileÅŸeni, yani biz C++ kodu yazarken C++ dilinin standart kÃ¼tÃ¼phenesinin bir parÃ§asÄ± olarak bu kursta Ã¶ÄŸrendiÄŸimiz C dilinin standart kÃ¼tÃ¼phenesini bazÄ± ufak farklÄ±lÄ±klarla kullanabiliyoruz. </br>
DolayÄ±sÄ±yla C++ dilini Ã¶ÄŸrenecek kiÅŸiler sÄ±fÄ±rdan Ã¶ÄŸreneceklerse bu kursu almalarÄ± halinde Ã§ok daha ileri bir bilgi birikimiyle C++ dilini Ã¶ÄŸrenmeye baÅŸlayacaklarÄ± sÃ¶ylenebilir. </br>
Necati Ergin eÄŸer C++ dili kursunu sÄ±fÄ±rdan Ã¶ÄŸretmeye baÅŸlasaydÄ± kursun sÃ¼re 150 saat civarÄ±nda daha fazla olmasÄ± gerekirdi denilebilir. </br>
Bunun yanÄ±nda her yeni C ve C++ standardÄ±yla birlikte iki dil arasÄ±ndaki uyumsuzluklar artmÄ±ÅŸtÄ±r, mesela **variable length array(VLA)** aracÄ± C++ dilinde bulunmamaktadÄ±r ve C dilinde de 11 standardÄ±yla birlikte derleyiciyi yazanlara bÄ±rakÄ±lmÄ±ÅŸtÄ±r, mesela **designated initializer** aracÄ± C dilinde var C++ dilinde yoktur, Ã¶zellikle C99 ve C11 standardÄ±yla C diline eklenen araÃ§larÄ±n Ã¶nemli bir kÄ±smÄ± C++ dilinde mevcut deÄŸildir. </br>
C dili kÃ¼Ã§Ã¼k bir dil olmasÄ±na raÄŸmen C dilinde olan fakat C++ dilinde olmayan araÃ§lar mevcut, C++ dilinde olan fakat C dilinde olmayan yÃ¼zlerce araÃ§ vardÄ±r. </br>
Ä°ki dil arasÄ±ndaki farklÄ±lÄ±klarÄ±n belki de en Ã¶nemli kÄ±smÄ± programlama pradigmalarÄ±yla ilgili. C dili aslen **procedural paradigmayÄ±** uygulamaktadÄ±r. C dili **OOP**, **Functuonal** programlama yaklaÅŸÄ±mlarÄ±na doÄŸrudan destek vermemektedir. </br>
C++ dili endÃ¼stride kullanÄ±lan programlama dillerinin hemen hepsinden farklÄ± olacak biÃ§imde Ã§ok paradigmalÄ± bir programlama dilidir. </br>
C++ dili ÅŸu programlama yaklaÅŸÄ±mlarÄ±nÄ± destekler: **procedural programming**, **object oriented programming**, **functional programming**, **generic programming** gibi farklÄ± programlama yaklaÅŸÄ±mlarÄ±nÄ±n hepsine destek vermektedir. </br>
Her yeni C++ stadardÄ±yla birlikte dile yeni araÃ§lar eklenmektedir ve dil Ã§ok daha bÃ¼yÃ¼k hale gelmektedir, bunun ne kadar iyi bir durum olduÄŸu tartÄ±ÅŸÄ±lÄ±r. </br>
Ã–zellikle C++ dilinin 2011 yÄ±lÄ±nda yayÄ±nlanmÄ±ÅŸ olan standardÄ± C++ dilini Ã§ok deÄŸiÅŸtirmiÅŸtir, C++ dilini tarihsel geliÅŸim sÃ¼recinde iki ayrÄ± dÃ¶neme ayÄ±rmakta fayda var, biri eski C++ denilebilecek olan 2011 standardÄ±ndan Ã¶nceki dÃ¶nem ve diÄŸeri 2011 standardÄ± ve sonraki dÃ¶nemdir. </br>
C++ standardÄ± bÃ¶yle bir terim kullanmamasÄ±na raÄŸmen 2011 ve sonrasÄ± C++ dili iÃ§in "**Modern C++**" terimi kullanÄ±lmaktadÄ±r, 2011 ve sonrasÄ± C++ dili Ã§ok daha fazla bÃ¼yÃ¼k daha fazla araca sahip bir dildir. </br>
Eski C++ programcÄ±larÄ± **modern C++** dilini Ã¶ÄŸrenmek iÃ§in ciddi bir Ã§aba sarfetmek zorundadÄ±r Ã§Ã¼nkÃ¼ dile eklenen araÃ§lar dili bÃ¼yÃ¼k Ã¶lÃ§Ã¼de deÄŸiÅŸtirmiÅŸtir. </br>


C++ dili **generic programming** yaklaÅŸÄ±mÄ±na endÃ¼stride kullanÄ±lan programlama dilleri arasÄ±nda en bÃ¼yÃ¼k desteÄŸi veren programlama dilidir. </br>
C++ dili iÃ§in **object oriented programming language** tanÄ±mlamasÄ± yanlÄ±ÅŸtÄ±r, C++ dili bu yaklaÅŸÄ±ma destek vermektedir fakat C++ dili en fazla desteÄŸi **generic programming** yaklaÅŸÄ±mÄ±na vermektedir. </br>
C derleyicisi yazÄ±lmÄ±ÅŸ olan C kodlarÄ±nÄ± doÄŸrudan makine koduna dÃ¶nÃ¼ÅŸtÃ¼rmektedir, C++ derleyicilerinin kodlarÄ± dÃ¶nÃ¼ÅŸtÃ¼rme iÅŸleminin dÄ±ÅŸÄ±nda bir de kod yazma Ã¶zelliÄŸine sahiptir. </br>
C++ dilinde iki ayrÄ± kod tÃ¼rÃ¼ vardÄ±r, biri C dilindeki gibi dÃ¼z yazÄ±lan kodlar, diÄŸeri de derleyiciye kod yazdÄ±ran kodlardÄ±r. </br>
Derleyiciye kod yazdÄ±ran kodlara **template** denilmektedir, ayrÄ± bir sÃ¶zdizim kurallarÄ±na sahip amacÄ± derleyiciye kod yazdÄ±rmak olan kod yazabiliyoruz, bÃ¶ylece kodun kendisini yazmak yerine derleyiciye kod yazdÄ±ran kodu yazdÄ±ÄŸÄ±mÄ±zda mesela farklÄ± tÃ¼rler iÃ§in birbirine Ã§ok benzeyen ama sadece tÃ¼r farkÄ± olan fonksiyonlar yazmak yerine derleyicinin benzer fonksiyonlarÄ± yazabileceÄŸi bir kod formunu oluÅŸturup o kod formundan faraketle derleyicinin ayrÄ± ayrÄ± fonksiyonlar yazmasÄ±nÄ± saÄŸlayabiliyoruz.


C++ dilindeki **template** aracÄ± Ã§ok kullanÄ±ÅŸlÄ± ve Ã¶nemli bir araÃ§tÄ±r, bu araÃ§ Ã§ok kullanÄ±ÅŸlÄ± ve kullanÄ±mÄ±nÄ± Ã¶ÄŸrenmek biraz zorlayÄ±cÄ±dÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda 
```C

// C dilinde aÅŸaÄŸÄ±daki gibi takas iÅŸlemi yapan bir fonksiyon aÅŸaÄŸÄ±daki gibi yazÄ±labilir ama farklÄ± tÃ¼rler iÃ§in benzer bir iÅŸlemi yapmak istesek o tÃ¼rler iÃ§in de aÅŸaÄŸÄ±daki aynÄ± fonksiyonun adÄ± ve tÃ¼rleri farklÄ± halini yeniden yazmak gerekecektir.
void swap(int* p1, int* p2)
{
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda dilin **template** aracÄ±nÄ±n basit bir kullanÄ±mÄ± incelenebilir.
```Cpp

template <template T>
void Swap(T* p1, T* p2)
{
    T temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}

int main()
{
    int x = 12, y= 32;

    Swap(&x, &y);

    double xd = 12, yd= 32;

    Swap(&xd, &yd);
}
```


â—â—â— C++ dilinin standart kÃ¼tÃ¼phenesinin en bÃ¼yÃ¼k bileÅŸeni **STL(Standart Template Library)** dir. C++ dilinin standart kÃ¼tÃ¼phenesinin kendisi de doÄŸrudan kaynak kod dosyalarÄ±ndan deÄŸil kod yazdÄ±ran kodlarÄ±dan oluÅŸmaktadÄ±r.


C dilinde olmayan C++ dilinde bulunan bazÄ± araÃ§lar aÅŸaÄŸÄ±daki gibidir;
- **Funciton everloading**
- **Class** tÃ¼rÃ¼(C++ dilindeki struct tÃ¼rleri de bir Ã§eÅŸit class tÃ¼rÃ¼dÃ¼r. C deki struct ile C++ taki struct tÃ¼rÃ¼ Ã¶zellikleri birbirinden farklÄ±dÄ±r)
- **Operator everloading**
- **Namespace** aracÄ±
- **Template** aracÄ±(bu araÃ§ kendi iÃ§inde bir Ã§ok farklÄ± araca sahiptir)
- **Default argument** 
- **Lambda Expression**


Kurs sonu ...
