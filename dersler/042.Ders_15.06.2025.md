# 42.Ders 15.06.2025 ğŸ•˜

Derse 10(09:01)-11(09:10)-11(10:01)-12(11:02)-12(12:18) kiÅŸi katÄ±ldÄ±.
---


## Dynamic Arrays(Dinamik diziler)

Programlamada bir veri yapÄ±sÄ± kullanÄ±lmasÄ± gerken yerlerde varsayÄ±lan olarak dinamik dizilerin kullanÄ±lmasÄ± dÃ¼ÅŸÃ¼nÃ¼lmeli ama dinamik dizi ihtiyacÄ± tam olarak karÅŸÄ±lamÄ±yorsa o zaman baÅŸka veri yapÄ±larÄ± araÅŸtÄ±rÄ±lmalÄ±dÄ±r. </br>
Static diziler tÃ¼m programlama dillerinde ekleme/silme iÅŸlemlerine sahip olmayan veri yapÄ±sÄ±dÄ±r ama dinamik dizilerde ekleme/silme iÅŸlemleri vardÄ±r. </br>
Dinamik dizilerin en Ã¶nemli avantajÄ± indeksi bilinen bir elemana eriÅŸmenin $O(1)$ zaman karmaÅŸÄ±klÄ±ÄŸÄ±nda olmasÄ± ve dizi boyutunun ihtiyaÃ§ oldukÃ§a arttÄ±rÄ±lÄ±p azaltÄ±labilmesidir.



â—â—â— Sondan yapÄ±lan eklenme iÅŸlemleri "**amortised constand time**" karmaÅŸÄ±klÄ±ktadÄ±r. Bu ÅŸu anlama geliyor, dinamik dizilerde sona eleman ekleme iÅŸlemi eklenecek eleman dizinin kapasitesinin deÄŸiÅŸmesini gerektirmiyorsa $O(1)$ zaman karmaÅŸÄ±klÄ±ÄŸÄ±ndadÄ±r ama sona eklenen eleman **reallocate** gerektiriyorsa $O(n)$ zaman karmaÅŸÄ±klÄ±ÄŸÄ±nda olacaktÄ±r, iÅŸte bundan dolayÄ± "**amortised constand time**" deniliyor. </br>
Dinamik dizilerle ilgili bazÄ± terimler; 
- **Capacity**: EdinilmiÅŸ bellek alanÄ±nda tutulabilecek eleman sayÄ±sÄ±dÄ±r.
- **Size**    : Dinamik dizide tutulan eleman sayÄ±sÄ±dÄ±r.


>â”
> 
> Sorulan Soru?
> 
> Bu statik dizide de ayni degil mi. char a[100] tanimlayip 50 eleman kullanabilirim </br>
> Fark nedir burada anlayamadim
> 
> Cevap;
> 
> Statik dizide dizinin boyutu sabit olur ihtiyaÃ§ olduÄŸunda bu bellek alanÄ± deÄŸiÅŸtirilemeyecektir. </br>
> Dizinin ek elemana sahip olacaÄŸÄ± Ã§alÄ±ÅŸma zamanÄ±nda belli olduÄŸunda Statik dizi kullanÄ±lamayacaktÄ±r.


â—â—â— Size deÄŸeri kapasite deÄŸerine eÅŸit iken yeni bir ekleme talebi geldiÄŸinde kaÃ§Ä±nÄ±lmaz olarak **reallocation** yapÄ±lacak, kapasite dinamik dizinin gerÃ§ekleÅŸtirimine baÄŸlÄ± olarak  1.5, 2 ya da baÅŸka bir katÄ±na Ã§Ä±kartÄ±lacaktÄ±r.



Dinamik dizilerin Ã¶zellikleri;
- Elemanlar bellekte ardÄ±ÅŸÄ±k(contigious), bÃ¶ylece indeksle eriÅŸim constant time($O(1)$ karmaÅŸÄ±klÄ±k).
- Sondan ekleme **amortised constand time**
- Sondan silme constant time($O(1)$ karmaÅŸÄ±klÄ±k)
- Ekleme ya da silme iÅŸlemleri son olmayan bir konumdan yapÄ±lÄ±rsa $O(n)$ karmaÅŸÄ±klÄ±kta.
- DeÄŸerle eriÅŸim $O(n)$ karmaÅŸÄ±klÄ±kta.
- **Cache friendly(Ã¶nbellek dostu)** Ã¶zelliktedir, bunun nedeni elemanlarÄ±n bellekte sÄ±ralÄ± olmasÄ± ve bellekte sÄ±ralÄ± olan bu verilerin Ã¶nbelleÄŸe kolayca yÃ¼klenebilmesi ve iÅŸlemcide iÅŸlemlerin yapÄ±labilmesi iÃ§in sÃ¼rekli ram'e gidilmesine gerek olmamasÄ±dÄ±r.
- **Vectorization(SIMD)** iÅŸlemlerinde avantaj saÄŸlamaktadÄ±r. **Vectorization(SIMD)** modern iÅŸlemcilerde olan iÅŸlemcinin tek bir iÅŸlemde birden fazla iÅŸlemi yapabilme Ã¶zelliÄŸidir. **Vectorization(SIMD)** iÅŸleminin yapÄ±labilmesi iÃ§in kullanÄ±lan veri yapÄ±sÄ±ndanki elemanlarÄ±n bellekte sÄ±ralÄ± olmasÄ± gerekmesidir. 
- Dinamik dizilerin Ã¶ÄŸelerin bellekte sÄ±ralÄ± olmasÄ± gerekmesinden dolayÄ± tek parÃ§a bellek bloklarÄ±na ihtiyaÃ§ duyulmaktadÄ±r, bu da bu veri yapÄ±sÄ±nÄ±n **fragmentation**'a karÅŸÄ± direnÃ§li olmadÄ±ÄŸÄ± anlamÄ±na geliyor.



**Cache friendly(Ã¶nbellek dostu)** kavramÄ±yla iliÅŸkili bazÄ± terimler aÅŸaÄŸÄ±daki gibidir; 
- **Cache miss(Ã–nbelleÄŸi Ä±skalamak)**
- **Cache hit(Ä°sabetli Ã–nbellek)**
- **Cache hit(Ä°sabetli Ã–nbellek)** / **Cache miss(Ã–nbelleÄŸi Ä±skalamak)** oranÄ± ne kadar yÃ¼ksekse o veri yapÄ±sÄ± o kadar **Cache friendly(Ã¶nbellek dostu)**'dir.



Dinamik dizi sondan ekleme ve sondan silme iÅŸlemlerini sabit zaman karmaÅŸÄ±klÄ±ÄŸÄ±na Ã§ekmektedir.


â—â—â— Veri yapÄ±larÄ± sÃ¶z konusuysa baÅŸtan ve sondan yapÄ±lmayan ekleme ya da Ã§Ä±karma iÅŸlemlerinde iÅŸlem yapÄ±lan konumu belirtmek iÃ§in **middle** terimi kullanÄ±lmaktadÄ±r.


â—â—â— Veri yapÄ±larÄ±nda yapÄ±lan bazÄ± iÅŸlemler ve ne anlama geldikleri aÅŸaÄŸÄ±da gÃ¶rÃ¼lebilir;
- **Push Front**: Veri yapÄ±sÄ±nÄ±n baÅŸÄ±ndan yapÄ±lan tek bir elemanÄ±n eklenmesi iÅŸlemini ifade eder.
- **Push Back**: Veri yapÄ±sÄ±nÄ±n sonundan yapÄ±lan tek bir elemanÄ±n eklenmesi iÅŸlemini ifade eder.
- **Pop Front**: Veri yapÄ±sÄ±nÄ±n baÅŸÄ±ndan yapÄ±lan tek bir elemanÄ±n silinmesi iÅŸlemini ifade eder.
- **Pop Back**: Veri yapÄ±sÄ±nÄ±n sonundan yapÄ±lan tek bir elemanÄ±n silinmesi iÅŸlemini ifade eder.
- **Insert**: Veri yapÄ±sÄ±nÄ±n arasÄ±na yapÄ±lan tek bir elemanÄ±n eklenmesi iÅŸlemini ifade eder.
- **Erase** ya da **Remove**: Veri yapÄ±sÄ±nÄ±n arasÄ±na yapÄ±lan tek bir elemanÄ±n silnmesi iÅŸlemini ifade eder.




ğŸ‘‡ AÅŸaÄŸÄ±daki programda C++ dilinde hazÄ±r gelen dinamik veri yapÄ±sÄ±nÄ±n kullanÄ±mÄ± incelenebilir
```C++
#include <vector> // C++ dilinde dinamik veri yapÄ±sÄ±nÄ±n bulunduÄŸu kÃ¼tÃ¼phane

int main(void)
{
    using namescape std;

    vector<int> vec(10);

    auto cap = vec.capacity();

    cout << "capacity = " << cap << '\n';
    cout << "size = " << cap << '\n';

    for(int i = 0; i < 100'000; ++i){
        vec.push_back(4);

        if(vec.capacity() > cap){
            cout << "size = " << vec.size() << "capacity = " << vec.capacity() <<  '\n';
            cap = vec.cavacity;
            (void)getchar();
        }
    }
}
```



Ä°leriki derlerde **dynamic array** gerÃ§ekleÅŸtirimini yapacaÄŸÄ±z, bunu yapabilmek iÃ§in **user-defined-types** konusunun iÅŸlenmesi gerekiyor.

**User-defined-types** konusu Ã§ok sayÄ±da detay iÃ§ermektedir ve 16-20 saat civarÄ±nda sÃ¼recektir.


## C Dilindeki KullanÄ±lan BazÄ± Ã–nemli Anahtar SÃ¶zcÃ¼kler 

Bu baÅŸlÄ±k altÄ±nda incelenecek olan anahtar sÃ¶zcÃ¼kler, C dilinin standardÄ±nda "**Storage class specifiers**" ve "**Type qualifer**" olarak iki Ã¶beÄŸe ayrÄ±lmaktadÄ±r.

1. Storage class specifiers
    - `auto` bu anahtar sÃ¶zcÃ¼k C dilinde kullanÄ±mdan dÃ¼ÅŸmÃ¼ÅŸtÃ¼r, C++ dilinde baÅŸka bir anlam kazanarak kullanÄ±mÄ± devam etmektedir.
    - `register` bu anahtar sÃ¶zcÃ¼k te Ã§ok eski bir C derleyicisi kullanÄ±lmayacaksa pek kullanÄ±lmayacaktÄ±r. 
    - `extern`
    - `static` 
2. Type qualifer
    - `const`
    - `volative`
    - `restrict` (C99 ile dile eklendi)


### `auto` Anahta SÃ¶zcÃ¼ÄŸÃ¼ 

Ã–nceden `auto` anahtar sÃ¶zcÃ¼ÄŸÃ¼ **otomatic** Ã¶mÃ¼rlÃ¼ deÄŸiÅŸkenler bildirmek iÃ§in kullanÄ±lÄ±yordu fakat varsayÄ±lan olarak yerel deÄŸiÅŸkenlerin Ã¶mÃ¼rleri zaten **otomatic** Ã¶mÃ¼rlÃ¼ olmaktadÄ±r ve global alandaki deÄŸiÅŸkenlerin Ã¶mÃ¼rleri zorunlu olarak `static` olmasÄ± gerekiyor.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `auto` ve `static` anahtar sÃ¶zcÃ¼klerinin kullanÄ±mÄ± incelenebilir.
```C
auto int gx = 23; // Buradaki bildirim sÃ¶zdizim hatasÄ±dÄ±r(syntax error).

int main(void)
{
    auto int x1 = 10; // x1 nesnesinin 'otomatik' Ã¶mÃ¼rlÃ¼ olacaÄŸÄ± bildiriliyor.
    int x2 = 10; // x2 nesnesi varsayÄ±lan olarak 'otomatik' Ã¶mÃ¼rlÃ¼ olarak bildiriliyor.
    static int y = 20; // y nesnesinin 'static' Ã¶mÃ¼rlÃ¼ olacaÄŸÄ± bildiriliyor.    
}
```


#### `auto` Anahta SÃ¶zcÃ¼ÄŸÃ¼ ve Type Deduction KullanÄ±mÄ± 

Statik tÃ¼r sistemine sahip dillerde az ya da Ã§ok genellikle **type deduction** mekanizmasÄ± bulunur, **type deduction** mekanizmasÄ±yla bir deÄŸiÅŸken ilklendirildiÄŸinde deÄŸiÅŸkenin tÃ¼rÃ¼ bildirilmez ama o deÄŸiÅŸkene verilen ilk deÄŸerin tÃ¼rÃ¼ ne olarak yorumlanÄ±yorsa o deÄŸiÅŸkenin tÃ¼rÃ¼ de o olacaktÄ±r. </br>



ğŸ‘‡ AÅŸaÄŸÄ±daki programda C++ dilinde  **type deduction** mekanizmasÄ± 
```Cpp
int main(void)
{
    auto x = 12; // burada 'x' deÄŸiÅŸkeninin tÃ¼rÃ¼, ilk verilen deÄŸirin 'int' olmasÄ±ndan dolayÄ± 'int' olacaktÄ±r, buna 'type deduction' deniliyor.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda C99 standardÄ±ndan Ã¶nce `const` ile tÃ¼rÃ¼ bildirilmeyen `x` gibi bir deÄŸiÅŸkenin varsayÄ±lan olarak `int` tÃ¼rÃ¼nde kabul edildiÄŸi incelenebilir, derleyiciler geriye doÄŸru uyumluluktan dolayÄ± bunu desteklemeyi sÃ¼rdÃ¼rmektedir.
```C
#include <vector>

int main(void)
{
    const x = 6; // C99 standardÄ±ndan Ã¶nce olan 'implicit-int' Ã¶zelliÄŸinden dolayÄ± buradaki 'x' deÄŸiÅŸkninin tÃ¼rÃ¼ derleyici tarafÄ±ndan 'int' olarak yorumlanacaktÄ±r.
}
```


### `register` Anahtar SÃ¶zcÃ¼ÄŸÃ¼ 

Bir deÄŸiÅŸkenin Ã¼zerinde iÅŸlem yapÄ±labilmesi iÃ§in ilk Ã¶nce o deÄŸiÅŸkenin iÅŸlemciye alÄ±nmasÄ± gerekiyor, o deÄŸiÅŸkenin iÅŸlemciye alÄ±nmasÄ± demek o deÄŸiÅŸkenin iÅŸlemcinin Ã¶nbelleÄŸine yÃ¼klenmesi demektir, Ã¼zerinde iÅŸlem yapÄ±lacak olan deÄŸiÅŸkenin ana bellekten iÅŸlemci Ã¶nbelleÄŸine alÄ±nmasÄ±(yani yazmaÃ§'a aktarÄ±m) yine makine komutlarÄ±yla oluyor ve bunun bir maliyeti var.

**Register(YazmaÃ§)** iÅŸlemcideki fiilen iÅŸlemin yapÄ±ldÄ±ÄŸÄ± bellek alanÄ±dÄ±r(assembly dillerini bilen biri bu terimi biliyordur).



ğŸ‘‡ AÅŸaÄŸÄ±daki programda deÄŸiÅŸkenin `register` olarak bildiriliÅŸinin ne anlama geldiÄŸi incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    // AÅŸaÄŸÄ±daki 'x' deÄŸiÅŸken bildiriminde derleyiciye bu deÄŸiÅŸkenin doÄŸrudan 'yazmaÃ§ta(register)' tutmasÄ± iÃ§in rica ediliyor.
    // Bu ÅŸekilde derleyiciye sadece rica edilebilir emir verilemez.
    int register x = 5;
}
```


Eskiden yazÄ±lan C programlarÄ±nda bir **kapsamda(scope)** geÃ§erli olan deÄŸiÅŸkenlerden sÃ¼rekli Ã¼zerinde iÅŸlem yapÄ±lacak olanlarÄ±n yazmaÃ§larda tutulmasÄ± halinde program daha hÄ±zlÄ± Ã§alÄ±ÅŸacaÄŸÄ± iÃ§in `register` anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n bir karÅŸÄ±lÄ±ÄŸÄ± vardÄ± ama sonradan derleyiciler bu gibi durumlarÄ± Ã§ok iyi optimize edebildiÄŸi iÃ§in bu anahtar sÃ¶zcÃ¼ÄŸe gerek kalmamÄ±ÅŸtÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda dÃ¶ngÃ¼nÃ¼n sayacÄ± olan `i` deÄŸiÅŸkeni `register` olarak iÅŸaretlenmiÅŸtir ama moder derleyiciler hangi deÄŸiÅŸkenlerin yazmaÃ§larda tutulacaÄŸÄ±na karar verme konusunda Ã§ok iyi olmasÄ±ndan dolayÄ± gereksizdir.
```C
#include <stdio.h>

int main(void)
{
    int register i;
    
    for(i = 0; i < 100000; ++i){

    }    
}
```


â—â—â— Derleyicilerin en iyi yaptÄ±ÄŸÄ± iyileÅŸtirmelerden biri hangi deÄŸiÅŸkeni yazmaÃ§larda tutacaÄŸÄ±na karak vermektir bu nedenle de `register` anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n kullanÄ±mÄ±na pek gerek kalmamÄ±ÅŸtÄ±r.

`register` anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n kullanÄ±mÄ± emir deÄŸil bir ricadÄ±r Ã§Ã¼nkÃ¼ derleyicinin durumuna baÄŸlÄ± olarak ilgili deÄŸiÅŸken bir yazmaÃ§ta tutulabilir ya da tutulmayabilir. 

âš ï¸ `register` anahtar sÃ¶zcÃ¼ÄŸÃ¼ sadece **otomatik** Ã¶mÃ¼rlÃ¼ deÄŸiÅŸkenler iÃ§in kullanÄ±labilir, `static` Ã¶mÃ¼rlÃ¼ deÄŸiÅŸkenler zaten process'in baÅŸÄ±ndan sonuna kadar bellekte olacaÄŸÄ± iÃ§in bu nesnelerin sadece bir yazmaÃ§ta tutulmasÄ±nÄ± istemek mantÄ±klÄ± deÄŸildir.

âš ï¸ Adres operatÃ¶rÃ¼nÃ¼n(`&` operator) operandÄ± `register` anahtar sÃ¶zcÃ¼ÄŸÃ¼yle tanÄ±mlanmÄ±ÅŸ bir deÄŸiÅŸken olamaz.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `register` anahtar sÃ¶zcÃ¼ÄŸÃ¼yle tanÄ±mlanmÄ±ÅŸ bir deÄŸiÅŸkenin adres operatÃ¶rÃ¼nÃ¼n(`&` operator) operandÄ± olamayacaÄŸÄ± incelenebilir.
```C
#include <stdio.h>

void foo(int)
{
    register int x = 5;

    int* p = &x; // Buradaki '&x' ifadesi 'x' deÄŸiÅŸkeninin 'register' olarak tanÄ±mlanmasÄ±ndan dolayÄ± sÃ¶zdizim hatasÄ±dÄ±r(syntax error).

    printf("%d\n", *p);
}

int main(void)
{

}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.35-10.56 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


### `static` Anahtar SÃ¶zcÃ¼ÄŸÃ¼ 

C Ã¶ÄŸrenenlerin `static` anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n kullanÄ±mÄ±nda en Ã§ok zorlandÄ±ÄŸÄ± durum bu anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n iki farklÄ± anlamda kullanÄ±lÄ±yor olmasÄ±dÄ±r, C dilinde birden fazla anlama gelen sadece `static` anahtar sÃ¶zcÃ¼ÄŸÃ¼ vardÄ±r. </br>
Dil tarafÄ±ndan anahtar sÃ¶zcÃ¼klere birden fazla anlam yÃ¼klenmesi biraz kafa karÄ±ÅŸÄ±klÄ±ÄŸÄ±na nenden olabilir, C++ dilinde bu durum daha Ã§oktur(mesela `using` anahtar sÃ¶zcÃ¼ÄŸÃ¼ kullanÄ±ldÄ±ÄŸÄ± baÄŸlama gÃ¶re altÄ± farklÄ± anlama gelmektedir), C dilinde bu durum sadece `static` anahtar sÃ¶zcÃ¼ÄŸÃ¼nde vardÄ±r. </br>
Peki neden dile yeni bir anahtar sÃ¶zcÃ¼k eklemek yerine zaten Ã¶nceden olan bir anahtar sÃ¶zcÃ¼ÄŸe yeni anlamlar yÃ¼kleniyor, Ã§Ã¼nkÃ¼ dile yeni bir anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n eklenmesinin derleyiciyi geliÅŸtirme aÃ§Ä±sÄ±ndan maliyeti olan bir anahtar sÃ¶zcÃ¼ÄŸe yeni anlamlar yÃ¼klenmesinin maliyetinden daha dÃ¼ÅŸÃ¼ktÃ¼r.



`static` anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n yerel ve global deÄŸiÅŸkenlerle kullanÄ±mÄ± birbirinden farklÄ± anlama gelmektedir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `static` olarak bildirilen bir yerel deÄŸiÅŸkenin **statik Ã¶mÃ¼rlÃ¼** olacaÄŸÄ± incelenebilir.
```C
#include <stdio.h>

int* foo(void)
{
    int x = 5;
    static int y = 5; // Buradaki 'y' adÄ±ndaki yerel deÄŸiÅŸken 'static' olarak bildirildiÄŸi iÃ§in bellekte process sonlanana kadar kalacaktÄ±r.

    printf("x = %d, y = %d\n", x, y);

    ++x;
    ++y;
}

int main(void)
{
    for(int i = 0; i < 10; ++i){
        foo();
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `static` olarak bildirilen bir yerel dizinin **statik Ã¶mÃ¼rlÃ¼** olacaÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

void foo_v1(void)
{
    int ary[5] = { 1, 2, 3, 4, 5 }; // 'automatic storage duration' dizi tanÄ±mÄ±.

    print_array(ary, 5);

    for(int i = 0; i < 5; ++i)
        ary[i] += 2;
}


void foo_v2(void)
{
    static int ary[5] = { 1, 2, 3, 4, 5 }; // 'static storage duration' dizi tanÄ±mÄ±.

    print_array(ary, 5);

    for(int i = 0; i < 5; ++i)
        ary[i] += 2;
}


int main(void)
{
    for(int i = 0; i < 10; ++i){
        foo_v1();
    }

    printf("\n~~~~~~~~~~\n");

    for(int i = 0; i < 10; ++i){
        foo_v2();
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda virgÃ¼l ile ayrÄ±larak bildirilen deÄŸiÅŸkenlerin `static` olarak bildirilmeleri durumunda `static` bildiriminin virgÃ¼l ile ayrÄ±lan tÃ¼m deÄŸiÅŸkenler iÃ§in geÃ§erli olduÄŸu gÃ¶rÃ¼lebilir.
```C
#include <stdio.h>

void foo(void)
{
    static int x = 5, y = 7; // Buradaki hem x hem de y deÄŸiÅŸkeni 'static' Ã¶zelliktedir aynÄ± durum 'const' iÃ§in de geÃ§erlidir.

    printf("x = %d, y = %d\n", x, y);

    ++x;
    ++y;
}

int main(void)
{
    for(int i = 0; i < 10; ++i){
        foo();
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `static` olarak bildirilen ve bildirilmeyen bir karakter dizisinin bulunduÄŸu kapsamda `strcat` standart fonksiyonuyla baÅŸka bir yazÄ±yla birleÅŸtirme iÅŸleminden sonra ilgili karakter dizisi deÄŸiÅŸkeninin elemanlarÄ±nÄ±n ne olacaÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

void foo_v1(void)
{
    char str[100] = "nur";

    puts(str);
    strcat(str, "can");
}

void foo_v2(void)
{
    static char str[100] = "nur";

    puts(str);
    strcat(str, "can");
}

int main(void)
{
    for(int i = 0; i < 10; ++i){
        foo_v1();
    }

    printf("\n~~~~~~~~~~\n");

    for(int i = 0; i < 10; ++i){
        foo_v2();
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **global scope**'ta bildirilen bir deÄŸiÅŸken ve **local scope**'ta bildirilen bir deÄŸiÅŸken `static` olmasÄ±nÄ±n ne anlama geldiÄŸi incelenebilir 
```C
#include <stdio.h>

int g = 5; // Burdadaki global 'g' deÄŸiÅŸkeni 'static storage duration' Ã¶zelliktedir.

void foo(void)
{
    static int x = 5; // Burdadaki yerel 'x' deÄŸiÅŸkeni 'static storage duration' Ã¶zelliktedir.

    printf("g = %d, x = %d\n", g, x);
    ++g, ++x;
}

int main(void)
{
    // Buradan 'g' static deÄŸiÅŸkenine eriÅŸilebilir ama 'x' static deÄŸiÅŸkenine eriÅŸilemez.
}
```



â—â—â— EÄŸer **static Ã¶mÃ¼rlÃ¼** bir deÄŸiÅŸkene ihtiyacÄ±mÄ±z varsa, o deÄŸiÅŸken aÅŸaÄŸÄ±daki durumlarda `global` deÄŸiÅŸken olmalÄ±dÄ±r;
1. Birden fazla kaynak dosyada kendi adÄ±yla kullanÄ±lacak ise.
2. AynÄ± kaynak dosyada birden fazla fonksiyon iÃ§inde kullanÄ±lacak ise.

EÄŸer sadece `static` Ã¶mÃ¼rlÃ¼ bir deÄŸiÅŸkene ihtiyacÄ±mÄ±z varsa o deÄŸiÅŸken sadece bir fonksiyonu ilgilendiriyorsa yani o fonksiyonun gerÃ§ekleÅŸtirimiyle ilgiliyse baÅŸka fonksiyonlardan o `static` yerel deÄŸiÅŸkene eriÅŸilmesi ilgili fonksiyonun Ã§alÄ±ÅŸmasÄ±nÄ± bozabileceÄŸinden dolayÄ± sakÄ±ncalÄ±dÄ±r.


#### `static` Anahtar SÃ¶zcÃ¼ÄŸÃ¼nÃ¼n KullanÄ±ldÄ±ÄŸÄ± Yerler 

##### Ä°lk KullanÄ±m Yeri

Adres dÃ¶ndÃ¼ren fonksiyonlarÄ±n statik yerel deÄŸiÅŸken adresleri dÃ¶ndÃ¼rmesi iÃ§in `static` anahtar sÃ¶zcÃ¼ÄŸÃ¼ kullanÄ±lÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `get_psw` adÄ±ndaki rastgele parola Ã¼reten bir fonksiyonun Ã¼reteceÄŸi parolayÄ± kendisine adresi geÃ§ilen deÄŸiÅŸkene atadÄ±ÄŸÄ± incelenebilir, burada Ã¼retilen parolanÄ±n tutulacaÄŸÄ± bellek alanÄ± fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±lan yerden gelmektedir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "nutility.h"

// 'Get Password' sÃ¶zcÃ¼klerinin kÄ±saltmasÄ±ndan adÄ±nÄ± alan rastgele bir parola yazÄ±sÄ± dÃ¶ndÃ¼ren bir fonksiyondur.
// p        : Ãœretilecek parolanÄ±n atanacaÄŸÄ± karakter dizisinin adresi.
// return   : Fonksiyona geÃ§ilen adresin kendisi.
char* get_psw(char* p)
{
    int len = rand() % 4 + 5;
    
    for(int i = 0; i < len; ++i){
        p[i] = (rand() % 2 ? 'A': 'a') + (rand() % 26);
    }

    p[len] = '\0';

    return p;
}

int main(void)
{
    randomize();

    char str[40];

    puts(get_psw(str));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda yukarÄ±daki `get_psw` fonksiyonunun dÄ±ÅŸarÄ±dan adres almadan static yerel bir karakter dizisinin adresini dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ durum incelenebilir. </br>
Geriye statik yerel deÄŸiÅŸkenin adresini dÃ¶ndÃ¼ren fonksiyonlarÄ±n genel olarak kullanÄ±lma ÅŸekli: Fonksiyon Ã§aÄŸrÄ±sÄ±ndan dÃ¶nen adresteki deÄŸerin kullanÄ±lmasÄ± ve o deÄŸerle iÅŸin bitmesi ardÄ±ndan ilgili aynÄ± fonksiyonun Ã§aÄŸÄ±rÄ±lmasÄ± gerekiyorsa fonksiyon Ã§aÄŸrÄ±sÄ±nÄ±n yapÄ±lmasÄ±dÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "nutility.h"

// 'Get Password' sÃ¶zcÃ¼klerinin kÄ±saltmasÄ±ndan adÄ±nÄ± alan rastgele bir ÅŸifre yazÄ±sÄ± dÃ¶ndÃ¼ren bir fonksiyondur.
// return   : Parola bilgisini tutan statik Ã¶mÃ¼rlÃ¼ deÄŸiÅŸkenin adresi.
char* get_psw(void)
{
    static char pws[20];
    int len = rand() % 4 + 5;
    
    for(int i = 0; i < len; ++i){
        pws[i] = (rand() % 2 ? 'A': 'a') + (rand() % 26);
    }

    pws[len] = '\0';

    return pws;
}

int main(void)
{
    randomize();

    char* pa[5];

    for(int i = 0; i < 5; ++i){
        pa[i] = get_psw(); // 'get_psw' fonksiyonundan geriye hep aynÄ± dizi adresi dÃ¶ndÃ¼rÃ¼lmektedir.
    }
    
    for(int i = 0; i < 5; ++i){
        puts(pa[i]);
    }

    printf("\n~~~~~~~~~~~~~~\n");
    
    char* pa2[5];

    for(int i = 0; i < 5; ++i){
        char* p = get_psw(); // 'get_psw' fonksiyonundan geriye hep aynÄ± dizi adresi dÃ¶nÃ¼lmektedir ve bu adres otomatik Ã¶mÃ¼rlÃ¼ 'p' deÄŸiÅŸkeni atandÄ±ktan sonra 'pa2' karakter dizisinin elemanlarÄ±na atana atanÄ±yor ama  adres deÄŸeri aynÄ± olduÄŸu iÃ§in parolalar aynÄ± olacaktÄ±r.
        pa2[i] = p;
    }
    
    for(int i = 0; i < 5; ++i){
        puts(pa2[i]);
    }

    for(int i = 0; i < 5; ++i){
        char* p = get_psw();
        printf("%p\n", p); // Burada 'get_psw' fonksiyon Ã§aÄŸrÄ±sÄ±ndan dÃ¶nen deÄŸer o anda standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderildiÄŸi iÃ§in her adÄ±mda farklÄ± bir parola yazacaktÄ±r.
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `get_psw` adÄ±ndaki rastgele parola Ã¼reten bir fonksiyonun Ã¼reteceÄŸi parolayÄ± dinamik olarak oluÅŸturulacak bir bellek bloÄŸuna yazÄ±p o bellek bloÄŸunun baÅŸlangÄ±ÅŸ adresini dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "nutility.h"

// 'Get Password' sÃ¶zcÃ¼klerinin kÄ±saltmasÄ±ndan adÄ±nÄ± alan rastgele bir ÅŸifre yazÄ±sÄ± dÃ¶ndÃ¼ren bir fonksiyondur.
// return   : Parola bilgisini tutan dinamik Ã¶mÃ¼rlÃ¼ deÄŸiÅŸkenin adresi.
char* get_psw(void)
{
    int len = rand() % 4 + 5;
    char* pd = (char*)malloc(len  + 1);
    
    if(!pd)
        return pd;
    
    for(int i = 0; i < len; ++i){
        pd[i] = (rand() % 2 ? 'A': 'a') + (rand() % 26);
    }

    pd[len] = '\0';

    return pd;
}

int main(void)
{
    randomize();

    char* pa[5];

    for(int i = 0; i < 5; ++i){
       pa[i] = get_psw(); // 'get_psw' fonksiyonundan geriye dinamik Ã¶mÃ¼rlÃ¼ bir nesnenin adresi dÃ¶nÃ¼ldÃ¼ÄŸÃ¼ iÃ§in her fonksiyon Ã§aÄŸrÄ±sÄ±ndan geriye farklÄ± adres dÃ¶necektir.
    }
    
    // 'pa' dizisinde saklanan farklÄ± parolalar standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderiliyor.
    for(int i = 0; i < 5; ++i){
        puts(pa[i]);
    }

    // 'Memory Leak' olmamasÄ± iÃ§in nesnelerin adresleri iade ediliyor, 'pa' dizisindeki her bir nesne dinamik Ã¶mÃ¼rlÃ¼ karakter dizisi olduÄŸu iÃ§in bellek iade iÅŸleminin yapÄ±lmasÄ± gerekiyor.
    for(int i = 0; i < 5; ++i){
        free(pa[i]);
    }
}
```


##### Ä°kinci KullanÄ±m Yeri 

BazÄ± fonkisyonlar Ã§aÄŸÄ±rÄ±ldÄ±klarÄ± zaman kendilerine yapÄ±lan daha Ã¶nceki Ã§aÄŸrÄ±lardan elde ettikleri deÄŸerleri kullanÄ±rlar. </br>
Bir fonksiyon kendisine yapÄ±lan Ã§aÄŸrÄ±larÄ±n sayÄ±sÄ±nÄ± tutmak istediÄŸimizde statik Ã¶mÃ¼rlÃ¼ yerel deÄŸiÅŸken kullanÄ±lmasÄ± gerekir, bunun iÃ§in yerel deÄŸiÅŸken `static` anahtar sÃ¶zcÃ¼ÄŸÃ¼yle bildirilmelidir. </br>
Statik yerel deÄŸiÅŸken kullanÄ±lan her yerde global deÄŸiÅŸken de kullanÄ±labilir fakat, bir fonksiyon dÄ±ÅŸÄ±ndan eriÅŸilebilir olmamasÄ± gereken deÄŸiÅŸkeler dÄ±ÅŸarÄ±dan eriÅŸilebilir olacaÄŸÄ± iÃ§in bu tercih edilmemelidir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `foo` fonksiyonunda bu fonksiyonunun kaÃ§ defa Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ± bilgisinin tutulmasÄ± iÃ§in kÃ¶tÃ¼ bir yÃ¶ntem olarak global deÄŸiÅŸken kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>

int cnt = 0; // 'foo' fonksiyonunda kullanÄ±lan bir deÄŸer ama 'foo' fonksiyonunun dÄ±ÅŸarÄ±sÄ±na aÃ§Ä±lmÄ±ÅŸ durumdadÄ±r ve bu kÃ¶tÃ¼ bir kullanÄ±mdÄ±r.

void foo(void)
{
    printf("foo fonksiyonu %d. defa Ã§aÄŸÄ±rÄ±ldÄ±.\n", ++cnt);
}

int main(void)
{
    for(int i = 0; i < 10; ++i){
        foo();
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `foo` fonksiyonunda bu fonksiyonunun kaÃ§ defa Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ± bilgisinin tutulmasÄ± iyi bir yÃ¶ntem olan `static` yerel deÄŸiÅŸken kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>

void foo(void)
{
    static int cnt = 0; // Bu bildirim ile 'cnt' deÄŸiÅŸkeni hayata tek sefer gelecektir.
    printf("foo fonksiyonu %d. defa Ã§aÄŸÄ±rÄ±ldÄ±.\n", ++cnt);
}

int main(void)
{
    for(int i = 0; i < 10; ++i){
        foo();
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `foo` fonksiyonunda sadece ilk defa Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ± durumunda belirli iÅŸlemleri yapmasÄ± saÄŸlanan durumun nasÄ±l yazÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include <stdbool.h>

void foo(void)
{
    static bool first_call_flag = false;

    if(!first_call_flag){
        printf("fonksiyon ilk defa cagrildiginda database baglantisi kuruldu.\n");
        first_call_flag = true;
    }

    printf("database'de sorgulama yapildi.\n");
}

int main(void)
{
    for(int i = 0; i < 10; ++i){
        foo();
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda her Ã§aÄŸrÄ±da belirli bir aralÄ±ktaki tam sayÄ± deÄŸerini geriye dÃ¶ndÃ¼receÄŸi teminatÄ±nÄ± veren `urand` adÄ±ndaki fonksiyonun nasÄ±l yazÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include "nutility.h"

#define URAND_MAX 20

// Her Ã§aÄŸrÄ±da rastgele olarak 0 dahil 'URAND_MAX' hariÃ§ bir deÄŸer Ã¼retecektir.
int urand(void);
{
    static int call_count = 0;
    static _Bool flags[URAND_MAX] = { false };
    
    // Fonksiyon her seferinde ayrÄ± bir deÄŸer dÃ¶ndÃ¼receÄŸi iÃ§in 'URAND_MAX' deÄŸerinden fazla deÄŸer Ã¼retilmemesi iÃ§in gerite baÅŸarÄ±sÄ±z anlamÄ±nda '-1' deÄŸeri dÃ¶ndÃ¼rÃ¼lÃ¼yor.
    if(call_count == URAND_MAX)
        return -1;
    
    while(true){
        int val = rand() % URAND_MAX;

        if(!flags[val]){
            ++call_count;
            flags[val] = true;
            return val;
        }
    }
}

int main(void)
{
    randomize();

    for(int i = 0; i < 10; ++i){
        printf("%d", urand());
    }

    printf("\n%d\n", );
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.04-12.15 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


##### ÃœÃ§Ã¼nÃ¼ KullanÄ±m Yeri

**Lookup table** kullanÄ±lacaÄŸÄ±nda bunun iÃ§in oluÅŸturulacak olan deÄŸiÅŸkenlerin `static` olarak bildirilmesi yerel deÄŸiÅŸkenlerde birden fazla hayata baÅŸlatÄ±lmalarÄ±nÄ±n Ã¶nÃ¼ne geÃ§er. 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda faktoriyel fonksiyonu ve aylarÄ±n gÃ¼n sayÄ±sÄ±nÄ± standart Ã§Ä±ktÄ±ya gÃ¶nderen fonksiyonun `const` bildirilen **lookup table**'lar kullanÄ±lara nasÄ±l gerÃ§ekleÅŸtirildiÄŸi incelenebilir.
```C
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include "nutility.h"

int factorial(int n)
{
    // Faktoriyel deÄŸerlerini tutan 'a' adÄ±nda bir deÄŸiÅŸken bildiriliyor.
    const int a[] = { 1, 2, 6, 24, 120, 720, 5040, 40320 };

    return a[n];
}

void print_date(int d, int m, int y)
{
    const int mdays[][13] = {
        { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
        { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
    };

    printf("girilen tarih: %d %d %d(gun-ay-yil) %d gundur.\n", d, m, y, mdays[isleap(y)][m]);
}
```


### `static` Anahtar SÃ¶zcÃ¼ÄŸÃ¼nÃ¼n Global DeÄŸiÅŸkenlerde KullanÄ±lmasÄ± ve `extern` Anahtar SÃ¶zcÃ¼ÄŸÃ¼ 

Kursun en Ã¶nemli konularÄ±ndan biri ve iyi bilinmesi gerekiyor. </br>
`static` anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n global deÄŸiÅŸken ve fonksiyonlarda kullanÄ±lmasÄ±. </br>

**Module**: C ve C++ programlarÄ± birden fazla kaynak dosyadan oluÅŸmaktadÄ±r yani bu dillerde yazÄ±lan programlar organize edilirken birden fazla kaynak dosya ÅŸeklinde organize edilmektedir iÅŸte herbir **.c** ve **.h** dosyalarÄ±ndan oluÅŸan ikili dosya sistemine **module** deniliyor.

ğŸ§­ DeÄŸiÅŸkenler aÅŸaÄŸÄ±daki Ã¶zelliklere sahiptir;
1. **Scope**
2. **Storage Duration**
3. **Linkage(baÄŸlantÄ±)**
    1. **Extern Linkage(DÄ±ÅŸ BaÄŸlantÄ±)**: EÄŸer bir modÃ¼lde tanÄ±mlanan bir global deÄŸiÅŸkenin ya da fonksiyonun adÄ± diÄŸer modÃ¼llerden de kullanÄ±ldÄ±ÄŸÄ±nda aynÄ± varlÄ±ÄŸa karÅŸÄ±lÄ±k geliyorsa o ad dÄ±ÅŸ baÅŸlantÄ±ya aittir demektir.
    2. **Intern Linkage(Ä°Ã§ BaÄŸlantÄ±)**: Statik Ã¶mÃ¼rlÃ¼ bir deÄŸiÅŸkenin ya a bir fonksiyonun sadece kendi modÃ¼lÃ¼ iÃ§inden kullanÄ±labilmesidir.
    3. **No Linkage(BaÄŸlantÄ±sÄ±z)**



ğŸ§­ Bir kaynak dosyada bir global deÄŸiÅŸken tanÄ±mlandÄ±ÄŸÄ±nda iki durum var;
1. Bu global deÄŸiÅŸken adÄ±yla projedeki diÄŸer kaynak dosyalardan da kullanÄ±labilir. Bunun iÃ§in deÄŸiÅŸkenin **extern linkage(dÄ±ÅŸ baÄŸlantÄ±)** olmasÄ± gerekir.
2. Bu global deÄŸiÅŸken adÄ±yla projedeki diÄŸer kaynak dosyalardan kullanÄ±lmasÄ± istenmeyebilir. Bunun iÃ§in deÄŸiÅŸkenin **intern linkage(iÃ§ baÄŸlantÄ±)** olmasÄ± gerekir.

ğŸ§­ Bir kaynak dosyada bir fonksiyon tanÄ±mlandÄ±ÄŸÄ±nda iki durum var;
1. Bu fonksiyon adÄ±yla projedeki diÄŸer kaynak dosyalardan da Ã§aÄŸrÄ±labilir. Bunun iÃ§in fonksiyonun **extern linkage(dÄ±ÅŸ baÄŸlantÄ±)** olmasÄ± gerekir.
2. Bu fonksiyon adÄ±yla projedeki diÄŸer kaynak dosyalardan Ã§aÄŸrÄ±lmasÄ± istenmeyebilir. Bunun iÃ§in fonksiyonun **intern linkage(iÃ§ baÄŸlantÄ±)** olmasÄ± gerekir.


ğŸ“Œ C++, Java, C# gibi dillerde `public`, `private`, `protected` gibi eriÅŸim belirleyiciler(**access modifier**) var ama C dilinde yoktur fakat C dilindeki **extern linkage(dÄ±ÅŸ baÄŸlantÄ±)** bir nevi `public` ve **intern linkage(iÃ§ baÄŸlantÄ±)** bir nevi `private` gibi dÃ¼ÅŸÃ¼nÃ¼lebilir. 


Bir deÄŸiÅŸken ya da fonksiyonu **extern linkage(dÄ±ÅŸ baÄŸlantÄ±)** olarak kullanmak iÃ§in hiÃ§ bir anahtar sÃ¶zcÃ¼k ile tanÄ±mlanmasÄ± gerekmemektedir.</br>
Bir deÄŸiÅŸken ya da fonksiyonu **intern linkage(iÃ§ baÄŸlantÄ±)** olarak kullanmak iÃ§in `static` anahtar sÃ¶zcÃ¼ÄŸÃ¼yle tanÄ±mlanmasÄ± gerekiyor.

**Extern decleration**: `extern` anahtar sÃ¶zcÃ¼ÄŸÃ¼yle bildirilen deÄŸiÅŸkenler derleyici tarafÄ±ndan dÄ±ÅŸ bir dosyada tanÄ±mlanan deÄŸiÅŸken olarak yorumlanÄ±r o deÄŸiÅŸken iÃ§in bir bellek konumu belirlenmez, baÄŸlama aÅŸamasÄ±nda ilgili deÄŸiÅŸken iliÅŸkilendirilecektir.



C ve C++ programlarÄ±nda kaynak dosyalar ".c" ve ".h" uzantÄ±lÄ± iki dosyaya parÃ§alanmÄ±ÅŸ olarak kullanÄ±lmaktadÄ±r.
- **.h** uzantÄ±lÄ± dosyalar **header file** olarak alandÄ±rÄ±lÄ±r. Bu dosyalarÄ± kullanacak olan dosyalardan gÃ¶rÃ¼nmesi istenilen varlÄ±klarÄ±n bildirimleri bulunmalÄ±dÄ±r.
- **.c** uzantÄ±lÄ± dosyalar **implementation file**, **code file** ya da **source file** olarak alandÄ±rÄ±lÄ±r.


DÄ±ÅŸarÄ±dan kullanÄ±lmasÄ± istenilen deÄŸiÅŸkenler **.h** uzantÄ±lÄ± dosyalarda `extern` olarak bildirilmek zorundadÄ±r fakat dÄ±ÅŸarÄ±dan kullanÄ±lmasÄ± istenilen fonksiyonlar iÃ§in bÃ¶yle bir zorunluluk yoktur.


Ders sonu ...
