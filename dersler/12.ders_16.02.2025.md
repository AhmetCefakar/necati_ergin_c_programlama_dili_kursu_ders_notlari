# 12.Ders 16.02.2025 ğŸ•˜

Derse 20(09:02)-25(09:30)-27(11:00)-23(12:10)-23(12:45)-22(12:53)-22(13:04) kiÅŸi katÄ±ldÄ±.
---


â— "**KÄ±sa devre davranÄ±ÅŸÄ±**": Logic operatÃ¶rlerin ilk Ã¶nce sol operandlarÄ±nÄ±n iÅŸlenmesi ve oluÅŸan sonuca gÃ¶re saÄŸ tarafta baÅŸka kodlar varsa bu kodlarÄ±n Ã§alÄ±ÅŸtÄ±rÄ±lÄ±p Ã§alÄ±ÅŸtÄ±rÄ±lmayacaÄŸÄ± kararÄ±nÄ±n ilk iÅŸlemin sonucuna gÃ¶re karar verildiÄŸi davranÄ±ÅŸa verilen addÄ±r. 

ğŸ§­ Bu derste **Sequence Point** oluÅŸturan operatÃ¶rler iÅŸlenecektir, bu operatÃ¶rler aÅŸaÄŸÄ±daki gibidir;
- **Assignment Operators(`=`)** 
- **Logical-and Operator(`%%`)**
- **Logical-or Operator(`||`)**
- **Comma Operator(`,`)**
- **Ternary Operator(`exp1 ? exp2 : exp3`)**

## Assignment Operators(Atama OperatÃ¶rleri) 

â— **Assignment Operators(Atama OperatÃ¶rleri)** bir nesneye(yani bir L-value expression) deÄŸer atayan yani onun deÄŸerini deÄŸiÅŸtiren operatÃ¶rlerdir, bu operatÃ¶rlerinin hepsinin **yan etkisi(side effect)** vardÄ±r.

Bu operatÃ¶rlerin hepsi **binary infix** ve **side effect** Ã¶zelliÄŸine sahiptir.

**Assignment Operators(Atama OperatÃ¶rleri)** `,` operatÃ¶rÃ¼ hariÃ§ tÃ¼m operatÃ¶rlerden daha dÃ¼ÅŸÃ¼n Ã¶nceliÄŸe sahiptir.

Ä°ki tÃ¼re ayrÄ±lÄ±r:
1. **DÃ¼z sadece atama iÅŸlemi yapan operatÃ¶r**: Sadece `=` operatÃ¶rÃ¼.
2. **Compound Assignment operators(Ä°ÅŸlemli atama operatÃ¶rleri)**: `+=` `-=` `*=` `/=` `>>=` `<<=` `&=` `^=` `|=`


Atama operatÃ¶rlerinin Ã¶ncelik yÃ¶nÃ¼nÃ¼n saÄŸdan sola doÄŸru olmasÄ± ne anlama geliyor?
- Bir ifade(expression) iÃ§inde birden fazla atama operatÃ¶rÃ¼ kullanÄ±labilir.
- `a = b = c = y` ifadesi operatÃ¶r yÃ¶nÃ¼nden dolayÄ± `a = (b = (c = y))` ÅŸeklinde yorumlanacaktÄ±r.


### Assignment Operator 

"**Initialization is not an assignment**" ifadesi `int x = 26;` burada atama iÅŸlemi olmadÄ±ÄŸÄ±nÄ± deÄŸiÅŸkene ilk deÄŸer verme iÅŸleminin yapÄ±ldÄ±ÄŸÄ±nÄ± ifade eder.
`int x = 26;` burada **declaration statement** vardÄ±r **assignment statement** deÄŸil ve teknik olarak burada yapÄ±lan bir deÄŸer atama iÅŸlemi deÄŸildir.



ğŸ‘‡ AÅŸaÄŸÄ±daki program ilk deÄŸer verme ile atama iÅŸlemlerinin birbirlerindne farklarÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 13; // Bu bir 'decleration statement' ve buradaki deyimdeki '=' token'Ä± teknik olarak bir atama operatÃ¶rÃ¼ deÄŸildir. 

    x = 45; // Burada 'x' deÄŸiÅŸkenine '45' deÄŸeri atanÄ±yor ve buradaki deyimdeki '=' token'Ä± atama operatÃ¶rÃ¼dÃ¼r.
}
```


â—â—â— C dilinde bÃ¼tÃ¼n operatÃ¶rlerin Ã¼rettiÄŸi bir deÄŸer vardÄ±r, atama operatÃ¶rleri de bir deÄŸer Ã¼retir. 
- Ã‡oÄŸunlukla atama operatÃ¶rlerinin Ã¼rettiÄŸi deÄŸer kullanÄ±lmaz(discarding). 
- Ama bir Ã§ok C idiyomu atama operatÃ¶rÃ¼nÃ¼n Ã¼rettiÄŸi deÄŸeri kullanÄ±r.


>â”
> 
> Sorulan soru;
> 
> Peki operandlardan biri diÄŸerinden farklÄ± bir tÃ¼rse ne olur, bu bi hatamÄ±?
> 
> Cevap;
> 
> Bu sorunun cevabÄ± ileriki derslerde verilecek ama kÄ±sa cevap olarak bir double deÄŸiÅŸken bir int deÄŸiÅŸkene atanabilir ama burada veri kaybÄ± oluÅŸur.
> 
> Bir ifadenin **sÃ¶zdizim(syntax)** aÃ§Ä±sÄ±ndan legal olmasÄ± ile o ifadenin doÄŸru olmasÄ±, gÃ¼venilir olmasÄ±, Ã¼retimde kullanÄ±labilir olmasÄ± ya da **ub** iÃ§erip iÃ§ermemesi farklÄ± ÅŸeylerdir. 
> 
> ```C
> #define _CRT_SECURE_NO_WARNINGS
> 
> #include <stdio.h>
> 
> int foo(void);
> 
> int main(void)
> {
>     int x = 24; // declaration statement
> 
>     double dval = 5.60564; 
> 
>     x = dval; // buradaki statement legaldir ama bu doÄŸru bir kullanÄ±m olduÄŸu anlamÄ±n gelmez.
> }
> ```



ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ Atama operatÃ¶rÃ¼nÃ¼n Ã¼rettiÄŸi deÄŸer nesneye atanan deÄŸerdir. 
â—â—â— Bu cÃ¼mle iÃ§in kurs boyunca akÄ±lda 5-6 cÃ¼mle kalacaksa bu 5-6 cÃ¼mleden birisinin bu cÃ¼mle olmasÄ± gerektiÄŸi belirtildi, yani bu bilgi Ã§ok Ã¶nemli.

â—â—â— "**Atama operatÃ¶rÃ¼nÃ¼n Ã¼rettiÄŸi deÄŸer saÄŸ operandÄ±n Ã¼rettiÄŸi deÄŸerdir.**" bu cÃ¼mle yanlÄ±ÅŸtÄ±r Ã§Ã¼nkÃ¼ atama yapÄ±lan deÄŸiÅŸkenin tÃ¼rÃ¼ ile atanan deÄŸiÅŸkenin tÃ¼rÃ¼ birbirinden farklÄ± ise bu cÃ¼mle doÄŸru olmamaktadÄ±r.

â—â—â— "**Atama operatÃ¶rÃ¼nÃ¼n Ã¼rettiÄŸi deÄŸer nesneye atanan deÄŸerdir.**" bu cÃ¼mle doÄŸrudur.


ğŸ‘‡ AÅŸaÄŸÄ±daki program "**Atama operatÃ¶rÃ¼nÃ¼n Ã¼rettiÄŸi deÄŸer nesneye atanan deÄŸerdir.**" cÃ¼mlesinin doÄŸruluÄŸu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int foo(void);

int main(void)
{
    int x = 24; // declaration statement

    double dval = 5.60564; 

    x = dval; // buradaki 'x = dval' ifadesinin Ã¼reteceÄŸi deÄŸer '5' olacaktÄ±r '5.60564' deÄŸeri olmayacaktÄ±r.
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki program incelenerek `=` operatÃ¶rÃ¼nden oluÅŸturulan ifadelerin(expression) hangi deÄŸere sahip olacaÄŸÄ±yla ilgilidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 4;
    
    printf("%d\n", x = 34506); // 'x = 34506' ifadesi '34506' deÄŸerini Ã¼retir ve konsola '34506' yazar.
    
    printf("%d\n", x = 8.2032); // 'x = 8.2032' ifadesi '8' deÄŸerini Ã¼retir ve konsola '8' yazar.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda 1. ve 2. kullanÄ±mlar aynÄ±dÄ±r. C dilinde "2. kullanÄ±m durumu" bir idiom'dur ve bu ÅŸekilde kodlama yapmak kodlama yapan kiÅŸiyi daha profesyonel gÃ¶sterecektir. 
AyrÄ±ca Unix/Linux sistemlerinde 2. kullanÄ±mdaki gibi kodlamalar ile sÃ¼rekli karÅŸÄ±laÅŸÄ±lacaktÄ±r. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int foo(void);

int main(void)
{
    int x;
    // some code here

    // 1. kullanÄ±m durumu
    x = foo();
    if(x == -1){
        // some code here
        // ...
    }
    // ...
    
    // 2. kullanÄ±m durumu. Bu kullanÄ±m bir 'C idiom' olan yapÄ±dÄ±r.
    if((x = foo()) == -1){
        // some code here
        // ...
    }
    // ...

    return 0;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `=` operatÃ¶rÃ¼nÃ¼n bir `if` statement iÃ§erisinde bir **C idiom** olarak nasÄ±l kullanÄ±labileceÄŸi gÃ¶rÃ¼lecektir.
"1." ve "2." kullanÄ±m tamamen birbirinin aynÄ±sÄ±dÄ±r ve profesyonel C programcÄ±larÄ± "2." durumu kullanÄ±rlar. Buradaki programÄ±n tam olarak anlaÄ±ÅŸlmasÄ± beklenmiyor Ã§Ã¼nkÃ¼ henÃ¼z anlatÄ±lmayan kodlar kullanÄ±lÄ±yor.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

int foo(void);

int main(void)
{
    int n;
    int* p;
    // some code here('n' variable setting here)
    

    // 1. kullanÄ±m durumu
    p = malloc(n * sizeof(int));
    if(p == NULL ){
        printf("stderr", "cpnnot allocate memory!\n");
        return 1;
    }

    // 2. kullanÄ±m durumu(idiomatic kullanÄ±m)
    if((p = malloc(n * sizeof(int))) == NULL ){
        printf("stderr", "cpnnot allocate memory!\n");
        return 1;
    }
    

    // 'p' deÄŸiÅŸkenini burada kullanabiliriz
}
```


â— Kodlamada **C idiom** kullanÄ±lmasÄ± bazÄ± durumlarda kodu Ã§ok daha kompakt ve kolay okunur hale getiriyor. 



ğŸ‘‡ AÅŸaÄŸÄ±daki program bu dersin en Ã¶nemli kodunu barÄ±ndÄ±rmaktadÄ±r, bir **C idiom** yapÄ±sÄ±nÄ±n kullanÄ±lmasÄ± ve kullanÄ±lmamasÄ± durumunda nasÄ±l kodlama yapÄ±ldÄ±ÄŸÄ± gÃ¶sterilmektedir.
ğŸ‘‡ AÅŸaÄŸÄ±daki program klavyeden girilen yazÄ±yÄ± buffer'dan okur ve bu yazÄ±nÄ±n her karakteri ekrana gÃ¶rÃ¼ntÃ¼sÃ¼ ve kodu ile yazdÄ±rÄ±lÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int foo(void);

int main(void)
{
    int ch;
    

    // 1. kullanÄ±m durumu

    // Buradaki dÃ¶ngÃ¼ deyimine(idiom) sonsuz dÃ¶ngÃ¼(infinity loop) deniliyor.
    while(1){ 
        ch = getchar();
        if(ch == '\n')
            break;

        printf("%c %d", ch, ch);
    }


    // 2. kullanÄ±m durumu

    // Buradaki dÃ¶ngÃ¼ deyimine(idiom) sonsuz dÃ¶ngÃ¼(infinity loop) deniliyor. 
    // Burada kullanÄ±lan '(ch = getchar())' Ã¶ncelik parantezi Ã¶nemlidir
    while((ch = getchar()) != '\n'){ 
        printf("%c %d", ch, ch);
    }

    return 0;
}
```




ğŸ‘‡ AÅŸaÄŸÄ±daki program `=` operatÃ¶rÃ¼nÃ¼n **side effect** Ã¶zelliÄŸini anlayabilmek iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 7;
    
    printf("%d\n", x); // 7 yazar
    printf("%d\n", x = 54); // 54 yazar
    printf("%d\n", x); // 54 yazar
    
    return 0;
}
```


### Compound Assignment Operators(Ä°ÅŸlemli atama operatÃ¶rleri) 


**Compound assignment** terimi `+=` `-=` `*=` `/=` `>>=` `<<=` `&=` `^=` `|=` operatÃ¶rlerine verilen addÄ±r ve bu operatÃ¶rlerin hepsi aynÄ± Ã¶nceliÄŸe sahiptir.

`x += 34 -= 3 *= 4 /= 2;` ÅŸeklinde bir statement `x += (34 -= (3 *= (4 /= 2)));` olarak yorumlanacaktÄ±r, genelde mÃ¼lakatlarda soruluyormuÅŸ ve bu statement saÄŸdan sola doÄŸru Ã¶ncelik yÃ¶nÃ¼ne sahip olacaktÄ±r.



ğŸ‘‡ `+=` yerine `=+` ÅŸeklinde yazÄ±lÄ±rsa ne olur? ÅŸeklinde bir yorum yapÄ±ldÄ± ve bu durumda ne olacaÄŸÄ± aÅŸaÄŸÄ±daki programdan gÃ¶rÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 17;

    x =+ 5;
    
    printf("x = %d\n", x); // Burada konsola 'x = 5' yazar
    
    return 0;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `!=` yerine `=!` kullanÄ±lmasÄ± durumunda ne olacaÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 8;

    if(x != 5)
        printf("dogru\n");
    else
        printf("yanlis\n");

    // AÅŸaÄŸÄ±daki if deyimindeki 'x =! 5' ifadesi legaldir ve her zaman '0' yani 'false' deÄŸer Ã¼retir.
    if(x =! 5) // Burada '!=' yerine '=!' yazÄ±lmasÄ± durumu gÃ¶rÃ¼lebilir
        printf("dogru\n");
    else
        printf("yanlis\n");
    
    return 0;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **compound assignment** operatÃ¶rleri kullanÄ±larak `ndigit` fonksiyonunun nasÄ±l yazÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int ndigit(int x)
{
    if(x == 0){
        return 1;
    }

    int digit_count;

    whiel(x != 0){
        ++digit_count;
        x /= 10;
    }

    return digit_count;
}

int main(void)
{
    
    return 0;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **compound assignment** operatÃ¶rlerinin kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int day, hour, min, sec;
    
    printf("sureyi gun, saat, dakika ve saniye olarak giriniz:");
    scanf("%d%d%d%d", &day, &hour, &min, &sec);
    
    min += sec/60;
    sec %= 60;

    hour += min/60;
    min %= 60;

    day += hour/24;
    hour %= 24;
    
    printf("%d gun, %d saat, %d dakika ve %d saniye.\n", day, hour, min, sec);
}
```


ğŸ§­ Bir kodun doÄŸru olmasÄ±ndan sonraki o kodun kalitesini gÃ¶steren en Ã¶nemli faktÃ¶r kolay okunur olmasÄ±dÄ±r. 
- Kodun kolay okunmasÄ± dilin **idiom** yapÄ±larÄ±yla birlikte kodlandÄ±ÄŸÄ±nda okunmasÄ±nÄ±n kolay olmasÄ±dÄ±r. Mesele `whilne(n--){ ... }` ÅŸeklinde bir kullanÄ±m C dilinde **idiom** yapÄ±dÄ±r ve kolay okunabilirdir, kodu okuyabilmek belirli seviyede o dilin kÃ¼ltÃ¼rÃ¼ne hakim olmak gerekir.
- Ãœretimde en Ã§ok yapÄ±lan iÅŸ kod yazmaktan daha fazla kod okumaktÄ±r.

Ãœretimde en Ã§ok yapÄ±lan iÅŸler yoÄŸunluk miktarÄ±na gÃ¶re aÅŸaÄŸÄ±daki gibi sÄ±ralanabilir;
1. **Kodda hata aramak(Bug fixing)**
2. Kodu deÄŸiÅŸtirmek;
    1. Requirements(Kodun ihtiyacÄ±nÄ±n, isterlerinin deÄŸiÅŸimi)
    2. Algoritmik deÄŸiÅŸikliklerin yapÄ±lmasÄ±
    3. Efficiency(Ä°ÅŸin daha az iÅŸlemle yapÄ±lmasÄ±nÄ± saÄŸlama gereksinimin olmasÄ±)
    4. Porting different platform(YazÄ±lÄ±mÄ±n baÅŸka bir cihazda, iÅŸletim sisteminde Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlama ihtiyaÃ§larÄ±)
    5. Refactoring(Kodun anlamÄ±nÄ± deÄŸiÅŸtirmeden kodun deÄŸiÅŸtirilmesi). Bu konu da kendi iÃ§inde ayrÄ± baÅŸlÄ±klara ayrÄ±labilir ve kÄ±saca bu iÅŸlemler kodu okuyup iyileÅŸtirmek iÃ§in yapÄ±lÄ±r.



âœï¸ **Donald Knuth**: "**Early optimization is evil**(Kodun erken aÅŸamada hÄ±zlÄ± Ã§alÄ±ÅŸmasÄ± iÃ§in yapÄ±lan iÅŸlemler Ã¶lÃ¼mcÃ¼ldÃ¼r)" sÃ¶zÃ¼ Ã¶nemlidir.

Kodun hÄ±zlÄ± Ã§alÄ±ÅŸmasÄ± niyetiyle(ki Ã§oÄŸunlukla bÃ¶yle bir ihtiyaÃ§ yoktur) kodu anlaÅŸÄ±lÄ±r(okunabilir) olmaktan Ã§Ä±kartmak doÄŸru bir yaklaÅŸÄ±m deÄŸildi.
Mikro dÃ¼zeyde iyileÅŸtirme(optimization) yapmaya Ã§alÄ±ÅŸÄ±lmamalÄ±. 


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.42-11.00 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


>â”
> 
> Sorulan soru;
> 
> Dersin baÅŸÄ±nda bir Ã¶rnek vardÄ±
> if(!(x == z)) ÅŸeklinde
> bunun if (x != z) ifadesinden bir fark var mÄ±?
> dÃ¼nkÃ¼ "De Morgan" ve bÃ¼tÃ¼n deÄŸil iÅŸlemlerinde `!` operatÃ¶rÃ¼nÃ¼ kullandÄ±k, `!=` operatÃ¶rÃ¼nÃ¼ de tercih edilemez miydik, eÅŸitlik karÅŸÄ±laÅŸtÄ±rmalarÄ± iÃ§in?
> 
> Cevap;
> 
> CevabÄ± yukarÄ±da yazÄ±lmÄ±ÅŸ olan kodlar incelendiÄŸinde anlaÅŸÄ±lacaÄŸÄ± iÃ§in uzun ÅŸekilde cevabÄ± yazmadÄ±m!



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "1." ve "2." kullanÄ±m birbiriyle aynÄ± anlamda olmayabilir, eÄŸer `foo` fonksiyonu **pure function** ise iki kod kullanÄ±mÄ± aynÄ± olur fakat verimli Ã§alÄ±ÅŸmaz.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int foo(void);

int main(void)
{
    int x , y, z, t;
    
    // 1. kullanÄ±m
    x = foo();
    y = x;
    z = z;
    t = t;

    //// 2. kullanÄ±m
    //x = foo();
    //y = foo();
    //z = foo();
    //t = foo();

    x = y = z = t = foo(); // Buradaki kullanÄ±m bir 'C idiom' yapÄ±sÄ±dÄ±r ve buna benzer kodlar yoÄŸun olarak kullanÄ±lÄ±r.
    //x = (y = (z = (t = foo()))); // Buradaki atama iÅŸlemi yukarÄ±dakiyle aynÄ±dÄ±r, burada Ã¶nceliÄŸin nasÄ±l olacaÄŸÄ± vurgulanÄ±yor.

    printf("%d %d %d %d\n", x, y, z, t);

    return 0;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program ile iÅŸlemli atama operatÃ¶rlerinin nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int foo(void);

int main(void)
{
    int x = 10, y = 20, z = 30, t = 40;
    
    x += y *= z /= t -= 2; // Buradaki kodlama legaldir ama kullanÄ±ÅŸlÄ± deÄŸildir. Sadece mÃ¼lakat ve dili Ã¶ÄŸrenirken kullanÄ±ÅŸlÄ±dÄ±r.

    printf("t = %d\n", t);
    printf("z = %d\n", z);
    printf("y = %d\n", y);
    printf("x = %d\n", x);

    return 0;
}
```


## Sequence Point(Yan etki noktasÄ±)

Bu terim tÃ¼m programlama dillerinde olan ve bilinmesi Ã¶nemli olan bir terimdir.

**Sequence Point(Yan etki noktasÄ±)** kaynak kodda Ã¶yle bir nokta(yer) var ki bu noktadan Ã¶nceki **yan etkiler(side effects)** bu noktadan sonra gÃ¶rÃ¼lÃ¼r olmak zorundadÄ±r.
Bir Sequence Point(Yan etki noktasÄ±)'ten Ã¶nce yan etkiye maruz kalmÄ±ÅŸ bir nesnenin deÄŸerini kullanmak **UB(tanÄ±msÄ±z davranÄ±ÅŸ)** olacaktÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki program **yan etki noktasÄ±nÄ±n(sequence point)** ne olduÄŸunun bilinmesinin Ã¶nemi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 10;

    // AÅŸaÄŸÄ±daki 'x' deÄŸeri '++' operatÃ¶rÃ¼ ile yan etkisi olan bir iÅŸleme giriyor ve bu iÅŸlemden sonra 'sequence point' olmadÄ±ÄŸÄ± iÃ§in ve hemen sonra 'x' deÄŸeri kullanÄ±ldÄ±ÄŸÄ± iÃ§in burada 'ub' vardÄ±r.
    int y = x++ * x;

    printf("y = %d\n", y);

    return 0;
}
```



ğŸ§­ Nerelerde **Sequence Point(Yan etki noktasÄ±)** olduÄŸu aÅŸaÄŸÄ±da listelenmiÅŸtir(ÅŸu ana kadarlÄ±k iÅŸlenen konular iÃ§inde nerelerde olduÄŸu aÅŸaÄŸÄ±da listelenmiÅŸtir);
1. Deyim(statement) sonlarÄ±nÄ± bildiren `;` terminator token'Ä±nÄ±n kullanÄ±ldÄ±ÄŸÄ± yerlerde. 
2. comma operator(`,`) kullanÄ±ldÄ±ÄŸÄ± yerlerde.
3. `if(exp)`, `while(exp)`, `for(exp1; exp2; exp3)` iÃ§erisindeki ifadelerde.
4. DÃ¶rt tane operatÃ¶r(`&&` `||` `? :` `,`) kullanÄ±ldÄ±ÄŸÄ± yerlerde. 



ğŸ‘‡ AÅŸaÄŸÄ±daki program 
```C 
#include <stdio.h>

int foo(void);

int main(void)
{
    int x = 10;
    int y = 20;

    x++; // Burada bir 'Sequence Point' vardÄ±r.
    y += x; // Burada bir 'ub' yoktur.

    printf("y = %d\n", y);

    return 0;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program 
```C 
#include <stdio.h>

int foo(void);

int main(void)
{
    int x = 10;
    int y = 20;
    int z = 50;

    x++; // Burada bir 'Sequence Point' vardÄ±r.
    y = x *= 3; // Burada bir 'ub' yoktur.
    z = y + x;

    printf("y = %d\n", y);

    return 0;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program incelenerek **sequence point(Yan etki noktasÄ±)** olup olmamasÄ±ndan kaynaklÄ± oluÅŸan **ub** durumlarÄ± koddaki deyimler(statement) incelenerek gÃ¶rÃ¼lebilir.
ğŸ‘‡ AÅŸaÄŸÄ±daki program her bir deyim(statement) ayrÄ± ayrÄ± incelenmelidir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int foo(void);

int main(void)
{
    int x = 10, y = x++, z = --y; // Burada 'ub' yoktur Ã§Ã¼nkÃ¼ ',' operatÃ¶rÃ¼(token'Ä±) 'sequence point' gÃ¶revi gÃ¶rÃ¼r.

    x++; // Burada ';' token'Ä± 'sequence point' gÃ¶revi gÃ¶rÃ¼r.

    x = x++; // Burada 'x++' ifadesi 'side effect' iÃ§eriyor ve bu ifadenin deÄŸeri yine aynÄ± deÄŸiÅŸkene atanÄ±yor bu nedenle burada 'ub' vardÄ±r.

    int t = x + ++x; // Burada '++x' ifadesi 'side effect' iÃ§eriyor ve '++' iÅŸlemi yapÄ±ldÄ±ktan sonra bir 'sequence point' olmadan ifade baÅŸka bir 
    
    y = x *= 3; // Burada bir 'ub' yoktur.

    z = y + x; // Burada bir 'ub' yoktur.

    printf("x = %d\n", x);
    printf("y = %d\n", y);
    printf("z = %d\n", z);
    printf("t = %d\n", t);

    return 0;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **ub** yoktur Ã§Ã¼nkÃ¼ C dilinin kurallarÄ± "if deyiminin iÃ§indeki ifade bitiminde bir **sequence point** vardÄ±r." demesidir.
```C
#include <stdio.h>

int foo(void);

int main(void)
{
    int x = 10;  

    if(++x > 10) // Burada 'ub' olmamasÄ±nÄ±n nedeni dilin kurallarÄ±nÄ±n 'if' deyiminden sonra 'sequence point' olmasÄ±dÄ±r.
        printf("x = %d\n", x); // Burada konsola 'x = 11' yazacaktÄ±r. 

    return 0;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programÄ±n Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ± sonucunda oluÅŸacak Ã§Ä±ktÄ± `&&` operatÃ¶rÃ¼nÃ¼n bir **sequence point** oluÅŸturduÄŸunu anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>

int foo(int a)
{
    printf("a = %d\n", a);
    
    return 1;
}

int main(void)
{
    int x = 10;

    int b = ++x > 10 && foo(x); // Burada 'ub' durumu yoktur, '&&' operatÃ¶rÃ¼ bir 'sequence point' oluÅŸturur.

    printf("b = %d\n", b);

    return 0;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Microsoft firmasÄ±nÄ± mÃ¼lakatÄ±nda sorulmuÅŸ C sorusu "Program Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda 'z' deÄŸiÅŸkeninin deÄŸeri ne olur?". </br>
- Sorunun cevabÄ±: `z = (y = 9) * y` ifadesine(expression) **ub** vardÄ±r. **ub** durumu varsa program Ã§alÄ±ÅŸma anÄ±nda her ÅŸey olabilir, bu her ÅŸeye kodun nasÄ±l Ã§alÄ±ÅŸacaÄŸÄ± beklentisi de dahildir." ÅŸeklinde olacaktÄ±.
```C
#include <stdio.h>

int main(void)
{
    int y = 5;

    int z = (y = 9) * y; // Burada 'ub' durumu vardÄ±r Ã§Ã¼nkÃ¼ '(y = 9)' ifadesinden sonra bir 'sequence point' ve bu ifadede deÄŸeri deÄŸiÅŸtirilmek istenen 'y' deÄŸiÅŸkeni ikinci defa kullanÄ±lÄ±yor.

    printf("z = %d", z);

    return 0;
}
```


â— YukarÄ±daki kod misallerinde olan **ub** durumlarÄ±nÄ±n tehlikesi ÅŸudur: Kod programcÄ±nÄ±n beklentisine gÃ¶re Ã§alÄ±ÅŸÄ±yor olabilir fakat **ub** durumlarÄ± dilin standardÄ±nda aÃ§Ä±k ÅŸekilde belirtilmiÅŸtir, **ub** olan bir program binlerce defa Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda beklenildiÄŸi gibi Ã§alÄ±ÅŸabilir ama bu o programÄ±n kararlÄ± olarak doÄŸru Ã§alÄ±ÅŸtÄ±ÄŸÄ± anlamÄ±na gelmeyecektir.



ğŸ‘‡ AÅŸaÄŸÄ±daki program Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda konsola "8" yazacaktÄ±r. 
- â— **ternary operator**'Ä±n ilk ifadesinden sonra bir **sequence point** vardÄ±r, bu operatÃ¶r ilerki derlerde 2-3 saat olarak iÅŸlenecektir.
- Burada `exp1 ? exp2 : exp3` ilk ifade iÅŸlendikten sonra eÄŸer bu ilk ifadede **side effect** durumu olan bir iÅŸlem varsa bu iÅŸlem yapÄ±ldÄ±ktan sonra **ternary operator**'Ä±n diÄŸer ikinci ve Ã¼Ã§Ã¼ncÃ¼ ifadesinde deÄŸeri deÄŸiÅŸen bir deÄŸiÅŸken kullanÄ±lÄ±yorsa **ternary operator**'Ä±n ilk ifadesinden sonra bir **sequence point** olduÄŸu iÃ§in diÄŸer ifadelerde deÄŸeri deÄŸiÅŸen deÄŸiÅŸken deÄŸiÅŸmiÅŸ deÄŸeriyle birlikte kullanÄ±lacaktÄ±r.
```C
#include <stdio.h>

int main(void)
{
    int x = 0;
    
    printf("%d\n", ++x ? x + 7 : x - 3); // Konsola '8' yazacaktÄ±r.
}
```



C ve C++ dilleri arasÄ±nda **sequence point** kurallarÄ±nda bazÄ± farklÄ±lÄ±klarÄ± vardÄ±r.
ğŸ‘‡ AÅŸaÄŸÄ±daki program incelenerek buna dair bazÄ± bilgiler edinilebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 0;  
    
    // AÅŸaÄŸÄ±daki statement C dilinde 'ub' iÃ§erirken C++ dilinde 'ub' iÃ§ermez. 
    // C de 'ub' iÃ§erir Ã§Ã¼nkÃ¼ 'x = x++' ifadesinde hem 'x++' iÅŸlemi ile 'x' deÄŸeri deÄŸiÅŸtiriliyor hem de aynÄ± ifade iÃ§inde 'sequence point' yer almÄ±yor ve 'x' deÄŸeri yine kendisine atanÄ±yor.
    // C++ dilinde muhtemelen 'x++' ifadesi kendi iÃ§inde 'sequence point' barÄ±ndÄ±rÄ±yor bu nedenle 'ub'ye neden olmuyor.
    x = x++;
}
```


## Comma Operator 


Necati Ergin, C++ kursuma katÄ±lan kiÅŸiler arasÄ±nda iyi C biliyorum diyenlerden `,` operatÃ¶rÃ¼nÃ¼ sorduÄŸunda, `,` operatÃ¶rÃ¼nÃ¼n Ã§alÄ±ÅŸma mantÄ±ÄŸÄ±nÄ± bilen Ã§Ä±kmadÄ±ÄŸÄ±nÄ± ifade etti.

Kodda gÃ¶rÃ¼len her `,` bir operatÃ¶r deÄŸildir, bir kodda gÃ¶rÃ¼len her `(` token'Ä±nÄ±n bir operatÃ¶r olmamasÄ± gibi. Kodda gÃ¶rÃ¼len her token da bir operatÃ¶r deÄŸildir.

Birden fazla ifade(expression) `,` operatÃ¶rÃ¼ ile birleÅŸtirilerek tek bir ifade(expression) oluÅŸturulabilir. 

`,` operatÃ¶rÃ¼ aÅŸaÄŸÄ±daki Ã¶zelliklere sahiptir;
- `,` operatÃ¶rÃ¼nÃ¼n Ã¶nceliÄŸi tÃ¼m operatÃ¶rler arasÄ±ndaki en dÃ¼ÅŸÃ¼k Ã¶nceliktedir.
- `,` operatÃ¶rÃ¼ **binary infix** operatÃ¶rdÃ¼r.
- `,` token'Ä± kullanÄ±ldÄ±ÄŸÄ± yere gÃ¶re ya **comma separetor** ya da **comma operator** olarak gÃ¶rev alÄ±r.
- `,` operatÃ¶rÃ¼ **sequance point** oluÅŸturur.



ğŸ‘‡ AÅŸaÄŸÄ±daki program kodlamadaki hangi token'larÄ±n **operatÃ¶r** hangilerinin **declarator** olduÄŸunu anlamak iÃ§in Ã¶nemlidir.
```C
#include <stdio.h>

int foo(void);

int main(void)
{
    // AÅŸaÄŸÄ±daki statement'larda hangi token'lerÄ±n operatÃ¶r olup olmadÄ±ÄŸÄ±nÄ± yaz!
    int a[5] = { 0 }; // Buradaki 'a[5]' ifadesindeki '[]' bir operatÃ¶r deÄŸildir, diziyi tanÄ±mlamakta kullanÄ±ldÄ±ÄŸÄ± iÃ§in 'declarator' olarak adlandÄ±rÄ±lÄ±yor.
    int x = 5;
    int* ptr = &x; // 'int* ptr = &x' ifadesindeki 'int*' ifadesindeki '*' bir operatÃ¶r deÄŸildir, '&x' ifadesindeki '&' bir operatÃ¶rdÃ¼r.
    int y = *ptr; // 'int y = *ptr' ifadesindeki '*ptr' ifadesindeki '*' bir operatÃ¶rdÃ¼r.
    int (*p)[5] = &a; // Buradaki '(*p)[5]' ifadesindeki '()', '*', '[]' bir operatÃ¶r deÄŸildir, 'declarator' durumundadÄ±r.
    int z = a[5]; // Buradaki 'a[5]' ifadesindeki '[]' bir operatÃ¶rdÃ¼r. 


    int x = 5, y = 7, z = 4; // Buradaki ',' operatÃ¶r deÄŸildir 'comma separator' durumundadÄ±r.
    foo(x, y); // Buradaki ',' operatÃ¶r deÄŸildir 'comma separator' durumundadÄ±r.
    int a[] = {4, 8, 9}; // Buradaki ',' operatÃ¶r deÄŸildir 'comma separator' durumundadÄ±r.

    return 0;
}
```



ğŸ”¥ğŸ”¥ğŸ”¥ AÅŸaÄŸÄ±daki **ifadedir(expression)** ile **deyim(statement)** ayrÄ±mÄ±nÄ± iyi bilmek gerekiyor;
- `a = 5, b = 3` bu bir **ifadedir(expression)** Ã§Ã¼nkÃ¼ ifadeler operatÃ¶rlerden, deÄŸiÅŸkenlerden, sabitlerden oluÅŸan kodsal bir varlÄ±ktÄ±r. 
- Fakat `int a = 5, b = 3` bir ifade deÄŸildir Ã§Ã¼nkÃ¼ burada bir bildirim var, bildirimlerde ifadeleri bir birinden ayÄ±rmak iÃ§in kullanÄ±lan `,` token'Ä± operatÃ¶r deÄŸil seperator gÃ¶revindedir.
- Her ifadenin bir deÄŸeri vardÄ±r.


VirgÃ¼lÃ¼n operatÃ¶r olduÄŸu yerlerde bir ifade oluÅŸturulmuÅŸ olur.
- `a = 5, b = 3` ve `++x, ++y, z++, ++t` bir **ifadedir(expression)**.
- `a = 5, b = 3;` ve `++x, ++y, z++, ++t;` bir **deyimdir(statement)**, **ifadelerin(expression)** sonuna `;` token'Ä± eklenirse **deyim(statement)** oluÅŸturulur ve bu deyÃ¼mler **expression statement** olarak adlandÄ±rÄ±lmaktadÄ±r.
- `a = 5, b = 3;` ve `++x, ++y, z++, ++t;` **deyimleri(statement)** **expression statement** olarak adlandÄ±rÄ±lÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki program `,` operatÃ¶rÃ¼nÃ¼n **sequence point** oluÅŸturduÄŸu durum incelenebilir.
```C
#include <stdio.h>

int foo(void);

int main(void)
{
    int x = 5, y = 7; // Buradaki ',' token'Ä± operatÃ¶r deÄŸildir 'comma separator' durumundadÄ±r. Buradaki satÄ±r 'declaration statement' olarak adlandÄ±rÄ±lÄ±yor.  
    int temp;

    temp = x, x = y, y = temp; // Burada kullanÄ±lan ',' operatÃ¶r gÃ¶revindedir ve ',' operatÃ¶rÃ¼ 'sequence point' oluÅŸturduÄŸu iÃ§in buradaki gibi bir kullanÄ±m doÄŸrudur(legal).

    print("x = %d, y = %d, temp = %d", x, y, temp); // Konsola 'x = 7, y = 5, temp = 5' yazar. Buradaki ',' token'larÄ± operatÃ¶r deÄŸildir 'comma separator' durumundadÄ±r.

    return 0;
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.11-12.21 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


â— VirgÃ¼l operatÃ¶rÃ¼nÃ¼n Ã¼reteceÄŸi deÄŸer saÄŸ operandÄ±n deÄŸeridir.

Her ifadenin bir deÄŸeri vardÄ±r demiÅŸtik, `a = 5, b = 9, e = 3` ifadesinin deÄŸeri "3" oluyor o zaman.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda "z" deÄŸiÅŸkenine deÄŸer atarken kullanÄ±lan ifadelerdeki `,` **operatÃ¶r** iÅŸlevindedir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int x = 5, y = 7;
    int z;
    
    z = (x, y); // Buradaki ',' 'comma operator' iÅŸlevindedir.
    printf("z = %d", z);  // Konsola 'z = 7' yazar.

    
    z = (y, x); // Buradaki ',' 'comma operator' iÅŸlevinde.
    printf("z = %d", z);  // Konsola 'z = 5' yazar.
    
    return 0;
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda "z" deÄŸiÅŸkenine deÄŸer atarken kullanÄ±lan ifadelerdeki "," **operatÃ¶r** deÄŸildir **comma separator** iÅŸlevindedir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 5, y = 7;
    int z;
    
    z = x, y; // Buradaki ',' 'comma separator' iÅŸlevinde. Buradaki ifade ' (z = x), y;' olarak yorumlanacaktÄ±r.
    printf("z = %d", z);  // Konsola 'z = 5' yazar.

    
    z = y, x; // Buradaki ',' 'comma separator' iÅŸlevinde.
    printf("z = %d", z);  // Konsola 'z = 7' yazar.
    
    return 0;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program `,` operatÃ¶rÃ¼nÃ¼n Ã¼rettiÄŸi deÄŸerin saÄŸ operandÄ±n deÄŸeri olduÄŸunu anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int z;
    
    z = (1, 2, 3, 4, 5, 6, 7, 8, 9); // Buradaki ',' 'comma operator' iÅŸlevinde.

    printf("z = %d", z);  // Konsola 'z = 9' yazar.
    
    return 0;
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki program "if" **deyimi(statement)** iÃ§inde `,` operatÃ¶rÃ¼ iÃ§eren bir **ifade(expression)** kullanÄ±ldÄ±ÄŸÄ±nda nasÄ±l bir akÄ±ÅŸ olacak onu gÃ¶stermektedir(Necati Ergin burada virgÃ¼l operatÃ¶rÃ¼ iÃ§eren ifadelerin deÄŸeri saÄŸ opetandÄ±n deÄŸeridir ve virgÃ¼l operatÃ¶rÃ¼ bir **sequence point** oluÅŸturuyordu bunu unuttuk mu, daha az Ã¶nce konuÅŸtuk. "BalÄ±k hafÄ±zasÄ± diyorlar ya" dedi. Burada Ã§ok gÃ¼ldÃ¼m ğŸ˜‚ğŸ˜‚ğŸ˜‚). </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programÄ±n Ã§alÄ±ÅŸma mantÄ±ÄŸÄ±nÄ±n anlaÅŸÄ±lmasÄ± `,` operatÃ¶rÃ¼nÃ¼n nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± anlamak iÃ§in Ã¶nemlidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int z = 5;

    if(z++, z > 5) // Burada sÃ¶zdizim hatasÄ±(syntax error) yok, 'ub' yok. Burada Ã¼retilecek deÄŸer 'z > 5' ifadesinin deÄŸeridir ve ',' operatÃ¶rÃ¼ 'sequance point' oluÅŸturduÄŸu iÃ§in 'z' deÄŸiÅŸkeninin deÄŸeri '6' olacaktÄ±r.
        printf("%d", z); // Kod akÄ±ÅŸÄ± buraya girer ve konsola '6' yazar.

    return 0;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programÄ±n Ã§alÄ±ÅŸma mantÄ±ÄŸÄ±nÄ±n anlaÅŸÄ±lmasÄ± `,` operatÃ¶rÃ¼nÃ¼n nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± anlamak iÃ§in Ã§ok Ã¶nemlidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    double dval = 3.7;

    // AÅŸaÄŸÄ±daki 'if-else' Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda konsola 'dogru' yazacaktÄ±r.
    if(dval > 3.0) 
        printf("dogru\n");
    else
        printf("yanlis\n");

    
    // AÅŸaÄŸÄ±daki 'if-else' Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda konsola 'yanlis' yazacaktÄ±r. Bunun nedeni 'if' deyiminin iÃ§indeki ifadenin 'dval > 3,0' ÅŸeklinde olmasÄ± ve bu ifadedeki ',' operatÃ¶rÃ¼nÃ¼n
    // ilk operandÄ±nÄ±n 'dval > 3' olmasÄ± ama ikinci operandÄ±nÄ±n '0' olmasÄ± nedeniyle ve de ',' operandÄ±nÄ±n deÄŸerinin saÄŸ operandÄ±nÄ±n deÄŸeri olmasÄ±ndan dolayÄ±
    // 'dval > 3,0' ifadesinin deÄŸeri '0' olacaktÄ±r ve '0' deÄŸeri de 'false' olarak yorumlanacaÄŸÄ± iÃ§in programÄ±n akÄ±ÅŸÄ± 'else' kÄ±smÄ±na gider.
    if(dval > 3,0) // 
        printf("dogru\n");
    else
        printf("yanlis\n");

    return 0;
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programÄ±n Ã§alÄ±ÅŸma mantÄ±ÄŸÄ±nÄ±n anlaÅŸÄ±lmasÄ± "," operatÃ¶rÃ¼nÃ¼n nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± anlamak iÃ§in Ã§ok Ã¶nemlidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    double dval = 2.4;

    // AÅŸaÄŸÄ±daki 'if-else' Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda konsola 'yanlis' yazacaktÄ±r Ã§Ã¼nkÃ¼ '2.4' deÄŸeri '3.5' deÄŸerinden bÃ¼yÃ¼k olmadÄ±ÄŸÄ± iÃ§in.
    if(dval > 3.5)
        printf("doÄŸru\n");
    else
        printf("yanlis\n");


    // AÅŸaÄŸÄ±daki 'if-else' Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda konsola 'dogru' yazacaktÄ±r Ã§Ã¼nkÃ¼ 'dval > 3,5' ifadesinindeki ',' operatÃ¶rÃ¼nÃ¼n operantlarÄ± 'dval > 3' ve '5' olacaktÄ±r ve 
    // ',' operandÄ±nÄ±n deÄŸerinin saÄŸ operandÄ±nÄ±n deÄŸeri olduÄŸundan 'dval > 3,5' ifadesinin deÄŸeri '5' olacaktÄ±r, '5' 'non-zero' deÄŸer olduÄŸu iÃ§in 'true' olarak yorumlanÄ±r
    if(dval > 3,5)
        printf("dogru\n");
    else
        printf("yanlis\n");

    return 0;
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki program `,` operatÃ¶rÃ¼ ile birden fazla **expression statement** birleÅŸtirilip tek bir **expression statement** oluÅŸturulduÄŸu durum incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int x = 5, y = 6, z = 7;

    if(x > 3) 
        x++, y++, z++; // Buradaki `,` operatÃ¶rÃ¼ tek bir satÄ±rsa Ã¼Ã§ farklÄ± expression tek bir statement iÃ§inde birleÅŸtirmek iÃ§in kullanÄ±lmÄ±ÅŸtÄ±r. comma operatÃ¶rÃ¼ bunun iÃ§in de kullanÄ±labiliyor.
    
    return 0;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki Ã¼Ã§ farklÄ± kullanÄ±m da sonuÃ§ olarak aynÄ± Ã§alÄ±ÅŸacaktÄ±r, bunu gÃ¶rebilmek ve anlayabilmek Ã¶nemlidir!
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

int foo(void);
int bar(void);

int main(void)
{
    int ret;

    // 1. kullanÄ±m
    ret = foo();
    if(ret > 10)
        bar(ret);
    
    // 2. kullanÄ±m
    if((ret = foo()) > 10)
        bar(ret);
        
    // 3. kullanÄ±m
    if(ret = foo(), ret > 10) // Buradaki 'ret = foo(), ret > 10' ifadesinde 'if' ÅŸartÄ±nÄ± belirleyen ',' operatÃ¶rÃ¼nÃ¼n saÄŸ operandÄ± olan 'ret > 10' ifadesidir(burayÄ± anlamak Ã¶nemlidir).
        bar(ret);

    return 0;
}
```

â— C dilinde Ã¶yle yerler var ki ya biz o yerlerde kontrol deyimi kullanmak istemiyoruz ya da dilin **sÃ¶zdizimi(syntax)** orada kontrol deyimi kullanÄ±lmasÄ±na izin vermiyor, iÅŸte bu yerlerde `,` operatÃ¶rÃ¼nÃ¼n kullanÄ±lmasÄ± gerekebilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "for" dÃ¶ngÃ¼sÃ¼nÃ¼n Ã¼Ã§ tane **ifadesinde(expression)** ikiÅŸer tane ifade(expression) kullanabilmek iÃ§in `,` operatÃ¶rÃ¼nden faydalanÄ±lmÄ±ÅŸtÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x, y;
    
    // AÅŸaÄŸÄ±daki gibi bir 'for' dÃ¶ngÃ¼sÃ¼nÃ¼ yazmak iÃ§in ',' operatÃ¶rÃ¼ kullanÄ±labilir.
    for(x = 4, y = 5; x * y < 1000; ++x, y += x){
        // some code write here...
    }
    
    return 0;
}
```



â— VirgÃ¼l operatÃ¶rÃ¼ neden kullanÄ±lÄ±r;
1. VirgÃ¼l operatÃ¶rÃ¼nÃ¼n Ã¼rettiÄŸi deÄŸerden faydalanÄ±lan **idiom**'larda kullanÄ±lÄ±r.
2. BazÄ± makro tekniklerinde kullanÄ±lÄ±r(bu kÄ±sÄ±m ÅŸu anda ileri seviye bir konu, sonradan deÄŸinilecek).
3. Blok kullanmadan kaÃ§Ä±nmak iÃ§in kullanÄ±lÄ±r. `if(x > 3) { x++; y++; z++; }` bu **if statement** `if(x > 3) x++, y++, z++;` ÅŸeklinde yazÄ±ldÄ±ÄŸÄ± durumdaki gibi.


ğŸ‘‡ AÅŸaÄŸÄ±daki program "," operatÃ¶rÃ¼nÃ¼n kullanÄ±m nedenlerinden **1.** maddeyi aÃ§Ä±klamak iÃ§in incelenebilir.
- `while(scanf("%d", &x), x > 0)` dÃ¶ngÃ¼ deyimi(loop statement) incelenince iki farklÄ± ifade(expression) iÃ§erdiÄŸi gÃ¶rÃ¼lÃ¼r, 
- `scanf("%d", &x)` ifadesi ile kullanÄ±cÄ±dan girdi alÄ±nÄ±r ve ardÄ±ndan gelen "," operatÃ¶rÃ¼ **sequence point** oluÅŸturduÄŸu iÃ§in `x` deÄŸeri girdiden gelen deÄŸer ile gÃ¼ncellenir,
- "," operatÃ¶rÃ¼nÃ¼n ikinci operandÄ± olan `x > 0` ifadesi ise dÃ¶ngÃ¼ bloÄŸuna girilip girilmeyeceÄŸini belirler.
- AyrÄ±ca `while(scanf("%d", &x), x > 0)` dÃ¶ngÃ¼ deyimi(loop statement) C dilinde bir **idiomatic** kullanÄ±mdÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x;
    
    // AÅŸaÄŸÄ±daki gibi bir 'while' dÃ¶ngÃ¼sÃ¼nÃ¼ yazmak iÃ§in ',' operatÃ¶rÃ¼ kullanÄ±labilir.
    while(scanf("%d", &x), x > 0)
        printf("%d\n", x);
    
    return 0;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki yarÄ±m olan kodlarda "foo" fonksiyonunun deÄŸer dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ yerde `,` operatÃ¶rÃ¼ kullanÄ±larak deÄŸer dÃ¶ndÃ¼rmeden Ã¶nce baÅŸka bir fonksiyon Ã§alÄ±ÅŸtÄ±rÄ±lmÄ±ÅŸtÄ±r,
bu fonksiyonun Ã§alÄ±ÅŸmasÄ± bittikten sonra **ifadesi(expression)** "foo" fonksiyonundan geriye dÃ¶ndÃ¼rÃ¼lecektir.
Buradaki `return bar(), x -4` kullanÄ±mÄ± kursun ÅŸu aÅŸamasÄ±nda erken verilen bir kullanÄ±mdÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int bar();

int foo(int x)
{
    // some code can write here...

    return bar(), x -4;
}


int main(void)
{
    // some code can write here...
    
    return 0;
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki program `,` operatÃ¶rÃ¼nÃ¼n kullanÄ±mÄ±nda Ã¼retilen deÄŸerin ne olduÄŸunu anlamaya yÃ¶neliktir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 76, y;
    
    // ',' operatÃ¶rÃ¼ 'sequence point' oluÅŸturduÄŸu iÃ§in burada 'ub' yoktur ve y deÄŸiÅŸkenine sÄ±rasÄ±yla deÄŸiÅŸen '!x', '76!', '0' deÄŸeri atanÄ±r.
    // 'y = !x, y' ifadesi derleyici tarafÄ±nda ÅŸu ÅŸekilde yorumlanÄ±r '(y = !x), (y)' yukarÄ±daki durumun nedeni bu yorumlamadÄ±r.
    y = !x, y;   

    printf("x = %d\n y = %d\n", x, y); // Burada konsola 'x = 76\n y = 0\n' yazacaktÄ±r.
    
    printf("(!x, y) = %d\n", (!x, y)); // Burada konsola '(!x, y) = 0' yazacaktÄ±r.
    printf("(y = !x, y) = %d\n", (y = !x, y)); // Burada konsola '(y = !x, y) = 0' yazacaktÄ±r.
    
    return 0;
}
```


ğŸš€ C mÃ¼lakatlarÄ±nda `4.5` ve `4,5` gibi sabitlerin(constant) bazÄ± ifadelerde `.` yerine `,` kullanÄ±lmasÄ±ndan kaynaklanabilecek farklÄ±lÄ±klar sorulmaktadÄ±r. Bu durumla ilgili yukarÄ±da yazÄ±lan kodlar dikkatli incelenmelidir.

ğŸš€ Ã–yle yerler var ki biz virgÃ¼l operatÃ¶rÃ¼nÃ¼ kullanmak istiyoruz ancak **sÃ¶zdizim(syntax)** kullandÄ±ÄŸÄ±mÄ±z virgÃ¼lÃ¼ operatÃ¶r deÄŸil "**comma separator list**" yapÄ±yor, bunu yapmak iÃ§in sadece ifadeyi "( ... )" iÃ§ine almak gerekiyor.



ğŸ‘‡ AÅŸaÄŸÄ±daki program **comma separator** ve **comma operator** farkÄ±nÄ±n ne olduÄŸunu anlayabilmek iÃ§in incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int a1[10] = { 1, 2, 3, 4, 5, 6 }; // Burada kullanÄ±lan virgÃ¼ller 'comma separator' gÃ¶revindedir. Bu kod kullanÄ±lÄ±rsa ekranda '1 2 3 4 5 6 0 0 0 0' yazacaktÄ±r.
    int a2[10] = {(1, 2, 3, 4, 5, 6) }; // Burada kullanÄ±lan virgÃ¼ller 'comma operator' gÃ¶revindedir. Bu kod kullanÄ±lÄ±rsa ekranda '6 0 0 0 0 0 0 0 0 0' yazacaktÄ±r.

    for(int i = 0; i < 10; ++i){
        printf("%d ", a1[i]);
    }
    
    for(int i = 0; i < 10; ++i){
        printf("%d ", a2[i]);
    }
    
    return 0;
}
```


Ders sonu ...
