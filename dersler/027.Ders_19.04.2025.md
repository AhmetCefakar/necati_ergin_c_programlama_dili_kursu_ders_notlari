# 27.Ders 19.04.2025 ğŸ•˜

Derse 18(09:01)-20(09:39)-22(10:08)-21(11:01)-20(11:58)-21(12:10)-20(12:37) kiÅŸi katÄ±ldÄ±.
---

## Pointers Devam

â— Pointer deÄŸiÅŸkenlerin en sÄ±k kullanÄ±ldÄ±ÄŸÄ± yer **call by reference(pass by reference)** ile parametre alan fonksiyonlardÄ±r.

â— C benzeri programlama dillerinde fonksiyonlarÄ±n alacaÄŸÄ± deÄŸerlerin nasÄ±l gÃ¶nderileceÄŸi ikiye ayrÄ±lmaktadÄ±r bunlar, **call by value(pass by value)** ve **call by reference(pass by reference)**.

â— Programlama dillerinde **call by value(pass by value)** ve **call by reference(pass by reference)** ile fonksiyonlara argÃ¼man gÃ¶nderme iÅŸleminin **sÃ¶zdizimi(syntax)** farklÄ±lÄ±k gÃ¶stermektedir.


â— C dilinde fonksiyonlara gÃ¶nderilen parametreler varsayÄ±lan olarak **call by value(pass by value)** olarak gÃ¶nderilmektedir. 



ğŸ‘‡ AÅŸaÄŸÄ±daki program bir fonksiyona **call by value(pass by value)** yÃ¶ntemiyle nasÄ±l argÃ¼man olarak gÃ¶nderildiÄŸini anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>

void foo(int x)
{
    x = 6656;
}

int main(void)
{
    int ival = 345;
    printf("ival = %d\n", ival);

    foo(ival); // Burada fonsiyona geÃ§ilen argÃ¼man 'call by value(pass by value)' olarak gÃ¶nderilmektedir.
    printf("ival = %d\n", ival);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program bir fonksiyona **call by value(pass by value)** yÃ¶ntemiyle deÄŸer gÃ¶nderildiÄŸinde deÄŸer gÃ¶nderilen yerdeki gÃ¶nderilen deÄŸerin deÄŸiÅŸkeninin adresiyle fonksiyondaki ilgili paramtreye gelen deÄŸerin deÄŸiÅŸkeninin adresinin farklÄ± olduÄŸunu anlamak iÃ§in incelenebilir. 
```C
#include <stdio.h>

void foo(int x)
{
    printf("In function, &x = %p\n", &x);
    x = 6656;
}

int main(void)
{
    int ival = 345;
    printf("In main block, &ival = %p\n", &ival);
    printf("ival = %d\n", ival);

    foo(ival); // Burada fonsiyona geÃ§ilen argÃ¼man 'call by value(pass by value)' olarak gÃ¶nderilmektedir.
    printf("ival = %d\n", ival);
}
```



â—â—â— Bildirimlerdeki `*`, `&` gibi karakterler **operatÃ¶r(operator)** deÄŸildir bunlar **dekleratÃ¶rdÃ¼r(declerator)**. C ve C++ dilleriyle yeni tanÄ±ÅŸan programcÄ±lar **operatÃ¶r(operator)** ve **decleratÃ¶r(declerator)** kavramlarÄ±nÄ± ve kullanÄ±ldÄ±klarÄ± yerleri karÄ±ÅŸtÄ±rmaktadÄ±r.
- ğŸ‘‡ AÅŸaÄŸÄ±daki program neye **operatÃ¶r(operator)** neye **dekleratÃ¶rdÃ¼r(declerator)** denildiÄŸini anlamak iÃ§in incelenebilir. DeÄŸiÅŸken bildirimlerinde kullanÄ±lan deÄŸiÅŸkenin tÃ¼rÃ¼nÃ¼ anlatmaya yÃ¶nelik olarak kullanÄ±lan `*`, `[]` gibi token'lara **dekleratÃ¶rdÃ¼r(declerator)** denilmektedir.
```C
#include <stdio.h>

int main(void)
{
    int x = 10;
    int a[5] = { 0 }; // Buradaki 'int a[5]' bÃ¼nyesindeki '[]' bir operatÃ¶r deÄŸildir dekleratÃ¶rdÃ¼r, operatÃ¶r bir ifadede olur.
    int* p = &x; // Buradaki 'int* p' bÃ¼nyesindeki '*' bir operatÃ¶r deÄŸildir dekleratÃ¶rdÃ¼r fakat '&x' buradaki '&' bir operatÃ¶rdÃ¼r, operatÃ¶r bir ifadede olur.

    int (*fp)(int); // Buradaki bildirim ileride Ã¶ÄŸreneceÄŸimiz 'function pointer' ile ilgilidir. Burada kullanÄ±lan '()', '*' gibi token'lar dekleratÃ¶rdÃ¼r.

    int* ptr = &x;
    *ptr = 45; // Buradaki ifadedeki(expression) '*ptr' alt ifadesindeki '*' dereferensing operatÃ¶rÃ¼dÃ¼r.
    ptr[0] = 2; // Buradaki ifadedeki(expression) 'ptr[0]' alt ifadesindeki '[]' square bracket operatÃ¶rÃ¼dÃ¼r.
}
```



â—â—â— C dilinde **call by reference(pass by reference)** **pointer semantic** ile yapÄ±lmaktadÄ±r yani fonksiyona **nesnenin(object)** adresi gÃ¶nderiliyor.


ğŸ‘‡ AÅŸaÄŸÄ±daki program C dilinde bir fonksiyona nasÄ±l **call by reference(pass by reference)** olarak deÄŸer gÃ¶nderilebileceÄŸini anlamk iÃ§in incelenebilir.
```C
#include <stdio.h>

void foo(int* x)
{
    printf("x = %p\n", x);

    *x = 6656;
}

int main(void)
{
    int ival = 345;

    printf("&ival = %p\n", &ival);

    printf("ival = %d\n", ival);

    foo(&ival);

    printf("ival = %d\n", ival);
}
```


â—â—â— C dilinde bir fonksiyona gÃ¶nderilmek istenen deÄŸerlerin **call by reference(pass by reference)** olmasÄ± isteniyorsa fonksiyondaki ilgili paramtreler pointer tÃ¼rÃ¼nden bildirilmelidir eÄŸer pointer tÃ¼rÃ¼nden bildirilmezse ilgili fonksiyon parametreleri **call by value(pass by value)** olacaktÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki program C dilinde yapÄ±lan mÃ¼lakatlarda en temel seviyede sorulan sorlardan biridir, eÄŸer bu temel soru bilinmiyorsa C dili hakkÄ±nda hiÃ§bir ÅŸey bilinmediÄŸi dÃ¼ÅŸÃ¼nÃ¼lebilir. 
- â— MÃ¼lakatta iki deÄŸiÅŸkenin deÄŸerini takas eden bir programÄ±n bu iÅŸlemi ayrÄ± bir fonksiyonda yapacak ÅŸekilde yazÄ±lmasÄ± istenir, eÄŸer fonksiyon parametreleri pointer deÄŸilse deÄŸiÅŸkenlerin deÄŸerleri takat edilmeyecektir.
```C
#include <stdio.h>

int main(void)
{
    int x = 10;
    int y = 20;

    printf("x = %d, y = %d\n", x, y);

    int temp = x;
    x = y;
    y = temp;

    printf("x = %d, y = %d\n", x, y);
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda **call by reference(pass by reference)** yÃ¶ntemi kullanÄ±lan bir fonksiyona argÃ¼man geÃ§ilmektedir ve bu ÅŸekilde iki tane `int` tÃ¼rÃ¼nden deÄŸiÅŸkenin deÄŸerleri pointer tÃ¼rÃ¼nden olan fonksiyon parametreleri aracÄ±lÄ±ÄŸÄ±yla deÄŸiÅŸtirilmektedir.
```C
#include <stdio.h>

void swap(int* a, int* b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main(void)
{
    int x = 10;
    int y = 20;

    printf("x = %d, y = %d\n", x, y);

    swap(&x, &y);

    printf("x = %d, y = %d\n", x, y);
}
```


>â”
> 
> Sorulan soru; 
> 
> C++'da void foo(int& â€¦â€¦..) yaptÄ±ÄŸÄ±mÄ±zda da aynÄ± oluyor ya, o zaman cpp'de neden buna ihtiyaÃ§ duymuÅŸlar, c'de bunun karÅŸÄ±lÄ±ÄŸÄ± var.
> 
> Cevap;
> 
> C++ diline girmek bu noktada doÄŸru olmayacaktÄ±r ama kÄ±saca cevap vermek gerekirse C++ dilinde C dilinde olmayan bazÄ± araÃ§lar ve bu araÃ§lar ile fonksiyonlarÄ±n parametrelerinin `&prameter` ÅŸeklinde bildirilmesi gerekiyor, bu bildirimin neden gerektiÄŸi bilgisini tam anlayabilmek iÃ§in C++ dilini biliyor olmak gerekecektir.


ğŸ‘‡ AÅŸaÄŸÄ±daki program `swap` fonksiyonunun iki adet pointer deÄŸiÅŸken aldÄ±ÄŸÄ±nÄ± anlayabilmek iÃ§in incelenebilir.
```C
#include <stdio.h>

void swap(int* a, int* b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main(void)
{
    int x = 33442;
    int y = 89453;
    int* p1 = &x;
    int* p2 = &y;

    printf("x = %d, y = %d\n", x, y);

    swap(&x, &y);

    printf("x = %d, y = %d\n", x, y);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program `swap` fonksiyonuna dizi adlarÄ±nÄ±n gÃ¶nderilmesi durumunda nasÄ±l bir sonuÃ§ Ã¼retileceÄŸini anlamak iÃ§in incelenebilir, bu iÅŸlemde **array to pointer conversion(array decay)** konvensiyonu mevcuttur.
```C
#include <stdio.h>

void swap(int* a, int* b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main(void)
{
    int x = { 1, 3, 4, 5, 8 };
    int y = { 2, 4, 5, 7, 8 };

    print_array(x, 5);
    print_array(y, 5);

    swap(x, y); // Burada 'array to pointer conversion(array decay)' yorumundan dolayÄ± dizi adlarÄ± dizilerin ilk elemanlarÄ±nÄ±n adreslerine Ã§evrilecektir. 
    // swap(&x[0], &x[0]); // Buradaki kod yukarÄ±daki kod ile aynÄ±dÄ±r.

    print_array(x, 5);
    print_array(y, 5);
}
```


### Bir Fonksiyonun Parametresi Neden "Call By Reference" YapÄ±lÄ±r 

BazÄ± fonksiyonlarÄ±n amacÄ± kendilerine gÃ¶nderilen deÄŸiÅŸkenleri deÄŸiÅŸtirip onlara yeni bir deÄŸer yÃ¼klemektir, bunun iÃ§in de bÃ¶yle fonksiyonlarÄ±n parametrelerinin **call by reference(pass by reference)** olmasÄ± gerekir. </br>
BazÄ± fonsiyonlarÄ±n kendilerini Ã§aÄŸÄ±ran koda bir deÄŸer iletmek istemeleridir, bir fonksiyondan geriye tek bir deÄŸer dÃ¶ndÃ¼rÃ¼lebiliyor, bu yÃ¶ntem ile bir fonksiyondan geriye birden fazla deÄŸer dÃ¶ndÃ¼rÃ¼lebiliyor.



ğŸ‘‡ AÅŸaÄŸÄ±daki program bir geri dÃ¶nÃ¼ÅŸ deÄŸeri olmadan bir fonksiyondan geriye nasÄ±l deÄŸer dÃ¶ndÃ¼rÃ¼lebileceÄŸini anlamak iÃ§in incelenebilir, bunun iÃ§in **call by reference(pass by reference)** deÄŸiÅŸkenleri kullanÄ±lmaktadÄ±r.
```C
#include <stdio.h>

// AÅŸaÄŸÄ±daki fonksiyon 'pure function' Ã¶zelliktedir, 'pure function' kullanÄ±lmasÄ± karmaÅŸÄ±klÄ±ÄŸÄ± Ã¶nler.
double get_area_v1(double radius)
{
    return 3.1415926 * radius * radius;
}

// AÅŸaÄŸÄ±daki fonksiyon kendisine iletilen ikinci pointer parametrenin deÄŸerini deÄŸiÅŸtirdiÄŸi iÃ§in 'pure function' Ã¶zellikte deÄŸildir.
void get_area_v2(double radius, double* p_area)
{
    *p_area = * 3.1415926 * radius * radius;
}

int main(void)
{
    double r;
    double area;

    printf("alanini hesaplamak istediginiz dairenin yaricapini giriniz: \n");
    scanf("%lf", &r);

    area = get_area_v1(r);
    printf("alan = %f\n", area);

    area = 0.;
    
    get_area_v2(r, &area);

    printf("alan = %f\n", area);
}
```

â—â—â— **call by reference(pass by reference)** yÃ¶ntemiyle bir fonksiyona argÃ¼man gÃ¶ndermek en fazla faydayÄ± gÃ¶nderilen deÄŸiÅŸkenin bellekte kapladÄ±ÄŸÄ± alan bÃ¼yÃ¼k olduÄŸunda saÄŸlar ve gereksiz yere tÃ¼m o deÄŸiÅŸkenin bellekteki verisinin baÅŸka bir bellek alanÄ±na kopyalanmasÄ±na gerek kalmamasÄ±nÄ± saÄŸlar. Pointer deÄŸiÅŸkenler kullanÄ±ldÄ±ÄŸÄ±nda bu deÄŸiÅŸkenler kullanÄ±lan donanÄ±m mimarisine gÃ¶re hep aynÄ± boyutta(**pointer size of**) deÄŸer kaplayacaÄŸÄ± iÃ§in kopyalama iÅŸlemi daha verimli ve kolay yapÄ±lacaktÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki program bellekte kaplayacaÄŸÄ± boyut `int` tÃ¼rÃ¼ 4 byte yer kapladÄ±ÄŸÄ± varsayÄ±ldÄ±ÄŸÄ±nda $20 x 20 x 4 + (4 + 4)$ yani 1608 byte olan bir `struct` tÃ¼rÃ¼nÃ¼n bir fonksiyondan geriye dÃ¶ndÃ¼rÃ¼lmesi gerektiÄŸinde bu geri dÃ¶nÃ¼ÅŸ iÅŸleminin **call by reference(pass by reference)** yÃ¶ntemiyle yapÄ±lmasÄ±nÄ±n iÅŸlem maliyetini nasÄ±l azaltacaÄŸÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>

typedef struct{
    int a[20][20];
    int row, col;
}Matrix;

Matrix get_matrix_v1(int x, int y);
void get_matrix_v2(int x, int y, Matrix* pm); // Bu ÅŸekilde bir fonksiyon bildirildiÄŸinde gÃ¶nderim yapÄ±lan deÄŸiÅŸkenin boyutu buradaki gibi bÃ¼yÃ¼k olduÄŸunda bu fonksiyonun tanÄ±mÄ±nda oluÅŸturulacak geri dÃ¶nÃ¼ÅŸ deÄŸerinin geriye dÃ¶ndÃ¼rÃ¼lmesi sadece pointer boyutu kadar maliyetli olacaktÄ±r.

int main(void)
{
    printf("Matrix sizeof = %zu\n", sizeof(Matrix));

    Matrix x;
    get_matrix_v2(8, 12, &x);
}
```


âš ï¸ **User Definel Type** konusuna kursun 3. Ã§eyreÄŸinin sonunda deÄŸinilecektir.


â— `void get_matrix_v2(int x, int y, Matrix* pm);` ÅŸeklinde bir fonksiyon bildirimi yapÄ±ldÄ±ÄŸÄ±nda buradaki `pm` parametre standardÄ±n kullandÄ±ÄŸÄ± bir terim olmasa da yazÄ±lÄ±mcÄ±lar **output parameter** olarak adlandÄ±rÄ±lmaktadÄ±r.

â— Temel yaklaÅŸÄ±m olarak eÄŸer bir fonksiyona gÃ¶nderilecek olan argÃ¼manÄ±n boyutu uygulamanÄ±n Ã§alÄ±ÅŸacaÄŸÄ± donanÄ±na gÃ¶re deÄŸiÅŸmekle birlikte 16 byte, 32 byte, 64 byte boyutundan bÃ¼yÃ¼kse **output parameter** olarak kullanÄ±lmasÄ± doÄŸru olacaktÄ±r.


â—â—â— BazÄ± fonksiyonlar birden fazla deÄŸeri kendisini Ã§aÄŸÄ±ran koda iletmek ister, bu durumda bunu yapmanÄ±n tek yolu fonksiyon parametrelerinin **call by reference(pass by reference)** olarak bildirilmesidir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir fonksiyonun **output parameter** olarak birden fazla **parameter** aldÄ±ÄŸÄ± durumda nasÄ±l Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ± yerdeki deÄŸiÅŸkenlerin deÄŸerlerini deÄŸiÅŸtirdiÄŸi incelenebilir, bu ÅŸekilde "_Bir fonksiyonun tek bir geri dÃ¶nÃ¼ÅŸ deÄŸeri olabilir._" kuralÄ±nÄ± esnetmiÅŸ oluruz.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

// AÅŸaÄŸÄ±daki fonksiyonda 'p_area' ve 'p_circum' parametreleri 'out parameter' olarak nikelenmektedir ve bu parametreler 'call by referans' olarak deÄŸer almaktadÄ±r.
void get_circle_values(double radius, double* p_area, double* p_circum)
{
    *p_area = 3.1415926 * radius * radius;
    *p_circum = 2. * 3.1415926 * radius;
}

int main(void)
{
    double r;
    double area;
    double circumference;

    printf("alanini ve cevresini hesaplamak istediginiz dairenin yaricapini giriniz: \n");
    scanf("%lf", &r);

    get_circle_values(r, &area, &circumference);

    printf("alan  = %f\n", area);
    printf("cevre = %f\n", circumference);
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `get_min_max` fonksiyonundan geriye iki deÄŸer dÃ¶ndÃ¼rebilmek iÃ§in **output parameter** kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

void get_min_max(int x, int y, int* pmin, int* pmax)
{
    *pmin = x < y ? x : y; 
    *pmax = x > y ? x : y;
}

int main(void)
{
    int min, max;
    int i1 = 34, i2 = 246;
    
    get_min_max(i1, i2, &min, &max);

    printf("min = %d\n", min);
    printf("max = %d\n", max);
}
```


â— Bir fonksiyondan geriye birden fazla deÄŸer dÃ¶ndÃ¼rmek istendiÄŸinde bu **call by reference(pass by reference)** kullanÄ±mÄ±yla saÄŸlanabiliyor.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `Matrix` tÃ¼rÃ¼ Ã¼zerinde iÅŸlem yapan bir fonksiyonun alacaÄŸÄ± parametrelerin hangilerinin **input parameter** hangilerinin **output parameter** olacaÄŸÄ±nÄ± kodda aÃ§Ä±k ÅŸekilde gÃ¶stermek iÃ§in **const** anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

// AÅŸaÄŸÄ±daki 'user defined type' 1608 byte boyutunda bellekte yer kaplayacaktÄ±r.
typedef struct{
    int a[20][20];
    int row, col;
}Matrix;


// AÅŸaÄŸÄ±daki fonksiyonda parametreler 'call by value' olarak iletildiÄŸi iÃ§in 'Matrix' tÃ¼rÃ¼nden deÄŸiÅŸkenler bellekte kopyalanacaktÄ±r.
Matrix add_matrix_v1(Matrix x, Matrix y);

// AÅŸaÄŸÄ±daki fonksiyon 'p1' ve 'p2' pointer(adres) deÄŸiÅŸkenleri 'input parameter' olarak adlandÄ±rÄ±lÄ±r ve 'presult' pointer(adres) deÄŸiÅŸkeni 'output parameter' olarak adlandÄ±rÄ±lÄ±r.
void add_matrix_v2(Matrix *p1, Matrix *p2, Matrix *presult);

// AÅŸaÄŸÄ±daki fonksiyon 'p1' ve 'p2' parametreleri 'const' tanÄ±mlandÄ±ÄŸÄ± iÃ§in bu bu deÄŸiÅŸkenlerinin deÄŸerlerinin deÄŸiÅŸtirilmeyeceÄŸi anlamÄ±na geliyor eÄŸer deÄŸiÅŸtirilmek istenirse sÃ¶zdizim hatasÄ±(syntax error) alÄ±nacaktÄ±r.
void add_matrix_v3(const Matrix *p1, const Matrix *p2, Matrix *presult);

int main(void)
{
    Matrix m1;
    Matrix m2;
    Matrix result;

    result = add_matrix_v1(m1, m2); // Bu fonksiyon Ã§aÄŸrÄ±sÄ±yla Ã¼Ã§ defa 'Matrix' tÃ¼rÃ¼nden deÄŸiÅŸkenler kopyalanmaktadÄ±r.

    add_matrix_v2(&m1, &m2, &result);
    add_matrix_v3(&m1, &m2, &result); 
}
```


â— Java, C# gibi dillerde bir fonksiyona geÃ§ilen parametrelerin **input parameter** mÄ± yoksa **output parameter** mÄ± olacaÄŸÄ±nÄ± aÃ§Ä±k ÅŸekilde belirtmek iÃ§in bir yapÄ± bulunmuyor ama C ve C++ dillerinde bu parametrenin **const** anahtar sÃ¶zcÃ¼ÄŸÃ¼yle iÅŸaretlenmemesiyle belirtiliyor.



â—â—â— EÄŸer fonksiyonunuzun bir pointer parametre deÄŸiÅŸkeni bir "**input parameter**" ise yani amaÃ§ bu pointer parametreye adresi gelen nesneyi deÄŸiÅŸtirmek deÄŸil ise, amaÃ§ sadece salt o nesnenin deÄŸerini kullanmak ise asla `T * parameter` kullanÄ±lmamalÄ±dÄ±r, bunun yerine `const T * parameter` kullanÄ±lmalÄ±dÄ±r.



â—â—â— Bir fonksiyon parametre deÄŸiÅŸkeni neden pointer(adres) olacak ÅŸekilde kullanÄ±lÄ±r;
1. Ã‡aÄŸÄ±ran koddan gÃ¶nderilen argÃ¼manÄ±n bellek boyutu bÃ¼yÃ¼kse kopyalama maliyetinden kaÃ§Ä±nmak iÃ§in.
2. Fonksiyondan geriye dÃ¶ndÃ¼rÃ¼lecek olan deÄŸiÅŸkenin bellek boyutu bÃ¼yÃ¼kse kopyalama maliyetinden kaÃ§Ä±nmak iÃ§in.
3. Bir fonksiyondan geriye birden fazla deÄŸer dÃ¶ndÃ¼rebilmek iÃ§in.
4. FonksiyonlarÄ±n aldÄ±ÄŸÄ± deÄŸerlerin **input parameter** ya da **output parameter** olarak bildirilebilmesi iÃ§in(**const** anahtar sÃ¶zcÃ¼ÄŸÃ¼nden de faydalanÄ±lÄ±yor). 


â—â—â— C ve C++ dilerinde fonksiyonlarÄ±n parametre deÄŸiÅŸkenleri doÄŸrudan dizi olamaz Ã§Ã¼nkÃ¼ dizi adlarÄ±na **array decay** uygulanacaktÄ±r. Dizilerin deÄŸerleri bir fonksiyona argÃ¼man olarak gÃ¶nderilmek istendiÄŸinde bunu **call by value** olarak yapÄ±labilmesi iÃ§in bir **sÃ¶zdizim(syntax)** yÃ¶ntemi yoktur yani bir diziyi bir fonksiyona gÃ¶ndermenin tek yolu **call by reference** yÃ¶ntemidir.


ğŸ“Œ C ve C++ dillerinde geri dÃ¶nÃ¼ÅŸ tÃ¼rÃ¼ pointer olan fonksiyonlar mevcuttur, bÃ¶yle fonksiyonlara "**function returning pointers(adres dÃ¶ndÃ¼ren fonksiyonlar)**" denilmektedir bu fonksiyonlar iki-Ã¼Ã§ saatlik bir konu ve ileride iÅŸlenecektir, ÅŸu anda bu kavram kullanÄ±lmadan ilerlenecektir.


ğŸ§­ Pointer'larla birlikte kullanÄ±lan operatÃ¶rler aÅŸaÄŸÄ±daki gibidir;
- `&` address of operator.
- `*` dereferencing operator.
- `[]` subscript/index operator.


### Pointer AritmetiÄŸi 

**Pointer aritmetiÄŸi** terimi standardÄ±n kullandÄ±ÄŸÄ± bir terim deÄŸildir ama yazÄ±lÄ±mcÄ±lar arasÄ±nda sÄ±k kullanÄ±lan bir terimdir.

Pointer deÄŸiÅŸkenleriyle birlikte **toplama(increment)**, **Ã§Ä±karma(decrement)** operatÃ¶rleri sÄ±k sÄ±k kullanÄ±lmaktadÄ±r.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.40-11.02 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


>â”
> 
> Sorulan soru; 
> 
> **MISRA** kurallarÄ±na gÃ¶re kod yazmak nedir kÄ±saca bahsedebilir misiniz?
> 
> Cevap;
> C dili standart bir programlama dilidir, bu standardÄ± belirleyen C standardÄ± belgesidir. </br>
> Ã–yle ortamlar varki bu ortamlarda yazÄ±lan C kodlarÄ±nÄ±n belirli nedenlerden dolayÄ± bazÄ± dilin stanadrdÄ±nda olmayan kÄ±sÄ±tlamalara tabi olmasÄ± gerekiyor, bu amaÃ§la uygulanan bazÄ± alt standartlar ya da kurallar vardÄ±r. </br>
> C standardÄ±na ek olarak uygulanan bazÄ± alt standartlara **MISRA** kurallarÄ± denmektedir. </br>
> Bu ÅŸekildeki alt standartlar aÄŸÄ±rlÄ±klÄ± olarak havacÄ±lÄ±k, otomotiv gibi sektÃ¶rlerde kullanÄ±lmaktadÄ±r.


â—â—â— **Pointer aritmetiÄŸini** iyi deÄŸil Ã§ok Ã§ok iyi Ã¶ÄŸrenilmelidir ve Ã¶zÃ¼msenmelidir. Bir yazÄ±lÄ±mcÄ±nÄ±n C dilini iyi bildiÄŸini anlamanÄ±n en iyi yolu **pointer aritmetiÄŸini** iyi bildiÄŸini sÄ±namaktÄ±r.



â—â—â— C ve C++ dilerinde aÅŸaÄŸÄ±daki ifadeler **legaldir(yani dilin kurallarÄ±na uygundur)** ve bu ifadelerin tÃ¼rÃ¼ adres tÃ¼rÃ¼dÃ¼r; 
- Bir adres ile bir tam sayÄ± toplanabilir. 
- Bir tam sayÄ± ile bir adres toplanabilir.
- Bir adresten bir tam sayÄ± Ã§Ä±karÄ±labilir.

â—â—â— C ve C++ dilerinde aÅŸaÄŸÄ±daki ifadeler **legal deÄŸildir(illegal)**;
- Bir tam sayÄ±dan bir adres Ã§Ä±karÄ±lmasÄ± **legal deÄŸildir(illegal)**.
- Bir adres ile adres toplanmasÄ± **legal deÄŸildir(illegal)**.


ğŸ§­ AÅŸaÄŸÄ±daki **ifadelerin(expression)** tÃ¼rlerinin ne olduÄŸu iyi bilinmelidir;
- `int*` + `int`  --> `int*`
- `int`  + `int*` --> `int*`
- `int*` - `int`  --> `int*`
- `int`  - `int*` --> Bu ifade **illegal** olacaktÄ±r, bÃ¶yle bir kullanÄ±p yanlÄ±ÅŸtÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir tam sayÄ±dan bir pointer deÄŸiÅŸkenin Ã§Ä±kartÄ±lmasÄ±nÄ±n neden olacaÄŸÄ± **sÃ¶zdizim hatasÄ±(syntax error)** incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int a[5] = { 0 };
    int* ptr = a;

    ptr + 3; // Legal
    2 + ptr; // Legal
    4 - ptr; // Legal
    2 - ptr; // Bu ifade legal deÄŸildir ve sÃ¶zdizim hatasÄ±(syntax error) oluÅŸturacaktÄ±r.
}
```



â—â—â— Bir dizinin bir elemanÄ±nÄ±n adresi ile 1 toplanÄ±rsa dizinin bir sonraki elemanÄ±nÄ±n adresini elde ederiz bu **pointer aritmetiÄŸinin** bir sonucudur. Bu durum(kural) dizinin elemanlarÄ±nÄ±n tÃ¼rÃ¼nden baÄŸÄ±msÄ±z olarak doÄŸrudur.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir dizi Ã¼zerinde **Pointer aritmetiÄŸinin** nasÄ±l uygulandÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#define SIZE 5

int main(void)
{
    int ary[SIZE] = { 0 , 1, 2, 3, 4 };

    ary + 1; // Bu ifade legaldir ve 'ary' dizisinin 1 indexli elemanÄ±na karÅŸÄ±lÄ±k gelmektedir.
    ary + 2; // Bu ifade legaldir ve 'ary' dizisinin 2 indexli elemanÄ±na karÅŸÄ±lÄ±k gelmektedir.

    // AÅŸaÄŸÄ±daki Ã¼Ã§ ifade de aynÄ± anlama gelmektedir yani 'ary' dizisinin iki indisli olan Ã¼Ã§Ã¼ncÃ¼ elemanÄ±dÄ±r.
    *(ary + 2);
    *(&ary[0] + 2);
    ary[2]; 

    for(int i = 0; i < SIZE; ++i){
        printf("%p %p %p\n", &ary[i], ary + i, i + ary);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program bir dizinin tÃ¼rÃ¼nÃ¼n ne olduÄŸuna gÃ¶re dizi elemanlarÄ±nÄ±nÄ±n adreslerinin baÅŸlangÄ±cÄ±nÄ±n ne olacaÄŸÄ± bilgisinin nasÄ±l deÄŸiÅŸtiÄŸi ve **Pointer aritmetiÄŸini** daha iyi anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#define SIZE  10

int main(void)
{
    int ary[SIZE] = { 0 , 1, 2, 3, 4, 5, 6, 7, 8, 9 };

    for(int i = 0; i < SIZE; ++i){
        printf("%p   %p   %p\n", *(ary + i), *(i + ary), ary[i]);
    }

    for(int i = 0; i < SIZE; ++i){
        printf("%p   %p   %p   %d   %d   %d\n", ary + i, i + ary, &ary[i], *(ary + i), *(i + ary), ary[i]);
    }

    printf("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");


    short arys[SIZE] = { 0 , 1, 2, 3, 4, 5, 6, 7, 8, 9 };

    for(int i = 0; i < SIZE; ++i){
        printf("%p   %p   %p\n", *(arys + i), *(i + arys), arys[i]);
    }

    for(int i = 0; i < SIZE; ++i){
        printf("%p   %p   %p   %d   %d   %d\n", arys + i, i + arys, &arys[i], *(arys + i), *(i + arys), arys[i]);
    }

    printf("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");


    char aryc[SIZE] = { 0 , 1, 2, 3, 4, 5, 6, 7, 8, 9 };

    for(int i = 0; i < SIZE; ++i){
        printf("%p   %p   %p\n", *(aryc + i), *(i + aryc), aryc[i]);
    }

    for(int i = 0; i < SIZE; ++i){
        printf("%p   %p   %p   %d   %d   %d\n", aryc + i, i + aryc, &aryc[i], *(aryc + i), *(i + aryc), aryc[i]);
    }

    printf("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
}
```


ğŸ§  AÅŸaÄŸÄ±daki bilgiyi iyi anlamak Ã¶nemlidir;
- EÄŸer `ary` bir diziyse `&ary[i]` yazmak ile `ary + i` aynÄ± anlama gelmektedir.
- EÄŸer `ary` bir diziyse `ary[i]` yazmak ile `*(ary + i)` aynÄ± anlama gelmektedir.
- EÄŸer `ary` bir diziyse, derleyisi `ary[i]` ifadesini `*(ary + i)` ifadesine dÃ¶nÃ¼ÅŸtÃ¼rmektedir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `ary[i]` ifadesi ile `*(ary + i)` ifadesi aynÄ±dÄ±r ve `i[ary]` ifadesi ile `*(i + ary)` ifadesi aynÄ±dÄ±r, bu dÃ¶nÃ¼ÅŸÃ¼mÃ¼ derleyici yapmaktadÄ±r, aÅŸaÄŸÄ±daki programda bu durum aÃ§Ä±k ÅŸekilde gÃ¶rÃ¼lecektir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#define SIZE  10

int main(void)
{
    int ary[SIZE] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

    for(int i = 0; i < SIZE; ++i){
        printf("%d %d\n", ary[i], i[ary]);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir int pointer deÄŸiÅŸkene bri dizinin elemanlarÄ±ndan birinin nasÄ±l atanÄ±p kullanÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#define SIZE  10

int main(void)
{
    int ary[SIZE] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    int* p = ary + 5;

    printf("*p = %d\n", *p);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir dizinin ilk elemanÄ±nÄ±n adresinin bir pointer deÄŸiÅŸkene atanÄ±p ardÄ±ndan bu pointer deÄŸiÅŸkenin bir dÃ¶ngÃ¼ iÃ§erisinde dÃ¶ngÃ¼nÃ¼n her turunda deÄŸerinin bir arttÄ±rÄ±lmasÄ±yla dizinin elemanlarÄ±nÄ±n standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderilmesi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#define SIZE  10

int main(void)
{
    int ary[SIZE] = { 0 , 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    int* ptr = ary;

    for(int i = 0; i < SIZE; ++i){
        printf("%d\n", *ptr);
        ++ptr;
    }

    double ary2[SIZE] = { 0 , 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    double* ptr2 = ary2;

    for(int i = 0; i < SIZE; ++i){
        printf("%f\n", *ptr2);
        ++ptr2;
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **pointer aritmetiÄŸini** kullanÄ±larak bir pointer deÄŸeri Ã¼zerinden bir dizinin bir Ã¶nceki ve bir sonraki elemanlarÄ±na nasÄ±l eriÅŸilebileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#define SIZE  10

int main(void)
{
    int a[SIZE] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    int* p = a + 5;

    printf("%d\n", *p);
    printf("%d\n", *(p + 1));
    printf("%d\n", *(p - 1));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan pointer aritmetiÄŸi ile dizi adÄ± Ã¼zerinden dizi elemanlarÄ±na eriÅŸmeden dizi elemanlarÄ±nÄ±n bir dÃ¶ngÃ¼ ile nasÄ±l standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderilebileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#define SIZE  10

int main(void)
{
    int ary[SIZE] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    int* p = ary;
    int n = 10;

    while(n--){
        printf("%d ", *p);
        ++p;
    }
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programdan pointer aritmetiÄŸi ile dizi adÄ± Ã¼zerinden dizi elemanlarÄ±na eriÅŸmeden dizi elemanlarÄ±nÄ±n bir dÃ¶ngÃ¼ ile nasÄ±l standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderilebileceÄŸi incelenebilir. Buradaki kullanÄ±m bazÄ± deÄŸerlerin deÄŸiÅŸesi dÄ±ÅŸÄ±nda farklÄ± tÃ¼rler iÃ§in ortak bir arayÃ¼z sunduÄŸuna dikkat etmek gerekiyor, bu ileride Ã¶nemli olacak.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#define SIZE  10

int main(void)
{
    double ary[SIZE] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    double* p = ary;
    int n = 10;

    while(n--){
        printf("%f", *p);
        ++p;
    }
}
```


### Subscript(Index) Operantor(`[]` operatÃ¶rÃ¼) 


`[]` operatÃ¶rÃ¼ `a[b]` ÅŸeklinde iki operand almaktadÄ±r, bu operand'lardan birinin adres birinin tam sayÄ± olmasÄ± gerekiyor ama bunun sÄ±rasÄ± Ã¶nemli deÄŸil `a[b]` ve `b[a]` aynÄ± anlama gelmektedir.

ğŸ§­ Derleyisi `x[y]` ÅŸeklindeki bir ifadeyi alÄ±p `*(x + y)` ifadesine Ã§evirmektedir. `x[y]` ifadesinde "x" ve "y" operand'dÄ±r ve `[]` operatÃ¶rÃ¼ bu iki operandÄ± **pointer aritmetiÄŸini** kullanarak  taplama iÅŸlemine tabi tutar. "x" ve "y" operand'larÄ±ndan hangisinin adres tÃ¼rÃ¼nden olduÄŸu Ã¶nemli deÄŸildi, sadece birinin adres tÃ¼rÃ¼nden diÄŸerinin tam sayÄ± tÃ¼rÃ¼nden olmasÄ± yeterlidir. 
- `x[y]` ifadesi `*(x + y)` ifadesine Ã§evrilecektir.
- `y[x]` ifadesi `*(y + x)` ifadesine Ã§evrilecektir.



â—â—â— Bir adres ile adres toplanmasÄ± legal deÄŸildir(illegal), **sÃ¶zdizim hatasÄ±na(syntax error)** neden olacaktÄ±r. 


ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki pointer'Ä±n toplanmasÄ±nÄ±n **sÃ¶zdizim hatasÄ±na(syntax error)** neden olacaÄŸÄ± durumu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#define SIZE  10

int main(void)
{
    int x = 10;
    int y = 10;

    int* p1 = &x;
    int* p2 = &y;

    int* px = p1 + p2; // Burada iki pointer toplanmaya Ã§alÄ±ÅŸÄ±ldÄ±ÄŸÄ± iÃ§in sÃ¶zdizim hatasÄ±(syntax error) oluÅŸacaktÄ±r.

    x[y]; // Buradaki ifadede sÃ¶zdizim hatasÄ±(syntax error) olacaktÄ±r Ã§Ã¼nkÃ¼ bu ifade derleyici tarafÄ±ndan '*(x + y)' ÅŸeklinde yorumlanacaktÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `[]` oparatÃ¶rÃ¼nÃ¼n operandÄ±nÄ±n bir dizi adÄ± olmak zorunda olmadÄ±ÄŸÄ± gerÃ§eÄŸi detaylÄ± olarak incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#define SIZE  10

int main(void)
{
    int x = 10;

    // AÅŸaÄŸÄ±daki Ã¼Ã§ statement ta aynÄ± anlama gelmektedir.
    x = 66;
    (&x)[0] = 66;
    *(& x + 0) = 66;

    printf("x = %d\n", x);

    x = 10;
    printf("x = %d\n", x);

    (&x)[0] = 20;
    printf("x = %d\n", x);

    *(&x + 0) = 30;
    printf("x = %d\n", x);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program `[]` oparatÃ¶rÃ¼nÃ¼n operantlarÄ±nÄ±n nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#define SIZE  10

int main(void)
{
    int a[SIZE] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    int* p = a;

    // AÅŸaÄŸÄ±daki for dÃ¶ngÃ¼sÃ¼ ile dizi dÃ¶nÃ¼lÃ¼yor ve dÃ¶rt farklÄ± ÅŸekilde ilgili dizi elemanÄ± standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderiliyor.
    for(int i = 0; i < SIZE; ++i){
        printf("%d   %d   %d   %d\n", a[i], i[a], p[i], i[p]);
    }

    // AÅŸaÄŸÄ±daki ifalerin hepsi 'a' dizisinin 'i' indizli elemanÄ±na karÅŸÄ±lÄ±k gelmektedir.
    // a[i] --> *(a + i)
    // p[i] --> *(p + i)
    // i[a] --> *(i + a)
    // i[p] --> *(i + p)
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program bir pointer Ã¼zerinden **pointer aritmetiÄŸi** ile bir dizinin elemanlarÄ±na nasÄ±l eriÅŸilebileceÄŸini anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#define SIZE  10

int main(void)
{
    int ary[SIZE] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, };
    int* p = a + 6;

    printf("%d\n", *p);
    printf("%d\n", p[0]);  // 'p[0]' ifadesi '*(p + 0)' ifadesine denktir ve bu da dizinin 6 indisli elemanÄ±na karÅŸÄ±lÄ±k gelir.
    printf("%d\n", p[2]);  // 'p[2]' ifadesi '*(p + 2)' ifadesine denktir ve bu da dizinin 8 indisli elemanÄ±na karÅŸÄ±lÄ±k gelir.
    printf("%d\n", p[-3]); // 'p[-3]' ifadesi '*(p + 6 - 3)' ifadesine denktir ve bu da dizinin 3 indisli elemanÄ±na karÅŸÄ±lÄ±k gelir.

    p[4]; // Buradaki 'p[4]' ifadesi dizinin olmayan 10 indizli elemanÄ±na karÅŸÄ±lÄ±k geleceÄŸi iÃ§in 'ub' durumuna neden olacaktÄ±r.
}
```


>â”
> 
> Sorulan soru; 
> 
> Peki derleyicide dizi a[10] iÃ§in a degeri iÃ§in dizi gibi bir ayrÄ±m var mÄ±, yoksa buna da sadece bir address olarak mÄ± bakÄ±yor. </br>
> sizeof calistigina gÃ¶re derleyicide adres ve dizi diye de bir ayrim var diye dÃ¼sÃ¼nÃ¼rÃ¼m?
>
> Cevap;
> 
> Soru pek aÃ§Ä±k olmayabileceÄŸi iÃ§in aÅŸaÄŸÄ±daki gibi aÃ§Ä±klama yapÄ±ldÄ±. </br>
> Diziler ile pointer'lar arasÄ±nda sÄ±kÄ± sÄ±kÄ±ya bir baÄŸlantÄ± mevcuttur. </br>
> Diziler bir **nesnedir(object)** ve pointer deÄŸiÅŸkenler de bir **nesnedir(object)** bu iki nesne bellekte ayrÄ± yerlerde bulunmaktadÄ±r, pointer deÄŸiÅŸkenler baÅŸka nesnelerin(object) adres deÄŸerleri Ã¼zerinden iÅŸlemler yapÄ±lmasÄ±nÄ± saÄŸlar.
> 
> ```C
> #define _CRT_SECURE_NO_WARNINGS
> 
> #include <stdio.h>
> #define SIZE  10
> 
> int main(void)
> {
>     double a[5];
>     double* p = a;
> 
>     printf("sizeof(a): %zu\n", sizeof(a)); // Burada 'array decay' uygulanmamaktadÄ±r. sizeof operatÃ¶rÃ¼ 'double[5]' tÃ¼rÃ¼nÃ¼n kaÃ§ byte alan kapladÄ±ÄŸÄ± bilgisini Ã§Ä±ktÄ± olarak verecektir, 40 deÄŸeri Ã¼retilecektir.
>     printf("sizeof(a[0]): %zu\n", sizeof(a[0])); // sizeof operatÃ¶rÃ¼ 'double' tÃ¼rÃ¼nÃ¼n kaÃ§ byte alan kapladÄ±ÄŸÄ± bilgisini Ã§Ä±ktÄ± olarak verecektir, 'double' tÃ¼rÃ¼ olduÄŸu iÃ§in '8' deÄŸerini Ã¼retecektir.
>     printf("sizeof(*a): %zu\n", sizeof(*a)); // sizeof operatÃ¶rÃ¼ '*&a[0]' ifadesinin tÃ¼rÃ¼nÃ¼n('double' tÃ¼rÃ¼) kaÃ§ byte alan kapladÄ±ÄŸÄ± bilgisini Ã§Ä±ktÄ± olarak verecektir, 'double' tÃ¼rÃ¼ olduÄŸu iÃ§in '8' deÄŸerini Ã¼retecektir.
>     printf("sizeof(p): %zu\n", sizeof(p)); // sizeof operatÃ¶rÃ¼ 32 bitlik mimaride '4' deÄŸerini Ã¼retecektir Ã§Ã¼nkÃ¼ bu mimaride 'object pointer' tÃ¼rÃ¼ deÄŸiÅŸkenleri 4 byte yer kaplar.
>     printf("sizeof(*p): %zu\n", sizeof(*p)); // sizeof operatÃ¶rÃ¼ 'p' pointer'Ä±nÄ±n gÃ¶sterdiÄŸi deÄŸer 'double' tÃ¼rÃ¼ olduÄŸu iÃ§in '8' deÄŸerini Ã¼retecektir.
>     printf("sizeof(p[0]): %zu\n", sizeof(p[0])); // sizeof operatÃ¶rÃ¼ 'p[0]' iÃ§in '8' deÄŸerini Ã¼retecektir.
> }
> ```


â—C dilinde **array decay(array to pointer conversion)** uygulanmayan yerler aÅŸaÄŸÄ±daki gibidir;
- **sizeof** operatÃ¶rÃ¼nÃ¼n operandÄ± dizi deÄŸiÅŸkeni olduÄŸunda.
- Bir dizi adres operatÃ¶rÃ¼nÃ¼n(`&`) operandÄ± olduÄŸunda, `&(& ary[0])` bu ifade **sÃ¶zdizim hatasÄ±dÄ±r(syntax error)** ama `&ary` ifadesi **sÃ¶zdizim hatasÄ±(syntax error)** deÄŸildir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda adres operatÃ¶rÃ¼nÃ¼n(`&`) operandÄ± bir dizi olduÄŸunda **array decay** Ã¶zelliÄŸinin uygulanmadÄ±ÄŸÄ± durum incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#define SIZE  10

int main(void)
{
    int a[100] = { 0 };

    &(& a[0]); // SÃ¶zdizim hatasÄ±nadÄ±r(syntax error).
    &a; // sÃ¶zdizim hatasÄ±(syntax error) yoktur.
}
```



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programda **sizeof** operatÃ¶rÃ¼nÃ¼n operandÄ± olan ifade iÃ§in iÅŸlem kodu Ã¼retilmediÄŸi durumlarÄ± gÃ¶rmek iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#define SIZE  10

int main(void)
{
    int a[100] = { 0 };

    sizeof(a + 34234); // Burada 'ub' yoktur Ã§Ã¼nkÃ¼ 'sizeof' operatÃ¶rÃ¼ iÅŸlem kodu Ã¼retmediÄŸinden 'array decay' kuralÄ± uygulanmayacaktÄ±r. 
    sizeof(a[34234]); // Burada 'ub' yoktur Ã§Ã¼nkÃ¼ 'sizeof' operatÃ¶rÃ¼ iÅŸlem kodu Ã¼retmediÄŸinden 'array decay' kuralÄ± uygulanmayacaktÄ±r.

    int x = 10, y = 0;

    printf("sizeof(x / y) : ", sizeof(x / y)); // Burada 'ub' yoktur Ã§Ã¼nkÃ¼ 'sizeof' operatÃ¶rÃ¼ iÅŸlem kodu Ã¼retmediÄŸinden '10 / 0' iÅŸlemi zaten yapÄ±lmayacaktÄ±r.
}
```



â—â—â— Bir dizinin bittiÄŸi yerdeki adresi kullanmak(o adresteki nesneye eriÅŸmek deÄŸil) **ub** deÄŸildir. 
- ğŸ‘‡ AÅŸaÄŸÄ±daki programda yukarÄ±da belirtilen durum incelenebilir, kursun ilerleyen kÄ±sÄ±mlarÄ±nda bu adres deÄŸerinin nasÄ±l kullanÄ±labileceÄŸine deÄŸinilecektir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#define SIZE  10

int main(void)
{
    int a[5] = { 0 };

    int* ptr = a[5]; // Bu ÅŸekilde dizinin bittiÄŸi yerdeki diziye ait olmayan adres deÄŸeri bir pointer'a alÄ±nabilir, burada 'ub' yoktur.

    &a[5]; // Bu ifade(expression) 'ub' iÃ§ermemektedir.
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.11-12.21 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir fonksiyona pointer ile bir dizinin herhangi bir elemanÄ±nÄ±n adresini argÃ¼man olarak geÃ§erek nasÄ±l dizinin elemanlarÄ±nÄ±n yazdÄ±rÄ±labilidiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

#define SIZE 100

// AÅŸaÄŸÄ±daki 'int* p' parametresi 'output parameter' durumundadÄ±r, 'out parameter' parametreler deÄŸerleri deÄŸiÅŸtirilebileceÄŸi anlamÄ±na gelmektedir.
void setArrayRandom(int* p, int size)
{
    for(int i = 0; i < size; ++i){
        p[i] = rand() % 100;
    }
}

// AÅŸaÄŸÄ±daki 'int* p' parametresi 'input parameter' durumundadÄ±r
void printArray(const int* p, int size)
{
    for(int i = 0; i < size; ++i){
        pritf("%3d ", p[i]);
    }
    ptinrf("\n");
}

// AÅŸaÄŸÄ±daki 'int* p' parametresi 'input parameter' durumundadÄ±r
void printArrayV2(const int* p, int size)
{
    while(size--){
        printf("%3d ", *p);
        ++p;
    }
    ptinrf("\n");
}

int main(void)
{
    int a[SIZE];
    randomize();

    setArrayRandom(a, SIZE);
    printArray(a, SIZE);
    printArrayV2(a, SIZE);

    printArrayV2(a, 4); // // Dizinin ilk dÃ¶rt elemanÄ±nÄ± yazdÄ±rÄ±r.
    printArrayV2(a + 4, 4); // Dizinin beÅŸinci indeksinden itibaren ilk dÃ¶rt elemanÄ±nÄ± yazdÄ±rÄ±r.
    printArrayV2(a + SIZE - 4, 4); // Dizinin sondan dÃ¶rt elemanÄ±nÄ± yazdÄ±rÄ±r.
}
```



âœï¸ Ã–nceden `nutility` dosyamÄ±za eklediÄŸimiz `set_array_random` fonksiyonunu pointer aritmetiÄŸini kullanarak aÅŸaÄŸÄ±daki gibi yeniden yazabiliriz. 
```C
// 'nutility.c' dosyasÄ±nda 'set_array_random' fonksiyonunda aÅŸaÄŸÄ±daki ÅŸekilde deÄŸiÅŸiklik yapÄ±yoruz, bu ÅŸekilde C dilinin idiomatik yapÄ±sÄ±nda fonksiyonu yeniden yazmÄ±ÅŸ olduk.

void set_array_random(int* p, int size)
{
    while(size--)
        *p++ = rand() % 1000;

    /* ikinci versiyon
    while(size--){
        *p = rand() % 1000;
        ++p;
    }
    */

    /* Ä°lk versiyon
    for(int i = 0; i < size; ++i){
        p[i] = rand() % 1000;
    }
    */
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan elemanlarÄ± `int` tÃ¼rÃ¼nden olan bir dizinin elemanlarÄ±nÄ±n kÃ¼malatif toplamÄ±nÄ±n nasÄ±l hesaplandÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"
#include <math.h> // 'sqrt' fonksiyonunu kullanabilmek iÃ§in eklenmiÅŸtir.

#define SIZE  100

// AÅŸaÄŸÄ±daki 'int* p' parametresi 'input parameter' durumundadÄ±r
void setArrayRandom(int* p, int size)
{
    for(int i = 0; i < size; ++i){
        p[i] = rand() % 100;
    }
}

void printArray(const int* p, int size)
{
    while(size--){
        printf("%3d ", *p);
        ++p;
    }
    ptinrf("\n");
}

int sum_array_v1(const int* p , int size)
{
    int sum = 0;

    for(int i = 0; i < size; ++i){
        sum += p[i];
    }

    return sum;
}

int sum_array_v2(const int* p , int size)
{
    int sum = 0;

    while(size--){
        sum += *p;
        ++p;
    }

    return sum;
}

// Dizinin ortalama deÄŸerini hesaplayan fonksiyon
double get_array_mean(const int* p , int size)
{
    return (double)sum_array_v2(p, size) / size;
}

// Dizinin aritmetik ortalamasÄ±nÄ± hesaplayan fonksiyon
double get_std_dev(const int* p , int size)
{
    double mean = get_array_mean(p, size);
    double sum_square = 0;

    for(int i = 0; i < size; ++i){
        sum_square += (p[i] - mean) * (p[i] - mean);
    }

    return sqrt(sum_square / (size - 1));
}

int main(void)
{
    int a[SIZE];
    randomize();

    setArrayRandom(a, SIZE);
    printArray(a, SIZE);

    printf("dizi toplami: %d\n", sum_array_v2(a, SIZE));
    printf("dizi ortalamasi: %f\n", get_array_mean(a, SIZE));
    printf("dizinin standart sapmasÄ±: %f\n", get_std_dev(a, SIZE));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan dizinin en kÃ¼Ã§Ã¼k ve en bÃ¼yÃ¼k elemanlarÄ±nÄ± hesaplayan fonksiyonlarÄ±n nasÄ±l yazÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

#define SIZE  20

int get_array_max(const int* p, int size)
{
    int max = *p;
    //int max = p[0]; // Bu statement ile yukraÄ±daki statement aynÄ± anlama gelmektedir.

    for(int i = 1; i < size; ++i){
        if(p[i] > max)
            max = p[i];
    }

    return max;
}

int get_array_min(const int* p, int size)
{
    int min = *p;
    //int min = p[0]; // Bu statement ile yukraÄ±daki statement aynÄ± anlama gelmektedir.

    for(int i = 1; i < size; ++i){
        if(p[i] < min)
            min = p[i];
    }

    return min;
}

int main(void)
{
    int a[100];
    randomize();

    set_array_random(a, SIZE);
    printArray(a, SIZE);

    printf("max = %d", get_array_max(a, SIZE));
    printf("min = %d", get_array_min(a, SIZE));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir dizinin en bÃ¼yÃ¼k ve en kÃ¼Ã§Ã¼k deÄŸerlerini tek bir fonksiyonla hesaplayan fonksiyon incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

#define SIZE  20

void get_array_min_max(const int* p_ary, int size, int* pmin, int* pmax)
{
    *pmin = *pmax = *p_ary; // Buradaki atama iÅŸlemi C dilinde idiomatic bir kullanÄ±mdÄ±r.

    for(int i = 1; i < size; ++i){
        if(p_ary[i] < *pmin)
            *pmin = p_ary[i];

        if(p_ary[i] > *pmax)
            *pmax = p_ary[i];
    }
}

// YukarÄ±daki fonksiyon baÅŸaÄŸÄ±daki gibi yazÄ±ldÄ±ÄŸÄ±nda herkes yapÄ±lan iÅŸlemi daha iyi anlayacaktÄ±r.
void get_array_min_max_v2(const int* p_ary, int size, int* pmin, int* pmax)
{
    int* min = *p_ary;
    int* max = *p_ary;

    for(int i = 1; i < size; ++i){
        if(p_ary[i] < *pmin)
            *min = p_ary[i];

        if(p_ary[i] > *pmax)
            *max = p_ary[i];
    }

    *pmin = min;
    *pmax = max;
}


int main(void)
{
    int a[100];

    randomize();
    set_array_random(a, SIZE);

    printArray(a, SIZE);

    int min, max;

    get_array_min_max(a, SIZE, min, max);

    printf("min = %d", max);
    printf("max = %d", min);
}
```


Ders sonu ...
