# 33.Ders 10.05.2025 ğŸ•˜

Derse 9(09:01)-10(09:03)-11(09:15)-13(09:36)-13(10:05)-14(10:37)-13(11:02)-13(12:18)-12(12:45)-11(12:51) kiÅŸi katÄ±ldÄ±.
---

## Standart C KÃ¼tÃ¼phasindeki Fonksiyonlar Devam


### `strcmp` Fonksiyonu Devam



ğŸ‘‡ AÅŸaÄŸÄ±daki program `strcmp` fonksiyonu ile yazÄ±larÄ± karÅŸÄ±laÅŸtÄ±rma iÅŸlemlerinin nasÄ±l yapÄ±labileceÄŸini anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int strcmp(const char*, const char*);

int main(void)
{
    char s1[SIZE];
    char s2[SIZE];

    printf("iki sozcuk girin: ");
    scanf("%s%s", s1, s2);
    int result = strcmp(s1, s2);

    if(result > 0)
        printf("%s > %s\n", s1, s2);
    else if(result < 0)
        printf("%s < %s\n", s1, s2);
    else
        printf("%s = %s\n", s1, s2);
}
```


En Ã§ok karÅŸÄ±mÄ±za Ã§Ä±kan yazÄ± iÅŸlemlerinden biri iki yazÄ±nÄ±n karÅŸÄ±laÅŸtÄ±rÄ±lmasÄ± iÅŸlemidir ve bu iÅŸlem iÃ§in `strcmp` fonksiyonu kullanÄ±labilir.

âš ï¸ iki diziyi karÅŸÄ±laÅŸtÄ±rmak iÃ§in `==` operatÃ¶rÃ¼ kullanÄ±lmamalÄ±dÄ±r bu durumda dizilerin adresleri karÅŸÄ±laÅŸtÄ±rÄ±lÄ±r ve bu karÅŸÄ±laÅŸtÄ±rmanÄ±n sonucu **always false** olacaktÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki program `strcmp` fonksiyonu ile iki yazÄ±nÄ±n nasÄ±l karÅŸÄ±laÅŸtÄ±rÄ±labileceÄŸini anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int strcmp(const char*, const char*);

int main(void)
{
    char s1[SIZE];
    char s2[SIZE];

    printf("iki sozcuk girin: ");
    scanf("%s%s", s1, s2);

    // 'strcmp' fonksiyonu kendisine gÃ¶nderilen yazÄ±lar eÅŸitse '0' deÄŸeri dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ iÃ§in eÅŸitlik durumu aÅŸaÄŸÄ±daki dÃ¶ngÃ¼ koÅŸulu ile saÄŸlanmaktadÄ±r.
    if(!strcmp(s1, s2)){
        printf("evet, esit\n");
    }
    else{
        printf("hayir, esit degil\n");
    }

    if(strcmp(s1, s2) > 0){
        printf("%s > %s\n", s1, s2);
    }
    else if(strcmp(s1, s2) < 0){
        printf("%s < %s\n", s1, s2);
    }
    else{
        printf("%s = %s\n", s1, s2);
    }

    // AÅŸaÄŸÄ±daki gibi 'strcmp' fonksiyonu ile iki yazÄ±nÄ±n nasÄ±l kÄ±yaslanacaÄŸÄ± incelenebilir.
    // s1 == s2     if(!strcmp(s1, s2))  ya da  if(strcmp(s1, s2) == 0)
    // s1 != s2     if(strcmp(s1, s2))   ya da  if(strcmp(s1, s2) != 0)
    // s1 > s2      if(strcmp(s1, s2) > 0)
    // s1 >= s2     if(strcmp(s1, s2) >= 0)
    // s1 < s2      if(strcmp(s1, s2) < 0)      
    // s1 <= s2     if(strcmp(s1, s2) <= 0)
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strcmp` fonksiyonu **gerÃ§ekleÅŸtirimi(implemantation)** incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int mystrcmp(const char* p1, const char* p2)
{
    while(*p1 == *p2){
        if(*p1 == '\0') // Burada iki gÃ¶stericiden birinin son karakterine kadar gelinmiÅŸse yazÄ±lar eÅŸittir demektir.
            return 0;

        ++p1;
        ++p2;
    }

    return *p1 - *p2;
    //return *p1 > *p2 ? 1 : -1; // Bu ÅŸekilde de yazÄ±labilirdi.
}

int main(void)
{
    char s1[SIZE];
    char s2[SIZE];

    printf("iki sozcuk girin: ");
    scanf("%s%s", s1, s2);
    int result = strcmp(s1, s2);

    if(result > 0)
        printf("%s > %s\n", s1, s2);
    else if(result < 0)
        printf("%s < %s\n", s1, s2);
    else
        printf("%s = %s\n", s1, s2);
    
    printf("~~~~~~~~~~~~~~~~~~~~~~");
    
    result = mystrcmp(s1, s2);

    if(result > 0)
        printf("%s > %s\n", s1, s2);
    else if(result < 0)
        printf("%s < %s\n", s1, s2);
    else
        printf("%s = %s\n", s1, s2);
}
```



ğŸ§­ Åu ana kadar aÅŸaÄŸÄ±daki C standardÄ±nda olan fonksiyonlarÄ± inceledik;
- `strlen` --> Bu fonksiyon bir yazÄ±nÄ±n kaÃ§ karakterden oluÅŸtuÄŸu bilgisini geriye dÃ¶ner.
- `strchr` --> Bu fonksiyon bir yazÄ±da bir karakteri yazÄ±nÄ±n ilk elemanÄ±ndan baÅŸlayarak aramak iÃ§in kullanÄ±lÄ±yor, eÅŸleÅŸme bulunursa ilk eÅŸleÅŸme bulunan dizi elemanÄ±nÄ±n adresi geriye dÃ¶ndÃ¼rÃ¼lÃ¼yor, eÅŸleÅŸme bulunamazsa **NULL pointer** geriye dÃ¶ndÃ¼rÃ¼lÃ¼yor.
- `strrchr` --> Bu fonksiyon bir yazÄ±da bir karakteri yazÄ±nÄ±n son elemanÄ±ndan baÅŸlayarak aramak iÃ§in kullanÄ±lÄ±yor, eÅŸleÅŸme bulunursa ilk eÅŸleÅŸme bulunan dizi elemanÄ±nÄ±n adresi geriye dÃ¶ndÃ¼rÃ¼lÃ¼yor, eÅŸleÅŸme bulunamazsa **NULL pointer** geriye dÃ¶ndÃ¼rÃ¼lÃ¼yor.
- `strpbrk` --> Bu fonksiyon bir yazÄ±da birden fazla karakteri tek seferde aramak iÃ§in kullanÄ±lÄ±yor, yazÄ±nÄ±n ilk elemanÄ±ndan itibaren arama yapÄ±lmaktadÄ±r, eÅŸleÅŸme bulunursa ilk eÅŸleÅŸme bulunan dizi elemanÄ±nÄ±n adresi geriye dÃ¶ndÃ¼rÃ¼lÃ¼yor, eÅŸleÅŸme bulunamazsa **NULL pointer** geriye dÃ¶ndÃ¼rÃ¼lÃ¼yor.
- `strstr` --> Bir yazi iÃ§inde bir yazÄ±nÄ±n olup olmadÄ±ÄŸÄ±nÄ± anlamak iÃ§in kullanÄ±lan fonksiyondur.
- `strcpy` --> Bir yazÄ±yÄ± baÅŸka bir yazÄ±ya kopyalamak iÃ§in kullanÄ±lan fonksiyondur.
- `strcat` --> Bir yazÄ±yanÄ±n sonuna baÅŸka bir yazÄ±yÄ± eklemek iÃ§in kullanÄ±lan fonksiyon.
- `strcmp` --> Bu fonksiyon iki yazÄ±yÄ± karÅŸÄ±laÅŸtÄ±rmak iÃ§in kullanÄ±lÄ±r.
- `setlocale` --> Bu fonksiyona deÄŸinildi detaylÄ± incelenmedi. Bu fonksiyon local bilgisini deÄŸiÅŸtirmek iÃ§in kullanÄ±lÄ±yor.


>â”
> 
> Sorulan soru; 
> 
> Lokale kavramindan bahsetmistik, ama strcmp lokale bagimsiz. Ã¶yleyse strcmp referansini nereden aliyor diye bir soru sormustuk
> 
> Cevap;
> 
> Herhangi bir local ayarlanmadÄ±ÄŸÄ±nda bulunulan local'e "**C local**" denmektedir, ve "**C local**"inde **ASCI** karakter seti kullanÄ±lmaktadÄ±r.
> **ASCI** karakter seti dÄ±ÅŸÄ±ndaki karakterlerle de karÅŸÄ±laÅŸtÄ±rma yapabilmek iÃ§in local deÄŸerini deÄŸiÅŸtirmek gerekiyor.
> DiÄŸer geniÅŸletilmiÅŸ ASCI seti vb. deÄŸiÅŸiklikler sistem ayarlarÄ±yla ilgili(iÅŸletim sistemiyle ilgili), C kodundan sadece local bilgisi deÄŸiÅŸtirilebiliyor.


ğŸ“Œ C dilinin standart kÃ¼tÃ¼phenesi olan `string.h` kÃ¼tÃ¼hanesinin sahip olduÄŸu yazÄ±larla ilgili fonksiyonlar kÄ±sÄ±tlÄ± bu nedenden dolayÄ± yazÄ±lar Ã¼zerinde iÅŸlem yaparken ya Ã¼Ã§Ã¼ncÃ¼ taraf kÃ¼tÃ¼phenelerin kullanÄ±lmasÄ± ya da kendimizin yazmasÄ± gerekiyor. YazÄ±lar Ã¼zerinde iÅŸlem yapan bazÄ± fonksiyonlar Ã¶dev olarak verilecek.

ğŸ“Œ YazÄ±lar Ã¼zerinde iÅŸlem yaparken en Ã§ok ihtiyaÃ§ duyulan iÅŸlemlerden biri bir yazÄ±nÄ±n sonunda ya da baÅŸÄ±nda baÅŸka bir yazÄ±nÄ±n olup olmadÄ±ÄŸÄ±nÄ±n kontrol edilmesi ya da yazÄ±larÄ±n baÅŸÄ±ndan/sonundan boÅŸ karakterlerin ya da baÅŸka yazÄ±larÄ±n silinmesi(trim operation) gibi iÅŸlemleridir, bu tÃ¼r fonksiyonlar C standart kÃ¼tÃ¼phenesinde olmadÄ±ÄŸÄ± iÃ§in ya da alÄ±ÅŸtÄ±rma yapmak iÃ§in biz yazacaÄŸÄ±z.



>â”
> 
> Sorulan soru; 
> 
> C dilinde de regex var mÄ±?
> 
> Cevap;
> 
> C dilinin standardÄ±nda yok ama Ã¼Ã§Ã¼ncÃ¼ taraf kÃ¼tÃ¼phene desteÄŸi ile kullanÄ±labilir.


ğŸ“Œ YukarÄ±daki soru nedeniyle Regex kullanÄ±mÄ± yÃ¼zeysel olarak anlatÄ±ldÄ±.


## Regex(Regular Expression)(DÃ¼zenli Ä°fadeler) 

Bu konu C++ kursunda detaylÄ± anlatÄ±lÄ±yor ama burada kÄ±saca bahsedilmiÅŸtir.

ğŸ§­ Regex ile iligli temel kavramlar aÅŸaÄŸÄ±daki gibidir;
- **Regex Gramer(notation)**: Regex yazabilmek iÃ§in bilinmesi gereken yazÄ±m kurallarÄ±dÄ±r. FarklÄ± sistemlerin farklÄ± **regex gramer(notation)** kurallarÄ± kullanÄ±labilir ama %80 seviyesinde bu kurallar aynÄ±dÄ±r denilebilir.
- **Regex String**: Regex kontrolÃ¼nÃ¼n hangi desene gÃ¶re yapÄ±lacaÄŸÄ±nÄ± belirten yazÄ±dÄ±r.
- **Regex Engine**: Regex kontrolÃ¼nÃ¼n yapÄ±lmasÄ±nÄ± saÄŸlayan yazÄ±lÄ±ma verilen isimdir.


> ğŸ“Œ 
> 
> Birinin yorumu;
> 
> Benim anladÄ±ÄŸÄ±m regex iÃ§inde misal olarak eposta iÃ§in @ iÅŸareti var mÄ± gibi arama fonksiyonu var eÄŸer ben bir yere kayÄ±t olacaksam @ iÅŸareti koymadan yaparsam invalidation diye bana uyarÄ± verecek herhalde.
> 
> Cevap;
> 
> Bu kadar basit deÄŸil, Regex Ã§ok daha karmaÅŸÄ±k Ã¶rÃ¼ntÃ¼ eÅŸleÅŸmelerinin tespiti iÃ§in kullanÄ±lmaktadÄ±r.



ğŸ”­ Regex kullanÄ±mÄ± [regex101.com](regex101.com) sitesinden Ã¶ÄŸrenilebilir. Bu siteden yavaÅŸ yavaÅŸ Regex kullanÄ±mÄ± Ã¶ÄŸrenilmeye Ã§alÄ±ÅŸÄ±labilir.


## Standart C KÃ¼tÃ¼phenesinde Olmayan BazÄ± YazÄ±larla Ä°lgili FonksiyonlarÄ±n YazÄ±lmasÄ± 


â—â—â— Kendi yazdÄ±ÄŸÄ±mÄ±z fonksiyonlarda standart C fonksiyonlarÄ±nÄ± kullanabileceÄŸimiz yerlerde standart C fonksiyonlarÄ±nÄ± kullanmamÄ±z daha doÄŸru olacaktÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda C++ dilinin standart kÃ¼tÃ¼phanesinde olan ama C standart kÃ¼tÃ¼phanesinde olmayan `ends_with` adlÄ± fonksiyonun **gerÃ§ekleÅŸtirimi(implemantation)** incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

// ends_with("ankara", "kara"); olarak fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±ldÄ±ÄŸÄ±nda baÅŸarÄ±lÄ±(true) dÃ¶nÃ¼ÅŸ yapÄ±lmalÄ±dÄ±r.
int ends_with(const char* str, const char* end)
{
    size_t len_str = strlen(str);
    size_t len_end = strlen(end);

    if(len_end > len_str)
        return 0;

    // Buradaki kullanÄ±m ile nasÄ±l birinci yazÄ±nÄ±n sonunda ikinci yazÄ±nÄ±n olmasÄ± durumunun sÄ±nandÄ±ÄŸÄ± anlaÅŸÄ±lmasÄ± gerekiyor, bunun iÃ§in ya zihinden ya da de kaÄŸÄ±t kalem ile bu karÅŸÄ±laÅŸtÄ±rmanÄ±n neden doÄŸru sonuca gÃ¶tÃ¼rdÃ¼ÄŸÃ¼ anlaÅŸÄ±lmalÄ±dÄ±r.
    return !strcmp(str + len_str - len_end, end); 
}

int main(void)
{
    char s1[SIZE];
    char s2[SIZE];

    printf("birinci yaziyi girin: ");
    sgets(s1);

    printf("ikinci yaziyi girin: ");
    sgets(s2);

    printf("[%s]", s1);
    printf("[%s]", s2);

    if(ends_with(s1, s2)){
        printf("evet var!\n");
    }
    else{
        printf("hayir yok!\n");
    }
}
```


ğŸ“– Ã–dev-1, `int starts_with(const char* str, const char* end);` fonksiyonunun tanÄ±mÄ±nÄ± yazÄ±nÄ±z.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda C mÃ¼lakatÄ±nda Necati Ergin tarafÄ±ndan sorulan soru incelenebilir, bu gibi fonksiyonlarÄ±n kolaylÄ±kla yazÄ±labilir hale gelinmiÅŸ olmasÄ± gerekiyor; 
- Soru: Birinci yazÄ±nÄ±n iÃ§inde ikinci yazÄ± gÃ¶rÃ¼ldÃ¼ÄŸÃ¼nde birinci yazÄ±daki tespit edilen karakterler `*` karakterine dÃ¶ndÃ¼rÃ¼lecek bir fonksiyonu yazÄ±nÄ±z?
- Cevaba gidilirken `strstr`, `strlen` gibi standard C fonksiyonlarÄ±nÄ±n ne olduklarÄ±nÄ±n ve ne iÅŸ yaptÄ±klarÄ±nÄ±n iyi bilinmesi gerekiyor, bu bilgiyi iyi anlayÄ±p aÅŸaÄŸÄ±daki programÄ± okuyup anlayabiliyor olmak Ã¶nemlidir. KarmaÅŸÄ±k gÃ¶rÃ¼nen **string** varlÄ±klar Ã¼zerinde yapÄ±lan iÅŸlemleri kÃ¼Ã§Ã¼k parÃ§alara ayÄ±rÄ±p o parÃ§alarÄ± standart C fonksiyonlarÄ±yla yazabiliyorsak kolayca Ã§Ã¶zebiliriz.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

int main(void)
{
    char str[SIZE];
    char key[SIZE];

    printf("birinci yaziyi girin: ");
    sgets(str);

    printf("ikinci yaziyi girin: ");
    sgets(key);

    printf("[%s]\n", str);
    printf("[%s]\n", key);

    char* p = strstr(str, key);
    if(p != NULL){
        size_t len = strlen(key);

        // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ yerine ÅŸu standar C fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±labilir 'memset(p, '*', len)' ama bu fonksiyonu henÃ¼z Ã¶ÄŸrenmedik.
        while(len--)
            *p-- = '*';
    }

    printf("[%s]\n", str);
}
```


## C Dilinde Zor Konu Zinciri BaÅŸlangÄ±cÄ±(Ã–n Bilgi)


ğŸ§­ C diliyle ilgili zor konu zinciri baÅŸlangÄ±cÄ±na geldik, bu konular C dilini Ã¶ÄŸrenenleri zorluyormuÅŸ, bu konularÄ±n hepsi 20-25 saatlik bir zaman alacak ama araya ufak konular eklenecek, bu konularÄ±n iyi Ã¶ÄŸrenilmesi gerekiyor;
1. **String Literals**
2. **Pointer Arrays**
3. **Pointer to Pointer**
4. **Void Pointers**
5. **Function Pointers**
6. **Multi-dimensional Arrays**
7. **Dynamic Memory Managament**


## String Literals 

Kursun baÅŸÄ±nda Ã§ift tÄ±rnak iÃ§ine yazÄ±lan yazÄ±lara **string literal** denildiÄŸi belirtilmiÅŸti.

Derleyiciler iÃ§in sabit yazÄ± olan **string literal** varlÄ±klar bir dizi olarak gÃ¶rÃ¼lmektedir ve bu varlÄ±klar **array to pointer conversion(array decay)** iÅŸlemine tabi tutulan **L-value** varlÄ±klardÄ±r.

`"necati"` bir **string literal** varlÄ±ktÄ±r ve bir dizidir, bu dizi `char[7]` tÃ¼rÃ¼ndedir, yazÄ±nÄ±n eleman sayÄ±sÄ± yazÄ±daki karakter sayÄ±sÄ±nÄ±n bir fazlasÄ±dÄ±r Ã§Ã¼nkÃ¼ derleyici **string literal** varlÄ±klarÄ±n sonuna `'\0'` karakterini ekler.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **string literal** varlÄ±klarÄ±n **array to pointer conversion(array decay)** ile dizinin ilk elemanÄ±nÄ±n adresine Ã§evrilmesi iÅŸlemi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    // 'putchar' fonksiyonu aldÄ±ÄŸÄ± yazÄ±yÄ± standar Ã§Ä±ktÄ±ya yazÄ± sonunda yeni satÄ±r karakteri ile gÃ¶nderir. 

    putchar(*"muzaffer"); // '*"muzaffer"' bu ifadenin tÃ¼rÃ¼ 'char'dÄ±r, burada standart outup'a 'm' karakteri gÃ¶nderilir.
    putchar("tansel"[2]); // Burada standart outup'a 'n' karakteri gÃ¶nderilir.

    printf("\n~~~~~~~~~~\n");

    puts("cavit");
    puts("kara");
    puts("haldun");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan da gÃ¶rÃ¼leceÄŸi gibi **char** dizi adresi isteyen fonksiyonlara **string literal** gÃ¶nderilebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    printf("%zu\n", strlen("muharren urfali"));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **string literal** varlÄ±klarÄ±n **iÃ§erik operatÃ¶rÃ¼nÃ¼n(dereferencing operator)** ya da **index of** operandÄ± olabileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    // AÅŸaÄŸÄ±daki iki satÄ±r da aynÄ± iÅŸlemi yapmaktadÄ±r.
    putchar(*("haldun" + 3));
    putchar("haldun"[3]));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `strstr` fonksiyonuyla bir yazÄ± iÃ§inde bir yazÄ±nÄ±n aranmasÄ± iÅŸleminde ikinci parametreye gÃ¶nderilen deÄŸerin **string literal** olabileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int main(void)
{
    char str[] = "bugun bana cavit bey bir soru sordu.";

    char* p = strstr(str, "cavit");
    if(p != NULL){
        printf("bulundu idx = %d\n", p - str);
        printf("%c\n", *p);
        printf("[%s]\n", p);
    }
}
```


â—â—â— **String literal** varlÄ±klarÄ±n bir dizi olduÄŸu, **L-value** olduÄŸu ve **NULL terminated byte stream** bir dizi olduÄŸunun bilinmesi ve unutulmamasÄ± gerekiyor.



â—â—â— **string literal** varlÄ±klar sadece salt okuma amaÃ§lÄ± kullanÄ±lmalÄ±dÄ±r eÄŸer bir **string literal**'i deÄŸiÅŸtirmeye yÃ¶nelik kod yazÄ±lÄ±rsa bu "**ub**" durumuna neden olacaktÄ±r, mÃ¼lakatlarda bununla ilgili Ã§ok soru sorulmaktadÄ±r.

â—â—â— C dilinde **string literal** varlÄ±klar `const` olmayan `char*` dizilerdir ama bu **string literal** varlÄ±klarÄ±n deÄŸiÅŸtirilebileceÄŸi anlamÄ±na gelmiyor.

â—â—â— C dilini yeni Ã¶ÄŸrenenlerin Ã§ok sÄ±k yaptÄ±ÄŸÄ± yanlÄ±ÅŸlardan biri **string literal** bir varlÄ±ÄŸÄ±n elemanlarÄ±ndan birini deÄŸiÅŸtirmeye Ã§alÄ±ÅŸmaktÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir **string literal** varlÄ±ÄŸÄ±n elemanlarÄ±ndan birinin deÄŸerinin deÄŸiÅŸtirilmesinin "**ub**" durumuna neden olacaÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int main(void)
{
    char* p = "mete"; // Bu satÄ±r C++ dilinde senteks hatasÄ±dÄ±r Ã§Ã¼nkÃ¼ sabit yazÄ±lar 'const char*[n]' tÃ¼rÃ¼ndedir tÃ¼rÃ¼ ama C dilinde burada bir hata yoktur

    puts(p); 
    *p = 's'; // Bu iÅŸlem 'ub' durumuna neden olacaktÄ±r, bu nedenle bu ÅŸekilde bir kullanÄ±m yanlÄ±ÅŸtÄ±r.
    puts(p); 
}
```



â—â—â— C dilinde **string literal** varlÄ±klar, elemanlarÄ± `char` olan dizilerdir, C++ dilinde **string literal** varlÄ±klar elemanlarÄ± `const char` olan dizilerdir. </br>
Ancak her iki dilde de **sÃ¶zdizimi(syntax)** engeli aÅŸÄ±lsa bile **string literal** varlÄ±ÄŸÄ± deÄŸiÅŸtirme giriÅŸimi tanÄ±msÄ±z davranÄ±ÅŸtÄ±r(**ub**).



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `void xyzstr(char* p);` bildirimindeki bir fonksiyona **string literal** bir varlÄ±k ile fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±lmamasÄ± gerektiÄŸi anlaÅŸÄ±lmalÄ±dÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

void xyzstr(char* p);

int main(void)
{
    xyzstr("eren guven"); // Bu fonksiyon Ã§aÄŸrÄ±sÄ± 'xyzstr' fonksiyonunun aldÄ±ÄŸÄ± 'char array'leri deÄŸiÅŸtirebilme olasÄ±lÄ±ÄŸÄ±nÄ±n olmasÄ±ndan dolayÄ± yapÄ±lmamalÄ±dÄ±r Ã§Ã¼nkÃ¼ 'string literal' varlÄ±klarÄ±n deÄŸiÅŸtirilmemesi gerekiyor.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **string literal** bir varlÄ±ÄŸÄ± gÃ¶steren bir gÃ¶stericinin tÃ¼rÃ¼nÃ¼n `char*` yapÄ±lmamasÄ± gerektiÄŸi bunun yerine `const char*` yapÄ±lmasÄ± gerektiÄŸi iyi anlaÅŸÄ±lmalÄ±dÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int main(void)
{
    char* p1 = "murat deniz"; // BÃ¶yle bir bildirim yapmak legaldir ama doÄŸru deÄŸildir, 'p' gÃ¶stericisinin bildirimi 'const char*' olmalÄ±dÄ±r.
    const char* p2 = "murat deniz";

    *p1 = '!'; // Bu atama iÅŸlemi 'ub'dir.
    *p2 = '!'; // Bu atama iÅŸlemi sÃ¶zdizim hatasÄ±dÄ±r(syntax error).
}
```



â—â—â— Kursun bu kÄ±smÄ±na kadar nesnelerin Ã¶mÃ¼r kategorilerinden **static storage duration** ve **otomatic storage duration** kategorilerini Ã¶ÄŸrendik. </br>
C dilinde **string literal** varlÄ±klar **static storage duration** Ã¶mre sahiptir, bu da **string literal** deÄŸiÅŸkenlerin program Ã§alÄ±ÅŸmasÄ±ndan sonlanmasÄ±na kadar bellekte kaldÄ±ÄŸÄ± anlamÄ±na geliyor.

â—â—â— **String literal** varlÄ±klarÄ±n **static storage duration** Ã¶mÃ¼rlÃ¼ olduÄŸunu bilmek **static bellek alanÄ±** kÄ±sÄ±tlÄ± olan donanÄ±mlarda Ã§alÄ±ÅŸacak C programlarÄ±nÄ± yazarken ciddi sorunlarÄ±n programÄ±n Ã§alÄ±ÅŸma zamanÄ±nda oluÅŸmamasÄ± iÃ§in Ã¶nemlidir.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.40-11.02 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***



ğŸ‘‡ AÅŸaÄŸÄ±daki programda C dilinde sadece salt okuma amaÃ§lÄ± kullanÄ±lmasÄ± gereken `char` dizi tÃ¼rÃ¼nden olan **String literal** deÄŸerlerinin bir fonksiyonun geri dÃ¶nÃ¼ÅŸÃ¼nde nasÄ±l kullanÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

const char* day_to_name(int weekday)
{
    switch(weekday){
        case 1: return "pazartesi";
        case 2: return "sali";
        case 3: return "carsamba";
        case 4: return "persembe";
        case 5: return "cuma";
        case 6: return "cumartesi";
        case 7: return "pazar";
    }

    return "";
}

int main(void)
{
    for(int i = 0; i <= 7; ++i){
        puts(day_to_name(i));
    }
}
```


â—â—â— C dilinde **string literal** varlÄ±klar `char` tÃ¼rÃ¼nden dizilerdir, bu varlÄ±klarÄ±n deÄŸiÅŸtirilmemeleri gerekiyor.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **string literal** varlÄ±klarÄ±n kullanÄ±mlarÄ±yla ilgili farklÄ±lÄ±klar incelenebilir.
- Hem Ã¼retimde Ã¶nemli hem de C mÃ¼lakatlarÄ±nda sÄ±k sorulan bir soru aÅŸaÄŸÄ±daki programdaki durumlarla ilgilidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

void foo(void)
{
    // Buradaki 'str' adÄ±ndaki dizi 'otamatik' Ã¶mÃ¼rlÃ¼dÃ¼r ve istenildiÄŸi gibi deÄŸiÅŸtirilebilir.~
    // AÅŸaÄŸÄ±daki gibi 'char array' bildiirmi kolaylÄ±k olmasÄ± iÃ§in dilde olan sÃ¶zdizimidir(syntax).
    char str[] = "necati"; // Buradaki statement ÅŸuna denktir: 'char str[] = { 'n', 'e',  'c',  'a',  't',  'i',  '\0' }'

    puts(str);
    
    // AÅŸaÄŸÄ±daki Ã¼Ã§ statement'ta yapÄ±lan iÅŸlemler legal ve doÄŸrudur, 
    str[0] = 'k';
    str[2] = 'l';
    str[4] = 'm';

    puts(str);
}

void bar(void)
{
    char* p = "ergin";

    puts(str);

    // AÅŸaÄŸÄ±daki atamalar 'string literal' bir char dizinin elemanlarÄ±nÄ± deÄŸiÅŸtirme iÅŸlemi olduÄŸu iÃ§in 'ub' durumuna neden olacaktÄ±r. 
    str[0] = 'k';
    str[2] = 'l';
    str[4] = 'm';

    puts(str);
}

int main(void)
{
    foo();
    printf("\n~~~~~~~~~~~~~~~~~~\n");
    //bar();
}
```


>â”
> 
> Sorulan soru; 
> 
> `str = "kaya"` seklinde atama yapsam peki diziye hocam
> 
> Cevap;
> 
> Bir gÃ¶sterici programÄ±n farklÄ± yerlerinde farklÄ± **string literal** varlÄ±klarÄ± gÃ¶sterebilir ve bu geyet olaÄŸan bir durumdur.
> 
> ğŸ‘‡ AÅŸaÄŸÄ±daki programda herhangi bir hata ya da yanlÄ±ÅŸlÄ±k yoktur, "p" gÃ¶stericisi programÄ±n farklÄ± yerlerinde farklÄ± **string literal** varlÄ±klarÄ±n adreslerinin baÅŸlangÄ±cÄ±nÄ± gÃ¶stermektedir.
> ```C
> #define _CRT_SECURE_NO_WARNINGS
> 
> #include <stdio.h>
> #include <string.h>
> 
> int main(void)
> {
>     char* p = "neco"; // Buradaki 'string literal' varlÄ±k bellekte program sonuna kadar kalacaktÄ±r.
> 
>     puts(p);
> 
>     p = "zeyno"; // Buradaki 'string literal' varlÄ±k bellekte program sonuna kadar kalacaktÄ±r.
>     puts(p);
>     p = "haldun"; // Buradaki 'string literal' varlÄ±k bellekte program sonuna kadar kalacaktÄ±r.
>     puts(p);
> }
> ```



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki gibi **string literal** varlÄ±klarÄ±n Ã¶mÃ¼rleriyle ilgili C mÃ¼lakatlarÄ±nda sÄ±kÃ§a soru sorulmaktadÄ±r, programdaki yorumlarÄ±n iyi anlaÅŸÄ±lÄ±yor olmasÄ± gerekiyor.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int main(void)
{
    for(int i = 0; i < 10; ++i){
        char* p = "mustafa"; // 'string literal' bir varklÄ± 'static' Ã¶mÃ¼rlÃ¼ olduÄŸu iÃ§in programÄ±n Ã§alÄ±ÅŸmasÄ± boyunca sadece tek bir defa oluÅŸturulur.
        printf("%p\n", p); // Burada hep aynÄ± adres deÄŸeri yazacaktÄ±r.
    }

    // AÅŸaÄŸÄ±daki kodlama ile yukarÄ±daki birbirine denktir.
    char* str = "mustafa";
    for(int i = 0; i < 10; ++i){
        char* p2 = str;
        printf("%p\n", p2); // Burada hep aynÄ± adres deÄŸeri yazacaktÄ±r.
    }
}
```



â—â—â— "**Initialization is not an assignment**" cÃ¼mlesinin ne anlama geldiÄŸini hatÄ±rlamak iÃ§in aÅŸaÄŸÄ±daki program incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int main(void)
{
    // AÅŸaÄŸÄ±daki kod satÄ±rÄ±nda 'x' adÄ±nda 'int' tÃ¼rÃ¼nden bir deÄŸiÅŸken bildirimi yaÅŸamÄ±na 'otomatic' Ã¶mÃ¼rlÃ¼ olarak '13' deÄŸeriyle baÅŸlÄ±yor.
    // Ä°lk deÄŸer vermek bir deÄŸiÅŸkenin hayatÄ±na baÅŸlarken alacaÄŸÄ± ilk deÄŸeri belitmek(vermek) demektir. 
    // AÅŸaÄŸÄ±daki kodda 'name lookup(ad arama)' yoktur.
    // AÅŸaÄŸÄ±daki koddaki '=' bir operatÃ¶r deÄŸildir, buradaki '=' token'Ä± deÄŸiÅŸken bildiriminin sÃ¶zdiziminin(syntax) bir bileÅŸenidir, bu bilginin farkÄ±nda olmak Ã§ok Ã¶nemlidir!
    int x = 13; // Buradaki statement 'Decleration Statement' olarak adlandÄ±rÄ±lmaktadÄ±r.

    x = 24; // Buradaki statement 'Non Decleration Statement' durumundadÄ±r
}
```

**Statement** varlÄ±klar temelde iki farklÄ± Ã¶beÄŸe ayrÄ±lÄ±r, bu Ã¶bekler aÅŸaÄŸÄ±daki gibidir;
- **Decleration Statement**
- **Non Decleration Statement**


### String Literal Ne Ä°ÅŸe Yarar 

**string literal** varlÄ±klar, **compile-time** anÄ±nda kullanÄ±lacak olan sabit yazÄ±lar gerektiÄŸi yerlerde kullanÄ±lÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda sitring diziler Ã¼zerinde yapÄ±lan iÅŸlemler incelenebilir.
- Soru: `file_name` dizisindeki yazÄ±yÄ± `new_file_name` dizisine kopyalayÄ±n.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

#define SIZE 100

int main(void)
{
    char* file_name[SIZE];

    printf("dosya ismini giriniz: ");
    scanf("%s", file_name);

    char* new_file_name[SIZE];
    strcpy(new_file_name, file_name); // 'strcpy' fonksiyonu 'file_name' dizisini 'new_file_name' dizisine kopyalamak iÃ§in kullanÄ±lmÄ±ÅŸ.
    printf("[%s]    [%s]\n", file_name, new_file_name);

    // EÄŸer dosyanÄ±n uzantÄ±sÄ± yok ise dosyanÄ±n adÄ±nÄ±n uzantÄ±sÄ±nÄ± '.txt' yapÄ±n.
    char* p = strrchr(new_file_name, '.'); // Burada 'strrchr' fonksiyonu ile 'new_file_name' dizisinin en sonunda bir '.' karakteri var mÄ± diye arama yapÄ±lmÄ±ÅŸ.
    if(!p){ // 'new_file_name' dizisinde '.' karakteri bulunamamÄ±ÅŸ ise 'p' gÃ¶stericisinin deÄŸeri 'NULL' deÄŸerde olacak ve '!p' koÅŸulu 'non-zero' olacaÄŸÄ± iÃ§in if gÃ¶vdesine girecektir.
        strcat(new_file_name, ".txt"); // 'strcat' fonksiyonu ile 'new_file_name' dizisinin sonuna 'string literal' olan '.txt' yazÄ±sÄ± ekleniyor.
    }

    // EÄŸer dosyanÄ±n uzantÄ±sÄ± '.jpg' ise dosyanÄ±n uzantÄ±sÄ±nÄ± '.gif' olarak deÄŸiÅŸtir.
    if(!strcmp(p, ".jpg")){ // 'strcmp' fonksiyonu ile 'p' gÃ¶stericisinden sonraki yazÄ±nÄ±n '.jpg' deÄŸerine eÅŸit olmasÄ± sÄ±nanÄ±yor, eÄŸer eÅŸitse geriye '0' deÄŸer dÃ¶neceÄŸi iÃ§in bu fonksiyon Ã§aÄŸrÄ±sÄ±nÄ±n deÄŸili alÄ±nÄ±yor.
        strcpy(p, ".gif"); // 'strcpy' fonksiyonu ile 'p' gÃ¶stericisinden sonraki yazÄ± '.gif' olarak deÄŸiÅŸtiriliyor(buraki iÅŸlemi doÄŸru anlamak iÃ§in 'p' gÃ¶stericisinin gÃ¶sterdiÄŸi adresin 'new_file_name' karakter dizisindeki son '.' karakterinin adresi olduÄŸu ve karakter dizilerinin sonunda dizi sonu karakteri olan '\0' elemanÄ±n olduÄŸu bilinmelidir!).
    }
    
    // EÄŸer dosyanÄ±n uzantÄ±sÄ± '.docs' ise dosyanÄ±n uzantÄ±sÄ±nÄ± silin.
    if(!strcmp(p, ".docs")){ // 'strcmp' ile 'p' gÃ¶stericisinden sonraki yazÄ±nÄ±n '.docs' olduÄŸu sÄ±nanÄ±yor eÄŸer Ã¶yleyse 'strcmp' fonksiyonu geriye '0' deÄŸerini dÃ¶necektir bunun deÄŸili alÄ±narak istenilen durumun saÄŸlandÄ±ÄŸÄ± sÄ±nanÄ±yor ve if gÃ¶vdesine giriliyor.
        *p = '\0'; // Burada 'p' gÃ¶stericisinin taÅŸÄ±dÄ±ÄŸÄ± adres deÄŸeri 'new_file_name' karakter dizisinin sonundaki '.' karakterinin adres deÄŸeriydi ve bu adresteki deÄŸer '\0' yapÄ±ldÄ±ÄŸÄ±nda yazÄ±nÄ±n sonu silinmiÅŸ olacaktÄ±r.
    }

    printf("[%s]    [%s]\n", file_name, new_file_name);
}
```


ğŸ‘† YukarÄ±daki program ğŸ‘‡ aÅŸaÄŸÄ±daki gibi de yazÄ±labilir, ayrÄ±ca bu program yorum satÄ±rlarÄ± olmadan da okunabiliyor olmasÄ± gerekiyor ki C dilinin standart kÃ¼tÃ¼pheneleriyle birlikte Ã¶ÄŸrenildiÄŸi belli olsun, C bilmek demek C dilinin standardÄ±ndan olan her ÅŸeyiyle birlikte iyi seviyede bilmeyi gerektirir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

#define SIZE 100

int main(void)
{
    char* file_name[SIZE];

    printf("dosya ismini giriniz: ");
    scanf("%s", file_name);

    char* new_file_name[SIZE];
    strcpy(new_file_name, file_name);
    printf("[%s]    [%s]\n", file_name, new_file_name);

    char* p = strrchr(new_file_name, '.');
    
    if(!p){
        strcat(new_file_name, ".txt");
    } else if(!strcmp(p, ".jpg")){ 
        strcpy(p, ".gif");
    } else if(!strcmp(p, ".docs")){
        *p = '\0';
    }
    
    printf("[%s]    [%s]\n", file_name, new_file_name);
}
```



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki gibi bir durum "**Implemantation Specified**" bir durumdur, derleyiciler programdaki Ã¶zdeÅŸ **strinf literal** varlÄ±klarÄ± belleÄŸe ayrÄ± diziler olarak alabilir ya da farklÄ± diziler olarak alabilir ve derleyici her seferinde bu durumlardan herhangi birini uygulayabilir, C standardÄ± bunu derleyicilere bÄ±rakmÄ±ÅŸtÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int main(void)
{
    char* p1 = "asli ozer";
    char* p2 = "asli ozer";

    if(p1 == p1)
        printf("evet dogru\n");
    else
        printf("hayir yanlis\n");
}
```


**Implemantation Specified**: Derleyicinin iki ya da daha fazla sayÄ±da farklÄ± kod Ã¼retme seÃ§eneÄŸi arasÄ±ndan istediÄŸi seÃ§eneklerden biriyle kod Ã¼retebilmesi durumudur ve her seferinde de farklÄ± ÅŸekilde kod Ã¼retebilir, bu izni C standardÄ± derleyicilere vermiÅŸtir.


**Implemantation defined**: Derleyicinin iki ya da daha fazla sayÄ±da farklÄ± kod Ã¼retme seÃ§eneÄŸi arasÄ±ndan istediÄŸi seÃ§eneklerden biriyle kod Ã¼retebilmesi durumudur ama derleyici bunu dokÃ¼mente etmelidir ve her seferinde de aynÄ± ÅŸekilde kod Ã¼retmelidir.


â—â—â— **Implemantation Specified** ve **Implemantation defined** arasÄ±ndaki fark ise **Implemantation defined** durumlarÄ±nda Ã¼retilecek kodlarÄ±n ne olacaÄŸÄ± serleyici iÃ§in dokÃ¼mente edilmiÅŸ olmasÄ± gerekmesi ve her zaman aynÄ± ÅŸekilde kod Ã¼retilecek olmasÄ±dÄ±r ama **Implemantation Specified** durumlarÄ±nÄ± derleyiciler dokÃ¼mente etmek zorunda deÄŸiller ve her sefereinde farklÄ± ÅŸekilde kod Ã¼retebilirler.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **sabit yazÄ±larÄ±n(string literal)** eÅŸitlik karÅŸÄ±laÅŸtÄ±rmalarÄ±nÄ±n nasÄ±l doÄŸru ÅŸekilde yapÄ±lacaÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int main(void)
{
    char* psw = "blackdog";

    char entry[40];

    printf("parolayi girin: ");
    scanf("%s", entry);

    printf("~~yanlis yolla(entry == \"blackdog\") yazilarin karsilastirmasi~~");

    if(entry == "blackdog"){
        printf("paralo dogru\n");
    }
    else{
        printf("paralo yanlis\n");
    }

    printf("~~dogru yolla(!strcmp(entry, psw)) yazilarin karsilastirmasi~~");

    if(!strcmp(entry, psw)){
        printf("paralo dogru\n");
    }
    else{
        printf("paralo yanlis\n");
    }
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda sabit yazÄ±larÄ±n eÅŸitlik karÅŸÄ±laÅŸtÄ±rmalarÄ±nÄ±n nasÄ±l yapÄ±lmamasÄ± gerektiÄŸ incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int main(void)
{
    char* psw = "blackdog";

    char entry[40];

    printf("parolayi girin: ");
    scanf("%s", entry);

    // AÅŸaÄŸÄ±daki karÅŸÄ±laÅŸtÄ±rma doÄŸru deÄŸildir Ã§Ã¼nkÃ¼ karÅŸÄ±laÅŸtÄ±rma adresler Ã¼zerinde yapÄ±lmaktadÄ±r, bu da 'always false' anlamÄ±na gelmektedir.
    if(entry == psw){
        printf("paralo dogru\n");
    }
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.08-12.19 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


>â”
> 
> Sorulan soru; 
> 
> `static char* x = (char*)malloc(10)` bir dÃ¶ngÃ¼de cagirilsa mesela buradaki fonksiyon her for dÃ¶ngÃ¼sÃ¼nde cagirilmayacak diyebilir miyiz?
> sizin `%p` ile sordugunuz mÃ¼lakat sorusuna istinaden aklima geldi
> yani sormak istedigim `static` olunca degisken kalici evet anladim ama bildirim sag tarafinda fonksiyon varsa o da mÄ± yalnÄ±zca 1 kez cagiriliyor
> 
> Cevap;
> 
> ğŸ‘‡ AÅŸaÄŸÄ±daki programda `static` bir deÄŸiÅŸkene verilecek ilk deÄŸerin C dilinde `const` olma zorunluluÄŸu incelenebilir.
> ```C
> #define _CRT_SECURE_NO_WARNINGS
> 
> #include <stdio.h>
> #include <string.h>
> 
> int bar(int x)
> {
>     printd("bar() function called!");
> }
> 
> void foo()
> {
>     static int x = bar(100); // Buradaki ilk deÄŸer verme iÅŸlemi C silinde legal deÄŸiÅŸdir C++ dilinde legaldir, C dilinde legal olmama nedeni 'static' deÄŸiÅŸkene verilen ilk deÄŸerin 'const expression' olmamasÄ±dÄ±r.
> }
> 
> int main()
> {
>     for(int i = 0; i < 10; ++i){
>         foo(); // Burada 'foo' fonksiyonu ne kadar Ã§aÄŸÄ±rÄ±lÄ±rsa Ã§aÄŸÄ±rÄ±lsÄ±n bu fonksiyondaki 'static' deÄŸiÅŸkenlerin deÄŸerleri sadece bir defa belleÄŸe alÄ±nacaktÄ±r.
>     }
> }
> ```



â—â—â— **Strinf literal** varlÄ±klar ile ilgili aÅŸaÄŸÄ±daki bilgilerin iyi bilinmesi gerekiyor;
- **Strinf literal** varlÄ±klar sadece **readonly** olarak kullanÄ±labilir, bu varlÄ±klarÄ±n deÄŸiÅŸtirilmeye Ã§alÄ±ÅŸÄ±lmasÄ± "**ub**" durumuna neden olur.
- **Strinf literal** varlÄ±klar C ve C++ dillerinde `static` Ã¶mÃ¼rlÃ¼dÃ¼r.
- DeÄŸeri aynÄ± olan **Strinf literal** varlÄ±klarÄ±n aynÄ± bellek alanÄ±nda mÄ± yoksa farklÄ± bellek alanÄ±nda mÄ± tutulacaÄŸÄ± C ve C++ dillerinde **implemantation specified** olarak belirlenmiÅŸtir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã¶nemli olan birbirine benzer ama tamamen farklÄ± olan deÄŸiÅŸken bildirimleri incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int main(void)
{
    // AÅŸaÄŸÄ±daki assingment statement'lardaki varlÄ±klar birbirinden farklÄ±dÄ±r.
    char ary[100] = "ad-soyad"; // Burada 'ary' adÄ±nda dizi hayatÄ±na elemanlarÄ± sÄ±rasÄ±yla 'a', 'd', '-', 's', 'o', 'y', 'a', 'd' olarak baÅŸlayan karakter dizisidir.
    char* p = "ad-soyad"; // Burada 'p' gÃ¶stericisi, 'string literal'in adresi ile hayatÄ±na baÅŸlamaktadÄ±r.
}
```


## `sizeof` OperatÃ¶rÃ¼ ve `srtlen` Fonksiyonu FarkÄ± 

C dilini yeni Ã¶ÄŸrenenlerde "`sizeof` operatÃ¶rÃ¼" ve "`srtlen` fonksiyonu" kullanÄ±mlarÄ± birbirine karÄ±ÅŸtÄ±rÄ±lma eÄŸilimindeymiÅŸ.

`sizeof` operatÃ¶rÃ¼ aldÄ±ÄŸÄ± operandÄ±n tÃ¼rÃ¼ neyse o tÃ¼rÃ¼n bellekte kapladÄ±ÄŸÄ± byte deÄŸerini Ã¼retmektedir.


ğŸ‘‡ AÅŸaÄŸÄ±daki program "`sizeof` operatÃ¶rÃ¼" ve "`srtlen` fonksiyonu" kullanÄ±mlarÄ±nÄ±n farklarÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

void foo(char* p)
{
    // 'sizeof(p)' ifadesindeki 'p' bir pointer olduÄŸu iÃ§in 32 bit mimaride '4 byte' deÄŸer kaplayacaktÄ±r.
    printf("%zu\n", sizeof(p) / sizeof(p[0])); // Burada '4 byte / 1 byte' iÅŸleminden dolayÄ± standar Ã§Ä±ktÄ± akÄ±mÄ±na "4\n" deÄŸeri gÃ¶nderilir.
}

int main(void)
{
    char* p = "mete";
    char str[] = "necati";

    printf("%zu\n", strlen(p)); // 'strlen' fonksiyonu yazÄ±nÄ±n karakter uzunluÄŸunu dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ iÃ§in standar Ã§Ä±ktÄ± akÄ±mÄ±na "4\n" deÄŸeri gÃ¶nderilir.
    printf("%zu\n", sizeof(p)); // 32 bitlik mimaride standar Ã§Ä±ktÄ± akÄ±mÄ±na "4\n" deÄŸeri gÃ¶nderilir.
    printf("%zu\n", sizeof(*p)); // '*p' ifadesinin 'char' tÃ¼rÃ¼nden olduÄŸu iÃ§in standar Ã§Ä±ktÄ± akÄ±mÄ±na "1\n" deÄŸeri gÃ¶nderilir.
    printf("%zu\n", strlen("necati")); // 'strlen' fonksiyonu yazÄ±nÄ±n karakter uzunluÄŸunu dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ iÃ§in standar Ã§Ä±ktÄ± akÄ±mÄ±na "6\n" deÄŸeri gÃ¶nderilir.
    printf("%zu\n", sizeof "necati"); // Burada sizeof operatÃ¶rÃ¼nÃ¼n operandÄ±nÄ±n tÃ¼rÃ¼ 'char[7]' olduÄŸu iÃ§in standar Ã§Ä±ktÄ± akÄ±mÄ±na "7\n" deÄŸeri gÃ¶nderilir.

    printf("%zu\n", strlen(str)); // 'strlen' fonksiyonu yazÄ±nÄ±n karakter uzunluÄŸunu dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ iÃ§in standar Ã§Ä±ktÄ± akÄ±mÄ±na "6\n" deÄŸeri gÃ¶nderilir.
    printf("%zu\n", sizeof(str)); // Burada sizeof operatÃ¶rÃ¼nÃ¼n operandÄ±nÄ±n tÃ¼rÃ¼ 'char[7]' olduÄŸu iÃ§in standar Ã§Ä±ktÄ± akÄ±mÄ±na "7\n" deÄŸeri gÃ¶nderilir.

    foo(p);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki kod Necati Ergin tarafÄ±ndan bir firma iÃ§in hazÄ±rlanan C mÃ¼lakat sorusuymuÅŸ. </br> 
soru ÅŸu: Ã‡Ä±ktÄ± ne olur ve neden?
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int main(void)
{
    char* p = "mustafa";
    size_t sz = sizeof(++p); // 'sizeof' operatÃ¶rÃ¼ derleme zamanÄ±nda Ã§alÄ±ÅŸÄ±r sadece ve iÅŸlem kodu Ã¼retmez, burada 'sz' deÄŸiÅŸkenine '++p' ifadesinin tÃ¼rÃ¼ 'char*' yani bir pointer olduÄŸu iÃ§in 32 bitlik mimaride '4' deÄŸeri atanÄ±r.

    printf("%zu\n", strlen(p)); // Burada standart Ã§Ä±ktÄ± akÄ±mÄ±na 'sizeof' operatÃ¶rÃ¼ iÅŸlem kodu Ã¼retmediÄŸi iÃ§in '7\n' gÃ¶nderilir.
}
```



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã§Ä±ktÄ±larÄ±n ne olacaÄŸÄ± ve neden Ã¶yle olduÄŸu iyi anlaÅŸÄ±lmalÄ±dÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int main(void)
{
    "karya"; // Buradaki 6 elemanlÄ± bir dizidir.
    "kar"; // Buradaki 4 elemanlÄ± bir dizidir.
    "kayra ve"; // Buradaki 9 elemanlÄ± bir dizidir.
    ""; // Buradaki 1 elemanlÄ± bir dizidir.

    printf("%d\n", *""); // Standart Ã§Ä±ktÄ± akÄ±mÄ±na '0\n' gÃ¶nderilir.
    printf("%zu\n", sizeof ""); // Standart Ã§Ä±ktÄ± akÄ±mÄ±na '1\n' gÃ¶nderilir.
    printf("%zu\n", strlen("")); // Standart Ã§Ä±ktÄ± akÄ±mÄ±na '0\n' gÃ¶nderilir.
}
```



â—â—â— `char *p;` bildirimindeki "p" gÃ¶stericisi geÃ§erli bir deÄŸere sahipse, p bir yazÄ±yÄ± gÃ¶steriyorsa ve p'nin gÃ¶sterdiÄŸi yazÄ± boÅŸ deÄŸil ise
- `if(p != NULL && *p != '\0')` kullanÄ±mÄ± `if(p && *p)` ÅŸeklinde C dilinde idiomatik ÅŸekilde yazÄ±labilir ve burada **short circuit behavior** vardÄ±r.
- `if(!(p != NULL && *p != '\0'))` kullanÄ±mÄ± ile `if(p == NULL || *p == '\0')` kullanÄ±mÄ± aynÄ±dÄ±r ve buradaki ifadeler C dilinde idiomatik `if(!p || !*p)` ifadesine denktir. 


## String Literal VarlÄ±klarÄ± Birden Fazla SatÄ±rda GÃ¶sterme Ä°ÅŸlemi 

C dilinde bir **string literal**'i birden fazla satÄ±rda yazmak iÃ§in iki farklÄ± araÃ§(yÃ¶ntem) vardÄ±r.

ğŸ‘‡ AÅŸaÄŸÄ±daki program uzun bir yazÄ±nÄ±n birden fazla satÄ±r olarak nasÄ±l en az kullanÄ±lan yÃ¶ntemle yazdÄ±rÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int main(void)
{
    const char *p = "su an icin bellek yetersiz oldugu icin isteginize cevap veremiyoruz, \
devam etmek icin bir tusa basiniz."; // Bu ÅŸekilde yazÄ±lmasÄ± gerekiyor ki yazÄ± tek satÄ±rda gÃ¶rÃ¼nebilsin ama buradaki sorun arada bÄ±rakÄ±lan boÅŸluklarÄ±n da yazÄ±ya eklenmesidir. Burada alttaki yazÄ± sola dayalÄ± olarak yazÄ±ldÄ± Ã§Ã¼nkÃ¼ yazÄ±nÄ±n dÃ¼zgÃ¼n gÃ¶rÃ¼nmesi istendi.

    puts(p);
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda birden fazla **string literal** varlÄ±ÄŸÄ±n aralarÄ±nda sadece boÅŸluk karakteri(karalterleri) bÄ±rakÄ±ldÄ±ÄŸÄ±nda derleyicinin bu yazÄ±larÄ± birleÅŸtirip tek bir yazÄ±ya dÃ¶nÃ¼ÅŸtÃ¼rdÃ¼ÄŸÃ¼ durum incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int main(void)
{
    // AÅŸaÄŸÄ±daki 'p1' deÄŸiÅŸkeni bildiriminde derleyici aralarÄ±nda sadece boÅŸluk karakterleri olan 'string literal'varlÄ±klarÄ± birleÅŸtirip tek bir string varlÄ±k gibi yorumlayacaktÄ±r.
    char *p1 = "kayhan" "murat"
        "selami" "ayla" "nur" "zeyno";

    char *p2 = "kayhanmuratselamiaylanurzeyno"

    // AÅŸaÄŸÄ±daki fonksiyon Ã§aÄŸrÄ±larÄ± sonucunda standart Ã§Ä±ktÄ±ya aynÄ± deÄŸerlerin gÃ¶nderileceÄŸi incelenebilir.
    puts(p1);
    puts(p2);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki gibi **string literal** varlÄ±klarÄ±n yazdÄ±rÄ±lmasÄ± iÅŸlemi Ã¶zellikle gÃ¶mÃ¼lÃ¼ sistemlerde sÄ±k kullanÄ±lan bir yÃ¶ntemdir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int main(void)
{
    printf("[1]oyuna basla\n"
           "[2]oyunu durdur\n"
           "[3]oyunu bitir\n"
           "[4]oyunu yenile\n"
           "[5]oyundan cik\n");
}
```


Ders sonu ...
