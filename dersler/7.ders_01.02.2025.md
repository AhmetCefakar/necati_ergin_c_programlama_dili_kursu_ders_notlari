# 7.Ders 01.02.2025 ğŸ•˜

Derse 30(09:01)-40(09:24)-39(10:58)-36(11:33)-32(13:00) kiÅŸi katÄ±ldÄ±.

## Functions Devam(Kursun 1. Ã‡eyreÄŸinin en Ã¶nemli konusu)

En son fonksiyonlarÄ±n geri dÃ¶nÃ¼ÅŸ deÄŸerlerinde kalÄ±nmÄ±ÅŸtÄ±, bir Ã¶nceki derste anlatÄ±lan konularÄ±n kÄ±sa Ã¶zeti yapÄ±ldÄ±.


```C
// AÅŸaÄŸÄ±daki fonksiyon kendisine verilen sayÄ±nÄ±n asal olup olmadÄ±ÄŸÄ±nÄ± test etmektedir.
// SayÄ± prima(asal) ise 'non-zero' deÄŸer dÃ¶nÃ¼yor ve bu durum 'true' olarak yorumlanÄ±r.
// SayÄ± prima(asal) deÄŸilse 'zero' deÄŸer dÃ¶nÃ¼yor ve bu durum 'false' olarak yorumlanÄ±r.
// Bizim iÃ§in boolean olarak yorumlanacak 'int' deÄŸer dÃ¶ndÃ¼ren fonksiyonlar 'zero/non-zero' deÄŸer dÃ¶ndÃ¼ren fonksiyonlar olarak adlandÄ±rÄ±lÄ±r
int isprime(int x)
{
    // ...
}
```

### Ä°ÅŸ Yapan TÃ¼rden Fonksiyonlar 

Belirli bir iÅŸi yapan bir fonksiyonun iÅŸini baÅŸarÄ±lÄ± olarak yapacaÄŸÄ±nÄ±n garantisi yoktur. </br>
Bu tÃ¼r fonksiyonlarÄ± Ã§aÄŸÄ±ran kod baÅŸarÄ±/baÅŸarÄ±sÄ±zlÄ±k sonucunu bilmelidir. </br>
Belirli iÅŸleri yapan fonksiyonlardan geriye dÃ¶nen deÄŸerlerin baÅŸarÄ±/baÅŸarÄ±sÄ±zlÄ±k durumlarÄ±nÄ±n hamgi kurala gÃ¶re yapÄ±lacaÄŸÄ± konusunda fikir birliÄŸi yoktur, bu nedenle aÅŸaÄŸÄ±da aÃ§Ä±klanan durumlar sÃ¶zkonusudur;

- C dilinin standart kÃ¼tÃ¼phanesindeki "**iÅŸ yapan tÃ¼rden fonksiyonlar**";
    - "0" deÄŸer dÃ¶ndÃ¼rÃ¼yorsa baÅŸarÄ±lÄ± iÅŸlem yapÄ±ldÄ±ÄŸÄ± anlamÄ±na geliyor.
    - "non-zero" deÄŸer dÃ¶ndÃ¼rÃ¼yorsa baÅŸarÄ±sÄ±z iÅŸlem yapÄ±ldÄ±ÄŸÄ± anlamÄ±na geliyor, buradaki mantÄ±k baÅŸarÄ±sÄ±zlÄ±k durumlarÄ±nÄ±n birden fazla olduÄŸu iÃ§in farklÄ± hata durumlarÄ±nda farklÄ± deÄŸerler dÃ¶nÃ¼lerek hata nedeni takip edilebilir.
- C dilde 3. taraflar tarafÄ±ndan yazÄ±lan kÃ¼tÃ¼phanelerin bazÄ±larÄ±nda "**iÅŸ yapan tÃ¼rden fonksiyonlar**";
    - "0" deÄŸer dÃ¶ndÃ¼rÃ¼yorsa baÅŸarÄ±sÄ±z iÅŸlem yapÄ±ldÄ±ÄŸÄ± anlamÄ±na gelebilir.
    - "non-zero" deÄŸer dÃ¶ndÃ¼rÃ¼yorsa baÅŸarÄ±lÄ± iÅŸlem yapÄ±ldÄ±ÄŸÄ± anlamÄ±na gelebilir.
- C dilinin standart kÃ¼tÃ¼phanesindeki bazÄ± pointer dÃ¶ndÃ¼ren "**iÅŸ yapan tÃ¼rden fonksiyonlar**";
    - BaÅŸarÄ±lÄ± iÅŸlem yapÄ±lmÄ±ÅŸsa bir nesne adresi dÃ¶ndÃ¼rÃ¼r.
    - BaÅŸarÄ±sÄ±z iÅŸlem yapÄ±lmÄ±ÅŸsa "**NULL pointer**" deÄŸer dÃ¶ndÃ¼rÃ¼r.
- C dilinin standart kÃ¼tÃ¼phanesindeki "`printf`" fonksiyonu ekrana yazdÄ±rma iÅŸleminden sonra ekrana yazdÄ±rÄ±lan karakter sayÄ±sÄ±nÄ± geriye dÃ¶ndÃ¼rÃ¼r.

â— YukarÄ±daki durumlardan da anlaÅŸÄ±lacaÄŸÄ± gibi "**iÅŸ yapan tÃ¼rden fonksiyonlar**"Ä±n nasÄ±l deÄŸer dÃ¶ndÃ¼receÄŸi fonksiyona gÃ¶re ve fonksiyonun ne iÅŸ yaptÄ±ÄŸÄ±ne gÃ¶re deÄŸiÅŸebiliyor.


`printf()` fonksiyonu geriye ekrana bastÄ±rdÄ±ÄŸÄ± karakter adedini dÃ¶ndÃ¼rÃ¼r, fakat bu fonksiyondan dÃ¶nen deÄŸer Ã§oÄŸu zaman kullanÄ±lmaz, bu fonksiyon iÃ§in geriye dÃ¶nÃ¼len `int` deÄŸer eÄŸer "0"dan bÃ¼yÃ¼kse **BaÅŸarÄ±lÄ±** iÅŸlem yapÄ±ldÄ±ÄŸÄ± anlamÄ±na gelir. 

"**To discard the return value of a function**": Bu cÃ¼mle bir fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸerinin kullanÄ±lmayÄ±p gÃ¶zardÄ± edildiÄŸi durumu belirtmektedir.


AÅŸaÄŸÄ±da fonksiyonlarÄ±n geri dÃ¶nÃ¼ÅŸ deÄŸerine gÃ¶re kaÃ§ farklÄ± gruba ayrÄ±labileceÄŸi listenmiÅŸtir;
1. **Pure Functions**: Geri dÃ¶nÃ¼ÅŸ deÄŸeri varlÄ±k nedeni olan fonksiyonlar. Bu fonksiyonlar dÄ±ÅŸarÄ±daki deÄŸiÅŸkenleri deÄŸiÅŸtirmez, sadece kendi **function scope** iÃ§indeki deÄŸiÅŸkenleri kullanÄ±rlar.
2. **Test Functions**: Bir soruya **evet/hayÄ±r(true/false)** ÅŸeklinde dÃ¶nÃ¼ÅŸ yapan fonksiyonlar.
3. Ä°ÅŸ yapan ve iÅŸin baÅŸarÄ±lÄ± olup olmadÄ±ÄŸÄ± bilgisini geriye dÃ¶nen fonksiyonlar.
4. Geri dÃ¶nÃ¼ÅŸ deÄŸeri tamamlayÄ±cÄ± bilgi olan fonksiyonlar.
5. Geri dÃ¶nÃ¼ÅŸ deÄŸeri olmayan fonksiyonlar. Bu tÃ¼r fonksiyonlar geriye `void` deÄŸer dÃ¶ndÃ¼rÃ¼r, yani Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ± yere deÄŸer dÃ¶ndÃ¼rmez fakat **global variable** ile deÄŸer aktarÄ±mÄ± yapÄ±labilir.

Bir fonksiyondan geriye kaÃ§ farklÄ± ÅŸekilde deÄŸer dÃ¶ndÃ¼rÃ¼lebileceÄŸi aÅŸaÄŸÄ±da listelenmiÅŸtir;
1. Geri dÃ¶nÃ¼ÅŸ deÄŸeri(**return** kullanÄ±mÄ±yla) ile.
2. Fonksiyona adresi iletilen argÃ¼man ile(bu yÃ¶nteme **call by reference** il deÄŸer geÃ§mek deniliyor).
3. Global deÄŸiÅŸkenler ile.


â— C dilinde diÄŸer programlama dillerinde olan **Nested Function** kullanÄ±mÄ±na izin verilmemektedir, tÃ¼m fonksiyonlar **Global Space** iÃ§erisinde tanÄ±mlanmak zorundadÄ±r.

C dilinde **main** fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸeri Ã§oÄŸu zaman `int` olarak kullanÄ±lÄ±r fakat bazen `void` olduÄŸu da olur. Bir programÄ±n geri dÃ¶nÃ¼ÅŸ deÄŸeri o programÄ±n Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ± yere(iÅŸletim sisteminin komut satÄ±rÄ± vb.) programÄ±n Ã§alÄ±ÅŸmasÄ± sonlandÄ±ÄŸÄ±nda iÅŸlemin baÅŸarÄ± durumuyla ilgili bilgi vermek iÃ§in kullanÄ±lÄ±r.


Aksi bir belirleme olmadÄ±kÃ§a **main** fonksiyonunun geri dÃ¶nÃ¼ÅŸ deÄŸeri programÄ±n baÅŸarÄ±sÄ±nÄ± temsil eder. Derleyicinin oluÅŸturduÄŸu bir kod **main** fonksiyonunu Ã§aÄŸÄ±rÄ±r, **main** fonksiyonu programÄ±n Ã§alÄ±ÅŸmaya baÅŸladÄ±ÄŸÄ± fonksiyondur.
- **main** fonksiyonunun geri dÃ¶nÃ¼ÅŸ deÄŸeri programÄ±n baÅŸarÄ±sÄ±nÄ± temsil eder. 
- **main** fonksiyonunun geri dÃ¶nÃ¼ÅŸ deÄŸeri "0" ise programÄ±n Ã§alÄ±ÅŸmasÄ± sonunda programÄ±n yapmasÄ± gerektiÄŸi iÅŸi baÅŸarÄ±lÄ± ÅŸekilde yaptÄ±ÄŸÄ± anlamÄ±na gelir, diÄŸer durumlarda baÅŸarÄ±sÄ±z iÅŸlem yapÄ±ldÄ±ÄŸÄ± anlamÄ±na gelir.

ğŸš€ Bir C programÄ± derlendikten sonra oluÅŸturulan Ã§alÄ±ÅŸtÄ±rÄ±labilir dosya iÅŸletim sisteminin **shell(kabuk)** programÄ± tarafÄ±ndan Ã§alÄ±ÅŸtÄ±rÄ±labilir ve C programÄ±nÄ±n geri dÃ¶nÃ¼ÅŸ deÄŸeri **shell(kabuk)** programÄ±na dÃ¶nÃ¼lecektir, bazen bir programÄ±n Ã§alÄ±ÅŸmasÄ± bittikten sonra programÄ±n iÅŸini yapma durumunun baÅŸarÄ±lÄ±/baÅŸarÄ±sÄ±z olmasÄ±na gÃ¶re baÅŸka iÅŸlemler yapÄ±lacaksa **main** fonksiyonun geriye bir deÄŸer dÃ¶ndÃ¼rmesi Ã¶nemlidir.


ğŸ‘‡ AÅŸaÄŸÄ±daki program bir dosyayÄ± okuyup bazÄ± iÅŸlemler yapÄ±yorsa bu fonksiyonun geriye dÃ¶ndÃ¼receÄŸi deÄŸer Ã¶nemlidir, bu durum incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    FILE* f = fopen("someone.txt", "r");
    if(f == NULL){
        fprintf(stderr, "cannot open file!\n");
        return 1;
    }

    // ...

    return 0;
}
```

ğŸš€ C99 standardÄ±ndan sonra eÄŸer **main** fonksiyonunda **return** deÄŸeri kullanÄ±lmadÄ±ysa derleyiciler **main** fonksiyonun sonuna `return 0;` eklemesini yaparlar, C99 Ã¶ncesinde geriye dÃ¶nÃ¼ÅŸ deÄŸeri `int` olan **main** fonksiyonlarÄ±nÄ±n **return** deÄŸer iÃ§ermemesi derleyicilerin hata vermesine neden olacaktÄ±r.


ğŸš€ **Function Overloading(Fonksiyon YÃ¼klemesi)**: Bu tanÄ±m aynÄ± adda birden fazla fonksiyon tanÄ±mlanabilme durumunu ifade eder, fonksiyonlarÄ±n adlarÄ± aynÄ±dÄ±r ama imzalarÄ± farklÄ±dÄ±r. C dilinde "**function overloading**" yoktur. "**function overloading**" desteÄŸinin dilde olmasÄ± dilin derleyicilerinin boyutunun artmasÄ±na neden olacaktÄ±r, "**function overloading**" desteÄŸinin saÄŸlanmasÄ± derleme aÅŸamasÄ±nda fazladan iÅŸlem yapÄ±lmasÄ±na neden olacaktÄ±r, C dilini kÃ¼Ã§Ã¼k tutabilmek iÃ§in dilin "**Function Overloading**" desteÄŸi eklenmemiÅŸtir. C++ dilinde ise "**Function Overloading**" desteÄŸi vardÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki program C dilinde derlenmeye Ã§alÄ±ÅŸtÄ±rÄ±lÄ±rsa **sÃ¶zdizim hatasÄ±(syntax error)** oluÅŸacaktÄ±r(Ã§Ã¼nkÃ¼ C dilinde ) ama C++ dilinde baÅŸarÄ±lÄ± ÅŸekilde derlenecektir.
```C
#include <stdio.h>

int max(int x, int y)
{
    return x > y ? x : y;
}

double max(double x, double y)
{
    return x > y ? x : y;
}

int max(int x, int y, int z)
{
    int max_value = x;

    if(y > max_value)
        max_value = y;

    if(z > max_value)
        max_value = z;

    return max_value;
}
```

ğŸ§  C dilinde "**function overloading**" desteÄŸi doÄŸrudan yoktur ama C dilinin bazÄ± araÃ§larÄ± kullanÄ±larak bu desteÄŸe benzer bir yapÄ± oluÅŸturulabilir.


ğŸš€ C++ dilinde C dilinde olmayan "**Template**" aracÄ± vardÄ±r, "**Template**" aracÄ± ile derleyiciye kod yazdÄ±rÄ±labiliyor.


â—â—â— C++ dilinde iki tÃ¼r kodlama(kod yazma) tÃ¼rÃ¼ vardÄ±r, bunlar;
1. DÃ¼z C++ kodlarÄ± yazmak.
2. "**Function Template**" kod olarak adlandÄ±rÄ±lan derleyiciye kod yazdÄ±ran kodlama(kod yazma) tÃ¼rÃ¼, bu ÅŸekildeki programlama yaklaÅŸÄ±mÄ±na "**Generic Programming**" denilmektedir.


ğŸ‘‡ AÅŸaÄŸÄ±daki program C++ dilinde "**Template**" aracÄ± ile nasÄ±l derleyiciye en bÃ¼yÃ¼k deÄŸeri hesaplayan fonksiyonun farklÄ± tÃ¼rler iÃ§in Ã§alÄ±ÅŸabilecek ÅŸekilde "**generic programming**" kullanÄ±larak yazdÄ±rÄ±ldÄ±ÄŸÄ± incelenebilir.
```C++
// AÅŸaÄŸÄ±daki 'Function Template' programÄ±n Ã§alÄ±ÅŸma zamanÄ±nda kod yazÄ±lmasÄ±nÄ± saÄŸlamaktadÄ±r.
template <template T>
T max(T x, T y)
{
    return x > y ? x : y;
}
```



â—â—â— C dilinde Ã¼Ã§ farklÄ± ÅŸekilde "**Generic Programming**" yapÄ±labiliyor, bunlar;
1. "**Variadic Function**" yapÄ±sÄ± ile yapÄ±labilir.
2. "**Preprocessor**" aÅŸamasÄ±nda yapÄ±labilir.
3. "**Void Pointer Type**" ile yapÄ±labilir.


### C Dilinde Fonksiyon TanÄ±mlama SÃ¶zdizimi

C dilinin C89 standardÄ±ndan Ã¶nce ve sonra fonksiyon tanÄ±mlama **sÃ¶zdizimi(syntax)** birbirinden farklÄ±ydÄ±, aÅŸaÄŸÄ±da bu farklÄ±lÄ±k incelenebilir.

C dilinde iki farklÄ± fonksiyon tanÄ±mlama **sÃ¶zdizimi(syntax)** vardÄ±r, bunlar;
1. C89 standardÄ± ve sonrasÄ± fonksiyon tanÄ±mlama **sÃ¶zdizimi(syntax)**.
2. C89 standardÄ± Ã¶ncesi kullanÄ±lan "**Old-Style Function Definition**" fonksiyon tanÄ±mlama **sÃ¶zdizimi(syntax)**.

"**Old-Style Function Definition**": Eskiden kullanÄ±lan C dilinin kurallarÄ±na gÃ¶re yazÄ±lmÄ±ÅŸ C kodlarÄ±nÄ± tanÄ±mlamak iÃ§in kullanÄ±lan ifadedir.
"**Old-Style**" ÅŸekilde kod yazÄ±lmamasÄ± gerekiyor, bu tanÄ±mÄ± bilmek sadece eskiden yazÄ±lmÄ±ÅŸ C dilindeki kodlarÄ± okuyabilmek iÃ§in Ã¶nemlidir.

ğŸ‘‡ AÅŸaÄŸÄ±da `foo` adlÄ± fonksiyonun "**Old-Style Function Definition**" ile deÄŸiÅŸken tÃ¼rleri aÃ§Ä±k ÅŸekilde belirtilerek nasÄ±l tanÄ±mlandÄ±ÄŸÄ± incelenebilir.
```C
// AÅŸaÄŸÄ±daki 'foo' fonksiyonu 'Old-Style Function Definition' olarak tanÄ±mlanmÄ±ÅŸtÄ±r,
// bu kullanÄ±ma derleyiciler eski standartlarÄ± desteklemek iÃ§in izin verir ama kodlamada bu yÃ¶ntem ile kod yazÄ±lmamalÄ±dÄ±r.
double foo(a, b, c)
double a, b, c;
{
  return a * b - c;
}
```

ğŸ‘‡ AÅŸaÄŸÄ±da `foo` adlÄ± fonksiyonun "**Old-Style Function Definition**" ile "**implicit int rule(gizli int)**" kullanÄ±larak nasÄ±l tanÄ±mlandÄ±ÄŸÄ± incelenebilir.
```C
// AÅŸaÄŸÄ±daki fonksiyon tanÄ±mÄ± 'Old-Style Function Definition' olarak ifade edilir.
// Burada fonksiyonun geri dÃ¶nÃ¼ÅŸ tÃ¼rÃ¼ yazÄ±lmamÄ±ÅŸtÄ±r ve fonksiyon burada 'implicit int(gizli int)' vardÄ±r, fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸeri 'int' kabul edilir.
// Burada fonksiyonun parametrelerinin tÃ¼rleri yazÄ±lmamÄ±ÅŸtÄ±r, bu tÃ¼rler 'int' kabul edilecektir ve burada da 'implicit int(gizli int)' vardÄ±r.
foo(a, b, c)
{
  return a * b - c;
}
```

ğŸ§  C++ dilinde "**Old-Style Function Definition**" hiÃ§ bir zaman olmamÄ±ÅŸtÄ±r, bunun nedeni C++ dilinin C diline gÃ¶re daha sonradan oluÅŸturulan bir dil olmasÄ±dÄ±r.

### Fonksiyon Ã‡aÄŸrÄ±larÄ± 

Fonksiyonlara yapÄ±lan Ã§aÄŸrÄ±larÄ± "**To call a function**" ya da "**Function call**" olarak adlandÄ±rÄ±lmaktadÄ±r.

Bir fonksiyon Ã§aÄŸrÄ±sÄ± dilin kurallarÄ±na gÃ¶re bir **Expression(ifade)** olarak nitelenir, buna "**Function Call is an Expression**" denir.

**Function Call Operator**: Bir fonksiyonun Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ± yerde fonksiyonun Ã§aÄŸÄ±rÄ±lma iÅŸlemini yapan `()` operatÃ¶rÃ¼dÃ¼r.

â—â—â— C dilinde bir fonksiyon kaÃ§ adet parametre alÄ±yorsa tam olarak o kadar argÃ¼man gÃ¶nderilmesi gerekiyor, ne eksik ne de fazla argÃ¼man gÃ¶nderilmemelidir. `int foo(int a, int b, int c);` ÅŸeklinde tanÄ±mlanan bir fonksiyonu Ã§aÄŸÄ±rÄ±rken Ã¼Ã§ adet `int` tÃ¼rÃ¼nden **argument** gÃ¶nderilmesi gerekiyor, aksi durumda **sÃ¶zdizim hatasÄ±(syntax error)** oluÅŸacaktÄ±r. 

ğŸ§  Her bir **argument** **expression(ifade)** olarak adlandÄ±rÄ±lÄ±r. 


ğŸš€ DiÄŸer bir Ã§ok dilde olan **Default Argument** yapÄ±sÄ± C dilinde yoktur. **Default Argument** yapÄ±sÄ± bir fonksiyonun tanÄ±mÄ±ndaki parametrelere varsayÄ±lan bir argÃ¼man verilmesine izin verir.


â—â—â— C dilinde aÅŸaÄŸÄ±daki kullanÄ±mlar mevcut deÄŸildir yani C dili onlarÄ± desteklemez.
- "**Nested Function**" kullanÄ±mÄ± yoktur.
- "**Function Overloading**" kullanÄ±mÄ± yoktur.
- "**Default Argument**" kullanÄ±mÄ± yoktur.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `,` token'Ä±nÄ±n operator mÃ¼ yoksa seperator mÃ¼ olduÄŸu incelenebilir.
```C
void foo(int a, int b, int c);

int main(void)
{
    // AÅŸaÄŸÄ±daki statement'lardaki virgÃ¼ller 'comma seperator' olarak adlandÄ±rÄ±lmaktadÄ±r.
    int a[] = { 3, 6, 9, 12};
    int x = 1, y = 2, z = 3;
    foo(x, y, z);

    // AÅŸaÄŸÄ±daki statement'lardaki virgÃ¼ller 'comma operator' olarak adlandÄ±rÄ±lmaktadÄ±r
    x = (y, z);
    int t = ++x, ++y, ++z;
}
```



MÃ¼lakatlarda en Ã§ok sorulan sorulardan biri => `foo(a, b); // ',' separator`, `bar((a, b)) // ',' operator` kullanÄ±mlarÄ±nda `,` karakterinin **operator** mÃ¼ yoksa **separator** mÃ¼ diye sorulmasÄ±ymÄ±ÅŸ.



â—â—â— Fonksiyon Ã§aÄŸrÄ± ifadelerinde Ã¶nce fonksiyona gÃ¶nderilen argÃ¼manlarÄ±n deÄŸerleri hesaplanÄ±r ardÄ±ndan hesaplanan deÄŸerler fonksiyonun parametre deÄŸiÅŸkenlerine kopyalanÄ±r. 


ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir fonksiyona geÃ§ilecek olan argÃ¼manlarda belirtilen ifadelerin(expression) hesaplamasÄ±ndan sonra fonksiyon Ã§aÄŸrÄ±sÄ±nÄ±n yapÄ±lacaÄŸÄ± incelenebilir.
```C
int max(int a, int b)
{
    if(a > b)
        return a;

    return b;
}

int main(void)
{
    int x = 10;
    int y = 20;

    max(x + 9, y - 5); // Burada 'max' fonksiyonunun sÄ±rasÄ±yla ÅŸu argÃ¼manlar gÃ¶nderilecektir: '19, 15'.
}
```

â— Mesela `foo(a + b, x * y, c - 3);` buradaki fonksiyon Ã§aÄŸrÄ±sÄ±nda `foo` fonksiyonuna gÃ¶nderilen deÄŸerler iÃ§in matematiksel iÅŸlemler yapÄ±lÄ±r ardÄ±ndan fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±lÄ±r.  


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.30-10.50 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


Bu dersin en Ã¶nemli kurallarÄ±;
1. EÄŸer bir fonksiyon `void` fonksiyon deÄŸilse o fonksiyona yapÄ±lan Ã§aÄŸrÄ± ifadesinin deÄŸeri fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸeridir.
2. `void` fonksiyonlara yapÄ±lan Ã§aÄŸrÄ± ifadelerinin tÃ¼rÃ¼ void tÃ¼rÃ¼dÃ¼r ve deÄŸerleri yoktur. 


ğŸ‘‡ AÅŸaÄŸÄ±daki programda yapÄ±lan fonksiyon Ã§aÄŸrÄ±larÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int max(int a, int b)
{
    if(a > b)
        return a;

    return b;
}

void foo(int x)
{
    // some code here.
}

int main(void) // 'main' fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸeri 'int' olarak kabul edilir, burada 'Implicit int' kullanÄ±lmÄ±ÅŸtÄ±r ama bu tavsiye edilmez.
{
    int x = 5;
    int y = 7;
    
    max(3, 5); // 'max(3, 5)' bu bir ifadedir(expression), tÃ¼rÃ¼ 'int' ve deÄŸeri '5'tir.
    max(x + 4, y - 2); // 'max(x+ 4, y - 2)' bu bir expression ve deÄŸeri '7'dir.

    foo(5); // 'foo(5)' bu bir ifadedir(expression), tÃ¼rÃ¼ 'void' ve deÄŸeri yoktur.

    foo(5) + 5; // Burada 'foo(5)' ifadesinin deÄŸeri olmadÄ±ÄŸÄ± iÃ§in sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.

    return 1;
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda geÃ§en fonksiyon tanÄ±mlarÄ± ve yapÄ±lan fonksiyon Ã§aÄŸrÄ±larÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int ndigit(int x)
{
    if(x == 0)
        return 1;
    
    int digit_count = 0; // Buradaki deÄŸiÅŸken bildirimi kendisinden Ã¶nce statement olduÄŸu iÃ§in C89 standardÄ±nda legal deÄŸildir.

    while(x != 0){
        ++digit_count;
        x /= 10; // '/=' operatÃ¶rÃ¼ 'compound assignment operator' olarak adlandÄ±rÄ±lmaktadÄ±r.
    }

    return digit_count;
}

int gx = ndigit(3534); // Buradaki fonksiyon Ã§aÄŸrÄ±sÄ±nÄ±n bir fonksiyon dÄ±ÅŸÄ±ndan yapÄ±lmasÄ±ndan dolayÄ± sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.

int main(void) // 'main' fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸeri 'int' olarak kabul edilir, burada 'Implicit int' kullanÄ±lmÄ±ÅŸtÄ±r ama bu tavsiye edilmez.
{
    int x = 215435;
    int y = 38953;

    // Bir fonksiyondan dÃ¶necek olan geri dÃ¶nÃ¼ÅŸ deÄŸeri aÅŸaÄŸÄ±daki gibi herhangi bir ifade(expression) iÃ§erisinde kullanÄ±labilir.
    if(ndigit(x) == ndigit(y))
        printf("esit.\n");
    else
        printf("esit degil.\n");
}
```



â— Geri dÃ¶nÃ¼ÅŸ deÄŸeri olan bir fonksiyona yapÄ±lan Ã§aÄŸrÄ± ifadesi, bir ifadenin kullanÄ±ldÄ±ÄŸÄ± her yerde kullanÄ±labilir.

â—â—â— C dilinde fonksiyon Ã§aÄŸrÄ±larÄ± hiÃ§ bir zaman **Global Scope** alanÄ±nda yapÄ±lamaz.


â— Bir **fonksiyon tanÄ±mÄ±(function definition)** iÃ§inde fonksiyon tanÄ±mlanamaz, bir **fonksiyon tanÄ±mÄ±(function definition)** dÄ±ÅŸÄ±nda bir fonksiyon Ã§aÄŸÄ±rÄ±lamaz.

â— Bir fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸerini kullanmamak bir **sÃ¶zdizim hatasÄ±(syntax error)** deÄŸildir ama bu durum **logic** hataya neden olabilir(duruma gÃ¶re deÄŸiÅŸir). Bir fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸeri kullanÄ±lmayacaksa bu kodda `(void)foo();` ÅŸeklinde "**(void)**" expression ile belirtilebilir ve bu duruma "**To discard the return value**" denmektedir. "**(void)**" expression kullanÄ±mÄ±ndaki "**()**" "**Type Casting Operant**" durumundadÄ±r.


âš ï¸ AynÄ± geri dÃ¶nÃ¼ÅŸ deÄŸerini elde edecekseniz aynÄ± fonksiyonu 2., 3., 4. defa Ã§aÄŸÄ±rmayÄ±nÄ±z. Geri dÃ¶nÃ¼ÅŸ deÄŸerini bir deÄŸiÅŸkende saklayÄ±p o fonksiyonu Ã§aÄŸÄ±rmak yerine o deÄŸiÅŸkenin deÄŸeri kullanÄ±lmalÄ±dÄ±r. DiÄŸer tÃ¼rlÃ¼ kod okunurluÄŸu/takibi zorlaÅŸÄ±r, aynÄ± iÅŸlem gereksiz gere defalarca yapÄ±lÄ±yor olabilir(bu verim kaybÄ±na neden olabilir), fonksiyon **Pure Function** deÄŸilse veri kaybÄ± oluÅŸabilir. Fakat bir fonksiyon Ã§aÄŸrÄ±sÄ±ndan dÃ¶necek olan deÄŸer tek bir yerde kullanÄ±lacaksa fonksiyon dÃ¶nÃ¼ÅŸ deÄŸerini ayrÄ±ca bir deÄŸiÅŸkende tutulmasÄ±na gerek yoktur.



ğŸ‘‡ AÅŸaÄŸÄ±daki program bir fonksiyon Ã§aÄŸrÄ±sÄ±ndan dÃ¶nen deÄŸerin herhangi bir fonksiyon Ã§aÄŸrÄ±sÄ±nda argÃ¼man olarak kullanÄ±labileceÄŸini anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int max(int a, int b)
{
    if(a > b)
        return a;
   
   return b;
}

int main(void)
{
    int x,y,z,t;

    printf("4 tam sayi giriniz: ");
    scanf("%d%d%d%d", &x, &y, &z, &t);

    int result = max(max(x, y), max(z, t));

    printf("result = %d\n", result);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program **name-lookup** iÅŸleminin fonksiyon adlarÄ±nda nasÄ±l yapÄ±ldÄ±ÄŸÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int foo(int a, int b)
{
   return max(a, b); // Burada 'max' adÄ± 'name-lookup' aÅŸamasÄ±nda bulunamayacaÄŸÄ±ndan derleyici sÃ¶zdizim hatasÄ±(syntax error) verecektir.
}

int max(int a, int b)
{
    if(a > b)
        return a;
   
   return b;
}

int main(void)
{
    int* ptr1 = &foo; // Burada '&foo' ifadesi fonksiyonun adresine eriÅŸiyor ve burada hata yoktur.
    &bar; // Burada 'name-lookup' iÅŸleminde 'bar' adÄ± bulunamayacaÄŸÄ± iÃ§in sÃ¶zdizim hatasÄ±(syntax error) oluÅŸacaktÄ±r.
}

void bar(int a, int b)
{
    // statementes...
}
```



ğŸ§­ AÅŸaÄŸÄ±dakiler fonksiyonlardan dÃ¶nen deÄŸerlerin(fonksiyonlarÄ±n Ã§aÄŸrÄ± ifadelerinin kullanÄ±m ÅŸekilleri) kullanÄ±lmasÄ±yla ilgili karÅŸÄ±laÅŸÄ±lan farklÄ± durumlarÄ±n listesidir;
1. Fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸeri **discard** edilmesi durumu.
2. Fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸeri bir deÄŸiÅŸkende saklanmasÄ± durumu.
3. Fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸerinin bir operatÃ¶rÃ¼n operandÄ± olmasÄ± durumu, mesela `ndigt(x) > ndigt(y)` kullanÄ±mÄ±.
4. Fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸerinin bir fonksiyonun Ã§aÄŸrÄ±sÄ±nda argÃ¼man olacak ifade yapÄ±lmasÄ±.
5. Fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸerinin return ifadesinde kullanÄ±lmasÄ± durumu.



â— C dilinde bir fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸerinin bilerek isteyecek **discard** edildiÄŸini(geri dÃ¶nÃ¼ÅŸ deÄŸerinin kullanÄ±lmamasÄ±) belirtmek iÃ§in `(void)` kullanÄ±lÄ±r.

â— C++ dilinde `[[nodiscard]]` deÄŸeri fonksiyonlarÄ±n tanÄ±mÄ±ndan Ã¶nce kullanÄ±ldÄ±ÄŸÄ±nda derleyici ilgili fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸerinin **discard** edilmesine(geri dÃ¶nÃ¼ÅŸ deÄŸerinin kullanÄ±lmamasÄ±) izin vermeyecek ve hata verecektir, bu kullanÄ±m fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸerinin kullanÄ±lmamasÄ±nÄ±n **mantÄ±k(logic)** hataya neden olacaÄŸÄ± durumlarda tercih edilir. 
Fakat C standardÄ±nda desteÄŸi olmasa bile bazÄ± C derleyicileri `[[nodiscard]]` benzeri bir kullanÄ±mÄ± **Compiler Extension** olarak saÄŸlÄ±yor olabilir.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.01-12.11 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***

Daha sonraki derslerde "**C Standart Library**" ne demek ne iÅŸe yarÄ±yor neden var gibi sorularÄ±n cevabÄ±nÄ± verebilmek iÃ§in konu iÅŸlenecektir.



ğŸ‘‡ AÅŸaÄŸÄ±daki program [0, 100] aralÄ±ÄŸÄ±ndaki sayÄ±larÄ±n karakÃ¶k deÄŸerlerini standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶ndermektedir, bu programdaki fonksiyon Ã§aÄŸrÄ±larÄ± ve fonksiyonlara geÃ§ilen argÃ¼manlar incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <math.h>

int main(void)
{
    for(int i = 0; i < 100; ++i){
        printf("%2d %f\n", i, sqrt(i)); // Burada iki tane fonksiyon Ã§aÄŸrÄ± ifadesi vardÄ±, 'printf' fonksiyonuna Ã¼Ã§ tane argÃ¼man geÃ§iliyor.
    }
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki program `printf` fonksiyonunun dÃ¶ndÃ¼ÄŸÃ¼ deÄŸerin ne olduÄŸunu anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int n = printf("bir yazi"); // Burada 'printf' fonksiyonu geriye standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderdiÄŸi karakter sayÄ±sÄ±nÄ± dÃ¶necektir.

    printf("\nn = %d\n.", n);
}
```

## Variadic Function 

Bu konu kursun son Ã§eyreÄŸinde detaylÄ± olarak incelenecektir.

`printf()` fonksiyonu bir **variadic function**'dÄ±r ve bu ÅŸekilde birden fazla deÄŸiÅŸken sayÄ±da argÃ¼man alabilmektedir. **variadic function** olarak tanÄ±mlanan fonksiyonlar Ã¶zelliklerinden dolayÄ± birden fazla deÄŸiÅŸken sayÄ±da argÃ¼man alabilir.

**Variadic function** tanÄ±mlamasÄ±nÄ± yapabilmek iÃ§in fonksiyon tanÄ±mÄ±ndaki parametrelerinin en sonuna "**...**" **delimeter token**'Ä± eklenmesi gerekir, "**...**" **delimeter token**'Ä±na verilen ad **ellipsis** adÄ±dÄ±r. **ellipsis** tokenÄ±  bu ifade ile fonksiyon Ã§aÄŸrÄ±sÄ±nÄ±n 


C dilinde **variadic function** tanÄ±mlamak iÃ§in aÅŸaÄŸÄ±daki kurallarÄ±n saÄŸlanmasÄ± gerekiyor;
1. Dilin kurallarÄ± gereÄŸi bir fonksiyonun **variadic function** olmasÄ± iÃ§in fonksiyonun son **parameter** deÄŸiÅŸkeninin **ellipsis** adÄ±ndaki **delimeter token**'Ä±nÄ±n olmasÄ± gerekiyor.
2. Bir **variadic function** sadece bir tane **ellipsis** **delimeter token**'Ä±nÄ± parametre olarak alabilir.
3. Bir **variadic function** **ellipsis** **delimeter token**'Ä±nÄ±ndan Ã¶nce en az bir tane veri tÃ¼rÃ¼ belli parametre olmalÄ±dÄ±r.
4. Bir **variadic function** iÃ§in yapÄ±lacak bir **function call** **ellipsis** parametresinden Ã¶nceki tÃ¼m parametreler iÃ§in argÃ¼man gÃ¶nderilmesi gerekiyor.




ğŸ‘‡ AÅŸaÄŸÄ±daki program **variadic function** kullanÄ±mÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int func(int x, ...);

int main(void)
{
    // func(); // Burada sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.

    // AÅŸaÄŸÄ±daki fonskyion Ã§aÄŸrÄ±larÄ± legaldir ve bir yanlÄ±ÅŸlÄ±k yoktur.
    func(1);
    func(1, 3);
    func(1, 3, 4);
    func(1, 4, 2, 6);
    func(1, 7, 8, 8, 3, 3);
}
```


`int printf(const char*, ...);` bu **function decleration** bir **variadic function** olduÄŸu gÃ¶rÃ¼lmektedir.

`printf` fonksiyonunun adÄ±nÄ±n sonundaki "f" harfi "**Formatted**" sÃ¶zcÃ¼ÄŸÃ¼nden gelmektedir ve "**print Formatted**" olarak dÃ¼ÅŸÃ¼nÃ¼lebilir.



Standart kÃ¼tÃ¼phanenin `printf`, `scanf` fonksiyonlarÄ±na formatlÄ± deÄŸer aldÄ±ÄŸÄ± ya da formatlÄ± deÄŸer dÃ¶ndÃ¼ÄŸÃ¼ iÃ§in **Formatted Input/Output Functions** olarak adlandÄ±rÄ±lÄ±r. 
Bu fonksiyonlarÄ± anlamak iÃ§in aÅŸaÄŸÄ±dakileri iyi anlamÄ±ÅŸ olmak gerekiyor; 
1. **input/output(giriÅŸ/Ã§Ä±kÄ±ÅŸ)** ne demek.
2. **Formatted input/output(giriÅŸ/Ã§Ä±kÄ±ÅŸ)** ne demek.
3. **Unformatted input/output(giriÅŸ/Ã§Ä±kÄ±ÅŸ)** ne demek.


>â”
> 
> SorduÄŸum soru; 
> `void func(const char* value1, int value2, ...)` ÅŸeklinde bir fonksiyon tanÄ±mlayabiliyor muyuz ve bu ÅŸekilde bir tanÄ±mlama yapÄ±nca fonksiyon Ã§aÄŸrÄ±sÄ±nÄ±n yapÄ±ldÄ±ÄŸÄ± yerde ikinci argÃ¼mandan sonra girilen tÃ¼m argÃ¼manlar `int` tÃ¼rÃ¼nden olmasÄ± zorunlu mu?
> 
> Cevap;
> 
> KÄ±sa cevap evet tanÄ±mlanabiliyor.
> `void foo(const char* value1, double value2, int value3, ...)` ÅŸeklinde bir fonksiyon tanÄ±mlanabilir, fakat **ellipsis** parametresine gÃ¶nderilen deÄŸerler tamamen bu fonksiyonun Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ± yerdeki kodlamayÄ± yapan kiÅŸiye baÄŸlÄ±dÄ±r yani deÄŸerlerin doÄŸru gÃ¶nderilmelidir.


## Function Call Types 


â—â—â— AÅŸaÄŸÄ±daki terimler programlamaya Ã¶zgÃ¼(dilden baÄŸÄ±msÄ±z) terimlerdir, bu terimler Ã§ok Ã¶nemlidir;
1. **Call by Value(Pass by Value)**: Bir fonksiyona bir deÄŸiÅŸkenin deÄŸerinin geÃ§ilmesidir.
2. **Call by reference(Pass by reference)**: Bir fonksiyona bir deÄŸiÅŸkenin adresinin geÃ§ilmesidir.



ğŸ‘‡ AÅŸaÄŸÄ±daki program `foo` fonksiyonunu Ã§aÄŸÄ±rÄ±lmasÄ±nda fonksiyona gÃ¶nderilen(geÃ§ilen) argÃ¼man C dilinde **Call by Value(Pass by Value)** olarak gÃ¶nderilecektir(geÃ§ilecektir)
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

void foo(int x)
{
    x = 97794;
}

int main(void)
{
    int i = 10;

    printf("i = %d\n", i);
    foo(i);
    printf("i = %d\n", i);
}
```


â—â—â— C dilinde varsayÄ±lan olarak tÃ¼m fonksiyon Ã§aÄŸrÄ±larÄ±na geÃ§ilen argÃ¼manlarÄ±n deÄŸerleri "**Call by Value(Pass by Value)**" olarak fonksiyona gitmektedir, fakat C++ dilinde bu durum geÃ§erli olmadÄ±ÄŸÄ± durumlar vardÄ±r.

â—â—â— C dilinde bir fonksiyon Ã§aÄŸrÄ±sÄ±nÄ±n **Call by reference(Pass by reference)** olmasÄ± iÃ§in pointer'larÄ±n kullanÄ±lmasÄ± gerekiyor(bu konuya kursun ikinci yarÄ±sÄ±nda giriÅŸ yapÄ±lacak).



C mÃ¼lakatlarÄ±nda sorulan en temel soru: AÅŸaÄŸÄ±daki C kodunda ekrana ne yazÄ±lacaktÄ±r. </br>
Burada ÅŸuna dikkat edilmesi gerekiyor, `foo(i)` fonksiyonunun sadece bildirimi var **tanÄ±mlamasÄ±(gÃ¶vdesini)** yok ama biz ÅŸunu biliyoruz: "_C dilinde bir fonksiyona gÃ¶nderilen deÄŸerler varsayÄ±lan olarak **Call by Value(Pass by Value)** ve bu durumda `i` deÄŸiÅŸkeninin deÄŸerinin `foo` fonksiyonundan deÄŸiÅŸtirilmeyeceÄŸidir._". </br>
C++ dilinde cevap ÅŸudur: `foo(i)` fonksiyonunun **tanÄ±mÄ±nÄ±(gÃ¶vdesini)** gÃ¶rmemiz gerekiyor.
```C
#include <stdio.h>

void foo(int a);

main(void) // 'main' fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸeri 'int' olarak kabul edilir, burada 'Implicit int' kullanÄ±lmÄ±ÅŸtÄ±r ama bu tavsiye edilm
{
    int i = 10;

    printf("i = %d\n", i); // Ekrana 'i = 10' yazacaktÄ±r.
    foo(i); // Burada fonksiyona 'i' deÄŸiÅŸkeninin deÄŸeri gÃ¶nderiliyor.
    printf("i = %d\n", i); // Ekrana 'i = 10' yazacaktÄ±r.

    return 0;
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `foo` fonksiyon Ã§aÄŸrÄ±sÄ± **Call by reference(Pass by reference)** olarak yapÄ±lmaktadÄ±r, bu program C++ dilinde de geÃ§erlidir.
```C
#include <stdio.h>

void foo(int* p);

main(void) // 'main' fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸeri 'int' olarak kabul edilir, burada 'Implicit int' kullanÄ±lmÄ±ÅŸtÄ±r ama bu tavsiye edilm
{
    int i = 10;

    printf("i = %d\n", i); // Ekrana 'i = 10' yazacaktÄ±r.
    foo(&i); // Burada fonksiyona 'i' deÄŸiÅŸkeninin adresi gÃ¶nderiliyor.
    printf("i = %d\n", i); // Ekrana 'i = 10' yazacaktÄ±r.

    return 0;
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda  `foo` fonksiyon Ã§aÄŸrÄ±sÄ± **Call by reference(Pass by reference)** olarak yapÄ±lmaktadÄ±r, aÅŸaÄŸÄ±daki program C++ dilinde geÃ§erlidir, C dilinde geÃ§erli deÄŸildir.
```Cpp
#include <stdio.h>

void foo(int& a)
{
    a = 324325;
}

main(void) // 'main' fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸeri 'int' olarak kabul edilir, burada 'Implicit int' kullanÄ±lmÄ±ÅŸtÄ±r ama bu tavsiye edilm
{
    int i = 10;

    printf("i = %d\n", i); // Ekrana 'i = 10' yazacaktÄ±r.
    foo(i); // Burada fonksiyona 'i' deÄŸiÅŸkeninin adresi gÃ¶nderiliyor.
    printf("i = %d\n", i); // Ekrana 'i = 10' yazacaktÄ±r.

    return 0;
}
```

â—â—â— TÃ¼m programlama dilleri adres kavramÄ±nÄ± kullanmaktadÄ±r ama her programlama dili kullanÄ±m amacÄ±na gÃ¶re adres iÅŸlemlerini(pointer iÅŸlemleri) o dili kullanan programcÄ±lardan belirli seviyelerde gizleyebilir, mesela Java dilinde hiÃ§ pointer kavramÄ± yoktur, C# dilinde pointer gÃ¼vensiz iÅŸlem kapsamÄ±(scope) aÃ§Ä±larak kullanÄ±labilir. Adres kavramÄ±nÄ±n kullanÄ±lmasÄ± o dilin kullanÄ±mÄ±nÄ± donanÄ±ma yakÄ±nlaÅŸtÄ±racaktÄ±r.


Ders sonu ...
