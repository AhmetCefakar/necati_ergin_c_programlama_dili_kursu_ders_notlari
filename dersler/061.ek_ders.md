# 61.Ek Ders
---


## Bağlı Liste Veri Yapısı Gerçekleştirimi(Liked List Data Structure Implementation) 🌟

Bağlı liste veri yapısında öğeler bellekte ardışık(consecutive) değildir. Bağlı listenin her bir öğesi dinamik olarak ayrılan(allocation) bellek alanında pointer ya da pointerlarla birlikte tutulmaktadır. </br>
Bağlı liste veri yapısında tutulan her bir öğe bir ya da iki tane pointer değişken barındırır, bağlı liste veri yapısının her bir "**veri + pointer(s)**" bütününe **düğüm(node)** denilmektedir. </br>

Bağlı liste veri yapısının farklı türleri mevcuttur(bunlar dışında başka türler de var ama onlar birz özel olduğu için burada değinilmiyor);
- Singly linked list
- Doubly linked list
- Circular singly linked list
- Circular doubly linked list

Kullanıcı kod açısından bakıldığında düğümlerdeki veriler önemlidir ama farklı düğümlerin verilerine erişebilmek için düğümlerdeki pointer'lardan faydalanmak gerekmektedir.

**Tekli bağlı listede(Singly linked list)** ileriye doğru hataket edilebilir ama geriye doğru haraket edilemez. </br>
**Tekli bağlı listede(Singly linked list)** belirli bir indekse yapılacak ekleme işleminde algoritmik zaman maliyeti $O(1)$ dir. </br>
**Tekli bağlı listede(Singly linked list)** silme işlemini yaparken bir düğümün kendisini silemeyiz sadece o düğümden sonraki düğümleri silebiliriz, bunun nedeni düğümleri birbirine bağlayan pointer'ların yeni adreslerini belirlerken silinecek düğümden bir önceki düğüme erişimin olması gerekmesidir.

**Çifte bağlı listede(Doubly linked list)** silme işlemi silinecek düğümden sonraki ve önceki düğümlere erişilebildiği için **Tekli bağlı listede(Singly linked list)** daha kolaydır.

Bağlı liste veri yapısında ilk ve son düğümü tutacak göstericilere **çapa(anchor)** da denilmektedir. </br>
Bağlı liste veri yapısında ilk düğüm adresini tutan pointer **baş(head)**, son düğümün adresini tutan pointer **kuyruk(tail)** denilmektedir. </br>
**Tekli bağlı liste(Singly linked list)** veri yapısında çoğu zaman sadece sadece ilk düğümün adresini tutan pointer bulundurulur, son düğümün adresini tutan pointer bulundurulmaz. </br>
**Çifte bağlı listede(Doubly linked list)** veri yapısında çoğu zaman hem **baş(head)** hem de **kuyruk(tail)** göstericileri tutulmaktadır.



🧭 **Bağlı liste** veri yapısının faydaları ve kayıpları;
- Tek bir bellek bloğu için bellek ayrılmaktadır, bu nedenle **parçalı(fragmentation)** bir bellekte çalışırken veri yapısına yeni düğüm eklemek konusunda sıkıntı yaşanmaz. Fakat bir **dinamik dizi** veri yapısıyla **parçalı(fragmentation)** bir bellekte çalışmak daha zordur.
- **Reallocation** gibi bir maliyet yoktur, fakat bir **dinamik dizi** kullanıldığında veri yapısının boyutu arttırılacağı zaman yeni bellek bloğuna **dinamik dizinin** taşınması gerekir, bu işlem bazen büyük maliyet getirmektedir.
- Bağlı listelerde her yeni düğüm ekleme işleminde **allocation** işlem maliyeti vardır, her düğüm silme işleminde **deallocation** işlem maliyeti vardır.
- Bağlı listelerde her düğüm veri dışında bir ya da daha fazla gösterici bilgisi tutacağı için asıl veriden daha çok bellek alanı kullanılacaktır, bunun dışında her bellekten yer ayırma işlemi ayrılan bellek alanından ayrı olarak her bellekten yer ayırma işlemiyle ilgili bazı bilgilerin tutulduğu **header** kısmından kaynaklı daha fazla bellek kullanılacaktır.
- Bağlı listelerde belirli bir indekste bulunan düğüme erişmek için listenin başından itibaren tek tek düğümleri geçerek ilgili düğüme erişebiliriz, bu işlemin maliyeti ise $O(n)$ dir.


❗❗❗ Eğer yapılan işin büyük çoğunluğu indeks ile erişimse o zaman bağlı liste veri yapısının kullanılması yüksek maliyete neden olacaktır.

❗❗❗ Üzerinde çalışılan veri yapısının boyutunun belirli bir büyüklük sınırına kadar dinamik dizilerin **cache miss**/**cache hit** oranı bağlı listeye göre çok daha düşüktür, çünkü dinamik dizilerde veriler sıralıdır ama bağlı listelerde çoğunlukla sıralı olmayan bellek alanlarındadır, günümüz işlemcilerinin verimini en çok **cache miss**/**cache hit** oranı etkilemektedir.

❗❗❗ Günümüzün işlemcilerinin çoğunda olan **SIMD(Simgle Istruction Multiple Data)** yapısı işlemcinin tek bir makine komutuyla bir veri yerine birden çok veri üzerinde işlem yapabilme özelliğidir. **SIMD(Simgle Istruction Multiple Data)** özelliğinden yararlanmak için üzerinde işlem yapılan veri yapısının öğelerinin bellekte sıralı olması gerekiyor.

❗❗❗ **Dinamik dizi** veri yapısı üzerinde çalışılan veri yapısının boyutu belirli bir büyüklük sınırına gelene kadar veri yapısının adresi bilinen belirli bir indeksine yeni öğe ekleme/silme işlemleri yoğun yapıldığı durumlarda bile **dinamik dizi** veri yapısının kullanılması **bağlı liste** veri yapısının kullanılmasından daha iyidir. Şüphede kalındığında **Profiling** araçlarıyla ilgili işlemcide hangi veri yapısının daha hızlı çalıştığı incelenmelidir.


Bir veri yapısının kullanılmasının nedeni o veri yapısı üzerindeki veriler üzerinde bazı algoritmaların çalıştırılmasıdır, bundan dolayı veri yapıları ve algoritmalar birbirinden ayrı düşünülememektedir. </br>
Algoritmaların önemli bir kısmı gerçekleştirim tarafında çoğunlukla **takas(swap)** işlemi yapmaktadır, mesela bir sıralama algoritmasını bir dinamik dizi üzerinde çalıştırdığımızda her takas işleminde bellek bloklarını taşımak gerekecektir ama bir bağlı listede aynı **takas(swap)** işlemi yapmak için sadece pointer'ları değiş tokuş etmek yeterli olacaktır. </br>
**Takas(swap)** işlemi gerektiren bazı algoritmeler: Sıralama algoritmaları, ters çevirme algoritmaları, partition algoritmaları, merge algoritmaları, unique algoritması vb.


❗❗❗ Bir bağlı listede bulunan bir düğüm aynı anda aynı türden düğümlerden oluşan farklı bağlı listelerin bir düğümü olabilir, ya da bir düğüm bulunduğu bağlı listeden çıkartılıp bellekten düşürülmeden başka bir bağlı listeye eklenebilir(bu işleme **splice** adı verilmektedir, bu işlemler konum bilindiğinde $O(1)$ zaman karmaşıklığında yapılır). Çok fazla **splice** işlemi yapılıyorsa bağlı liste veri yapısının kullanımı doğru birtercih olabilir.

❗❗❗ Üretim ortamında **dinamik dizi** veri yapısı %90 civarında ve **bağlı liste** veri yapısı %10 civarında kullanılıyor diye bir oran verebiliriz, **bağlı liste** veri yapısının iyi bilinmesinin nedenlerinden biri de yazılım mülakatlarıdır ve mülakatlarda algoritma yazdırma aşamaları çoğunlukla **bağlı liste** veri yapısı üzerinden yapılmtadır.


🧠 Bağlı listelerde ekleme/silme işlemlerinde herhangi bir konuma yeni düğüm ekleme/silme işlemi yapılabildiğinden ilk düğüm yerine ve son düğüm yerine de ekleme/silme yapılabilir ve ekleme/silme bağlı liste gerçekleştirimi yaparken ekleme/silme işlemini yapacak fonksiyonun bu durumları da göz önünde bulundurarak yazmak gerekecektir. İşte bu durumların dikkate alınmasının dikkat gerektirmesinden dolayı mülakatlarda sık sorulmaktadır. </br>
🧠 Bağlı listelerde ekleme/silme işlemleri **çapa(anchor)** pointer'ları değilse yapılacak işlemler ayrı **çapa(anchor)** pointer'lar ise yapılacak işlemler ayrıdır. </br>
🧠 Bağlı listelerde silme işlemleri yaparken eğer listede tek bir düğüm varsa bu durumda da **çapa(anchor)** pointer'ların **NULL pointer** haline getirilmesi gerekir.


🧠🧠🧠 Yazılacak kütüphene ve kütüphane modüllerindeki varlıkların adları ad çakışması olmaması için ilgili kütüpheneyi niteleyen özen bir ön ek ile nitelendirilmelidir.



✍️ Burada `nlist.h` başlık dosyasını aşağıdaki gibi ekliyoruz, **çifte bağlı listede(doubly linked list)** veri yapısının gerçekleştiriminde kullanılacak olan başlık dosyasını aşağıdaki gibi yazıyoruz.
```C
#pragma once
// #ifndef NLIST_H
// #define NLIST_H

#include <stddef.h> // 'size_t' tür eş adının bildirimini içeren en hafif başlık dosyası eklendi.
#include <stdbool.h> // 'bool', 'true', 'false' gibi object-like makroları kullanabilmek için eklenmiştir.

typedef int DATATYPE; // Başlangıçta sadece 'int' türü tutan bir bağlı liste oluşturacağız.

// 'typedef struct' bildiriminde aşağıdaki gibi üç farklı yaklaşım(convension) kullanılabilmektedir.
typedef struct Node {
    DATATYPE value;
    struct Node* pprev;
    struct Node* pnext;
} Node;

// 'typedef struct' bildiriminde, tür eş adıyla yapının adı farklı verilmesi '_' karakteri ile sağlanmıştır.
// typedef struct Node_ {
//     DATATYPE value;
//     struct Node* pprev;
//     struct Node* pnext;
// } Node;

// 'typedef struct' bildiriminde, tür eş adıyla yapının adı farklı verilmesi 'tag' ön eki ile sağlanmıştır Bunu daha çok Microsoft firması tercih etmektedir.
// typedef struct tagNode {
//     DATATYPE value;
//     struct Node* pprev;
//     struct Node* pnext;
// } Node;


// List  : 'struct List' yapı türünün eş adı.
// *HList: 'struct List' yapı türünden nesnelerin adresi olan türün eş adı.
typedef struct List {
    Node* mphead;
    Node* mptail;
    size_t size; // Listenin düğüm sayısını tutacak yapı üyesi.
} List, *HList;


HList create_list(void);

// Bağlı listenin sonuna 'call by value' yöntemiyle düğüm eklemek için kullanılan fonksiyon(kopyalama maliyeti düşük olan nesneler için kullanışlı).
Node* push_back(HList hList, DATATYPE value);

// Bağlı listenin sonuna 'call by reference' yöntemiyle düğüm eklemek için kullanılan fonksiyon(kopyalama maliyeti yüksek olan nesneler için kullanışlı).
Node* push_back_ptr(HList hList, const DATATYPE* pvalue);

// Bağlı listenin başına 'call by value' yöntemiyle düğüm eklemek için kullanılan fonksiyon(kopyalama maliyeti düşük olan nesneler için kullanışlı).
Node* push_front(HList hList, DATATYPE value);

// Bağlı listenin başına 'call by reference' yöntemiyle düğüm eklemek için kullanılan fonksiyon(kopyalama maliyeti yüksek olan nesneler için kullanışlı).
Node* push_front_ptr(HList hList, const DATATYPE* pvalue);

// Bağlı listenin belirli bir konumundan bir önceki konuma 'call by value' yöntemiyle düğüm eklemek için kullanılan fonksiyon(kopyalama maliyeti düşük olan nesneler için kullanışlı).
Node* insert_prev(HList hList, Node* pnode, DATATYPE value);

// Bağlı listenin belirli bir konumundan bir önceki konuma 'call by reference' yöntemiyle düğüm eklemek için kullanılan fonksiyon(kopyalama maliyeti düşük olan nesneler için kullanışlı).
Node* insert_prev_ptr(HList hList, Node* pnode, const DATATYPE* pvalue);

// Bağlı listenin belirli bir konumundan bir sonraki konuma 'call by value' yöntemiyle düğüm eklemek için kullanılan fonksiyon(kopyalama maliyeti düşük olan nesneler için kullanışlı).
Node* insert_next(HList hList, Node* pnode, DATATYPE value);

// Bağlı listenin belirli bir konumundan bir sonraki konuma 'call by reference' yöntemiyle düğüm eklemek için kullanılan fonksiyon(kopyalama maliyeti düşük olan nesneler için kullanışlı).
Node* insert_next_ptr(HList hList, Node* pnode, const DATATYPE* pvalue);

// Bir düğümü silmek için kullanılan fonksiyon, bu fonksiyondan geriye çoğunlukla kullanılan bir konvensiyon olarak silinen düğümden sonraki düğümün adresi döndürülüyor.
Node* erase(HList hList, Node* pnode);

// Bağlı listedeki belirli bir indeksteki düğümü geriye dönen fonksiyon.
DATATYPE* get_item_idx(HList hList, size_t idx);

// Bağlı listeyi dolaşmak için kullanılan fonksiyon.
bool traverse(HList hList, bool(*fp)(DATATYPE*));
// Bağlı listeyi tersten dolaşmak için kullanılan fonksiyon.
bool rtraverse(HList hList, bool(*fp)(DATATYPE*));

// Tüm listeyi silmek için kullanılan fonksyion.
void clear_list(HList hList);

void destroy_list(HList);

// 
void pop_front(HList hlist);


// Bağlı listenin düğüm sayısını döndüren fonksiyon. 
static inline size_t get_size(HList hList)
{
    return hList->msize;
}

static inline bool is_empty(HList)
{
    // return hList->mphead == NULL;
    return hList->msize == 0;
}


// #endif
```


***
==================================================

✦✦✦✦✦ 20.50-21.11 birinci ara verildi. ✦✦✦✦✦

==================================================
***



✍️ Burada `nlist.c` kaynak dosyasını aşağıdaki gibi ekliyoruz, **çifte bağlı listede(doubly linked list)** veri yapısının gerçekleştiriminde kullanılacak olan kaynak dosyayı aşağıdaki gibi yazıyoruz.
```C
#include "nlist.h"
#include <stdlib.h> // İlk olarak 'malloc' fonksiyonunu kullanabilmek için eklendi.


// Yeni bir liste oluşturmak için kullanılan fonksiyon 
HList create_list(void)
{
    // HList hlist = (HList)malloc(sizeof(List));

    // Unix/Linux sistem programlamada aşağıdaki gibi bir yazım yöntemi tercih edilmektedir, bu yöntemde atama operatörünün ürettiği değerden faydalanılmaktadır.
    HList hlist;
    
    if((hlist = (HList)malloc(sizeof(List))) == NULL ) {
        return NULL;
    }

    hlist->mphead = hlist->mptail == NULL;
    hlist->msize = 0;

    return hlist;
}


// Bağlı listenin sonuna 'call by value' yöntemiyle düğüm eklemek için kullanılan fonksiyon(kopyalama maliyeti düşük olan nesneler için kullanışlı). 
Node* push_back(HList hList, DATATYPE value)
{
    Node* newnode;

    if((newnode = (Node*)malloc(sizeof(Node))) == NULL)
        return NULL;

    newnode->value = value; // Düğüme verisi atanıyor.

    if(hList->mphead != NULL) // Liste boş değil
        hList->mptail->pnext = newnode; // Son düğümün bir sonraki düğümü gösteren pointer'ı yeni düğümü gösterecek biçimde ayarlanması.
    else // Liste boş
        hList->mphead = newnode; // Liste boşsa eklenen yeni düğüm 'head' düğüm olarak ayarlanıyor.

    // Yeni eklenen düğüm artık en son düğüm olacağı için yeni eklenen düğümün pointer üyeleri ayarlanıyor.
    newnode->pprece = hlist->mptail;
    newnode->pnext = NULL;

    // Liste veriyapısının 'mptail' ve 'msize' verileri düzeltiliyor.
    hlist->mptail = newnode;
    ++hlist->msize;

    return newnode;
}


// Bağlı listenin sonuna 'call by reference' yöntemiyle düğüm eklemek için kullanılan fonksiyon(kopyalama maliyeti yüksek olan nesneler için kullanışlı). 
// Refactor this fuction later.
Node* push_back_ptr(HList hList, const DATATYPE* pvalue)
{
    Node* newnode;

    if((newnode = (Node*)malloc(sizeof(Node))) == NULL)
        return NULL;

    newnode->value = *pvalue; // Düğüme verisi atanıyor.
    
    if(hList->mphead != NULL) // Liste boş değilse.
        hList->mptail->pnext = newnode; // Son düğümün bir sonraki düğümü gösteren pointer'ı yeni düğümü gösterecek biçimde ayarlanması.
    else // Liste boşsa.
        hList->mphead = newnode; // Liste boşsa eklenen yeni düğüm 'head' düğüm olarak ayarlanıyor.

    // Yeni eklenen düğüm artık en son düğüm olacağı için yeni eklenen düğümün pointer üyeleri ayarlanıyor.
    newnode->pprece = hlist->mptail;
    newnode->pnext = NULL;

    // Liste veriyapısının 'mptail' ve 'msize' verileri düzeltiliyor.
    hlist->mptail = newnode;
    ++hlist->msize;

    return newnode;
}


// Bağlı listenin başına 'call by value' yöntemiyle düğüm eklemek için kullanılan fonksiyon(kopyalama maliyeti düşük olan nesneler için kullanışlı). 
Node* push_front(HList hList, DATATYPE value)
{
    // Belki sonradan yeni düğüm yaratma işlemini ayrı bir fonksiyona alabiliriz.
    Node* newnode;
    if((newnode = (Node*)malloc(sizeof(Node))) == NULL)
        return NULL;

    newnode->value = value; // Düğüme verisi atanıyor.

    // Liste nesnesindeki göstericiler ayarlanıyor.
    newnode->pnext = hList->mphead;
    newnode->pprev = NULL;

    if(hlist->mphead == NULL) // Liste boşsa.
        hlist->mptail = newnode; // Yeni eklenen düğüm listedeki tek düğüm olduğu için ilgili listenin sonraki düğümü yeni eklenen düğüm olarak ayarlanıyor.
    else // Liste boş değilse.
        hlist->mphead->pprev = newnode; // Liste boş olmadığında listenin o andaki ilk düğümü nesnesinin bir önceki düğümü gösteren göstericisi yeni eklenen düğümü gösterecek biçimde ayarlanıyor.
    
    hlist->mphead = newnode; // Listenin ilk düğümü yeni eklenen düğüm olacak biçimde düzenleme yapılıyor.
    ++hlist->msize; // Listede bulunan düğüm sayısı değeri bir arttırılıyor.

    return newnode;
}


// Bağlı listenin başına 'call by reference' yöntemiyle düğüm eklemek için kullanılan fonksiyon(kopyalama maliyeti yüksek olan nesneler için kullanışlı). 
Node* push_front_ptr(HList hList, const DATATYPE* pvalue)
{
    // Belki sonradan yeni düğüm yaratma işlemini ayrı bir fonksiyona alabiliriz.
    Node* newnode;
    if((newnode = (Node*)malloc(sizeof(Node))) == NULL)
        return NULL;

    newnode->value = *pvalue; // Düğüme verisi atanıyor.

    // Liste nesnesindeki göstericiler ayarlanıyor.
    newnode->pnext = hList->mphead;
    newnode->pprev = NULL;

    if(hlist->mphead == NULL) // Liste boşsa.
        hlist->mptail = newnode; // Yeni eklenen düğüm listedeki tek düğüm olduğu için ilgili listenin sonraki düğümü yeni eklenen düğüm olarak ayarlanıyor.
    else // Liste boş değilse.
        hlist->mphead->pprev = newnode; // Liste boş olmadığında listenin o andaki ilk düğümü nesnesinin bir önceki düğümü gösteren göstericisi yeni eklenen düğümü gösterecek biçimde ayarlanıyor.
    
    hlist->mphead = newnode; // Listenin ilk düğümü yeni eklenen düğüm olacak biçimde düzenleme yapılıyor.
    ++hlist->msize; // Listede bulunan düğüm sayısı değeri bir arttırılıyor.

    return newnode;
}


// Bağlı listenin belirli bir konumundan bir sonraki konuma 'call by value' yöntemiyle düğüm eklemek için kullanılan fonksiyon(kopyalama maliyeti düşük olan nesneler için kullanışlı). 
Node* insert_next(HList hList, Node* pnode, DATATYPE value)
{
    Node* newnode;
    if((newnode = (Node*)malloc(sizeof(Node))) == NULL)
        return NULL;

    newnode->value = value;

    // Ekleme sona yapılıp yapılmadığına göre yapılacak işlem değişecektir.
    if(pnode != hlist->mptail) // Eklenen düğüm son düğüm değilse
        pnode->pnext->pprev = newnode; // Yeni oluşturulan düğüm eklendiği yerdeki düğümün bir sonraki konumuna eklendiği için, bir sonraki konumdaki düğümün bir önceki düğümünü gösteren pointer'ın yeni eklenen düğümü göstermesi sağlanıyor.
    else // Eklenen düğüm son düğüm ise
        hlist->mptail = newnode; // Son düğümden sonraki düğüm olmadığı için listenin son düğümü yeni eklenen düğüm olarak ayarlanıyor.


    newnode->pnext = pnode->pnext; // Yeni eklenen düğümün kendinden sonraki düğümü gösteren pointer'ı ekleme yapıpan düğümün kendinden bir sonraki düğümünü gösteren pointer'ı olacak biçimde düzenleme yapılıyor.
    pnode->pnext = newnode; // Ekleme yapılan düğümün kendinden sonraki düğümü yeni eklenen düğüm olacak biçimde değişiklik yapılıyor.

    ++hlist->msize; // Listede bulunan düğüm sayısı değeri bir arttırılıyor.

    return newnode;
}


// Bağlı listenin belirli bir konumundan bir sonraki konuma 'call by reference' yöntemiyle düğüm eklemek için kullanılan fonksiyon(kopyalama maliyeti düşük olan nesneler için kullanışlı). 
Node* insert_next_ptr(HList hList, Node* pnode, const DATATYPE* pvalue)
{
    Node* newnode;
    if((newnode = (Node*)malloc(sizeof(Node))) == NULL)
        return NULL;

    newnode->value = *pvalue;

    // Ekleme sona yapılıp yapılmadığına göre yapılacak işlem değişecektir.
    if(pnode != hlist->mptail) // Ekleme işlemi yapılırken referans noktası olarak kullanılacak düğüm son düğüm değilse.
        pnode->pnext->pprev = newnode; // Yeni oluşturulan düğüm eklendiği yerdeki düğümün bir sonraki konumuna eklendiği için, bir sonraki konumdaki düğümün bir önceki düğümünü gösteren pointer'ının yeni eklenen düğümü göstermesi sağlanıyor.
    else // Ekleme işlemi yapılırken referans noktası olarak kullanılacak düğüm son düğüm ise.
        hlist->mptail = newnode; // Son düğümden sonraki düğüm olmadığı için listenin son düğümü yeni eklenen düğüm olarak ayarlanıyor.


    newnode->pnext = pnode->pnext; // Yeni eklenen düğümün kendinden sonraki düğümü gösteren pointer'ı ekleme yapılan düğümün kendinden bir sonraki düğümünü gösteren pointer'ı olacak biçimde düzenleme yapılıyor.
    pnode->pnext = newnode; // Ekleme yapılan düğümün kendinden sonraki düğümü yeni eklenen düğüm olacak biçimde değişiklik yapılıyor.

    ++hlist->msize; // Listede bulunan düğüm sayısı değeri bir arttırılıyor.

    return newnode;
}


// Bağlı listenin belirli bir konumundan bir önceki konuma 'call by value' yöntemiyle düğüm eklemek için kullanılan fonksiyon(kopyalama maliyeti düşük olan nesneler için kullanışlı). 
Node* insert_prev(HList hList, Node* pnode, DATATYPE value)
{
    Node* newnode;
    if((newnode = (Node*)malloc(sizeof(Node))) == NULL)
        return NULL;

    newnode->value = value;

    if(pnode != hList->mphead) // Ekleme işlemi yapılırken referans noktası olarak kullanılacak düğüm ilk düğüm değilse.
        pnode->pprev->pnext = newnode; // Yeni oluşturulan düğüm eklendiği yerdeki düğümün bir önceki konumuna eklendiği için, bir önceki konumdaki düğümün bir sonraki düğümünü gösteren pointer'ının yeni eklenen düğümü göstermesi sağlanıyor.
    else // Ekleme işlemi yapılırken referans noktası olarak kullanılacak düğüm ilk düğüm ise.
        hlist->mphead = newnode; // İlk düğümden önceki düğüm olmadığı için listenin ilk düğümü yeni eklenen düğüm olarak ayarlanıyor.

    newnode->pnext = pnode; // Yeni eklenen düğümün kendinden sonraki düğümü gösterdiği pointer'ı ekleme yapılan düğümün kendisini göstercek biçimde ayarlanıyor.
    newnode->pprev = pnode->pprev; // Yeni eklenen düğümün kendinden önceki düğümü gösteren pointer'ı ekleme işlemi yapılan düğümün kendinden önceki düğümü gösteren pointer'ı olacak biçimde değişiklik yapılıyor.
    pnode->pprev = newnode; // Ekleme işlemi yapılan düğümün kendinden önceki düğümü yeni eklenen düğüm olacak biçimde değişiklik yapılıyor.
    
    ++hlist->msize; // Listede bulunan düğüm sayısı değeri bir arttırılıyor.

    return newnode;
}

// Bağlı listenin belirli bir konumundan bir önceki konuma 'call by reference' yöntemiyle düğüm eklemek için kullanılan fonksiyon(kopyalama maliyeti düşük olan nesneler için kullanışlı). 
Node* insert_prev_ptr(HList hList, Node* pnode, const DATATYPE* pvalue)
{
    Node* newnode;
    if((newnode = (Node*)malloc(sizeof(Node))) == NULL)
        return NULL;

    newnode->value = *pvalue;

    if(pnode != hList->mphead) // Ekleme işlemi yapılırken referans noktası olarak kullanılacak düğüm ilk düğüm değilse.
        pnode->pprev->pnext = newnode; // Yeni oluşturulan düğüm eklendiği yerdeki düğümün bir önceki konumuna eklendiği için, bir önceki konumdaki düğümün bir sonraki düğümünü gösteren pointer'ının yeni eklenen düğümü göstermesi sağlanıyor.
    else // Ekleme işlemi yapılırken referans noktası olarak kullanılacak düğüm ilk düğüm ise.
        hlist->mphead = newnode; // İlk düğümden önceki düğüm olmadığı için listenin ilk düğümü yeni eklenen düğüm olarak ayarlanıyor.

    newnode->pnext = pnode; // Yeni eklenen düğümün kendinden sonraki düğümü gösterdiği pointer'ı ekleme yapılan düğümün kendisini göstercek biçimde ayarlanıyor.
    newnode->pprev = pnode->pprev; // Yeni eklenen düğümün kendinden önceki düğümü gösteren pointer'ı ekleme işlemi yapılan düğümün kendinden önceki düğümü gösteren pointer'ı olacak biçimde değişiklik yapılıyor.
    pnode->pprev = newnode; // Ekleme işlemi yapılan düğümün kendinden önceki düğümü yeni eklenen düğüm olacak biçimde değişiklik yapılıyor.
    
    ++hlist->msize; // Listede bulunan düğüm sayısı değeri bir arttırılıyor.

    return newnode;
}


// Bir düğümü silmek için kullanılan fonksiyon, bu fonksiyondan geriye çoğunlukla kullanılan bir konvensiyon olarak silinen düğümden sonraki düğümün adresi döndürülüyor. 
Node* erase(HList hList, Node* pnode)
{
    if(pnode == hlist->mphead) // Silinecek düğüm ilk düğüm ise.
        hlist->mphead = pnode->pnext; // Listenin ilk düğümünü gösteren pointer silinen düğümün bir sonraki düğümü olarak ayarlanıyor, burada listede tek düğüm olduğunda 'hlist->mphead' değeri 'null' olacaktır.
    else // Silinecek düğüm ilk düğüm değil ise.
        pnode->pprev->pnext = pnode->pnext; // Silinecek düğümün bir önceki düğümünün bir sonraki düğümünü gösteren pointer silinecek düğümün bir sonraki düğümü olacak biçimde değiştiriliyor.
    
    if(pnode == hlist->mptail) { // Silinecek düğüm son düğüm ise.
        hlist->mptail = pnode->pprev; // Listenin son düğümünü gösteren pointer silinen düğümün bir önceki düğümü olarak ayarlanıyor, burada listede tek düğüm olduğunda 'hlist->mptail' değeri 'null' olacaktır.
    }
    else { // Silinecek düğüm son düğüm değil ise.
        pnode->pnext->pprev = pnode->pprev; // Silinecek düğümün bir sonraki düğümünün bir önceki düğümünü gösteren pointer silinecek düğümün bir önceki düğümü olacak biçimde değiştiriliyor.
    }

    --hlist->msize; // Listede bulunan düğüm sayısı değeri bir azaltılıyor.
}

// Bağlı listedeki belirli bir indeksteki düğümü geriye dönen fonksiyon. 
DATATYPE* get_item_idx(HList hList, size_t idx)
{
    // Fonksiyona geçilen indeks değeri geçerli mi sınaması yapılıyor.
    if(idx >= hlist->msize)
        return NULL;

    Node* pnode = hlist->mphead; // listenin ilk düğümünün adres değeri 'pnode' nesnesine atanıyor.

    // Girilen indekse kadar listede dolaşılıp ilgili indekse gelindiğinde aradığımız düğümü bulmuş oluyoruz.
    for(size_t i = 0; i < idx; ++i) {
        pnode = pnode->pnext;
    }

    return &pnode->value;
}


// Bağlı listeyi dolaşmak için kullanılan fonksiyon. 
// Bu fonkisyonu anlayabilmek için 'funciton pointer' konusunun iyi bilinmesi gerekiyor.
bool traverse(HList hList, bool(*fp)(DATATYPE*))
{
    for(Node* pnode = hList->mphead; pnode != NULL; pnode = pnode->pnext)
        if(!fp(&pnode->value))
            return false;
    
    return true;
}


// Bağlı listeyi tersten dolaşmak için kullanılan fonksiyon. 
bool rtraverse(HList hList, bool(*fp)(DATATYPE*))
{
    for(Node* pnode = hList->mptail; pnode != NULL; pnode = pnode->pprev)
        if(!fp(&pnode->value))
            return false;
    
    return true;
}


// Tüm listeyi silmek için kullanılan fonksyion. 
void clear_list(HList hList)
{
    Node* pnode = hlist->mphead; // Listenin ilk düğümün adresi 'pnode' adındaki nesnesine atanıyor. 

    // Bu döngü ile listedeki tüm düğümler siliniyor.
    while(pnode != NULL) {
        Node* ptemp = pnode->pnext; // Bir sonraki düğümün adresi 'ptemp' adındaki nesneye atanıyor.
        free(pnode); // İlgili düğüm bellekten düşürülüp iade ediliyor.
        pnode = ptemp; // Yeni 'pnode' düğümü 'ptemp' olarak ayarlanıyor.
    }

    hlist->mphead = hlist->mptail = NULL; // Listenin pointer üyelerinin değerleri 'NULL pointer' olarak güncelleniyor.
    hlist->msize = 0; // Listedeki düğüm sayısı değeri '0' yapılıyor.
}


// Listeyi bellekten düşürmek için kullanılan fonksiyon. 
void destroy_list(HList hlist)
{
    clear_list(hlist); // Listeteki tüm düğümleri silmek(düğümlerin bellekleri iade edilir) için yapılan fonksiyon çağrısı.

    free(hlist); // Listenin kendi belleği iade ediliyor.
}


// Listenin başındaki ilk düğümü listeden çıkartma işlemini yapan fonksiyon. 
void pop_front(HList hlist)
{
    erase_from_list(hlist, hlist->mphead);
}
```


📌 Bazı durumlarda kod tekrar edebilir, bunun yapılmasının nedeni kodun tekilleştirilmesinin kodun kalitesini düşürüyor olması olabilir.



👇 Aşağıdaki programda yazdığımız bağlı liste modülünü sınama işlemleri için yazılmış olan ilk program incelenebilir.
```C
#include "nlist.h"
#include <stdio.h>
#include <stdlib.h> // İlk olarak 'exit' fonksiyonunu kullanmak için eklenmiştir.


bool print_item(int* p)
{
    int n;

    if((n = printf("%d ", *p)) == 0)
        return false;
    
    return true;
}


int main()
{
    HList hlist;

    if((hlist = create_list()) == NULL) {
        fprintf(stderr, "cannot create linked list!\n");
        // return 1;
        exit(EXIT_FAILURE);
    }

    printf("size = %zu\n", get_size(hlist));

    if(is_empty(hlist)) {
        printf("the list is empty!\n");
    }
    else {
        printf("the list is not empty!\n");
    }


    Node* p;

    for(int i = 0; i < 20; ++i) {
        if((p = push_back(hlist, i + 1)) == NULL) {
            fprintf(stderr, "cannot add item to the linked list!\n");
            exit(EXIT_FAILURE);
        }
    }

    printf("size = %zu\n", get_size(hlist));

    traverse(hlist, &print_item);
    clear_list(hlist);

    printf("size = %zu\n", get_size(hlist));
    if(is_empty(hlist)) {
        printf("the list is empty!\n");
    }
    else {
        printf("the list is not empty!\n");
    }

    destroy_list(hlist);
}
```



👇 Aşağıdaki programda yazdığımız bağlı liste modülünü sınama işlemleri için yazılmış olan ikinci program incelenebilir.
```C
#include "nlist.h"
#include <stdio.h>
#include <stdlib.h> // İlk olarak 'exit' fonksiyonunu kullanmak için eklenmiştir.


bool print_item(int* p)
{
    int n;

    if((n = printf("%d ", *p)) == 0)
        return false;
    
    return true;
}


int main()
{
    HList hlist;

    if((hlist = create_list()) == NULL) {
        fprintf(stderr, "cannot create linked list!\n");
        // return 1;
        exit(EXIT_FAILURE);
    }

    printf("size = %zu\n", get_size(hlist));

    if(is_empty(hlist)) {
        printf("the list is empty!\n");
    }
    else {
        printf("the list is not empty!\n");
    }


    Node* p;

    for(int i = 0; i < 20; ++i) {
        if((p = push_front(hlist, i + 1)) == NULL) {
            fprintf(stderr, "cannot add item to the linked list!\n");
            exit(EXIT_FAILURE);
        }
    }

    printf("size = %zu\n", get_size(hlist));

    traverse(hlist, &print_item);
    
    while(!is_empty(hlist)) {
        printf("value = %d, size = %zu\n", *get_item_idx(hlist, 0), get_size(hlist));
        pop_front(hlist);
        (void)getchar(); // Standart giriş akımından bir karakter girilmesi beklenecek.
    }

    destroy_list(hlist);
}
```


Ders sonu ...
