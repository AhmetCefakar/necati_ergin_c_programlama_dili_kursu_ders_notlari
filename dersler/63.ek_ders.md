# 63.Ek Ders
---


## `scanf` Fonksiyonunun Kullanımı

`scanf` fonksiyonunun kullanımını detaylı görmedik, belirli bir yere kadar bu fonksiyonu inceledik ama o seviyeden sonra bu fonksiyonun kullanım detaylarına hakimiyet kişinin C diliyle ilgili bilinç düzeyi yükseldiği için kendisine bırakılmıştır(kursta önerilen kaynak kitaplardan ve internetten bulunacak kaliteli kaynaklardan öğrenileblir).

Bu başlık altında `scanf` fonksiyonunun kullanımıyla ilgili bir iki noktaya değineceğiz.

`scanf` fonksiyonu başarılı biçimde değer ataması yapabildiği nesne sayısını geriye döndürür, eğer standart input'ta herhangi bir karakter olmadığı için başarısız olmuşsa geri dönüş değeri hada kodu olarak `EOF` değeri olur. </br>
Bu durum sadece `scanf` için değil `sscanf`, `fscanf` gibi tüm `scanf` türevi fonksiyonlar için geçerlidir. </br>
`scanf` fonksiyonunun "**Scanset**" denilen bir özelliği daha vardır, `scanf` türevi fonksiyonlar sadece belirli karakterleri kabul edecek biçimde kullanılabilir, iki farklı imkan var, biri sadece belirli karakterlere izin vermek, diğeri de belirli karakterlerin dışındaki karakterlere izin vermektir. </br>
**Formatting specifier** kullanımından önce "**Scanset**" özelliği kullanılabilir, aşağıdaki programlarda bu kullanım incelenebilir.



👇 Aşağıdaki programda önceden de bildiğimiz düz `scanf` kullanımı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    char str[100] = "";

    printf("bir yazi girin: ");
    scanf("%s", str);

    printf("[%s]\n", str);
}
```



👇 Aşağıdaki programda `scanf` fonksiyonunun sadece belirli karakterlere izin verecek biçimde **scanset** özelliğiyle birlikte kullanımı incelenebilir. </br>
Programı çalıştırıp kendin inceleme yapmalısın.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    char str[100] = "";

    printf("bir yazi girin: ");
    scanf("%[abcde ]s", str); // Burada 'scanf' fonksiyonu sadece 'abcde ' karakterlerini standart girişten okuyabilecek biçime 'scanset' özelliğiyle birlikte kullanılıyor.

    printf("[%s]\n", str);
}
```



👇 Aşağıdaki programda `scanf` fonksiyonunun sadece belirli karakterler dışındaki karakterlere izin verecek biçimde **scanset** özelliğiyle birlikte kullanımı incelenebilir. </br>
Programı çalıştırıp kendin inceleme yapmalısın.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    char str[100] = "";

    printf("bir yazi girin: ");
    scanf("%[^abcde\n]s", str); // Burada 'scanf' fonksiyonu sadece 'abcde\n' karakterleri dışındaki karakterleri standart girişten okuyabilecek biçime 'scanset' özelliğiyle birlikte kullanılıyor.

    printf("[%s]\n", str);
}
```



👇 Aşağıdaki programda `scanf` fonksiyonunun sadece sayı karakterlerine izin verecek biçimde **scanset** özelliğiyle birlikte kullanımı incelenebilir. </br>
Programı çalıştırıp kendin inceleme yapmalısın.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    char str[100] = "";

    printf("bir yazi girin: ");
    scanf("%[0123456789]s", str); // Burada 'scanf' fonksiyonu sadece sayı karakterlerini standart girişten okuyabilecek biçime 'scanset' özelliğiyle birlikte kullanılıyor.

    printf("[%s]\n", str);
}
```



👇 Aşağıdaki programda `scanf` fonksiyonunun yeni satır karakterini görene kadar olan tüm karakterleri standar input'tan okuyacak biçimde **scanset** özelliğiyle birlikte kullanımı incelenebilir. </br>
Bu kullanım ile `scanf` fonksiyonu ile sadece ilk **whitespace** karaktere kadar olan kısmı okuma özelliği değiştirilmiş olur. </br>
Programı çalıştırıp kendin inceleme yapmalısın.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    char str[100] = "";

    printf("bir yazi girin: ");
    scanf("%[^\n]s", str); // Burada 'scanf' fonksiyonu standart girişten tam bir satırı okuyacak biçimde 'scanset' özelliğiyle birlikte kullanılıyor.

    printf("[%s]\n", str);
}
```



👇 Aşağıdaki programda `scanf` fonksiyonunun okuyacağı bir türü(karakter kümesi) gözardı edecek biçimde **scanset** özelliğiyle birlikte kullanımı incelenebilir. </br>
Mesela standar girişte `12312314timur` biçiminde giriş yapıldı, yukarıdaki durumda sadece `timur` karakterleri dikkate alınacaktır. </br> 
Programı çalıştırıp kendin inceleme yapmalısın.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    char str[100] = "";

    printf("bir yazi girin: ");
    scanf("%*d%s", str); // Burada 'scanf' fonksiyonu standart input'tan gelecek ilk tam sayı bilgisini görmezden gelecek biçime 'scanset' özelliğiyle birlikte kullanılıyor.

    printf("str = (%s)\n", str);
}
```



👇 Aşağıdaki programda `scanf` fonksiyonunun okuduğu karakterlerin bazılarını görmezden gelecek biçimde **scanset** özelliğiyle birlikte kullanımı incelenebilir. </br>
Programı çalıştırıp kendin inceleme yapmalısın.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    int d, m, y;
    
    // Önceden de aşina olunan bir kullanım.
    printf("bir tarih girin: ");
    scanf("%d%d%d", &d, &m, &y); // '23 5 1854' girişimde nasıl çalıştığı incelenebilir.

    printf("%02d/%02d/%d\n", d, m, y);

    printf("\n~~~~~~~~~~~~~~\n");

    // Önceden de aşina olunmayan bir kullanım.
    printf("bir tarih girin: ");
    scanf("%d-%d-%d", &d, &m, &y); // '23-5-1854' girişimde nasıl çalıştığı incelenebilir. Burada '-' karakteri buffer'dan çıkartılacak ama dikkate alınmayacaktır.

    printf("%02d/%02d/%d\n", d, m, y);
}
```



👇 Aşağıdaki programda `scanf` fonksiyonunun okuduğu karakterlerin bazılarını görmezden gelecek biçimde(`%*c` kullanımıyla) **scanset** özelliğiyle birlikte kullanımı incelenebilir. </br>
Programı çalıştırıp kendin inceleme yapmalısın.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    int d, m, y;
    
    // Önceden de aşina olunmayan bir kullanım.
    printf("bir tarih girin: ");
    scanf("%d%*c%d%*c%d", &d, &m, &y); // '23-5|2249' girişimde nasıl çalıştığı incelenebilir. Burada '-' ve '|' karakterleri buffer'dan çıkartılacak ama dikkate alınmayacaktır.

    printf("%02d/%02d/%d\n", d, m, y);
}
```


## `printf` Fonksiyonunun Kullanımı 



👇 Aşağıdaki programda `printf` fonksiyonunun bazı kullanımları incelenebilir. </br>
Programı çalıştırıp kendin inceleme yapmalısın.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    int x = 7651;
    int w = 23;

    printf("[%d]\n", x);
    printf("[%12d]\n", x); // Burada 'yazma alanı genişliği(output-with)' değeri 12 karakter olacak biçimde sağa dayalı ayarlanmıştır.
    printf("[%-12d]\n", x); // Burada 'yazma alanı genişliği(output-with)' değeri 12 karakter olacak biçimde sola dayalı ayarlanmıştır.
    printf("[%*d]\n", w, x); // Burada 'yazma alanı genişliği(output-with)' değeri değişken olacak biçimde 'w' nesnesinin değerine bağlanarak sağa dayalı ayarlanmıştır.
    printf("[%-*d]\n", w, x); // Burada 'yazma alanı genişliği(output-with)' değeri değişken olacak biçimde 'w' nesnesinin değerine bağlanarak sola dayalı ayarlanmıştır.

}
```



👇 Aşağıdaki programda `printf` fonksiyonunun **yazma alanı genişliği(output-with)** değerinin değişken olarak nasıl faydalı biçimde kullanılabileceği incelenebilir. </br>
Programı çalıştırıp kendin inceleme yapmalısın.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main(void)
{
    for(int i = 0; i < 20; ++i) {
        printf("%*sNECATI\n", i, ""); // Burada döngünün 'i' değerine göre yazım formatının 'yazma alanı genişliği(output-with)' değerinin nasıl değişken olacak biçimde kullanımı incelenebilir.
    }
}
```


## `system` Fonksiyonunun Kullanımı 

`system` fonksiyonu `stdlib.h` başlık dosyasında bulunan geri dönüş değeri bir tam sayı olan, C standardı geri dönüş değerinin neasıl yorumlanacağı konusunda net bir şey söylemiyor ama çoğunlukla başarılı durumda "0" başarısızlık durumunda "non-zero" değer dönen bir sistem fonksiyonudur. </br>
Bu fonksiyona `NULL` değer geçilmediği sürece kendisine verilecek ilgili işletim sisteminin **CLI** komutlarını çalıştırmak için kullanılmaktadır.


👇 Aşağıdaki programda `system` fonksiyonunun kullanımı incelenebilir. </br>
Programın üzerinde çalışan sistemin komut yorumlayısının olması gerekmektedir. </br>
Programı çalıştırıp kendin inceleme yapmalısın.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>


int main(void)
{
    int system_chack = system(NULL); // Bu fonksiyona 'NULL' değer geçilirse ilgili sistemde komut yorumlayıcısının olup olmadığı öğrenilebilmektedir.

    if(system_chack) {
        printf("evet komut yorumlayicisi var!\n");

        // Windows işletim sistemi için geçerli olan CLI komutları çalıştırılacaktır.
        system("dir"); // ilgili dizini yazdıran komut.
        system("pause"); // Kullanıcıdan bir tuşa basmasını beklemek için kullanılan komut.
        system("cls"); // Ekranı silmek için kullanılan komut.
    }
    else {
        printf("hayir komut yorumlayicisi yok!\n");
    }
}
```



👇 Aşağıdaki programda `system` fonksiyonuyla kullanıcıdan alınacak CLI komutlarının çalıştırıldığı güzel bir kullanım incelenebilir. </br>
Programı çalıştırıp kendin inceleme yapmalısın.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


void clear_input_buffer(void)
{
    int c;

    while((c = getchar()) != '\n' && c != EOF)
        ; // null statement
}


int main(void)
{
    char entry[100];

    for(;;) {
        printf("enter your command > ");
        (void)scanf("%[^\n]s", entry); // '\n' harici tüm karakterler dikkate alınacak ve 'entry' nesnesine atanacak.

        if(!strcmp(entry, "finito"))
            break;

        system(entry);
        clear_input_buffer();
    }
}
```


## `#include` Önişlemci Komutu Kullanımı 

Bu başlık altında `#include` önişlemci komutunun ne olduğuyla ilgili kullanımı inceleyeceğiz.


👇 Aşağıdaki programda sıradan olarak bir iki boyutlu dizinin standart çıktı akımına gönderimi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "nutility.h"

int main(void)
{
    int ary[][4] = {
        { 1, 3, 6, 7 },
        { 1, 3, 6, 7 },
        { 1, 4, 6, 3 },
        { 1, 8, 6, 2 },
        { 1, 4, 6, 1 },
    };

    for(size_t i = 0; i < asize(ary); ++i) {
        for(int k = 0; k < 4; ++k) {
            printf("%d ",ary[i][k]);
        }
        printf(""\n);
    }
}
```



👇 Aşağıdaki programda `#include` önişlemci komutunun bir kopyala yapıştır konutu olduğu görülmelidir.
```C
/*
 
    'init.txt' dosyasını içeriği aşağıdaki gibi olsun ve bu dosya programın çalıştırıldığı dosyanınn bulunduğu dizinde bulunsun.

    { 1, 3, 6, 7 },
    { 1, 3, 6, 7 },
    { 1, 4, 6, 3 },
    { 1, 8, 6, 2 },
    { 1, 4, 6, 1 },

*/

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "nutility.h"

int main(void)
{
    int ary[][4] = {
        #include "init.txt"
    };

    for(size_t i = 0; i < asize(ary); ++i) {
        for(int k = 0; k < 4; ++k) {
            printf("%d ",ary[i][k]);
        }
        printf(""\n);
    }
}
```



## `X macro` Kullanımı 

**X** adının kullanılma nedeni bir zorunluluk değil sadece herkes bu adı tercih etmesinden kaynaklanmaktadır.



👇 Aşağıdaki programda `X macro` kullanımı incelenebilir.
```C
#include <stdio.h>

// Aşağıdaki gibi 'XCOLORS' adında bir makro kullanılarak tek bir yerden değerleri yöneterek birden çok farklı yerdeki kullanımın nasıl yönetilebileceği incelenebilir.
#define XCOLORS \
x(WHITE) \
X(GRAY) \
X(BLUE) \
X(RED) \
X(BLACK) \


// Aşağıdaki 'X macro' kullanımının nasıl açılacağını kullanılacak editör vasıtasıyla görülmesi faydalı olacaktır.
enum Color {
#define X(a) a,
    XCOLORS
#undef X
};


// Aşağıdaki 'X macro' kullanımının nasıl açılacağını kullanılacak editör vasıtasıyla görülmesi faydalı olacaktır.
#define X(a) #a,
const char *pcolors[] = { XCOLORS };
#undef X


// Aşağıdaki 'X macro' kullanımının nasıl açılacağını kullanılacak editör vasıtasıyla görülmesi faydalı olacaktır.
void foo(enum Color c)
{
#define X(a) case a:printf("%s", #a); break;
    switch (c) {
        XCOLORS
#undef X
    default: printf("invalid color.\n");
    }
}
```


## Generic Selection Aracı 

C11 standardı ile dile getirilen `_Generic` 

**Generic Selection** macro'larda kullanılan bir araç, C stanadrdı illa bu araçı macro'larda kullanılacağını söylemiyor ama çoğunlukla macro'larda kullanılıyor ve standart kütüphane de C11 standardından sonra bazı macro'larda `_Generic` kullanıyor.

👇 Aşağıdan temel 
```C
_Generic(expr,
    int : max_int,
    float: max_float,
    long: max_long,
    double: max_double,
    default: max_nec
)
```


C dilinde bir çok modern programlama dilinde olan **function overloading** aracı dilin ufak tutulması adına mevcut değildir, C dilinde tüm fonksiyonların adları farklı olmak zorundadır. </br>
C11 ile dile eklenen **Generic Selection** aracı sanki **function overloading** aracı gibi bir kullanım etkisi sağlamaktadır.



👇 Aşağıdaki programda `get_max` adında bir **Generic Selection** tanımlanmış ve bu tanım üzerinden farklı türlerde büyüklük karşılaştırmasının nasıl yapıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


#define get_max(a, b) _Generic((a), \
        int: max_int, \
        long: max_long, \
        float: max_float, \
        double: max_double \
    )(a, b)


static inline int max_int(int x, int y)
{
    return x > y ? x : y;
}

static inline long max_long(long x, long y)
{
    return x > y ? x : y;
}

static inline float max_float(float x, float y)
{
    return x > y ? x : y;
}

static inline double max_double(double x, double y)
{
    return x > y ? x : y;
}

int main(void)
{
    int max = get_max(11, 453);
    
    printf("max: %d", max);

    return 0;
}
```



👇 Aşağıdaki programda "cppreference.org" sitesindeki **Generic Selection** aracının kullanımını gösteren bir kullanım incelenebilir.
```C
#include <math.h>
#include <stdio.h>

// Possible implementation of tgmath.h macro cbrt
#define cbrt(X) _Generic((X),   \
            long double: cbrtl, \
                defoult: cbrt,  \
                  float: cbrtf  \
            )(X)

int main(void)
{
    cbrt(23.5);
    cbrt(23.5f);
}
```



👇 Aşağıdaki programda `tgmath.h` başlık dosyasındaki matematik fonksiyonların **over-loading** yapısının **Generic Selection** aracıyla oluşturulmuştur ve bu yapı incelenebilir.
```C
#include <math.h>
#include <stdio.h>
#include <tgmath.h> // Başlık dosyasının adı 'Type generic math' sözcüklerinden gelmektedir.

int main(void)
{
    // Aşağıda kullanılan 'sqrt' fonksiyonlarının hangi tür için çalışacağı 'Generic Selection' ile 'over-loading' yapısında çalışacaktır.
    printf("%f\n", sqrt(3.2F));
    printf("%lf\n", sqrt(4));
    printf("%lf", sqrt(3.2));
}
```



👇 Aşağıdaki programda **Generic Selection** aracının **conversion specifier** oluşturmak için nasıl kullanıldığı incelenebilir.
```C
#include <stdio.h>

// 'Generic Selection' bildirimi
#define printf_dec_format(x)    _Generic((x), \
    char                        : "%c", \
    signed char                 : "%hhd", \
    unsigned char               : "%hhu", \
    signed short                : "%hd", \
    unsigned short              : "%hu", \
    signed int                  : "%d", \
    unsigned int                : "%u", \
    long int                    : "%ld", \
    unsigned long int           : "%lu", \
    long long int               : "%lld", \
    unsigned long long int      : "%llu", \
    float                       : "%f", \
    double                      : "%f", \
    long double                 : "%Lf", \
    char *                      : "%s", \
    void *                      : "%p")


// Function-like macro bildirimleri
#define print(x)    printf(printf_dec_format(x), x)
#define println(x)  printf(printf_dec_format(x), x), printf("\n");

int main(void)
{
    println('b');
    println((char)'A');
    println(6868);
    println(23.531);
}
```


⭐ Sektörde tek başına C dili çok kabul görmüyor her ne kadar sadece C dilini kullanarak üretim yapan şirketler(ödeme sistemleri alanında çalışan firmalar, gömülü sistemler alanında çalışan firmalar) olsa da. </br>
Sektördeki genel beklenti C ve C++ programlama dillerinin ikisine de programcının hakim olması yönündedir, C dilini öğrenen kişilerin çoğunlukla C++ dilini de öğrenmesi gerekecektir. </br>
C++ dili çok daha büyük bir dildir, C++ dili ne kadar erken öğrenmeye başlanırsa o kadar iyi olacaktır ve kişiye o kadar çok kapı açılacaktır, C++ dilinin kullanım alanı C diline göre çok daha geniştir.


***
==================================================

✦✦✦✦✦ 20.49-21.10 birinci ara verildi. ✦✦✦✦✦

==================================================
***


## C++ içindeki C

C++ dili C dilinden büyük ölçüde farklı ayrı bir programlama dilidir. 

İki dilin ortak özellikleri
- İki dilin standardı bir comite tarafından belirlenmektedir ve bu diller bir kurum ya d abir şirketin malı değildir, tamamen o dilde uzmanlaşmış gönüllülerden oluşan kişilerin ortak olarak aldıkları kararlarla gelişen dillerdir.
- Bu dillerde geliştirme yapmak için herhangi bir kuruma ödeme yapılması gerekmemektedir.

C++ dilinin içinde bir C çekirdeği vardır(bu kısım önemlidir), C++ dilinin içindeki C dili bu kursta öğrenilen C diline oldukça benzerdir ama tamamen de aynı değildir. </br>
Bu kurs boyunca C dilini öğrendik ama aynı zamanda C++ dilini de öğrendik diyebiliriz çünkü C++ dilinin içinde bir C dili var. </br>
C++ dilinin içinde C ile ayrı programlama dili olan C dili arasında bazı uyumsuzluklar var yani kural farklılıkları var, bu kural farklılıklarını C++ dilini öğrenmeye geçişte bilmek gerekiyor. </br>

Neden C++ içindeki C ile C dili arasında farklılık var;
- C dilinde tür kontrolü zayıftır çünkü farklı farklı sistemler için kolaylıkla bir C derleyicisi oluşturulabilmesi istenmişti, ayrıca bu nedenden dolayı da C dili küçük bir dil olarak tutulmaktadır. C++ dili endüstriyel alanda kullanılan dillerin en büyüğü olduğu söylenebilie ve bundan dolayı da güçlü bir tür kontrol yapısı vardır. Her iki dil de static tür kavramına sahiptir ama C dilinde tür kontrolü gevşekken C++ dilinde tür kontrolü katıdır. Bu durum iki dilin birbirine karşı uyumsuz olmasına neden olmaktadır.
- C dilindeki kuralların C++ dilinde olan C dilinde olmayan C++ dilinin modern araçlarıyla tam olarak uyum sağlamaması, bu uyumu sağlayabilmek için bazı yerlerde kural değişikliklerine ihtiyaç olmuştur(burada tüm uyumsuzluklara değinilmedi).


C dilinin standart kütüphenesi tamamıyla C++ dilinin standart kütüphanesinin bir bileşeni, yani biz C++ kodu yazarken C++ dilinin standart kütüphenesinin bir parçası olarak bu kursta öğrendiğimiz C dilinin standart kütüphenesini bazı ufak farklılıklarla kullanabiliyoruz. </br>
Dolayısıyla C++ dilini öğrenecek kişiler sıfırdan öğreneceklerse bu kursu almaları halinde çok daha ileri bir bilgi birikimiyle C++ dilini öğrenmeye başlayacakları söylenebilir. </br>
Necati Ergin eğer C++ dili kursunu sıfırdan öğretmeye başlasaydı kursun süre 150 saat civarında daha fazla olması gerekirdi denilebilir. </br>
Bunun yanında her yeni C ve C++ standardıyla birlikte iki dil arasındaki uyumsuzluklar artmıştır, mesela **variable length array(VLA)** aracı C++ dilinde bulunmamaktadır ve C dilinde de 11 standardıyla birlikte derleyiciyi yazanlara bırakılmıştır, mesela **designated initializer** aracı C dilinde var C++ dilinde yoktur, özellikle C99 ve C11 standardıyla C diline eklenen araçların önemli bir kısmı C++ dilinde mevcut değildir. </br>
C dili küçük bir dil olmasına rağmen C dilinde olan fakat C++ dilinde olmayan araçlar mevcut, C++ dilinde olan fakat C dilinde olmayan yüzlerce araç vardır. </br>
İki dil arasındaki farklılıkların belki de en önemli kısmı programlama pradigmalarıyla ilgili. C dili aslen **procedural paradigmayı** uygulamaktadır. C dili **OOP**, **Functuonal** programlama yaklaşımlarına doğrudan destek vermemektedir. </br>
C++ dili endüstride kullanılan programlama dillerinin hemen hepsinden farklı olacak biçimde çok paradigmalı bir programlama dilidir. </br>
C++ dili şu programlama yaklaşımlarını destekler: **procedural programming**, **object oriented programming**, **functional programming**, **generic programming** gibi farklı programlama yaklaşımlarının hepsine destek vermektedir. </br>
Her yeni C++ stadardıyla birlikte dile yeni araçlar eklenmektedir ve dil çok daha büyük hale gelmektedir, bunun ne kadar iyi bir durum olduğu tartışılır. </br>
Özellikle C++ dilinin 2011 yılında yayınlanmış olan standardı C++ dilini çok değiştirmiştir, C++ dilini tarihsel gelişim sürecinde iki ayrı döneme ayırmakta fayda var, biri eski C++ denilebilecek olan 2011 standardından önceki dönem ve diğeri 2011 standardı ve sonraki dönemdir. </br>
C++ standardı böyle bir terim kullanmamasına rağmen 2011 ve sonrası C++ dili için "**Modern C++**" terimi kullanılmaktadır, 2011 ve sonrası C++ dili çok daha fazla büyük daha fazla araca sahip bir dildir. </br>
Eski C++ programcıları **modern C++** dilini öğrenmek için ciddi bir çaba sarfetmek zorundadır çünkü dile eklenen araçlar dili büyük ölçüde değiştirmiştir. </br>


C++ dili **generic programming** yaklaşımına endüstride kullanılan programlama dilleri arasında en büyük desteği veren programlama dilidir. </br>
C++ dili için **object oriented programming language** tanımlaması yanlıştır, C++ dili bu yaklaşıma destek vermektedir fakat C++ dili en fazla desteği **generic programming** yaklaşımına vermektedir. </br>
C derleyicisi yazılmış olan C kodlarını doğrudan makine koduna dönüştürmektedir, C++ derleyicilerinin kodları dönüştürme işleminin dışında bir de kod yazma özelliğine sahiptir. </br>
C++ dilinde iki ayrı kod türü vardır, biri C dilindeki gibi düz yazılan kodlar, diğeri de derleyiciye kod yazdıran kodlardır. </br>
Derleyiciye kod yazdıran kodlara **template** denilmektedir, ayrı bir sözdizim kurallarına sahip amacı derleyiciye kod yazdırmak olan kod yazabiliyoruz, böylece kodun kendisini yazmak yerine derleyiciye kod yazdıran kodu yazdığımızda mesela farklı türler için birbirine çok benzeyen ama sadece tür farkı olan fonksiyonlar yazmak yerine derleyicinin benzer fonksiyonları yazabileceği bir kod formunu oluşturup o kod formundan faraketle derleyicinin ayrı ayrı fonksiyonlar yazmasını sağlayabiliyoruz.


C++ dilindeki **template** aracı çok kullanışlı ve önemli bir araçtır, bu araç çok kullanışlı ve kullanımını öğrenmek biraz zorlayıcıdır.



👇 Aşağıdaki programda 
```C

// C dilinde aşağıdaki gibi takas işlemi yapan bir fonksiyon aşağıdaki gibi yazılabilir ama farklı türler için benzer bir işlemi yapmak istesek o türler için de aşağıdaki aynı fonksiyonun adı ve türleri farklı halini yeniden yazmak gerekecektir.
void swap(int* p1, int* p2)
{
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}
```



👇 Aşağıdaki programda dilin **template** aracının basit bir kullanımı incelenebilir.
```Cpp

template <template T>
void Swap(T* p1, T* p2)
{
    T temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}

int main()
{
    int x = 12, y= 32;

    Swap(&x, &y);

    double xd = 12, yd= 32;

    Swap(&xd, &yd);
}
```


❗❗❗ C++ dilinin standart kütüphenesinin en büyük bileşeni **STL(Standart Template Library)** dir. C++ dilinin standart kütüphenesinin kendisi de doğrudan kaynak kod dosyalarından değil kod yazdıran kodlarıdan oluşmaktadır.


C dilinde olmayan C++ dilinde bulunan bazı araçlar aşağıdaki gibidir;
- **Funciton everloading**
- **Class** türü(C++ dilindeki struct türleri de bir çeşit class türüdür. C deki struct ile C++ taki struct türü özellikleri birbirinden farklıdır)
- **Operator everloading**
- **Namespace** aracı
- **Template** aracı(bu araç kendi içinde bir çok farklı araca sahiptir)
- **Default argument** 
- **Lambda Expression**


Kurs sonu ...
