# 31.Ders 03.05.2025 ğŸ•˜

Derse 15(09:01)-17(09:08)-20(09:23)-21(09:32)-22(10:18)-23(10:39)-22(10:57)-21(11:06)-22(11:29)-20(12:11)-18(12:46)-21(13:01) kiÅŸi katÄ±ldÄ±.
---


## Typedef Declerations-1 (TÃ¼r EÅŸ AdÄ± Bildirimleri)

Bir tÃ¼rÃ¼n yerine geÃ§ecek yeni bir adÄ±n verilmesi iÃ§in **TÃ¼r eÅŸ adlarÄ±** kullanÄ±lmaktadÄ±r.

ğŸ§­ Bu konu ikiye ayrÄ±larak incelenecek;
1. **TÃ¼r eÅŸ ad** bildirimlerinin **sÃ¶zdizimi(syntax)** nasÄ±ldÄ±r.
2. **TÃ¼r eÅŸ ad** bildirimi neden yapÄ±lÄ±yor.

ğŸ“Œ Åu anda **Typedef Declerations** konusunun ilk kÄ±smÄ± iÅŸlenecek sonradan ikinci ve Ã¼Ã§Ã¼ncÃ¼ kÄ±sÄ±mlarÄ± da iÅŸlenecek.


### Typedef Declerations Sentax


â— `typedef` anahtar sÃ¶zcÃ¼ÄŸÃ¼yle yapÄ±lan bildirimlere "**Typedef Declerations**" denilmektedir ama daha fazla anlam vermek iÃ§in "**Typedef Alias Declerations**" terimi kullanÄ±lmaktadÄ±r.

AÅŸaÄŸÄ±da bazÄ± `typedef` bildirimleri incelenebilir;
- `typedef int Integer;` buradaki **tÃ¼r eÅŸ ad** bildirimi olan "**Integer**" adÄ± `int` tÃ¼rÃ¼ne eÅŸ addÄ±r.
- `typedef unsigned char Byte;` buradaki **tÃ¼r eÅŸ ad** bildirimi olan "**Byte**" adÄ± `unsigned char` tÃ¼rÃ¼ne eÅŸ addÄ±r.
- `typedef int* Iptr;` buradaki **tÃ¼r eÅŸ ad** bildirimi olan "**Iptr**" adÄ± `int*` tÃ¼rÃ¼ne eÅŸ addÄ±r.
- `typedef const int* Ciptr;` buradaki **tÃ¼r eÅŸ ad** bildirimi olan "**Ciptr**" adÄ± `const int*` tÃ¼rÃ¼ne eÅŸ addÄ±r.


â— Bir tÃ¼rÃ¼n kullanÄ±ldÄ±ÄŸÄ± her yerde **tÃ¼r eÅŸ adÄ±** da kullanmak mÃ¼mkÃ¼ndÃ¼r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda **tÃ¼r eÅŸ adÄ±** bildirimlerinin nasÄ±l yapÄ±labileceÄŸi incelenebilir.
```C
typedef int* Iptr;
typedef const int* Ciptr;

int main(void)
{
    Iptr ptr1, ptr2, ptr3; // Buradaki bildirim 'int* ptr1, * ptr2, * ptr3;' ile aynÄ± anlamdadÄ±r.
    Ciptr p1, p2, p3; // Buradaki bildirim 'const int* p1, p2, p3;' ile aynÄ± anlamdadÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program **tÃ¼r eÅŸ adÄ±** bildirimlerinin nasÄ±l yapÄ±lÄ±p nasÄ±l kullanÄ±labileceÄŸi incelenebilir.
```C
typedef int Word;
typedef Word Integer; // Bir 'typedef' buradaki gibi baÅŸka bir 'typedef' bildiriminde kullanÄ±labilir.

Word foo(Word);
Word* bar(Word*);

int main(void)
{
    Word x = 5;
    Word ar[10];
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `int` tÃ¼rÃ¼ iÃ§in Ã¼Ã§ farklÄ± `typedef` birdiriminin yapÄ±labileceÄŸi incelenebilir.
```C
typedef int Word;
typedef int Myint;
typedef int Day;

int main(void)
{

}
```



â— Her ad bildiriminin bir **kapsamÄ±(scope)** olduÄŸu gibi **tÃ¼r eÅŸ ad** bildiirmlerinin de kapsamÄ± global ya da local alanda geÃ§erli olabilir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `typedef` birdiriminin ad aramada nasÄ±l iÅŸleneceÄŸi incelenebilir, ad arama kurallarÄ± `typedef` bildirimleri iÃ§in de geÃ§erlidir.
```C
typedef unsigned char Byte;

Byte c = 0; // Global scope typedef decleration.

void foo(void)
{
    typedef unsigned char Byte2; // Local scope typedef decleration.
}

int main(void)
{

}
```


â—â—â— "**const**" anahtar sÃ¶zcÃ¼ÄŸÃ¼ bir pointer **tÃ¼r eÅŸ adÄ±** ile birlikte kullanÄ±ldÄ±ÄŸÄ±nda "**const**" olan pointer deÄŸiÅŸkenin kendisi olacaktÄ±r, yani C standardÄ±nda "**const pointer to int**" ya da C++ standardÄ±nda "**top lavel const**" olacaktÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda hem mÃ¼lakatlara girenler hem de Ã¼retimde Ã¶nemli olan ... konusuyla ilgili bilgi edinilebilir. `typedef` birdiriminin 
```C

int main(void)
{
    int x = 6;
    int y = 6;

    typedef int* iptr;
    iptr ip  = &x; // Buradaki statement ÅŸuna 'int* ip = &x;' denktir.
    
    const iptr p  = &x; // Buradaki statement ÅŸuna 'int* const p = &x;' denktir, burada beklenilenden farklÄ± olduÄŸu gÃ¶rÃ¼lecektir ve bu ayrÄ±m Ã¶nemlidir, bunu C milakatlarÄ±nda bÃ¼yÃ¼k ihtimal sorarlar ve C programlarÄ± yazarken de bu bilgi Ã¶enmlidir!

    *p = 888; // Legaldir
    p = &y; // Burada sÃ¶zdizim hatasÄ±(syntax error) alÄ±nacaktÄ±r.
}
```



â—â—â—
ğŸ‘‡ AÅŸaÄŸÄ±daki programda `typedef` birdirimi ile pointer deÄŸiÅŸkenlerin birlikte kullanÄ±mÄ±nda C standardÄ±nda "**pointer to const int**" ya da C++ standardÄ±nda "**low lavel const**" olarak kullanÄ±labileceÄŸi incelenebilir.
```C
int main(void)
{   
    typedef const int* ciptr;

    int x = 6;
    int y = 7;
    ciptr p = &x; // Buradaki statement ÅŸuna 'const int* p = &x;' denktir.

    p = &y; // Legal iÅŸlem 
    *p = 99; // Illegal iÅŸlem
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda mÃ¼lakatlarda Ã§ok sÄ±k sorulan bir soru incelenebilir. **Object like makro** ile `typedef` bildiriminin kullanÄ±mÄ±nÄ±n aralarÄ±ndaki farklarÄ±n iyi bilinmesi gerekiyor, makrolarÄ± derleyici gÃ¶rmez sadece Ã¶n iÅŸlemci program gÃ¶rÃ¼r ama `typedef` bildirimlerini sadece derleyici gÃ¶rÃ¼r, makrolarÄ±n kapsamÄ±(scope) yoktur ama `typedef` bildirimlerinin kapsamlarÄ± vardÄ±r, bu mÃ¼lakatlarda soruluyormuÅŸ.
```C
#define Word int

typedef int iptr;

int main(void)
{
    Word p1, p2, p3; // Buradaki kullanÄ±m 'iptr p1, p2, p3;' olarak yapÄ±lan 'typedef' bildirimiyle aynÄ± ÅŸey deÄŸildir, Ã§Ã¼nkÃ¼ makrolarÄ± derleyici gÃ¶rmÃ¼yor.
}
```


>â”
> 
> SorduÄŸum soru?
>
> `#define Word int` burada makrolarÄ±n tÃ¼m adlar bÃ¼yÃ¼k harf yazÄ±lma kurallarÄ±na uyulmamasÄ±nÄ±n Ã¶zel bir nedeni var mÄ±ydÄ±? 
> 
> Cevap;
> 
> Bu bir kural deÄŸil ama bu nedenle kesin olarak uyulmasÄ± gereken bir kural yok ve bu bir conversion'dur ama yine de makrolarÄ±n ne amaÃ§la kullanÄ±lÄ±rsa kullanÄ±lsÄ±n **All Caps** kullanÄ±lmasÄ± tavsiye edilir.

  

ğŸ‘‡ AÅŸaÄŸÄ±daki programda C mÃ¼lakatlarÄ±nda sorulan basit ama Ã¶nemli bir soru olan **makro** ve `typedef` kullanÄ±mlarÄ±nÄ±n arasÄ±ndaki farkÄ±n ne olacaÄŸÄ± sorusu incelenebilir.
```C
#define IPTR int*

typedef int* iptr;

int main(void)
{   
    IPTR p1, p2, p3; // Ã–n iÅŸlemci program Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda kod ÅŸuna dÃ¶nÃ¼ÅŸÃ¼r 'int* p1, p2, p3;' bu da sadece 'p1' deÄŸiÅŸkeninin pointer deÄŸiÅŸken olduÄŸu anlamÄ±na gelir.
    iptr p4, p5, p6; // Derleyici bu kodu ÅŸu ÅŸekilde gÃ¶recektir 'int* p4, * p5, * p6;' bu da sadece 'p3, p4, p5' deÄŸiÅŸkenlerinin pointer deÄŸiÅŸken olduÄŸu anlamÄ±na gelir.
}
```


### Neden `typedef` Bildirimi YapÄ±lÄ±r? 

Bu sorunun cevabÄ± tek deÄŸildir birden fazla nedeni olabilir, bu nedenleri inceleyelim.

#### Varolan Bir TÃ¼rÃ¼ Daha DaraltÄ±lmÄ±ÅŸ Bir BaÄŸlamda KullanÄ±ldÄ±ÄŸÄ±nÄ± Vurgulamak Ä°Ã§in `typedef` KullanÄ±labilir

Bazen bir tÃ¼rÃ¼n ne iÃ§in kullanÄ±ldÄ±ÄŸÄ±nÄ± kodu okuyana anlatabilmek yani kodun okunurluÄŸunu arttÄ±rmak iÃ§in `typedef` bildirimi kullanÄ±labilir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `double` tÃ¼rÃ¼nÃ¼n `typedef` bildirimi ile nasÄ±l bir parabirimi deÄŸiÅŸkeni olarak kullanÄ±labileceÄŸi incelenebilir.
```C
typedef double Dollar;
typedef double Euro;
typedef double Pound;

int main(void)
{   
    
}
```

ğŸ‘‡ AÅŸaÄŸÄ±daki programda `kilogram` **tÃ¼r eÅŸ adÄ±** `double` tÃ¼rÃ¼nÃ¼n dar kapsamda kullanÄ±ldÄ±ÄŸÄ±nÄ± vurgulamak iÃ§in kullanÄ±lmÄ±ÅŸtÄ±ÅŸ.
```C
typedef double kilogram;

int main(void)
{   
    kilogram = 4.65; // Kodu okuyana 'typedef' adÄ± Ã¼zerinden ilgili 
}
```


#### Ã–zel Bir AmaÃ§ Ä°Ã§in BirÃ§ok Yerde KullanÄ±lan TÃ¼rlerin TÃ¼rÃ¼ DeÄŸiÅŸtirilmesi GerektiÄŸinde KolaylÄ±k SaÄŸlanmasÄ± Ä°Ã§in `typedef` KullanÄ±labilir 


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `weight_t` adlÄ± `typedef` bildirimi ile programda bir Ã§ok yerde `weight_t` kullanÄ±ldÄ±ÄŸÄ±nda `float` tÃ¼rÃ¼nden `double` tÃ¼rÃ¼ne geÃ§iÅŸ yapÄ±lmak istendiÄŸinde bu iÅŸlemin kolayca yapÄ±labildiÄŸi anlaÅŸÄ±lmalÄ±dÄ±r. 
```C
typedef float weight_t;

int main(void)
{   
    weight_t = 4.65; // Kodu okuyana 'typedef' adÄ± Ã¼zerinden ilgili 
}
```

ğŸ§  `typedef` varlÄ±klarÄ± adlandÄ±rÄ±rken C ve C++ dillerinde yaygÄ±n olarak bu varlÄ±klarÄ±n adlarÄ±nÄ±n sonuna "**_t**" getirilir.

ğŸ§  `typedef` bildirimleri hata Ã§ok baÅŸlÄ±k dosyalarÄ±nda yapÄ±lmaktadÄ±r.


##### DÃ¶ngÃ¼lerde KullanÄ±lan SayaÃ§ DeÄŸiÅŸkenlerin TÃ¼rleri Ä°Ã§in KullanÄ±labilir 

Mesela programda bir Ã§ok yerde dÃ¶ngÃ¼lerde kullanÄ±lan sayaÃ§ deÄŸiÅŸkenlerinin tÃ¼rÃ¼ `int` ise ve bu tÃ¼rÃ¼n deÄŸiÅŸtirilmesi gerektiÄŸi durumlarda `typedef` bildiriminin kullanÄ±lmasÄ± kolaylÄ±k saÄŸlayacaktÄ±r.

DÃ¶ngÃ¼lerdeki sayaÃ§ deÄŸiÅŸkenlerinin `int` tÃ¼rÃ¼ mÃ¼ yoksa `unsigned int` tÃ¼rÃ¼ olmasÄ± Ã§ok tartÄ±ÅŸÄ±lan bir konuymuÅŸ, bu derste daha detaylÄ± bahsedileceÄŸi belirtildi.

Mesela bildirimi `typedef int counter_t;` ÅŸeklinde olan bir tÃ¼r eÅŸ adÄ±nÄ±n tÃ¼rÃ¼ sonradan `typedef long long counter_t;` olacak ÅŸekilde kolayca deÄŸiÅŸtirilebilir, bu da tek bir deÄŸiÅŸiklikle tÃ¼m dÃ¶ngÃ¼lerdeki sayaÃ§ deÄŸiÅŸkenlerinin tÃ¼rlerinin deÄŸiÅŸtirilebileceÄŸi anlamÄ±na geliyor.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bazÄ± deÄŸiÅŸken bildirimlerinin tÃ¼rleri incelenebilir.
```C
typedef float weight_t;

int main(void)
{   
    int x; // Burada bildirilen deÄŸiÅŸkenin tÃ¼rÃ¼ 'int'
    int* p = &x; // Burada bildirilen deÄŸiÅŸkenin tÃ¼rÃ¼ 'int*'
    const int* cp = &x; // Burada bildirilen deÄŸiÅŸkenin tÃ¼rÃ¼ 'const int*'
    int a[5]; // Burada bildirilen deÄŸiÅŸkenin tÃ¼rÃ¼ 'int[5]'

    // AÅŸaÄŸÄ±daki tÃ¼r bildirimini henÃ¼z kursta gÃ¶rmedik.
    int (*p)[10]; // Burada bildirilen deÄŸiÅŸkenin tÃ¼rÃ¼ 'int*[10]'
}
```


#### Bildirimleri karmaÅŸÄ±k olan TÃ¼r Bildirimlerini BasitleÅŸtirmek iÃ§in "Typedef Declerations" KullanÄ±lÄ±r 

C dilinde bildirimleri karmaÅŸÄ±k olan tÃ¼rleri kullanmak yerine bunlarÄ± `typedef` olarak bildirerek programÄ±n daha rahat okunup anlaÅŸÄ±lmasÄ± saÄŸlanabilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda karmaÅŸÄ±k deÄŸiÅŸken ya da fonksiyon bildirimleri incelenebilir, bu bildirimler C dilinde olaÄŸan olarak karÅŸÄ±laÅŸÄ±labilecek kullanÄ±mlardÄ±r.
```C
void foo(char* (*fp)(const char*, const char*)); // Burada 'foo' ve 'fp' birer identifier tÃ¼rÃ¼nden varlÄ±ktÄ±r.
void bar(char* (*fp1)(const char*, const char*), char* (*fp2))(const char*, const char*)); // Burada 'bar', 'fp1' ve 'fp2' birer identifier tÃ¼rÃ¼nden varlÄ±ktÄ±r.
char* (*baz(char* (*fp)(const char*, const char*)))(const char*, const char*); // Burada 'baz' ve 'fp' birer identifier tÃ¼rÃ¼nden varlÄ±ktÄ±r.

int main(void)
{
    char* (*fp))(const char*, const char*); // Buradaki 'fp' adÄ±nda deÄŸiÅŸken bildirimi yapÄ±lÄ±yor, 'fp' dÄ±ÅŸÄ±nda kalan tÃ¼m varlÄ±klara 'declerator' denilebilir. Bu tÃ¼r deÄŸiÅŸkenlere 'function pointer' denilmektedir.
    char* (*fpa[10]))(const char*, const char*); // Buradaki 'fpa' deÄŸiÅŸkeni 'fp' adÄ±ndaki varlÄ±klardan oluÅŸan dizidir. Bu tÃ¼r deÄŸiÅŸkenlere 'function pointer array' denilmektedir.
    char* (**fptr))(const char*, const char*) = &fp; // Buradaki 'fptr' deÄŸiÅŸkeni . Bu tÃ¼r deÄŸiÅŸkenlere 'Pointer to function pointer' denilmektedir.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda yukarÄ±daki programda bildirimleri yapÄ±lmÄ±ÅŸ olan karmaÅŸÄ±k bildirimlerin `typedef` kullanÄ±mÄ±yla nasÄ±l sadeleÅŸtirilebileceÄŸi incelenebilir.
```C
typedef char* (*fptr)(const char*, const char*); // Burada sadece 'fptr' identifier tÃ¼rÃ¼nden varlÄ±ktÄ±r.

void foo(fptr); // Burada sadece 'foo' identifier tÃ¼rÃ¼nden varlÄ±ktÄ±r.
void bar(fptr, fptr); // Burada sadece 'bar' identifier tÃ¼rÃ¼nden varlÄ±ktÄ±r.
fptr baz(fptr); // Burada sadece 'baz' identifier tÃ¼rÃ¼nden varlÄ±ktÄ±r.

int main(void)
{   
    //char* (*fp)(const char*, const char*); // Burada 'fp' adÄ±nda deÄŸiÅŸken bildirimi yapÄ±lÄ±yor.
    fptr fp;

    //char* (*fpa[10]))(const char*, const char*); // 'function pointer array'
    fptr fpa = fpa[10];

    //char* (**fptr))(const char*, const char*) = &fp; // 'Pointer to function pointer'
    fptr* fpp = &fp;
}
```


â—TÃ¼r eÅŸ ad bildirimlerinin karmaÅŸÄ±k bildirimlerde kullanÄ±lÄ±ÅŸÄ±nÄ± Necati Ergin "**KarmaÅŸÄ±k bildirimleri indirgemek**" olarak tanÄ±mlÄ±yormuÅŸ.



ğŸ§­ Bir tÃ¼re eÅŸ ad vermek istiyorum ancak "`typedef`" bildirimini nasÄ±l yapacaÄŸÄ±m konusunda kafam karÄ±ÅŸÄ±k;
1. Hangi tÃ¼re eÅŸ adÄ± verilecekse o tÃ¼rden bir deÄŸiÅŸken tanÄ±mlanÄ±r.
2. En baÅŸa "`typedef`" anahtar sÃ¶zcÃ¼ÄŸÃ¼ eklenir.
3. DeÄŸiÅŸken adÄ± yerine seÃ§ilen **tÃ¼r eÅŸ ad**'Ä± yazÄ±lÄ±r.


ğŸ§­ AÅŸaÄŸÄ±da adÄ±m adÄ±m `int` tÃ¼rÃ¼nden bir deÄŸiÅŸkenin nasÄ±l `Word` adÄ±nda **tÃ¼r eÅŸ ad** olarak bildirileceÄŸi incelenebilir;
1. `int x;`
2. `typedef int x;`
3. `typedef int Word;`



ğŸ§­ AÅŸaÄŸÄ±da adÄ±m adÄ±m `int*` tÃ¼rÃ¼nden bir deÄŸiÅŸkenin nasÄ±l `iptr` adÄ±nda **tÃ¼r eÅŸ ad** olarak bildirileceÄŸi incelenebilir;
1. `int* x;`
2. `typedef int* x;`
3. `typedef int* iptr;`



ğŸ§­ AÅŸaÄŸÄ±da adÄ±m adÄ±m `int[10]` tÃ¼rÃ¼nden bir deÄŸiÅŸkenin nasÄ±l `intary10` adÄ±nda **tÃ¼r eÅŸ ad** olarak bildirileceÄŸi incelenebilir;
1. `int ary[10];`
2. `typedef int ary[10];`
3. `typedef int intary10[10];`


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `int ary[10];` bildiriminin nasÄ±l `typedef` anahtar sÃ¶zcÃ¼ÄŸÃ¼ ile kullanÄ±labileceÄŸi incelenebilir.
```C
int main(void)
{
    typedef int intary10[10];

    intary10 a, b, c; // Buradaki bildirim ÅŸuna denktir 'int a[10], b[10], c[10]'
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `int (*fp)(int);` ÅŸeklindeki "**function pointer**" deÄŸiÅŸken bildiriminin nasÄ±l **tÃ¼r eÅŸ ad** olarak bildirilebileceÄŸi incelenebilir.
```C
int main(void)
{
    // int (*fp)(int); // 1.adÄ±m
    // typedef int (*fp)(int); // 2.adÄ±m
    typedef int (*FPTR)(int); // 3.adÄ±m
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir **tÃ¼r eÅŸ adÄ±nÄ±n** baÅŸka declerator'lerle birlikte kullanÄ±labileceÄŸi incelenebilir.
```C
int main(void)
{ 
    typedef int Woord;
    Woord* ptr;  
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda elemanlarÄ± **function pointer** olan on elemanlÄ± bir dizi deÄŸiÅŸkeninin **tÃ¼r eÅŸ ad** olarak nasÄ±l bildirildiÄŸi incelenebilir.
```C
int main(void)
{
    typedef int (*FPTR)(int); // Buradaki 'FPTR' adÄ± bir 'function pointer' adÄ±nÄ±n tÃ¼r eÅŸ adÄ±dÄ±r.
    FPTR a[10]; // Buradaki 'a' dizisi elemanlarÄ± 'function pointer' olan on elemanlÄ± dizidir.
}
```


#### FarklÄ± Derleyiciler KullanÄ±ldÄ±ÄŸÄ±nda Basit(Primitive) TÃ¼rlerin Byte BoyutlarÄ± aynÄ± olmasÄ± Ä°Ã§in KullanÄ±lÄ±r 

â— Bundan Ã¶nce anlatÄ±lanlar bir yana ÅŸimdi ifade edilecekler **tÃ¼r eÅŸ ad** kullanÄ±m nenedeni bir yana yani bu kullanÄ±m nedeni diÄŸerlerinden daha Ã¶nemlidir.

â­ Standart kÃ¼tÃ¼phenenin kullandÄ±ÄŸÄ± tÃ¼r eÅŸ adlarÄ±ndan bazÄ±larÄ±;
- `size_t` en Ã§ok kullanÄ±lan `typedef` bildirimidir, bu nedenle diÄŸer `typedef` bildirimlerinden Ã¶zel bir yeri vardÄ±r.
- `time_t` 
- `ptrdiff_t`
- `ldiv_t`
- `fpost_t`
- `int16_t`
- `uint16_t`



â—â—â— TÃ¼r eÅŸ adlarÄ± neden var diye sorulursa ÅŸu dÃ¼ÅŸÃ¼nÃ¼lmelidir: C dili standardÄ±nÄ±n bir gerÃ§eÄŸi olarak var ilkel tÃ¼rlerin bellek boyutlarÄ±nÄ±n kaÃ§ byte olacaÄŸÄ± derleyicilere bÄ±rakÄ±lmÄ±ÅŸtÄ±r(her derleyici iÃ§in bit tÃ¼rÃ¼n boyutu farklÄ± olabilir, bunun nedeni C dilinin farklÄ± donanÄ±mlara destek veren program yazÄ±labilmesine izin verme amacÄ±dÄ±r).

â—â—â— TÃ¼r eÅŸ adlarÄ± kullanÄ±ldÄ±ÄŸÄ±nda, yazÄ±lan bir C programÄ±nÄ±n farklÄ± derleyiciler arasÄ±nda taÅŸÄ±nabilirliÄŸi kolaylaÅŸmaktadÄ±r.

ğŸ“Œ ÃœÃ§Ã¼ncÃ¼ taraf firmalarÄ±n yazdÄ±ÄŸÄ± C kÃ¼tÃ¼phenelerinde de **tÃ¼r eÅŸ adlarÄ±** sÄ±klÄ±kla kullanÄ±lmaktadÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda standart C fonksiyonun olan "strlen" fonksiyonunun geri dÃ¶nÃ¼ÅŸ deÄŸeri `size_t` tÃ¼r eÅŸ adÄ±dÄ±r ve hangi tÃ¼re karÅŸÄ±lÄ±k geleceÄŸi bilgisi derleyiciyi yazanlara bÄ±rakÄ±lmÄ±ÅŸtÄ±r bu ÅŸekilde `size_t` tÃ¼r eÅŸ adÄ± bazÄ± derleyicilerde "**unsinged int**" tÃ¼rÃ¼nde olabilir bazÄ± erleyicilerde "**unsinged long**" tÃ¼rÃ¼nde olabilir, bu ÅŸekilde derleyiciyi yazanlara esneklik tanÄ±nmÄ±ÅŸtÄ±r.
```C
#include <string.h>

size_t strlen(const char* _Str); // 'string.h' dosyasÄ±ndaki standart C fonksiyonudur.

int main(void)
{
    strlen(); // Buradaki C tandart fonksiyonu geri dÃ¶nÃ¼ÅŸ tÃ¼rÃ¼ 
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda kullanÄ±lan `time_t` tÃ¼r eÅŸ adÄ±nÄ±n(ki bu ad bir tarihten sonra geÃ§miÅŸ olan saniye sayÄ±sÄ±nÄ± tutmaktadÄ±r) hangi tÃ¼re karÅŸÄ±lÄ±k geleceÄŸi derleyiciyi yazanlara bÄ±rakÄ±lmÄ±ÅŸtÄ±r, bazen `long` bazen `long long` tÃ¼rÃ¼nÃ¼n eÅŸ adÄ±dÄ±r.
```C
#include <time.h>

time_t time(time_t*); // 'time.h' dosyasÄ±ndaki standart C fonksiyonudur.

int main(void)
{

}
```


### `size_t` TÃ¼r EÅŸ AdÄ± 

`size_t` adÄ± "**size type**" sÃ¶zcÃ¼klerinden gelmektedir.

C standardÄ±nda `size_t` tÃ¼rÃ¼nÃ¼n iÅŸaretsiz bir tam sayÄ± tÃ¼rÃ¼nÃ¼n(en kÃ¼Ã§Ã¼n `unsigned int` olmasÄ±na izin veriliyor) eÅŸ adÄ± olacaÄŸÄ±nÄ± belirtilmiÅŸtir ama bunun kararÄ±nÄ± derleyicileri yazanlara bÄ±rakmÄ±ÅŸtÄ±r.



ğŸ§­ C standard kÃ¼tÃ¼phanesi nerelerde `size_t` tÃ¼rÃ¼nÃ¼ kullanÄ±yor(bu bir kural deÄŸildir sadece standardÄ±n nasÄ±l kullandÄ±ÄŸÄ± durumudur)?
1. YazÄ± uzunluÄŸunu tutmak iÃ§in kullanÄ±lÄ±r.
2. Tane, adet gibi deÄŸiÅŸkenleri tutmak iÃ§in kullanÄ±lÄ±r.
3. Dizilerin eleman sayÄ±sÄ± deÄŸerini tutacak olan deÄŸiÅŸkenlerin tÃ¼rÃ¼ olarak kullanÄ±lÄ±r.
4. `sizeof` deÄŸeri, `sizeof` operatÃ¶rÃ¼nÃ¼n Ã¼rettiÄŸi deÄŸerin tÃ¼rÃ¼ `size_t` tÃ¼rÃ¼dÃ¼r.
5. Daha Ã§ok C++ dilinde kullanÄ±m ÅŸekli dizi indeksi tÃ¼rÃ¼ olarak kullanmaktÄ±r.

â— `sizeof` operatÃ¶rÃ¼nÃ¼n Ã¼rettiÄŸi deÄŸerin tÃ¼rÃ¼ `size_t` tÃ¼rÃ¼dÃ¼r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `size_t` tÃ¼r eÅŸ adÄ±nÄ±n kullanÄ±mlarÄ± incelenebilir. Sadece `size_t` tÃ¼rÃ¼ kullanÄ±lmak isteniyorsa o zaman en hafif olan "stddef.h" baÅŸlÄ±k dosyasÄ± eklenebilir, bir Ã§ok baÅŸlÄ±k dosyasÄ± "stddef.h" baÅŸlÄ±k dosyasÄ±nÄ± kullanmaktadÄ±r.
```C
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    stdlen(); // YazÄ± uzunluÄŸunu dÃ¶ndÃ¼ren fonksiyon.
    malloc(); // 
    qsort(); // Dizi sÄ±ralamak iÃ§in kullanÄ±lan fonksiyon.
}
```


### `ptrdiff_t` TÃ¼r EÅŸ AdÄ± 

`ptrdiff_t` tÃ¼r eÅŸ adÄ± "**Pointer Different Type**" ifadesinden gelmektedir ve bu tÃ¼r eÅŸ adÄ± pointer aritmetiÄŸi uygulanan fonksiyonlarda da kullanÄ±lmaktadÄ±r. Ä°ki adresin farkÄ± iÅŸaretli tam sayÄ± tÃ¼rÃ¼dÃ¼r ve `ptrdiff_t` tÃ¼r eÅŸ adÄ± da iÅŸaretli bir tam sayÄ±nÄ±n eÅŸ adÄ±dÄ±r.


### `int8_t` `int16_t` `int32_t` `int64_t` `uint8_t` `uint16_t` `uint32_t` `uint64_t` vb. TÃ¼r EÅŸ Ä°simleri 

Bu tÃ¼r eÅŸ adlar, gÃ¶mÃ¼lÃ¼ sistemlerde Ã§alÄ±ÅŸan yazÄ±lÄ±mcÄ±larÄ±n sÄ±klÄ±kla kullandÄ±klarÄ± tÃ¼rlerdir. 


â—â—â— Bu tÃ¼r eÅŸ adlarÄ± C99 standardÄ±yla dile eklenen `stdint.h` baÅŸlÄ±k dosyasÄ±nda bulunmaktadÄ±r ve bu tÃ¼rler opsiyonel olarak C99 standardÄ± ile dile eklenmiÅŸtir yani her C derleyicisinde bu tÃ¼ reÅŸ adlarÄ± olmak zorunda deÄŸildir bunun nedeni: Bizim `byte` dediÄŸimiz C standardÄ±nÄ±n `char` dediÄŸi birimin 8 bit olmak zorunda olmamasÄ±dÄ±r mesela bazÄ± donanÄ±mlarda bu temel birim 8 bit yerine 12 bit olabilir(bu sistemler Ã§ok az olduÄŸu iÃ§in bunlara ezoterik sistemler denilmektedir) bu durumda da 32 bit bu donanÄ±mlarda bir ÅŸey ifade etmeyecektir, eÄŸer `byte` uzunluÄŸu 12 bit ise bu donanÄ±mda `int_12, int_24, int_48` gibi tÃ¼r eÅŸ adlarÄ±nÄ±n bir anlamÄ± olacaktÄ±r.


### `int_least8_t` `int_least16_t` `int_least32_t` `uint_least8_t` `uint_least16_t` `uint_least32_t` vb. TÃ¼r EÅŸ AdlarÄ± 

`int_leastx_t` ile biten tÃ¼r eÅŸ adlarÄ± C standardÄ± tarafÄ±ndan zorunlu olarak belirlenmiÅŸtir, her derleyici bu tÃ¼r eÅŸ adlarÄ±nÄ± desteklemek zorundadÄ±r.

â—â—â— ProgramcÄ±lar `int8_t` ve `int_least8_t` vb. tÃ¼rleri arasÄ±ndaki farklarÄ± genelde anlamamaktadÄ±r, mesela bu `int8_t` tÃ¼rÃ¼ ezoterik donanÄ±mlarÄ±n derleyicilerinde anlamsÄ±zdÄ±r bu nedenle C standardÄ± bu tÃ¼r eÅŸ adlarÄ±nÄ± zorunlu tutmamÄ±ÅŸtÄ±r. Mesela bir byte birimi 12 bit olan bir ezoterin derleyicide `int_least8_t` tÃ¼r eÅŸ adÄ± o sistemin 12 bitlik biriminin deÄŸiÅŸkenine karÅŸÄ±lÄ±k gelecektir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda opsiyonel olan ve opsiyonel olmayan tÃ¼r eÅŸ adlarÄ±yla yapÄ±lan deÄŸiÅŸken bildirimleri gÃ¶rÃ¼lebilir.
```C
#include <stdint.h>

int main(void)
{
    int16_t x; // Opsiyonel
    int_least16_t y; // Opsiyonel deÄŸildir her derleyicide C99 standardÄ± sonrasÄ±nda olmasÄ± zorunludur.
}
```


>â”
> 
> Sorulan soru? 
> 
> Farkli derleyicilerde `stdint.h` dosyasinin farklÄ± olmasÄ± gerekir, deÄŸil mi?
> 
> Cevap;
> 
> Evet ve bu sadece `stdint.h` baÅŸlÄ±k dosyasÄ±yla sÄ±nÄ±rlÄ± deÄŸil C dilinin standardÄ±nÄ±n tÃ¼m baÅŸlÄ±k dosyalarÄ± iÃ§in geÃ§erlidir yani her derleyici bu dosyalardaki fonksiyonlarÄ±n gerÃ§ekleÅŸtirmesini farklÄ± yolla yazmaktadÄ±r.



***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.57-11.16 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


>â”
> 
> Sorulan soru? 
>
> BaÅŸlÄ±k dosyalarÄ±nda `::` operatÃ¶rÃ¼ gÃ¶rdÃ¼m c de var mÄ± bu durum?
> 
> Cevap;
> 
> BazÄ± baÅŸlÄ±k dosyalarÄ± hem C hem de C++ dilinde kullanÄ±lmak iÃ§in oluÅŸturulduÄŸu iÃ§in `::` tokenÄ± olan "**scope resolution operator**" kullanÄ±lan yerlerde C++ dilinin kullanÄ±lacaÄŸÄ± iÃ§in eklendiÄŸi anlaÅŸÄ±lacaktÄ±r.


### `int_fast8_t` `int_fast16_t` `int_fast32_t` `uint_fast8_t` `uint_fast16_t` `uint_fast32_t` vb. TÃ¼r EÅŸ AdlarÄ± 

`_fastx_t` ile biten tÃ¼r eÅŸ adlarÄ± C standardÄ± tarafÄ±ndan zorunlu olarak belirlenmiÅŸtir, her derleyici bu tÃ¼r eÅŸ adlarÄ±nÄ± desteklmek zorundadÄ±r.

â—â—â— `int_fast32_t` bu tÃ¼r eÅŸ adÄ± 32 bitlik tam sayÄ± iÅŸleminin en hÄ±zlÄ± yapÄ±ldÄ±ÄŸÄ± tÃ¼r anlamÄ±na gelmektedir, bu donanÄ±mla ilgili, bazÄ± donanÄ±mlarda bazÄ± iÅŸlemler bazÄ± tÃ¼rlerde daha hÄ±zlÄ± yapÄ±lmaktadÄ±r ve bu durumdan dolayÄ± `type_fast_t` ile biten tÃ¼r eÅŸ adlarÄ± dilin standardÄ±nda mevcuttur.



âœï¸ `nutility` dosyalarÄ±nda `print_array` ve `set_array_random` fonksiyonlarÄ±nÄ±n `int` tÃ¼rleri `size_t` tÃ¼r eÅŸ adÄ±na dÃ¶nÃ¼ÅŸtÃ¼rÃ¼ldÃ¼.
```C
// 'nutility.h' dosyasÄ±na aÅŸaÄŸÄ±daki 'fuction decleration'larÄ±n 'int size' olan parametre bildirimi 'size_t size' olarak deÄŸiÅŸtirildi.

#include <stddef.h> // Buradaki baÅŸlÄ±k dosyasÄ±nÄ± 'size_t' tÃ¼r eÅŸ adÄ±nÄ± tanÄ±tmak iÃ§in ekliyoruz.

void print_array(const int* p, size_t size);
void set_array_random(int* p, size_t size);
```

```C
// 'nutility.c' dosyasÄ±na aÅŸaÄŸÄ±daki 'fuction definition'larÄ±n 'int size' olan parametre bildirimi 'size_t size' olarak deÄŸiÅŸtirildi.

void print_array(const int* p, size_t size)
{
    for(size_t i = 0; i < size; ++i){
        // dongu degiskeni 0 degilse ve 20'nin kati olan dongu adimindaysa yeni satirdan devam edilsin diye 'if statement' yazildi.
        if(i && i % 20 == 0){
            printf("\n");
        }

        // dizinin ilgili adimdaki elemani Ã¼Ã§ birimlik alana formatli yazdirilacak.
        printf("%3d ", p[i]);
    }
    
    putline();
}

void set_array_random(int* p, size_t size)
{
    while(size--)
        *p++ = rand() % 1000;

    /* ikinci versiyon
    while(size--){
        *p = rand() % 1000;
        ++p;
    }
    */

    /* Ä°lk versiyon
    for(int i = 0; i < size; ++i){
        p[i] = rand() % 1000;
    }
    */
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program `get_array_min` fonksiyonunun gÃ¶vdesinde kullanÄ±lan dÃ¶ngÃ¼nÃ¼n sayaÃ§ deÄŸiÅŸkeninin neden `size_t` tÃ¼rÃ¼nden yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#include <stddef.h>
#include <time.h>
#include <stddin.h>

int* get_array_min(const int* p, size_t size)
{
    int *pmin = *p;

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼de dizinin sayazÄ±nÄ±n tÃ¼rÃ¼ 'int' yerine 'size_t' yapÄ±ldÄ± bunun nedeni 'size_t' tÃ¼rÃ¼nÃ¼n iÅŸaratsiz tam sayÄ± tÃ¼rÃ¼ olmasÄ± ve 'int' sayaÃ§ deÄŸiÅŸkeni ile iÅŸleme girince derleyicinin vereceÄŸi uyarÄ±yÄ± almamaktÄ±r.
    for(size_t i = 1; i < size; ++i){
        if(p[i] < *pmin)
            *pmin = (int*)(p + i);
    }

    returm pmin;
}
```


## `string.h` Standar KÃ¼tÃ¼phanesi 

`string.h` baÅŸlÄ±k dosyasÄ±ndaki bir kaÃ§ fonksiyon hariÃ§ tÃ¼m fonksiyonlar string dizilerle ilgili iÅŸlemler yapan fonksiyonlardÄ±r, .

ğŸ§­ `string.h` kÃ¼tÃ¼phanesinin ilk Ã¶ÄŸrenilecek olan fonksiyonlarÄ± aÅŸaÄŸÄ±dakilerdir;
- `strlen`: Bu fonkaiyonun adÄ± "**string lenght**" sÃ¶zcÃ¼klerinden gelir ve kendisine pointer olarak iletilen bir yazÄ±nÄ±n uzunluÄŸunu geriye dÃ¶ndÃ¼rÃ¼r.
- `strchr`
- `strcpy`
- `strrchr`
- `strstr`
- `strpbrk`
- `strspn`
- `strcspn`
- `strcmp`: Bu fonkaiyonun adÄ± "**string compare**" sÃ¶zcÃ¼klerinden gelir ve iki yazÄ±yÄ± karÅŸÄ±laÅŸtÄ±rmak iÃ§in kullanÄ±lÄ±r.
- `strtok`
- `strerr`


â—â—â— C dili diÄŸer diller gibi olmadÄ±ÄŸÄ± iÃ§in C dilinin standart C fonksiyonlarÄ±nÄ±n en az %70 kadarÄ±nÄ±n ne olduklarÄ± ve ne iÃ§in kullanÄ±ldÄ±klarÄ± iyi bilinmelidir.

â—â—â— Temel ilke olarak bir iÅŸi yapacak bir fonksiyon gerektiÄŸinde bu iÅŸi yapabilecek standart C fonksiyonu varsa Ã§ok Ã§ok Ã¶zel bir durum yoksa C dilinin standart fonksiyonlarÄ±nÄ±n kullanÄ±lmasÄ± tercih edilmelidir.



**Intrinsic Function**: Derleyiciler bazÄ± standart C fonksiyonlarÄ±nÄ± **Intrinsic Function** olarak tanÄ±mlamaktadÄ±r, bu da o fonksiyonlara yapÄ±lan Ã§aÄŸrÄ±larÄ±n daha verimli olarak ele alÄ±nmasÄ±nÄ± saÄŸlamaktadÄ±r, bu konu ileride bir derste daha detaylÄ± olarak incelenecektir.


**SIMD(Single Instruction Multiple Data)**: Ä°ÅŸlemcinin tek bir komutuyla birden Ã§ok komutun Ã§alÄ±ÅŸtÄ±ÄŸÄ± komutlardÄ±r. Bu tÃ¼re ait olan makine komutlarÄ± her iÅŸlemcide olmayabilir.


>â”
> 
> Sorulan soru; 
> 
> Ã–ÄŸretmenim mÃ¼fredatta concurrency olacak mi C icin?
> 
> Cevap;
> 
> Bu kursta olmayacak bunun iki nedeni var;
> 1. Concurrency araÃ§larÄ± C dilinin C17 standardÄ±na kadar standart olmadÄ±ÄŸÄ± iÃ§in, C17 standardÄ±na kadar concurrency iÃ§in Ã¼Ã§Ã¼ncÃ¼ taraf kÃ¼tÃ¼phaneler kullanÄ±larak yapÄ±lmaktaydÄ±(Linux/Unix sistemlerinde **pthreads** kÃ¼tÃ¼phenesi concurrency iÃ§in kullanÄ±lÄ±yor). **Ä°leri C ve sistem programlama** kursunda concurrency konularÄ± ve araÃ§larÄ± anlatÄ±lÄ±yormuÅŸ.


>â”
> 
> Sorulan soru; 
>
> Hangisine niye devam etmeliyiz aslinda kafam karisiyor, ileri C mi yoksa c++ olarak mi devam etmeliyiz?
> 
> Cevap;
> 
> **Ä°leri C ve sistem programlama** kursunun amacÄ± C dilini kullanarak ileri seviye konularÄ± ve sistem programlamayla ilgili kavramlarÄ± Ã¶ÄŸrenmektir, C++ kursunun amacÄ± C++ dilinin Ã¶ÄŸrenilmesidir ama C++ dilini Ã¶ÄŸrenirken Ã¼st seviye programlama kavramlarÄ± da anlatÄ±lmaktadÄ±r, C++ dili 200 saat ama C kursunda anlatÄ±lan hiÃ§birÅŸey o kursta anlatÄ±lmadÄ±ÄŸÄ± iÃ§in o kurs 200 saattir diÄŸer tÃ¼rlÃ¼ daha fazla olmasÄ± gerekirdi.
> Yani kÄ±saca her kes kendi ihtiyacÄ±na gÃ¶re nereden devam edeceÄŸine karar vermelidir.



**Generic Programing**: Kod yazan kodlar kullanÄ±larak yapÄ±lan programlama yaklaÅŸÄ±mÄ±na verilen addÄ±r. C++ dilinde bunu yapmak iÃ§in araÃ§lar mevcut.

ğŸ“Œ C derleryicisi sadece yazÄ±lan kodu derlerken C++ derleyicisi programcÄ± iÃ§in kod da yazmaktadÄ±r.


>â”
> 
> Sorulan soru; 
> 
> BildiÄŸim kadarÄ±yla oop yi en hÄ±zlÄ± kullanan dil c++ o yÃ¼zden Ã§ok geniÅŸ alanÄ± var diye biliyorum.
> 
> Cevap;
> 
> Bu saptama tam doÄŸru deÄŸil. Birinci yanlÄ±ÅŸlÄ±k C++ dilinin OOP bir dil olduÄŸunu dÃ¼ÅŸÃ¼nmek, C++ **multi pradigm** bir dildir, functional programing, generic programing, procedural programing yaklaÅŸÄ±mÄ±nÄ± desteklemektedir.
> C++ dilinin Ã§ok kullanÄ±lmasÄ±nÄ±n nedeni hÄ±z kritik bir dil olmasÄ±dÄ±r ve bir Ã§ok aracÄ±nÄ±n olmasÄ± ama bunun eleÅŸtirilen tarafÄ± ise dilin Ã§ok bÃ¼yÃ¼k olmasÄ±nÄ±n dilde uzmanlaÅŸmayÄ± zorlaÅŸtÄ±rmasÄ±dÄ±r.


>â”
> 
> Sorulan soru; 
> 
> Ã–ÄŸretmenim C yi bu kadar detayli Ã¶grenince de kullanmamak ya da sadece C++ icindekiyle sinirli kalmak biraz atil gibi olacak burada Ã¶grendiklerimiz
> 
> Cevap;
> 
> Bu kÄ±smen doÄŸru ama gÃ¶mÃ¼lÃ¼ yazÄ±lÄ±mda hem C hem de C++ dili kullanÄ±lÄ±yor. Sadece C dilinin kullanÄ±ldÄ±ÄŸÄ± yazÄ±lÄ±mlar da mevcut ama onlar C dilinin Ã¶zelliÄŸinden dolayÄ± donanÄ±mla doÄŸrudan iliÅŸki kurulmasÄ± gereken **OS cernals**, **drivers** vb. yazÄ±lÄ±mlarda kullanÄ±lÄ±yor.


>â”
> 
> Sorulan soru; 
> 
> Ã–ÄŸretmenim malesef geÃ§miÅŸte yanlÄ±ÅŸ Ã¶ÄŸrenen birisiyim bize oop altÄ±nda generic gÃ¶sterdiler o yÃ¼zden oop nin bir alt dalÄ± gibi gÃ¶stediler, c++ ben hep c with classes olarak gÃ¶rdÃ¼m.
> 
> Cevap;
> 
> Bunu ben bÃ¶yle yazÄ±yorum: Ä°ÅŸ bilmeyenden Ã¶ÄŸrenilince malesef Ã¶yle oluyor. C dilini Ã¶ÄŸrendikten sonra C++ dilini yarÄ±m yamalak Ã¶ÄŸrenip kod yazan kiÅŸiler de Ã§ok eleÅŸtiriliyormuÅŸ.


>â”
> [Ahmet Furkan DaÄŸlÄ±]
> 
> Sorulan soru; 
> 
> Ben bu c dilini Ã¶ÄŸrendikten sonra direk **stm32 cube Ä±de** kursuna gidicem ilerde muhtemelen c++ alÄ±cam, hedefim gÃ¶mÃ¼lÃ¼ yazÄ±lÄ±m mÃ¼hendisliÄŸi olmak
> 
> Cevap;
> 
> Herkesin kiÅŸisel durumuna baÄŸlÄ± bir durum ama yurtdÄ±ÅŸÄ± iÅŸlerde Ã§alÄ±ÅŸmak isteniyorsa gÃ¶mÃ¼lÃ¼ yazÄ±lÄ±mlarda da C++ dili yoÄŸun olarak kullanÄ±ldÄ±ÄŸÄ± iÃ§in C++ dilinin Ã¶ÄŸrenilmesi doÄŸru olabilir.



ğŸ§­ `string.h` Standard KÃ¼tÃ¼phanesinin aÅŸaÄŸÄ±daki fonksiyonlarÄ±nÄ±(bunlar sadece beÅŸ tanedir) doÄŸrudan yazÄ±larla ilgili olmayan fonksiyonlardÄ±r, bu beÅŸ fonksiyonu "**void pointers**" konusunu iÅŸledikten sonra detaylÄ± olarak Ã¶ÄŸreneceÄŸiz, ÅŸu anda bu fonksiyonlarÄ±n C dilinde **generic programing** uygulanabilmesini saÄŸlamak iÃ§in kullanÄ±ldÄ±ÄŸÄ± bilinmelidir.
- `memchr`
- `memset`
- `memcmp`
- `memcpy`
- `memmove`


### YazÄ±yla Ä°lgili Ä°ÅŸlem Yapan Fonksiyonlar 

**NULL Terminated Byte Streams** olan yazÄ±lar son karakteri `\0` olan yazÄ±lardÄ±r. 

ğŸ§­ AÅŸaÄŸÄ±daki fonksiyonlarÄ±n hepsi **NULL terminated byte streams** olan yazÄ±lar Ã¼zerinde iÅŸlem yapÄ±ldÄ±ÄŸÄ± varsayÄ±larak yazÄ±lmÄ±ÅŸtÄ±r;
- `strlen`
- `strchr`
- `strcpy`
- `strrchr`
- `strstr`
- `strpbrk`
- `strspn`
- `strcspn`
- `strcmp`
- `strtok`
- `strerr`


#### `puts` Fonksiyonu


`puts` fonksiyonu standart Ã§Ä±kÄ±ÅŸ akÄ±mÄ±na kendisine gÃ¶nderilen yazÄ±nÄ±n satÄ±r sonu karakterini(`'\n'`) gÃ¶rene kadar tÃ¼m karakterleri gÃ¶nderir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda standard `puts` fonksiyonunun `Puts` adÄ±yla gerÃ§ekleÅŸtirimi(implemantation) incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

#define SIZE 100

void Puts(const char* p)
{
    while(*p)
        putchar(*p++);

    putchar('\n');
}

int main(void)
{
    char str[] = "ad soyad";

    puts(str);
    Puts(str);
}
```


#### `gets` Fonksiyonu


`gets` fonksiyonu standart giriÅŸ akÄ±mÄ±ndan satÄ±r sonu karakterini(`'\n'`) gÃ¶rene kadar tÃ¼m karakterleri okumak iÃ§in kullanÄ±lÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda standard `gets` fonksiyonunun `Gets` adÄ±yla gerÃ§ekleÅŸtirimi(implemantation) incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

#define SIZE 100

// AÅŸaÄŸÄ±daki fonksiyon C99 ile dilin standard kÃ¼tÃ¼phanesinden Ã§Ä±kartÄ±lan "gets" fonksiyonunun yaptÄ±ÄŸÄ± iÃ§i yapmaktadÄ±r, bu fonksiyonun sorunu dizi taÅŸmasÄ± sonucunda oluÅŸan 'ub' durumunu engelleyecek bir yapÄ±sÄ±nÄ±n olmamasÄ±dÄ±r.
void Gets(char* p)
{
    int ch;

    while((ch = getchar()) != '\n')
        *p++ = (char)ch;

    *p = '\0';
}

int main(void)
{
    char str[SIZE];

    printf("bir yazi giriniz: ");
    Gets(str); // Standart giriÅŸ akÄ±mÄ±ndan kullanÄ±cÄ±nÄ±n girdiÄŸi yazÄ±nÄ±n alÄ±nmasÄ±nÄ± saÄŸlayan fonksiyon. Dizi taÅŸmasÄ± durumunun sorumluluÄŸu Ã§aÄŸÄ±ran koddadÄ±r.
    puts(str); // KullanÄ±cÄ±nÄ±n giriÅŸ yaptÄ±ÄŸÄ± yazÄ±nÄ±n yazdÄ±rÄ±lmasÄ± iÅŸlemini yapan 'puts' fonksiyonuna Ã§aÄŸrÄ± yapÄ±lÄ±yor.
}
```



â—â—â— Ben yazÄ±larla ilgili bir fonksiyon oluÅŸturmak istiyorum, yazacaÄŸÄ±m fonksiyon adresini aldÄ±ÄŸÄ± bir diziye, yazÄ± yerleÅŸtirecek ya da o adresteki yazÄ±yÄ± deÄŸiÅŸtirecek(yazÄ±nÄ±n dizi uzunluÄŸunu arttÄ±rabilir) </br>
Benim fonksiyonum dizinin boyutunu alsÄ±n mÄ± almasÄ±n mÄ±? </br>
Bu tÃ¼r fonksiyonlarda iki durum vardÄ±r;
1. Standart C fonksiyonlarÄ±n yÃ¶ntemi dizi boyutunu almamaktÄ±r. Dizi boyutu alÄ±nmÄ±yorsa daha hÄ±zlÄ± Ã§alÄ±ÅŸacaktÄ±r ama taÅŸma sorumluluÄŸu fonksiyonu Ã§aÄŸÄ±ran koda devredilir.
2. Dizi boyutunu isteyen fonksiyonlar.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.11-12.21 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


#### `strlen` Fonksiyonu 

`strlen` fonksiyonu kendisine gÃ¶nderilen yazÄ±nÄ±n uzunluk bilgisini `size_t` tÃ¼rÃ¼nden geriye dÃ¶ner. "strlen" adÄ± "string lenght" sÃ¶zcÃ¼klerinden gelmektedir.


ğŸ‘‡ AÅŸaÄŸÄ±daki program `strlen` fonksiyonunun bir yazÄ±nÄ±n uzunluÄŸunu dÃ¶ndÃ¼rmek iÃ§in nasÄ±l kullanÄ±ldÄ±ÄŸÄ±nÄ± anlamak iÃ§in incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

size_t strlen(const char* p);

#define SIZE 100

int main(void)
{
    char str[SIZE];

    printf("bir yazi girin: ");
    sgets(str);

    size_t len = strlen(s);

    primtf("uzunluk = %zu\n", len);
}
```

â—â—â— C99 standardÄ±nda `%zu` **conversion specifier(format dÃ¶nÃ¼ÅŸtÃ¼rÃ¼cÃ¼sÃ¼)** dile eklenmiÅŸtir ve bu ÅŸekilde kullanÄ±lan **tÃ¼r eÅŸ adlarÄ±nÄ±n** tÃ¼rlerinin ne olduÄŸunun doÄŸrudan aÃ§Ä±k ÅŸekilde **conversion specifier(format dÃ¶nÃ¼ÅŸtÃ¼rÃ¼cÃ¼sÃ¼)** olarak belirtilmesine gerek olmadan yazÄ±m kolaylÄ±ÄŸÄ± saÄŸlanmÄ±ÅŸtÄ±r, `%zu` olmasaydÄ± kullanÄ±lan derleyicide 'size_t' tÃ¼r eÅŸ adÄ± iÃ§in belirlenen tÃ¼rÃ¼n **conversion specifier(format dÃ¶nÃ¼ÅŸtÃ¼rÃ¼cÃ¼sÃ¼)** deÄŸerinin aÃ§Ä±k ÅŸekilde yazÄ±lmasÄ± gerekecekti.


>â”
> 
> Sorulan soru; 
> 
> Konu ile alakalÄ± bir sorum var,
> AnÄ±l adÄ±nda bir string dizisine atamak istesem,
> string dizisinin size en az 5 olmalÄ± diye Ã¶ÄŸrendim,
> string dizisinin derleyiciye bittiÄŸini gÃ¶steren '\0' bu karakteri koymasÄ± iÃ§in dediler doÄŸru mu Ã¶ÄŸrenmiÅŸim hocam?
> 
> Cevap;
> 
> Bu soru belirtilen konular Ã¶nceki derslerde detaylÄ± olarak iÅŸlenmiÅŸtir, Ã¶nceki derlere bakÄ±labilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda parametre olarak aldÄ±ÄŸÄ± bir yazÄ±yÄ± ters Ã§eviren `rputs` adlÄ± fonksiyonun nasÄ±l yazÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE 100

size_t strlen(const char* p);

void rputs(const char* p)
{
    for(int i = (int)strlen(p) - 1; i >= 0; --i)
        putchar(p[i]);
    printf('\n');
}

int main(void)
{
    char str[SIZE];

    printf("bir yazi giriniz: ");
    sgets(str);

    puts(str);
    rputs(str);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `puts` fonksiyonuyla pointer aritmetiÄŸini kullanrak nasÄ±l bir yazÄ±nÄ±n tamamÄ±ndan sadece en son karakterini yazdÄ±racak ÅŸekilde bir dÃ¶ngÃ¼ kullanÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <string.h>

#define SIZE 100

int main(void)
{
    char str[SIZE];

    printf("bir yazi giriniz: ");
    sgets(str);

    size_t len = strlen(str);

    for(size_t i = 0; i < len; ++i)
        puts(str + i); // Burada 'puts' fonksiyonu 'NULL character' gÃ¶rene kadar bir karakter dizisinin yazdÄ±rÄ±lmasÄ± iÃ§in kullanÄ±lmaktadÄ±r. Burada pointer aritmetiÄŸi kullanÄ±lmaktadÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda ...
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE 100

int main(void)
{
    char s[SIZE];

    printf("bir yazi giriniz: ");
    sgets(s);

    size_t len = strlen(s);

    for(size_t i = 0; i < len; ++i)
        puts(s + i);
    
}
```



Burada `sgets` fonksiyonun tanÄ±mÄ±nÄ±n ne olduÄŸu aÃ§Ä±klanÄ±yor ama Ã¶nceden detaylÄ± not aldÄ±ÄŸÄ±m iÃ§in tekrardan yazmadÄ±m.


â—â—â— Atama operatÃ¶rÃ¼nÃ¼n Ã¼rettiÄŸi deÄŸer nesneye atanan deÄŸerdir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda standart C fonksiyonu olan `strlen` fonksiyonunun nasÄ±l gerÃ§ekleÅŸtirildiÄŸi(implementation) edildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE 100

// 'strlen_c' adÄ±nÄ±n sonundaki 'c' harfi 'custom' sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n kÄ±saltmasÄ±ndan gelmektedir.
size_t strlen_c_v1(const char* p)
{
    size_t len = 0;

    while(*p != '\0'){
        ++p;
        ++len;
    }

    return len;
}

size_t strlen_c_v2(const char* p)
{
    size_t len = 0;

    while(*p){
        ++p;
        ++len;
    }

    return len;
}

size_t strlen_c_v3(const char* p)
{
    size_t len = 0;

    while(*p++)
        ++len;
    
    return len;
}

size_t strlen_c_v4(const char* p)
{
    const char* ps = p;

    while(*p)
        ++p;
    
    return (size_t)(p - ps);
}


size_t strlen_c_v5(const char* p)
{
    const char* ps = p;

    while(*p++)
    ; // NULL statement

    p--;
    
    return (size_t)(p - ps);
}

int main(void)
{
    char s[SIZE];

    printf("bir yazi girin: ");
    sgets(s);
    size_t len = strlen_cv4(s);
    
    printf("uzunluk = %zu\n", len);

    for(size_t i = 0; i < len; ++i)
        puts(s + i);
}
```


#### Ä°ki Tane(`strchr`,`strrchr`) Ã‡ok SÄ±k KullanÄ±lan Standart KÃ¼tÃ¼phanedeki Arama FonksiyonlarÄ± 


`strchr` fonksiyonu bir yazÄ±nÄ±n baÅŸÄ±ndan itibaran bir karakteri arar ve ilk bulduÄŸu eÅŸleÅŸmede ilgili dizi elemanÄ±nÄ±n adresini geriye dÃ¶ner. `strchr` adÄ± "string character" sÃ¶zcÃ¼klerinden kÄ±saltÄ±lmÄ±ÅŸtÄ±r.

`strrchr` fonksiyonu bir yazÄ±nÄ±n sonundan itibaran bir karakteri arar ve ilk bulduÄŸu eÅŸleÅŸmede ilgili dizi elemanÄ±nÄ±n adresini geriye dÃ¶ner. `strrchr` adÄ± "string reverse character" sÃ¶zcÃ¼klerinden kÄ±saltÄ±lmÄ±ÅŸtÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir karakteri aramak iÃ§in kullanÄ±lan `strchr`, `strrchr` fonksiyonlarÄ±nÄ±n kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h> // 'strchr' fonksiyonu iÃ§in dahil edilmiÅŸtir.
#include "nutility.h"

#define SIZE 100

// char* strchr(const char* p, int c); // Aranan karakterin ilk tespit edildiÄŸi yerin adresini dÃ¶ndÃ¼rÃ¼r, aranan karakter bulunamazsa 'null character' dÃ¶ndÃ¼rÃ¼lÃ¼r.
// char* strrchr(const char* p, int c); // Aranan karakterin son tespit edildiÄŸi yerin adresini dÃ¶ndÃ¼rÃ¼r, aranan karakter bulunamazsa 'null character' dÃ¶ndÃ¼rÃ¼lÃ¼r.

int main(void)
{
    char s[SIZE];

    printf("bir yazi girin: ");
    sgets(s);
    printf("[%s]\n", s);

    int ch;

    printf("aranacak karakteri giriniz: ");
    ch = getchar();

    char* p = strchr(s, ch);

    // 'p != NULL' yazmak yerine 'p' ve 'p == NULL' yazmak yerine '!p' yazmak daha Ã§ok tercihedilmektedir.
    if(p != NULL){
        printf("bulundu dizinin %d indisli karakteri.\n", p- s);
    }
    else{
        printf("bulunamadi.\n");
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir yazÄ±da geÃ§en bir karakterin olup olmadÄ±ÄŸÄ±nÄ± anlama iÅŸleminin `strchr` fonksiyonu kullanÄ±larak nasÄ±l yazÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE 100

int main(void)
{
    char s[SIZE];

    printf("bir yazi giriniz: ");
    sgets(s);
    printf("[%s]\n", s);

    printf("aranÄ±lan karakteri giriniz: ");
    int ch = getchar();

    // AÅŸaÄŸÄ±daki ÅŸart ile bir yazÄ±da geÃ§en bir karakterin olup olmadÄ±ÄŸÄ± sÄ±nanmaktadÄ±r.
    // if(strchr(s, ch) != NULL)
    //     printf("evet var.\n");
    // else
    //     printf("hayir yok.\n");

    if(strchr(s, ch))
        printf("evet var.\n");
    else
        printf("hayir yok.\n");
}
```


Ders sonu ...
