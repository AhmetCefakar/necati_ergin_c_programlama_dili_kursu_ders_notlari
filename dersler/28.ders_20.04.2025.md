# 28.Ders 20.04.2025 ğŸ•˜

Derse 11(09:03)-14(09:50)-14(10:01)-16(10:40)-18(11:11)-18(12:16) kiÅŸi katÄ±ldÄ±.


## Pointers Devam


ğŸ‘‡ AÅŸaÄŸÄ±daki programdan bir diziyi ters Ã§evirme iÅŸleminin nasÄ±l yazÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

#define SIZE = 20

void reverse_array_v1(int* p, int size)
{
    for(int i = 1; i < size / 2; ++i){
        int temp = p[i];
        p[i] = p[size - 1 - i];
        p[size - 1 - i] = temp;
    }
}

void reverse_array_v2(int* p, int size)
{
    for(int i = 1; i < size / 2; ++i){
        // swap(&p[i], &p[size - 1 - i]); // 'nutility.h' altÄ±nda bulunan 'swap' fonksiyonuyla takas iÅŸlemi yapÄ±lÄ±yor
        swap(p + i, p + size - 1 - i); // Burada pointer aritmetiÄŸi ile takas edilecek adres deÄŸerleri fonksiyona iletiliyor
    }
}

int main(void)
{
    int a[100];

    randomize();
    set_array_random(a, SIZE);
    print_array(a, SIZE);

    reverse_array_v2(a, SIZE);
    print_array(a, SIZE);
}
```



âœï¸ Takas ekme iÅŸlemini yapan bir fonksiyonun kendi kÃ¼tÃ¼phenemize ekleyelim. 
```c
// 'nutility.h' dosyasÄ±na aÅŸaÄŸÄ±daki 'fuction decleration' eklemelerini yapÄ±yoruz.

void swap(int* p1, int* p2);
```

```C
// 'nutility.c' dosyasÄ±na aÅŸaÄŸÄ±daki 'fuction definition' eklemelerini yapÄ±yoruz.

// p1: Takan edilecek ilk 'int' tÃ¼rÃ¼nden nesnenin adresi
// p2: Takan edilecek ikinci 'int' tÃ¼rÃ¼nden nesnenin adresi
void swap(int* p1, int* p2)
{
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}
```



â—â—â— C dilinde bir adresten baÅŸka bir badres Ã§Ä±kartÄ±labilir, bÃ¶yle bir ifadenin tÃ¼rÃ¼ iÅŸaretli tam sayÄ± tÃ¼rÃ¼dÃ¼r, ancak bÃ¶yle bir ifadenin geÃ§erli olmasÄ±nÄ±n(legal) yanÄ±sÄ±ra doÄŸru olmasÄ± iÃ§in Ã§Ä±kartÄ±lan operatÃ¶rÃ¼n operantlarÄ±nÄ±n aynÄ± dizinin elemanlarÄ±nÄ±n adresleri olmasÄ± gerekir. 


ğŸ‘‡ AÅŸaÄŸÄ±daki programdan iki adres deÄŸerinin birbirinden Ã§Ä±kartÄ±ldÄ±ÄŸÄ±nda iÅŸaretli tam sayÄ± tÃ¼rÃ¼nden deÄŸer Ã¼retildiÄŸi durum incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int ar[20] = { 0 };
    int* p1 = &ar[14];
    int* p2 = &ar[2];

    printf("%d\n", &ar[13] - &ar[4]); // 9 yazacaktÄ±r
    printf("%d\n", &ar[3] - &ar[17]); // -14 yazacaktÄ±r
    printf("%d\n", (ar + 18) - (ar + 5)); // 13 yazacaktÄ±r
    printf("%d\n", p1 - p2); // 12 yazacaktÄ±r
    printf("%d\n", p2 - p1); // -12 yazacaktÄ±r
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki tam sayÄ±nÄ±n adreslerinin birbirlerinden Ã§Ä±kartÄ±lmasÄ± sonucunda elde edilen iÅŸaretli tam sayÄ± tÃ¼rÃ¼nÃ¼n legal ama mantÄ±klÄ± olmadÄ±ÄŸÄ± durum incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 5; y = 12;
    int* p1 = &x;
    int* p2 = &y;

    int n = p1 - p2; // Buradaki iÅŸlemde 'ub' yoktur legal bir kullanÄ±mdÄ±r ama bu iÅŸlemden elde edilen deÄŸerin kullanÄ±labileceÄŸi mantÄ±klÄ± bir yer yoktur.

    printf("%d\n", n);
}
```



â”`ptr` adlÄ± bir pointer deÄŸiÅŸken adÄ± `a` olan bir dizinin bir elemanÄ±nÄ± gÃ¶stermektedir, `ptr`nin gÃ¶sterdiÄŸi dizi elemanÄ±nÄ±n indeksi nedir? </br>
â—â—â— Cevap `ptr - a` olacaktÄ±r buradan ÅŸu sonuÃ§ Ã§Ä±kacaktÄ±r;
- Bir dizinin bir elemanÄ±nÄ±n adresini biliyorsak indeksini de biliyoruz demektir.
- Bir dizinin bir elemanÄ±nÄ±n indeksini biliyorsak adresini de biliyoruz demektir.

â”Ä°smi `a` olan bir dizinin bir elemanÄ±nÄ±n indeksi `idx` ise bu elemanÄ±n adresi nedir? </br>
â—â—â— Cevap `a + idx` olacaktÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir dizinin bittiÄŸi yerin adresini kullanarak kullanarak nasÄ±l o dizinin test Ã§evrilebileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

#define SIZE = 20

void reverse_array(int* p, int size)
{
    int* p_end = p + size; // Dizinin bittiÄŸi yerin adresidir, dizinin son elemanÄ±ndan sonraki adres, bu adresin deÄŸerine eriÅŸip kullanmak 'ub' durumuna neden olacaktÄ±r.
    int n = size / 2;

    while(n--){
        swap(p++, --p_end); // Burada dÃ¶ngÃ¼nÃ¼n her adÄ±mÄ±nda dizinin ortanca elemanÄ±na doÄŸru ilk ve son elemanÄ±nÄ±n adresi 'swap' fonksiyonuna gÃ¶nderiliyor.
    }
}

int main(void)
{
    int a[100];

    randomize();
    set_array_random(a, SIZE);
    print_array(a, SIZE);

    reverse_array(a, SIZE);
    print_array(a, SIZE);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda diziler Ã¼zerinde yapÄ±labilecek olan **pointer aritmetiÄŸi** incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int a[5] = { 0, 1, 2, 3, 4 };

    int* p = a + 5;

    a[5]; // Buradaki ifade dizinin dÄ±ÅŸÄ±ndaki bir adersteki deÄŸeri kullanÄ±ldÄ±ÄŸÄ± iÃ§in 'ub' durumu oluÅŸturacaktÄ±r.

    p - a; // Bu ifadenin sonucu dizinin uzunluÄŸunu verecektir.
    
    --p; // Bu ifade dizinin son elemanÄ±nÄ±n adresidir.
}
```



â—â—â— Dizinin bittiÄŸi yerin adresi dizinin son elemanÄ±nÄ±n adresini toplayarak elde edilen adrestir, dizinin ilk elemanÄ±nÄ±n adresine dizinin boyutunu toplayarak elde edilen adrestir. Bu adres dizinin bir elemanÄ± olmadÄ±ÄŸÄ± iÃ§in bu adresin derefenece edilmesi tanÄ±msÄ±z davranÄ±ÅŸtÄ±r, ancak bu adres bazÄ± iÅŸlemlerde kullanÄ±labilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda dizinin son elemanÄ±ndan sonraki adresin ve deÄŸerin kullanÄ±lmasÄ±nÄ±n **ub** olup olmamasÄ± durumu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int a[10] = { 0 };

    a[10]; // Burada 'ub' vardÄ±r Ã§Ã¼nkÃ¼ diziye ait olmayan bir adresteki deÄŸere eriÅŸiliyor.
    &a[10]; // Burada 'ub' yoktur.
    a + 10; // Buradaki ifade '&a[10]' ifadesiyle aynÄ± anlama gelmektedir.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **booble sort** algoritmasÄ±nÄ±n farklÄ± ÅŸekillerde nasÄ±l yazÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

#define SIZE 20

void booble_sort_v1(int* p, int size)
{
    for(int i = 0; i < size; ++i){
        for(int j = 0; j < size - 1 - i; ++j){
            if(p[j] > p[j + 1]){
                int temp = p[j];
                p[j] = p[j + 1];
                p[j + 1] = temp;
            }
        }
    }
}

void booble_sort_v2(int* p, int size)
{
    for(int i = 0; i < size; ++i){
        for(int j = 0; j < size - 1 - i; ++j){
            if(p[j] > p[j + 1]){
                // swap(&p[j], &p[j + 1]); // Burada deÄŸiÅŸtirilecek olan dizi elemanlarÄ±nÄ±n adresleri adres operatÃ¶rÃ¼ kullanÄ±larak 'swap' fonksiyonuna gÃ¶nderiliyor.
                swap(p + j, p + j + 1); // Burada pointer aritmetiÄŸi ile 'swap' fonksiyonuna adres deÄŸerleri gÃ¶nderiliyor.
            }
        }
    }
}

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    booble_sort_v2(ar, SIZE);
    print_array(ar, SIZE);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan bir diziyi baÅŸka bir diziye kopyalayan fonksiyonun pointer kullanarak nasÄ±l yazÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

#define SIZE 50

void copy_array_v1(int* pdestination, const int* psource, int size)
{
    for(int i = 0; i < size; ++i){
        pdestination[i] = psource[i];
    }
}

void copy_array_v2(int* pdestination, const int* psource, int size)
{
    while(size--){
        *pdestination = *psource;
        ++pdestination;
        ++psource;
    }
}

void copy_array_v3(int* pdestination, const int* psource, int size)
{
    while(size--){
        *pdestination++ = *psource++;
    }
}

int main(void)
{
    int a[SIZE];

    randomize();
    set_array_random(a, SIZE);
    printArray(a, SIZE);

    copy_array_v1(b, a, SIZE);

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile 'a' dizisinin elemanlarÄ± 'b' dizisine kopyalanmaktadÄ±r ama kodun yÃ¶netiminin kolay olmasÄ± iÃ§in bu iÅŸlemi fonksiyonlara alÄ±yoruz.
    //for(int i = 0; i < SIZE; ++i){
    //    b[i] = a[i];
    //}

    int b[SIZE] = { 0 };
    printArray(b, SIZE);

    int idx_a, idx_b, n;

    printf("a dizisinin hangi indisli elemanÄ±ndan baslayarak : ");
    scabf("%d", &idx_a);
    printf("b dizisinin hangi indisli elemanÄ±ndan baslayarak : ");
    scabf("%d", &idx_b);
    printf("kaÃ§ eleman kopyalanacak : ");
    scabf("%d", &n);

    copy_array_v3(b + idx_b, a + idx_a, n); // Pointer aritmetiÄŸi yapÄ±lÄ±yor.
    //copy_array_v3(&b[idx_b], &a[idx_a], n); // Buradaki kullanÄ±m yukarÄ±daki kullanÄ±mla aynÄ± anlama gelmektedir.
}
```



ğŸ§  EÄŸer bir fonksiyon biri okuma amaÃ§lÄ± diÄŸeri yazma amaÃ§lÄ± iki adres alacaksa C'de genel kabule gÃ¶re konvensiyon Ã¶nce hedef adresin sonra kaynak adresin parametre olarak yazÄ±lmasÄ±dÄ±r. Bu konvensiyon ilk C standart kÃ¼tÃ¼phanesinde kullanÄ±lmÄ±ÅŸ ve C dilinde kÃ¼tÃ¼phene geliÅŸtirenler de bu konvensiyona uymuÅŸlardÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda dizi ve pointer notasyonuyla yapÄ±lan parametre bildirimlerinin aynÄ± anlama geldiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

// AÅŸaÄŸÄ±daki iki fonksiyon bildirimi birbirinin aynÄ±sÄ±dÄ±r, 'int* p' ve 'int p[]' parametreleri aynÄ± anlama geliyor. 'int p[]' ifadesi dizinin ilk elemanÄ±na karÅŸÄ±lÄ±k gelmektedir.
void func(int* p, int size);
void func(int p[], int size);
void func(int p[13], int size); // Buradaki 'p[13]' bildirimini derleyici dikkate almaz ve 'p' olarak yorumlar, burada da 'array decay' uygulanacaktÄ±r.
```



MÃ¼lakat sorusu; </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda dizi ve pointer notasyonuyla parametre bildirimlerindeki konvensiyonel durum incelenebilir, buradaki durum mÃ¼lakatlarda farklÄ± ÅŸekillerde sorulmaktadÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

#define SIZE 100


// AÅŸaÄŸÄ±daki gibi Ã¼Ã§ farklÄ± ÅŸekilde fonksiyon yazÄ±lsa da bu tanÄ±mlarÄ±n hepsi aynÄ± anlama gelmektedir.
//void foo(int* p)
void foo(int p[])
//void foo(int p[100])
{
    printf("sizeof(p) = %zu\n", sizeof(p)); // Standart Ã§Ä±ktÄ±ya 'sizeof(p) = 4\n' gÃ¶nderilir.
    printf("sizeof(p[0]) = %zu\n", sizeof(p[0])); // Standart Ã§Ä±ktÄ±ya 'sizeof(p[0]) = 4\n' gÃ¶nderilir.
    printf("sizeof(p[70]) = %zu\n", sizeof(p[70])); // Standart Ã§Ä±ktÄ±ya 'sizeof(p[70]) = 4\n' gÃ¶nderilir.

    printf("%zu\n", sizeof(p) / sizeof(p[0])); // Burada 'sizeof(int*) / sizeof(int)' iÅŸlemi yapÄ±lÄ±r. 
}

int main(void)
{
    int a[100] = { 0 };

    foo(a);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `foo` ve `bar` fonksiyonlarÄ±nÄ±n bildirimleri ve Ã§aÄŸrÄ±lma iÅŸlemlerindeki benzerlikleri gÃ¶rmek iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

// AÅŸaÄŸÄ±daki fonksiyon parametrelerini derleyici pointer olarak yorumlayacaktÄ±r.
void foo(int p[]); // BazÄ± programcÄ±lar dizilerin pointer'Ä±nÄ± bekleyen fonksiyonlarÄ± bu ÅŸekilde yazÄ±yormuÅŸ ama bunun 'int* p' parametresinden bir farkÄ± yoktur.
void bar(int* p);

int main(void)
{
    int[100] = { 0 };
    int x = 5;

    // AÅŸaÄŸÄ±daki fonksiyon Ã§aÄŸrÄ±larÄ± aynÄ±dÄ±r.
    foo(a);
    foo(&x);
    
    // AÅŸaÄŸÄ±daki fonksiyon Ã§aÄŸrÄ±larÄ± aynÄ±dÄ±r.
    bar(a);
    bar(&x);
}
```


ğŸ§  `void get_array_min_max(const int* p_ary, int size, int* pmin, int* pmax);` ve `void get_array_min_max(const int p_ary[], int size, int* pmin, int* pmax);` fonksiyonlarÄ±nÄ±n bildirimlerimleri aynÄ± ÅŸekilde yorumlanmaktadÄ±r, buradaki farklÄ± kullanÄ±m konvensiyonel olan bir farklÄ±lÄ±ktÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda C standardÄ±nda belirtilen "**Herhangibir tÃ¼rden bir deÄŸiÅŸken tek elemanlÄ± bir diziymiÅŸ gibi pointer operatÃ¶rleriyle birlikte kullanÄ±labilir.**" durumunu gÃ¶rmek iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 10;
    int* p = &x;
    ++p; // Burada pointer aritmetiÄŸi ile 'p' gÃ¶stericisinin adresi arttÄ±rÄ±lÄ±yor.

    int y = *--p; // Burada 'x' deÄŸiÅŸkeninin deÄŸeri 'y' deÄŸiÅŸkenine atanÄ±yor.


    int x1 = 10;
    int* p1 = &x1 + 1;

    ++*(p1 - 1); // Burada bir 'ub' yoktur, 'x' deÄŸiÅŸkeninin deÄŸeri 1 arttÄ±rÄ±lÄ±yor.
    printf("x1 = %d", x1);


    int x2 = 10;
    int* p2 = &x2;

    p2[0] = 1231232; // Burada bir 'ub' yoktur
    printf("x2 = %d", x2);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**reverce copy**" iÅŸlemini yapan fonksiyonlar incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

#define SIZE 10

// pdest   : Kopyala yapÄ±lacak dizinin ilk elemanÄ±nÄ±n adres deÄŸeri.
// psource : Kopyalanacak dizinin ilk elemanÄ±nÄ±n adres deÄŸeri.
// size    : Dizilerin eleman sayÄ±larÄ±(burada iki dizi de eÅŸit elemana sahip olmalÄ± ki kopyalama mantÄ±klÄ± olsun).
void reverse_copy_v1(int* pdest, const int* psource, int size)
{
    for(int i = 0; i < SIZE; ++i){
        pdest[i] = psource[SIZE - 1 - i];
    }
}

void reverse_copy_v2(int* pdest, const int* psource, int size)
{
    int* p = pdest + size; // Buradaki 'p' deÄŸiÅŸkeni 'pdest' dizisinin son elemanÄ±ndan sonraki ilk adresi gÃ¶stermektedir.

    while(size--){
        *--p = *psource++; // C idiom kullanÄ±larak yazÄ±m ÅŸekli.
        //*(--p) = *(psource++); // YukaÄ±daki ile aynÄ± anlama gelmektedir.
    }
}

void reverse_copy_v3(int* pdest, const int* psource, int size)
{
    pdest += size; //'pdest' gÃ¶stericisinin son dizi elemanÄ±ndan sonraki adresi gÃ¶stermesi saÄŸlanÄ±yor.

    while(size--){
        *--pdest = *psource++; // C idiom kullanÄ±larak yazÄ±m ÅŸekli.
    }
}

int main(void)
{
    int a[SIZE] = {1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };
    int b[SIZE];

    print_array(a, SIZE);

    reverse_copy(b, a, SIZE);

    print_array(b, SIZE);
}
```


### Invalid State Pointers 

ğŸ§­ Pointer deÄŸiÅŸkenlerin iki durum bilgisi(state) vardÄ±r, bunlar;
1. **Invalid State**: GeÃ§ersiz bir adresi gÃ¶steren durum iÃ§in kullanÄ±lan terimdir. O adres hiÃ§bir ÅŸekilde kullanÄ±lmamalÄ±dÄ±r.
2. **Valid State**: GeÃ§erli bir adresi gÃ¶steren durum iÃ§in kullanÄ±lan terimdir. O adres kullanÄ±labilir.

ğŸ§­ **Invalid State** durumundaki gÃ¶stericiler aÅŸaÄŸÄ±daki ÅŸartlarda oluÅŸmaktadÄ±r; 
- **Otomatik storage** pointer deÄŸiÅŸenler ilk deÄŸer verilmeden kullanÄ±ldÄ±klarÄ±nda **tanÄ±msÄ±z davranÄ±ÅŸtÄ±r(ub)**.
- Bir pointer deÄŸiÅŸkenin bir dizinin son elemanÄ±ndan sonraki adresleri deÄŸer olarak tutmasÄ± **tanÄ±msÄ±z davranÄ±ÅŸtÄ±r(ub)**.
- Bir pointer deÄŸiÅŸkenin gÃ¶sterdiÄŸi adresteki nesnenin Ã¶mrÃ¼ bittikten sonra o pointer'Ä± deÄŸer atamasÄ± dÄ±ÅŸÄ±nda kullanmak **tanÄ±msÄ±z davranÄ±ÅŸtÄ±r(ub)**, bu tÃ¼r gÃ¶stericilere ise **Dangling Pointer** denilmektedir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda pointer deÄŸiÅŸkene ilk edeÄŸer atanmamasÄ±nÄ±n tanÄ±msÄ±z davranÄ±ÅŸ olduÄŸu durumlar incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int* ptr;
    *ptr = 467; // Burada 'ub' vardÄ±r, bunun nedeni 'ptr' gÃ¶stericisine ilk deÄŸer verilmediÄŸi iÃ§in Ã§Ã¶p deÄŸerde olmasÄ±dÄ±r.

    int x = 651;
    ptr = &x;
    *ptr = 54; // Burada tanÄ±msÄ±z davranÄ±ÅŸ yoktur.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir pointer deÄŸiÅŸkenin bir dizinin elemanlarÄ± ve son elemanÄ±ndan bir sonraki adres dÄ±ÅŸÄ±ndaki adresleri gÃ¶steriyor olmasÄ±nÄ±n **ub** olduÄŸu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    // AÅŸaÄŸÄ±daki 'p1' ve 'p2' gÃ¶stericilerine 'invalid pointer' denilmektedir.
    int a[10] = { 0 };
    int* p1 = a + 11; // Bu deÄŸerin kullanÄ±lmasÄ± 'ub'ye neden olacaktÄ±r.
    int* p2 = a - 1;  // Bu deÄŸerin kullanÄ±lmasÄ± 'ub'ye neden olacaktÄ±r.
}
```



**Dangling Pointer**: Bir pointer deÄŸiÅŸken bir nesneyi gÃ¶steriyor, ancak pointer deÄŸiÅŸken hayatÄ±na devam ederken gÃ¶sterdiÄŸi nesnenin hayatÄ± bitiyor ise bu hayatÄ± biten nesneyi gÃ¶steren pointer'a **dangling Pointer** denilmektedir. **Dangling Pointer** durumlarÄ± daha Ã§ok **Dynamic Memory Management** konusuyla ilgilidir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda kullanÄ±lan `ptr` deÄŸiÅŸkeni "1" ve "3" satÄ±rlarÄ±nda "**invalid state**" durumundadÄ±r Ã§Ã¼nkÃ¼ `ptr` gÃ¶stericisine atanan adres deÄŸerinin **nesnesinin(object)** Ã¶mrÃ¼ blok dÄ±ÅŸÄ±nda bitiyor, bu duumda `ptr` gÃ¶stericisinin tuttuÄŸu adres deÄŸeri Ã§Ã¶p deÄŸere dÃ¶nÃ¼ÅŸÃ¼yor.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int* ptr;
    // 1 

    if(1){
        int x = 10;
        ptr = &x;
        // 2
    }

    // 3
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **dereferencable** nitelikte olmayan `p` gÃ¶stericisinin durumu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int a[5] = { 0 };

    int* p = a + 5; // Buradaki 'p' gÃ¶stericisi 'a' dizisinin son elemanÄ±ndan bir sonraki adresi deÄŸer olarak almÄ±ÅŸtÄ±r, bu pointer 'dereferencable' nitelikte deÄŸildir.
    
    *p; // Bu ifade bu ÅŸekilde kullanÄ±lÄ±rsa tanÄ±msÄ±z davranÄ±ÅŸa neden olacaktÄ±r.
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.41-11.00 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


### Valid State Pointers

ğŸ§­ AÅŸaÄŸÄ±daki durumlarda bir pointer'Ä±n **valid state** durumdadÄ±r;
1. HayatÄ± devam etmekte olan bir nesnenin adresi.
2. Dizinin bittiÄŸi yerin adresi(**not to dereference**).
3. `Null` pointer deÄŸeri(**not to dereference**).


## Const Qualifier(Const Niteleyicisi) 

ğŸ§­ Nesneler aÅŸaÄŸÄ±daki Ã¶zelliklere sahip olabiliyor;
1. **Mutable Object**: DeÄŸeri deÄŸiÅŸtirilebilir nesnelerdir.
2. **Inmutable Object**: DeÄŸeri deÄŸiÅŸtirilemeyen nesnelerdir.


ğŸ§  C ve C++ dillerinde bir nesne varsayÄ±lan olarak **mutable** Ã¶zelliktedir ve bir nesneyi **inmutable** yapmak iÃ§in `const` anahtar sÃ¶zcÃ¼ÄŸÃ¼yle iÅŸaretlemek gerekiyor. Rust dilinde nesneler varsayÄ±lan olarak **inmutable** Ã¶zelliktedir. Her programlama dilinde olmasa da bir Ã§ok programlama dilinde bir nesnenin **mutable** ya da **inmutable** olmasÄ± ayarlanabiliyor.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `const` anahtar sÃ¶zcÃ¼ÄŸÃ¼yle **inmutable** yapÄ±lan deÄŸiÅŸkenlerin deÄŸerleri deÄŸiÅŸtirilmek istendiÄŸinde alÄ±nacak **sÃ¶zdizim hatalarÄ±(syntax error)** incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    const int x = 10;
    const int a[] = { 1, 2, 3, 4, 5 };

    // AÅŸaÄŸÄ±daki statement'lar sÃ¶zdizim hatasÄ±na(syntax error) neden olacaktÄ±r.
    x = 46;
    ++x;
    x--;
    x += 3;

    a[3] = 1213;
}
```


**const variable** aslÄ±nda oksimoron bir terimdir Ã§Ã¼nkÃ¼ bu deÄŸiÅŸkenlerin taÅŸÄ±dÄ±ÄŸÄ± deÄŸerler deÄŸiÅŸtirilemez ama bu nesneler deÄŸiÅŸken olarak nitelendirilmektedir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `const` anahtar sÃ¶zcÃ¼ÄŸÃ¼yle **inmutable** yapÄ±lan `primes` dizisinin herhangi bir elemanÄ±nÄ±n deÄŸerinin deÄŸiÅŸtirilmesi iÃ§in iÅŸlem yapÄ±ldÄ±ÄŸÄ±nda alÄ±nacak **sÃ¶zdizim hatasÄ±(syntax error)** incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    const int primes[] = { 0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, };

    primes[7]++; // Burada sÃ¶zdizim hatasÄ±(syntax error) oluÅŸacaktÄ±r.
}
```


>â”
> 
> Sorulan soru; 
> 
> Constness run-time'da da deÄŸiÅŸmemeyi garati eder mi? `const` dizinin bir elemanÄ±nÄ± run-time'da bir fonk. deÄŸiÅŸtirmeye Ã§alÄ±ÅŸsa, tassa vs..
> 
> Cevap;
> 
> `const` anahtar sÃ¶zcÃ¼ÄŸÃ¼yle iÅŸaretlenen bir deÄŸiÅŸkenin deÄŸerinin pointer Ã¼zerinden deÄŸiÅŸtirilmesi **ub** durumuna neden olacaktÄ±r, bu durum C mÃ¼lakatlarÄ±nda sorulabilir. </br>
> ğŸ‘‡ AÅŸaÄŸÄ±daki programda yularÄ±da belirtilen durum incelenebilir.
> ```C
> #define _CRT_SECURE_NO_WARNINGS
> 
> #include <stdio.h>
> 
> int main(void)
> {
>     const int primes[] = { 0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, };
>     int* ptr = (int*)(primes +7); // Buradaki gibi bir kullanÄ±m legaldir fakat kullanÄ±lmasÄ± doÄŸru deÄŸildir Ã§Ã¼nkÃ¼ deÄŸeri deÄŸiÅŸmeyecek olarak bildirilen bir dizinin bir elemanÄ±nÄ±n adresi bir gÃ¶stericiye atanÄ±yor.
> 
>     *ptr = 2142131; // Buradaki kod 'legal'dir ama kullanÄ±lmasÄ± 'ub' durumu oluÅŸturacaktÄ±r Ã§Ã¼nkÃ¼ 'const' iÅŸaretlenen 
> }
> ```


ğŸ§  **const variable** kullanmanÄ±n faydalarÄ±;
1. `const` iÅŸaretlenen bir deÄŸiÅŸken program iÃ§erisinde doÄŸrudan deÄŸiÅŸken adÄ± Ã¼zerinden deÄŸiÅŸtirilmek istendiÄŸinde setaks hatasÄ± oluÅŸacaktÄ±r, bu da hata yapmayÄ± Ã¶nleyecektir.
2. Okuyucuyu bilgilendirmek iÃ§in kullanÄ±lÄ±r. DeÄŸeri deÄŸiÅŸtirilmeyecek olan deÄŸiÅŸkenler `const` olarak iÅŸaretlenmelidir.
3. Derleyicinin daha etkin bir makine kodu(ya da assembly) Ã¼retebilmesini saÄŸlayabiliyor.


â— C++ dilinde makrolarÄ±n kullanÄ±lmasÄ± istenmiyormuÅŸ. C dilinde sabit olacak deÄŸerlerin duruma gÃ¶re bazen **object like macro** bazen de `const` iÅŸeretlenen nesne olarak kullanÄ±labilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir **object like macro** varlÄ±ÄŸÄ±n adres operatÃ¶rÃ¼nÃ¼n operandÄ± yapÄ±ldÄ±ÄŸÄ± durumda **sÃ¶zdizim hatasÄ±(syntax error)** oluÅŸacaÄŸÄ± gÃ¶rÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

#define SIZE 100

void foo(const int* ptr);

int main(void)
{
    const int x = 78;

    foo(&SIZE); // Hata verir Ã§Ã¼nkÃ¼ 'SIZE' makrosu sabit bir deÄŸer olduÄŸu iÃ§in 'R-value'dur, '&' operatÃ¶rÃ¼ de sadece 'L-value' bir ifadeyi operant olarak alabilir.
    foo(&x);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda kullanÄ±lan `const` bildirilen `x` nesnesinin bellekte yer kaplayÄ±p kaplamayacaÄŸÄ±na derleyici karar veriyor, programÄ±n gÃ¶zlemlenen davranÄ±ÅŸÄ± deÄŸiÅŸmemek ÅŸertÄ±yla derleyici program iÃ§in oluÅŸtutulacak olan makine komutlarÄ±nÄ± deÄŸiÅŸtirebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

#define SIZE 100

const int x = 5;

int main(void)
{
    int y = x + 5;
    int z = x * x + 2;
    int t = x - 3;

    // Derleyici yukarÄ±daki statement'larÄ± aÅŸaÄŸÄ±daki gibi yorumlayabilir ve bu durumda 'x, y, z' deÄŸiÅŸkenleri iÃ§in bellekte yer ayÄ±rmaz;
    //int y = 10;
    //int z = 27;
    //int t = 2;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir dizi deÄŸiÅŸkeni bildiriminde dizinin uzunluÄŸunu belirten ifadenin **const expression** olmasÄ± gerektiÄŸi kuralÄ±nÄ±n kullanÄ±lan derleyiciye gÃ¶re deÄŸiÅŸebileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

int main(void)
{
    const int x = 7;

    int a[x]; // C derleyicisi 'VLA' desteklemiyorsa, dizilerin uzunluklarÄ±nÄ± belirten ifadelerin sabit ifadeler olmasÄ± gerekiyor. C++ dilinde bu kullanÄ±m 'legal'dir.
}
```


â—â—â— Pointer deÄŸiÅŸkenlerle birlikte `const` anahtak sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n kullanÄ±lmasÄ± anlaÅŸÄ±lmasÄ± biraz zor olan bir konudur.

â—â—â— Pointer deÄŸiÅŸkenler `const` iÅŸaretleneceÄŸinde tanÄ±mlama **sÃ¶zdizimminde(syntax)** kullanÄ±lan `*` karakterinin `const` anahtarÄ±ndan Ã¶nce ya da sonra yazÄ±lmasÄ± kodun anlamÄ±nÄ± deÄŸiÅŸtirecektir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan C standardÄ±nda **const pointer to type** olarak ve C++ standardÄ±nda **top-level const** olarak adlandÄ±rÄ±lan(standard dÄ±ÅŸÄ± olarak **rigth const** ya da **east const** olarak adlandÄ±rÄ±lÄ±yormuÅŸ ama bu teimleri kullanma) pointer deÄŸiÅŸkenlerinin `const` bildirimiyle ilgili bilgiler incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

int main(void)
{
    int x = 5;
    int y = 14;

    // AÅŸaÄŸÄ±daki tanÄ±mlamada 'p' pointer deÄŸiÅŸkeninin deÄŸerinin deÄŸiÅŸtirilmeyeceÄŸi bildirilmiÅŸ oluyor.
    // AÅŸaÄŸÄ±daki bildirim C standardÄ±nda 'const pointer to int' olarak adlandÄ±rÄ±lÄ±yor, C++ standardÄ±nda 'top-level const' olarak adlandÄ±rÄ±lÄ±yor.
    // StandardÄ±n kullandÄ±ÄŸÄ± terimler olmasa da bazÄ± kiÅŸiler 'right const' ya da 'east const' olarak adlandÄ±rÄ±lÄ±yormuÅŸ.
    // 'const pointer to int' olarak bildirilen bir pointer deÄŸiÅŸkenin deÄŸerinin yani tuttuÄŸu adres deÄŸerinin deÄŸiÅŸmeyeceÄŸi belirtilmiÅŸ oluyor, eÄŸer pointercdeÄŸiÅŸkenin deÄŸeri olan adres deÄŸiÅŸtiren bir kod yazÄ±lÄ±rsa sÃ¶zdizim hatasÄ±(syntax error) oluÅŸacaktÄ±r.
    int * const p = &x;

    // p = &y; // Burada sÃ¶zdizim hatasÄ±(syntax error) oluÅŸacaktÄ±r.
    *p = 9574; // Bu kullanÄ±m legaldir ve kullanÄ±mÄ± doÄŸrudur.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan C standardÄ±nda **pointer to const type** olarak ve C++ standardÄ±nda **low-level const** olarak adlandÄ±rÄ±lan(standard dÄ±ÅŸÄ± olarak **left const** ya da **west const** olarak adlandÄ±rÄ±lÄ±yormuÅŸ ama bu teimleri kullanma) pointer deÄŸiÅŸkenlerinin `const` bildirimiyle ilgili inceleme yapÄ±labilir.
```C
#define _CRT_SECURE_NO_WARNINGS

int main(void)
{
    //int* const p = expr;
    
    // AÅŸaÄŸÄ±daki iki kullanÄ±m aynÄ± anlama gelecektir.
    //const int * p = expr;
    //int const * p = expr;

    // AÅŸaÄŸÄ±daki iki kullanÄ±m aynÄ± anlama gelecektir, sÄ±klÄ±kla ilk kullanÄ±m tercih edilmektedir.
    //const int x1 = 7;
    //int const x2 = 7;


    int x = 5;
    int y = 14;

    // AÅŸaÄŸÄ±daki tanÄ±mlamada 'p' pointer deÄŸiÅŸkeni ile p'nin gÃ¶sterdiÄŸi nesnenin deÄŸiÅŸtirilmeyeceÄŸi belirtilmiÅŸ oluyor, yani '*p' ifadesi ile deÄŸer atanamaz('*p' ifadesi salt okunur tanÄ±mlanmÄ±ÅŸ olur)
    // AÅŸaÄŸÄ±daki bildirim C standardÄ±nda 'pointer to const int' olarak adlandÄ±rÄ±lÄ±yor, C++ standardÄ±nda 'low-level const' olarak adlandÄ±rÄ±lÄ±yor.
    // StandardÄ±n kullandÄ±ÄŸÄ± terimler olmasa da bazÄ± kiÅŸiler 'left const' ya da 'west const' olarak adlandÄ±rÄ±lÄ±yormuÅŸ.
    const int * p = &x;
    //int const * p = &x; // Buradaki 'p' pointer bildirimi yukarÄ±daki bildirim ile aynÄ±dÄ±r.

    //AÅŸaÄŸÄ±daki statement'lar 'p' gÃ¶stericisi Ã¼zerinden iÅŸaret edilen nesnenin deÄŸeri deÄŸiÅŸtirilmek istendiÄŸi iÃ§in sÃ¶zdizim hatasÄ±na(syntax error) neden olacaktÄ±r.
    *p = 3; 
    ++*p;
    p[0] = 3; // 'p[0]' ifadesi derleyici tarafÄ±ndan '*(p + 0)' ifadesine Ã§evriliyor. 

    p = &y; // Bu legaldir ve 'p' deÄŸiÅŸkeni baÅŸka bir nesnenin adresini tutabilir ama 'p' deÄŸiÅŸkeni Ã¼zerinden iÅŸeret edilen nesnenin deÄŸeri deÄŸiÅŸtirilemez.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **pointer to const type** olarak bildirilen `p` gÃ¶stericisi Ã¼zerinden gÃ¶sterdiÄŸi nesnenin deÄŸerinin deÄŸiÅŸtirilmek istenmesinin **sÃ¶zdizim hatasÄ±na(syntax error)** neden olacaÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

int main(void)
{
    int a[] = { 2, 3, 4, 5, 6, 7 };
    const int * p = a;

    //AÅŸaÄŸÄ±daki statement'lar sÃ¶zdizim hatasÄ±na(syntax error) neden olacaktÄ±r.
    *p = 2;
    p[4] = 3;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **const pointer to const type** olarak bildirim yapÄ±lmasÄ±nÄ±n nasÄ±l **sÃ¶zdizimi(syntax)** seviyesinde kontrol saÄŸladÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

int main(void)
{
    int x = 10;
    int x = 20;

    const int* const p = &x;

    // AÅŸaÄŸÄ±daki iki atama iÅŸlemi de sÃ¶zdizim hatasÄ±na(syntax error) neden olacaktÄ±r.
    p = &y;
    *p = 723;
}
```



â—â—â— AÅŸaÄŸÄ±da pointer deÄŸiÅŸkenler ile `const` anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n kaÃ§ farklÄ± ÅŸekilde kullanÄ±labildiÄŸi bilgisi listelenmiÅŸtir.
1. `type * const p` deÄŸiÅŸken bildirimiyle ilgili bilgiler aÅŸaÄŸÄ±daki gibidir;
    - Åu ÅŸekilde adlandÄ±rÄ±lÄ±r;
        - **const pointer to type**(C standardÄ±nÄ±n kullandÄ±ÄŸÄ± terim)
        - **top level const**(C++ standardÄ±nÄ±n kullandÄ±ÄŸÄ± terim)
        - **right const**(standardÄ±n kullandÄ±ÄŸÄ± terim deÄŸildir)
        - **east const**(standardÄ±n kullandÄ±ÄŸÄ± terim deÄŸildir)
    - Åu anlama gelmektedir: `p` deÄŸiÅŸkeninin deÄŸeri deÄŸiÅŸmeyecek, `p` gÃ¶stericisinin gÃ¶sterdiÄŸi nesne `*p` ifadesine deÄŸer atamsÄ±yla deÄŸiÅŸtirilebilir. 
2. `const type * p` deÄŸiÅŸken bildirimiyle ilgili bilgiler aÅŸaÄŸÄ±daki gibidir;
    - Åu ÅŸekilde adlandÄ±rÄ±lÄ±r;
        - **pointer to const type**(C standardÄ±nÄ±n kullandÄ±ÄŸÄ± terim)
        - **low level const**(C++ standardÄ±nÄ±n kullandÄ±ÄŸÄ± terim)
        - **left const**(standardÄ±n kullandÄ±ÄŸÄ± terim deÄŸildir)
        - **west const**(standardÄ±n kullandÄ±ÄŸÄ± terim deÄŸildir)
    - Åu anlama gelmektedir: `*p` deÄŸiÅŸkeninin deÄŸeri deÄŸiÅŸmeyecek, `p` deÄŸiÅŸkeninin deÄŸeri deÄŸiÅŸtirilebilir.
3. `const type * const p` deÄŸiÅŸken bildirimiyle ilgili bilgiler aÅŸaÄŸÄ±daki gibidir;
    - Åu ÅŸekilde adlandÄ±rÄ±lÄ±r;
        - **const pointer to const type**
    - Åu anlama gelmektedir: `p` deÄŸiÅŸkeninin deÄŸeri deÄŸiÅŸmeyecek ve `*p` deÄŸiÅŸkeninin deÄŸeri deÄŸiÅŸmeyecek.



ğŸ‘‡ AÅŸaÄŸÄ±daki program C dilini Ã¶ÄŸrenen bazÄ± Ã¶ÄŸrencilerin aÅŸaÄŸÄ±daki programdaki gibi bir durumda programÄ±n nasÄ±l Ã§alÄ±ÅŸacaÄŸÄ± konusunda kafalarÄ± karÄ±ÅŸtÄ±ÄŸÄ± iÃ§in yazÄ±lmÄ±ÅŸtÄ±r.  
```C
#define _CRT_SECURE_NO_WARNINGS

int main(void)
{
    int x = 10;
    const int* p = &x;

    x = 6456; // Buradaki iÅŸlemde sÃ¶zdizim hatasÄ±(syntax error) oluÅŸmaz, sadece 'p' pointer'Ä± Ã¼zerinden deÄŸeri deÄŸiÅŸtirilmek istenirse sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `const` anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n kullanÄ±lmasÄ±yla algili bazÄ± durumlar incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

int main(void)
{
    int x = 10;
    const int* cp = &x;
    int* p = &x;
    
    *cp = 523; // Senteks hatasÄ± vardÄ±r.
    *p = 5674; // Legal ve doÄŸru bir kullanÄ±m.
    x = 6343; // Legal ve doÄŸru bir kullanÄ±m.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `const` anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n kullanÄ±lmasÄ±yla algili bazÄ± durumlar incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

int main(void)
{
    const int x = 5, y = 6; // Buradaki kodda hem 'x' hem de 'y' deÄŸiÅŸkeni 'const int' olarak bildirilmektedir.

    int z = 3;
    const int t = 4, *ptr = &z;

    *ptr = 24; // Burada sÃ¶zdizim hatasÄ±(syntax error) vardÄ±r.
    ptr = &z; // Burada sÃ¶zdizim hatasÄ±(syntax error) yoktur ve 'ub' de yoktur.    
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.01-12.11 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


>â”
> 
> Sorulan soru; 
> 
> Sorunun aciklamasina tekrar bakmanÄ±z mÃ¼mkÃ¼n mÃ¼?
> ```C
> const int x = 5;
> int *ptr = &x;
> *ptr = 3;
> ```
> durumu **ub** mi diye sormak istemistim?
> 
> Cevap;
> 
> HatanÄ±n `int *ptr = &x;` satÄ±rÄ±nda olduÄŸu gÃ¶rÃ¼lecektir. Derleyiciler burada ya hata verirler ya da uyarÄ± iletisi.
> `x` deÄŸiÅŸkeninin deÄŸiÅŸmeyeceÄŸi bildiriliyor fakat `x` deÄŸiÅŸkeninin adresi bir pointer deÄŸiÅŸkene atanÄ±yor, bu ÅŸekilde kod yazÄ±lmasÄ±nda mantÄ±k hatasÄ± olduÄŸu aÃ§Ä±k zaten.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda  
```C
#define _CRT_SECURE_NO_WARNINGS

int main(void)
{
    const int x = 5;
    int* ptr = &x; // Bu satÄ±rda derleyici ya sÃ¶zdizim hatasÄ±(syntax error) verecektir ya da uyarÄ± verecektir Ã§Ã¼nkÃ¼ 'const' olduÄŸu bildirilen bir deÄŸiÅŸkenin deÄŸeri Ã¼zerinde deÄŸiÅŸiklik yapÄ±lmasÄ±na neden olabilecek bir iÅŸlem yapÄ±lÄ±yor.
}
```



â—â—â— AÅŸaÄŸÄ±daki cÃ¼mleler Ã¶nemlidir;
- `const Type *` tÃ¼rÃ¼nden `Type *` tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸÃ¼me izin verilmemelidir, bu iÅŸlem **ub** durumu oluÅŸturacaktÄ±r.
- `Type *` tÃ¼rÃ¼nden `const Type *` tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸÃ¼m yapÄ±labilir, bu iÅŸlem herhangi bir hata deÄŸildir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `const` iÅŸaretlenen tÃ¼rlerden `const` iÅŸaretli olmayan tÃ¼rlere Ã¶rtÃ¼lÃ¼ olarak dÃ¶nÃ¼ÅŸÃ¼m yapÄ±lmasÄ±nÄ±n hatalÄ± olduÄŸu durumular incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

int main(void)
{
    int x = 5;
    const int cx = 523;
    int* ptr = &x;

    const int* cptr = &x;

    // '&x' ifadesinin tÃ¼rÃ¼ 'int*'
    // '&cx' ifadesinin tÃ¼rÃ¼ 'const int*'
    // 'ptr' ifadesinin tÃ¼rÃ¼ 'int *'
    // 'cptr' ifadesinin tÃ¼rÃ¼ 'const int*'

    // AÅŸaÄŸÄ±daki '&cx' ifadesinin tÃ¼rÃ¼ 'const int*' ama 'ptr' 'int*' tÃ¼rÃ¼ndedir ve iki tarafÄ±n tÃ¼rÃ¼ aynÄ± olmadÄ±ÄŸÄ± iÃ§in yapÄ±lan iÅŸlem doÄŸru deÄŸildir. 
    // AÅŸaÄŸÄ±daki atama iÅŸlemi yanlÄ±ÅŸtÄ±r ve asla yapÄ±lmamasÄ± gerekiyor, derleyici hata vermesi gerekir ama uyarÄ± iletisi da verebilir.
    // ptr = &cx; 

    cptr = ptr; // YanlÄ±ÅŸlÄ±k olmayan atama.
    cptr = &cx; // YanlÄ±ÅŸlÄ±k olmayan atama.
    ptr = cptr; // Burada 'const int*' tÃ¼rÃ¼nden 'int*' tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸÃ¼m yapÄ±ldÄ±ÄŸÄ± iÃ§in yanlÄ±ÅŸ bir iÅŸlem yapÄ±lmaktadÄ±r.    
}
```


â—â—â— BazÄ± durumlarda `const typr*` tÃ¼rÃ¼nden `type*` tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸÃ¼mÃ¼nÃ¼n yapÄ±lmasÄ±nÄ±n gerekeceÄŸi yerler olacaktÄ±r, gerekli olduÄŸunda bu iÅŸlem tÃ¼r dÃ¶nÃ¼ÅŸÃ¼m operatÃ¶rÃ¼ ile aÃ§Ä±k ÅŸekilde yapÄ±lmalÄ±dÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda pointer tÃ¼rlerde aÃ§Ä±k tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼nÃ¼n nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

int main(void)
{
    const int x = 523;
    
    int* p = (int*)&x; // AÃ§Ä±k tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapÄ±lÄ±yor, bu kullanÄ±m Ã§oÄŸu zaman mantÄ±klÄ± deÄŸildir ama bu tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mlerin yapÄ±lmasÄ± gerekecek yerler vardÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda pointer tÃ¼rlerde kullanÄ±lan Ã¶rtÃ¼lÃ¼ ve aÃ§Ä±k tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mleri incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

int main(void)
{
    int x = 123;
    char* ptr1 = &x; // Derleyici burada uyarÄ± iletisi verir.
    char* ptr2 = (char*)&x; // Derleyici burada uyarÄ± iletisi vermez ve bazen bu ÅŸekilde kodlar yazÄ±lmasÄ± gerekecektir.
}
```


### `const` Anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n KullanÄ±m DurumlarÄ±yla Ä°lgili Son Bilgiler 

FonksiyonlarÄ±n parametre deÄŸiÅŸkeninin pointer olmasÄ± durumunda ikitane farklÄ± interface(arayÃ¼z) var, bunlar **input parameter** ve **output parameter**.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **input parameter** ve **output parameter** kullanÄ±mlarÄ± ve bunlar hakkÄ±nda bazÄ± bilgilerin ne olduÄŸu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

// AÅŸaÄŸÄ±daki gibi sadece 'output' parametre alan fonksiyonlar 'set function', 'mutator function', 'setter function' olarak adlandÄ±rÄ±lÄ±r.
// Bu tÃ¼r fonksiyonlar aldÄ±klarÄ± pointer tÃ¼rÃ¼nden parametreleri deÄŸiÅŸtirebilie ÅŸeklinde yorumlanÄ±r.
void foo(int* p);

// AÅŸaÄŸÄ±daki gibi sadece 'input' parametre alan fonksiyonlar olabilir.
// Bu tÃ¼r fonksiyonlar aldÄ±klarÄ± pointer tÃ¼rÃ¼nden parametreleri deÄŸiÅŸtirmeyeceÄŸini kodu okuyana ve derleyiciye bildirmiÅŸ olurlar.
// AÅŸaÄŸÄ±daki fonksiyon ayrÄ±ca 'pure function' olarak adlandÄ±rÄ±lmaktadÄ±r(tani tanÄ±mÄ±nda global bir deÄŸiÅŸkene eriÅŸip deÄŸer deÄŸiÅŸikliÄŸi yapmadÄ±ÄŸÄ± sÃ¼rece!)
void bar(const int* p);

// AÅŸaÄŸÄ±daki ÅŸekilde fonksiyon bildirimi anlamlÄ± olmayacaktÄ±r Ã§Ã¼nkÃ¼ burada fonksiyona adresi gÃ¶nderilen nesnenin deÄŸerinin deÄŸiÅŸmeyeceÄŸi bildirilmiÅŸ olmuyor sadece pointer'Ä±n tuttuÄŸu adresin deÄŸiÅŸmeyeceÄŸi bildirilmiÅŸ oluyor. 
void baz(int * const p); 

int main(void)
{

}
```



FonksiyonlarÄ±n parametreleri pointer deÄŸilse onlarÄ± `const` olarak bildirmek pek iÅŸlevi olan bir kullanÄ±m olmayacaktÄ±r, bu durum ğŸ‘‡ aÅŸaÄŸÄ±daki programdan incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

// AÅŸaÄŸÄ±daki iki fonksiyon tanÄ±mÄ± da fonksiyon Ã§aÄŸrÄ±sÄ±nÄ±n yapÄ±ldÄ±ÄŸÄ± yerde birbiriyle aynÄ± ÅŸekilde yorumlanacaktÄ±r. 
void foo(int x);
void bar(const int x);

int main(void)
{
    int i = 0;

    foo(i);
    bar(i);
}
```



â—â—â— Necati Ergin yaptÄ±ÄŸÄ± **kod incelemelerinde(code review)** en Ã§ok karÅŸÄ±laÅŸtÄ±ÄŸÄ± semantik yanlÄ±ÅŸlÄ±klar ğŸ‘‡ aÅŸaÄŸÄ±daki programdan incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

// AÅŸaÄŸÄ±daki ÅŸekilde bir fonksiyon tanÄ±mÄ± neden kÃ¼tÃ¼dÃ¼r;
// 1. Fonksiyonun ilk parametresi 'ptr' olan deÄŸiÅŸken pointer Ã¼zerinden deÄŸeri deÄŸiÅŸtirilmeyeceÄŸi iÃ§in 'const' olarak tanÄ±mlanmalÄ±ydÄ± ama tanÄ±mlanmamÄ±ÅŸ, bu da kodu okuyan kiÅŸinin ilk paramtrenin 'output' olduÄŸunu anlayamamasÄ±na neden olacaktÄ±r.
// 2. Kodlama hatasÄ±na aÃ§Ä±k kod yazÄ±lmÄ±ÅŸ olur.
// 3. Derleyicinin yapabileceÄŸi optimizasyonlar kÄ±sÄ±tlanmÄ±ÅŸ olur.
// 4. 'const' nesneler bu fonksiyonun ilk parametresine argÃ¼man olarak gÃ¶nderilirse sÃ¶zdizim hatasÄ±na(syntax error) neden olmalÄ±dÄ±r(bu davranÄ±ÅŸ derleyiciye gÃ¶re deÄŸiÅŸiyor ama mantÄ±ken yanlÄ±ÅŸ bir iÅŸlemdir).
void print_array(int* ptr, int size);

int main(void)
{
    const int primes[5] = { 2, 3, 5, 7, 11, };
    print_array(primes, 5); // BÃ¶yle bir fonksiyon Ã§aÄŸrÄ±sÄ± 'const int*' tÃ¼rÃ¼nden 'int*' tÃ¼rÃ¼ne tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapÄ±lacaÄŸÄ± iÃ§in doÄŸru olmayacaktÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program `const` parametrelere sahip fonksiyonlar hakkÄ±nda bazÄ± bilgileri edinmek iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

void foo(int* const ptr)
{
    // Bu fonksiyonun tanÄ±mÄ± iÃ§inde parametre deÄŸiÅŸkeni olan 'ptr' deÄŸiÅŸkeninin deÄŸeri deÄŸiÅŸmeyecektir, 
    // ama 'ptr' deÄŸiÅŸkenin tuttuÄŸu adresteki nesnenin deÄŸeri deÄŸiÅŸtirilebilir.
}

int main(void)
{
    int x = 10;
    int y = 20;
    int* p = &x;

    p = &y; // Burada 'p' deÄŸiÅŸkeninin tutuÄŸu adres deÄŸerinin 'x' deÄŸiÅŸkeninin adresinden 'y' deÄŸiÅŸkeninin adresine deÄŸiÅŸtirilmesi iÅŸlemidir.
}
```


â—â—â— BazÄ± durumlarda `type* const ptr` ÅŸeklindeki pointer deÄŸiÅŸkenlerin tuttuÄŸu adres deÄŸerlerinin deÄŸiÅŸmeyeceÄŸini belirten deÄŸiÅŸken bildirimleri bilerek ve isteyerek kullanÄ±lmaktadÄ±r, bunun nedeni pointer tÃ¼rÃ¼nde tutulan deÄŸiÅŸkenin bir register adresi olmasÄ± ve program Ã§alÄ±ÅŸma zamanÄ± boyunca deÄŸiÅŸmemesi gerekmesi olabilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `const` parametrelere sahip fonksiyonlar hakkÄ±nda bilgi edinilebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

// AÅŸaÄŸÄ±daki fonksiyon bildirimlerinde deÄŸeri deÄŸiÅŸtirilmeyecek nesneler 'const' olarak iÅŸaretleniyor.
size_t strlen(const char*);
int strcmp(const char* cp1, const char* cp2);
char* strcpy(char* pdestination, const char* psource);

// AÅŸaÄŸÄ±daki iki fonksiyon bildirimi de fonksiyon Ã§aÄŸrÄ±larÄ±nÄ±n yapÄ±ldÄ±ÄŸÄ± yerde derleyici tarafÄ±ndan birbiriyle aynÄ± ÅŸekilde yorumlanacaktÄ±r.
void foo(int x);
void bar(const int x);

int main(void)
{
    int i = 0;

    foo(i);
    bar(i);
}
```

ğŸ§­ GÃ¶rece pointer kosunun hayla baÅŸÄ±nda sayÄ±lÄ±rÄ±z, daha Ã¶ÄŸrenilecek Ã§ok konu var ğŸ˜Š.


## Adresler(pointer) ve KarÅŸÄ±laÅŸtÄ±rma Ä°ÅŸlemleri 


Pointer'lar karÅŸÄ±laÅŸtÄ±rma operatÃ¶rlerinin operandÄ± olabilmektedir.

`<`, `<=`, `>`, `>=` operatÃ¶rleri **relational operators** olarak nitelendirilmektedir.
`==`, `!=` operatÃ¶rleri **equality operators** olarak nitelendirilmektedir.


ğŸ§­ Pointer konusu bundan sonraki on ders boyunca devam edecek diyebiliriz ama farklÄ± baÅŸlÄ±klar altÄ±nda farklÄ± araÃ§lar ile birlikte pointer'larÄ±n kullanÄ±mÄ±yla ilgili konular var;
- **Function returning pointers**
- **Pointer pointer**
- **string literals**
- **Pointer arrrays**
- **void pointers**
- **Function pointers**
- **Function pointer arrays**
- **Multi-dimantional arrays**
- **Dynamic memory management**


â—â—â— Pointer'lar ile yapÄ±lan karÅŸÄ±laÅŸtÄ±rma iÅŸlemlerinin **legal** olmasÄ± ayrÄ± **doÄŸru** olmasÄ±, bir amaca hizmet etmesi, kullanÄ±labilir olmasÄ± farklÄ± ÅŸeylerdir, buna dikkat etmek gerekiyor.



ğŸ§­ C dilinin standardÄ± iki pointer deÄŸiÅŸkenin eÅŸitlik karÅŸÄ±laÅŸtÄ±rmasÄ±na tabi tutulmasÄ± halinde aÅŸaÄŸÄ±daki durumlardan biri sÃ¶z konusuysa pointer deÄŸiÅŸkenlerin eÅŸit olma durumu kesindir;
1. Her iki adres de aynÄ± nesnenin adresine sahip ise.
2. Her iki adres de aynÄ± dizinin bittiÄŸi yerin adresi ise.
3. Her iki adres te **null pointer** adres ise.



ğŸ‘‡ AÅŸaÄŸÄ±daki program pointer eÅŸitliÄŸinin nasÄ±l sÄ±nandÄ±ÄŸÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

int main(void)
{
    int x = 10, y = 55;

    int* p1 = &x, *p2 = &y;

    if(p1 == p2){
        printf("evet p1 ve p2 gostericileri esittir.\n");
    }
    else{
        printf("hayir p1 ve p2 gostericileri esit degildir.\n");
    }
    
    p2 = &x;

    if(p1 == p2){
        printf("evet p1 ve p2 gostericileri esittir.\n");
    }
    else{
        printf("hayir p1 ve p2 gostericileri esit degildir.\n");
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `char*` tÃ¼rÃ¼nden deÄŸiÅŸkenler arasÄ±ndaki karÅŸÄ±laÅŸtÄ±rmanÄ±n nasÄ±l yapÄ±lacaÄŸÄ± incelenebilir. </br>
Bir Ã§ok kiÅŸi buradaki karÅŸÄ±laÅŸtÄ±rmanÄ±n yazÄ±larÄ±n eÅŸitliÄŸini sÄ±nadÄ±ÄŸÄ±nÄ± zannediyormuÅŸ ama buradaki karÅŸÄ±laÅŸtÄ±rma iÅŸlemi **array to pointer conversion** iÅŸlemi yapÄ±lacak pointer deÄŸerlerin karÅŸÄ±laÅŸtÄ±rmasÄ± ÅŸeklinde yapÄ±lmaktadÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    char* s1[] = "yazi";
    char* s2[] = "yazi";

    // AÅŸaÄŸÄ±daki 's1 == s2' karÅŸÄ±laÅŸtÄ±rmasÄ± pointerlarÄ±n ilk adreslerinin karÅŸÄ±laÅŸtÄ±rmasÄ± ÅŸeklinde olacaktÄ±r, yazÄ± iÃ§eriklerinin karÅŸÄ±laÅŸtÄ±rmasÄ± yapÄ±lmamaktadÄ±r.
    if(s1 == s2) // 'always-false'
        printf("evet esit.\n");
    else
        printf("evet esit degil.\n");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `int*` tÃ¼rÃ¼nden iki dizinin arasÄ±ndaki karÅŸÄ±laÅŸtÄ±rmanÄ±n nasÄ±l yapÄ±lacaÄŸÄ± incelenebilir. </br>
Buradaki iÅŸlemde **array to pointer conversion** uygulandÄ±ktan sonra pointer deÄŸerlerinin karÅŸÄ±laÅŸtÄ±rmasÄ± yapÄ±lmaktadÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int* ary1[] = { 1, 2, 3, 4 };
    int* ary2[] = { 1, 2, 3, 4 };

    // AÅŸaÄŸÄ±daki 'ary1 == ary2' karÅŸÄ±laÅŸtÄ±rmasÄ± pointerlarÄ±n ilk adreslerinin karÅŸÄ±laÅŸtÄ±rmasÄ± ÅŸeklinde olacaktÄ±r.
    if(ary1 == ary2) // 'always-false'
        printf("evet esit.\n");
    else
        printf("evet esit degil.\n");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda pointer deÄŸiÅŸkenlerin kendi deÄŸerlerinin karÅŸÄ±laÅŸtÄ±rÄ±lmasÄ±yla gÃ¶sterdikleri nesnelerin deÄŸerlerinin karÅŸÄ±laÅŸtÄ±rÄ±lmasÄ± iÅŸlemleri incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 10, y = 10;
    int* p1 = &x, *p2 = &y;

    if(p1 == p2) // Burada 'p1' ve 'p2' pointer deÄŸiÅŸkenlerinin tutuÄŸu adres deÄŸerleri karÅŸÄ±laÅŸtÄ±rÄ±lÄ±yor ve bu karÅŸÄ±laÅŸtÄ±rmanÄ±n sonucu 'always-false' durumundadÄ±r.
        printf("evet esit.\n");
    else
        printf("evet esit degil.\n");

    if(*p1 == *p2) // Burada 'p1' ve 'p2' pointer deÄŸiÅŸkenlerinin tutuÄŸu adreslerdeki nesnelerin deÄŸerleri karÅŸÄ±laÅŸtÄ±rÄ±lÄ±yor ve bu karÅŸÄ±laÅŸtÄ±rmanÄ±n sonucu 'always-true' durumundadÄ±r.
        printf("evet esit.\n");
    else
        printf("evet esit degil.\n");
}
```


Ders sonu ...
