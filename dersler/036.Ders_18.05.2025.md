# 36.Ders 18.05.2025 🕘

Derse 10(09:01)-11(09:04)-12(09:07)-13(09:08)-12(09:41)-13(09:49)-12(10:01)-11(10:19)-12(10:29)-13(10:40)-12(11:01)-12(12:03)-11(12:47) kişi katıldı.
---

## void Pointers Devam


❗❗❗ Primitive türden nesnelerin(pointer nesnelerde bu gruba dahildir) bellek bloklarının byte byte o nesnenin bir yerden başka yere kopyalanması işlemi her zaman doğru çalışacaktır ama **user defined type** varlıklar ile çalışırken böyle bir kesinlik yoktur.

❗❗❗ **Generic Function**'ların `void*` türünden parametreleri tanımsız davranış riski olmadan `char*`, `signed char*`, `unsigned char*` türlerine dönüştürülerek kullanılabilir.



🧭 Bugünkü derste C standart kütüphenesinda olan beş tane standart **generic fonksiyonlarını** inceleyeceğiz, bu **generic fonksiyonları** kendi yazacağımız **generic fonksiyonlarda** kullanacağız, bu nedenle iyi bilinmelidir, kendi yazacağımız **generic fonksiyonlarda** işlemlerin bir kısmını bu fonksiyonlarla birlikte yapacağız.
- `memset`
- `memcpy`
- `memmove`
- `memchr`
- `memcmp`



👇 Aşağıdaki programda herhangi bir türden diziyi ters çeviren `greverse` adlı **generic fonksiyonun** nasıl yazıldığı incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

#define SIZE    20

// Aşağıdaki fonksiyon generic olarak bir diziyi ters çevirme işini yapmaktadır.
// vpa  : Ters çevrilecek olan dizinin adresi
// size : Dizinin uzunluğu(dizinin eleman sayısı)
// sz   : Dizinin bir elemanının kaç byte olduğu bilgisi
void greverse(void* vpa, size_t size, size_t sz)
{
    char* p = (char*)vpa;

    for(size_t i = 0; i < size /2; ++i){
        // Dizinin baştan ve sondan elemanlarını takas etmek için şu şekilde dizi elemanlarını tespit etmek gerekirdi => p[i]   p[size - 1 - i]
        // Aşağıda pointer aritmetiği ve ters çevrilecek olan dizinin tek bir elemanının byte büyüklüğü bilindiğinde aşağıdaki gibi diziyinin baştan ve sondan elemanlarını takas edebiliriz.
        gswap(p + i * sz, p + (size - 1 - i) * sz, sz);
    }
}

int main(void)
{
    int a[SIZE];
    
    randomize();
    set_array_random(a, SIZE);
    print_array(a, SIZE);
    greverse(a, SIZE, sizeof(int));
    print_array(a, SIZE);
}
```



👇 Aşağıdaki programda herhangi bir türden diziyi ters çeviren `greverse` adlı **generic fonksiyonun** nasıl yazıldığı incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

#define SIZE    20

// Aşağıdaki fonksiyon generic olarak bir diziyi ters çevirme işini yapmaktadır.
// vpa  : Ters çevrilecek olan dizinin adresi
// size : Dizinin uzunluğu(eleman sayısı)
// sz   : Dizinin bir elemanının kaç byte olduğu bilgisi
void greverse(void* vpa, size_t size, size_t sz)
{
    char* p = (char*)vpa; // 

    for(size_t i = 0; i < size /2; ++i){
        // Dizinin baştan ve sondan elemanlarını takas etmek için şu şekilde dizi elemanlarını tespit etmek gerekirdi => p[i]   p[size - 1 - i]
        // Aşağıda pointer aritmetiği ve ters çevrilecek olan dizinin tek bir elemanının byte büyüklüğü bilindiğinde aşağıdaki gibi diziyinin baştan ve sondan elemanlarını takas edebiliriz.
        gswap(p + i * sz, p + (size -1 - i) * sz, sz);
    }
}

int main(void)
{
    double a[] = { 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8 };
    
    greverse(a, asize(a), sizeof(double));

    for(size_t i = 0; i < size; ++i){
        printf("%f \n", a[i]);
    }
}
```


### `string.h` Başlık dosyası Generic Fonksiyonları 


🧭 Aşağıdaki fonksiyonların başlık dosyası `string.h` ama bu başlık dosyasındaki şu fonksiyonlar yazılar ya da başka türden nesneler ile kullanılabilen fonksiyonlardır;
- `memset`: Fonksiyon adı "**Memory Set**". Bir bellek bloğunun her bir byte'ını bir tam sayı değeriyle doldurur(set ediyor).
- `memcpy`: Fonksiyon adı "**Memory Copy**". Bir bellek bloğunu bir yerden başka bir yere kopyalar.
- `memmove`: Fonksiyon adı "**Memory Move**". Bir bellek bloğunu bir yerden başka bir yere kopyalar. 
- `memchr`: Fonksiyon adı "**Memory Chare**". Bir bellek bloğunda bir byte'ın değerini aramak için kullanılıyor.
- `memcmp`: Fonksiyon adı "**Memory Compare**". İki bellek bloğunu karşılaştırıyor.


🚀 `strcpy`, `strchr`, `strcmp` adlı yazılarla kullanılan fonksiyonlardır ile `memcpy`, `memchr`, `memcmp` byte'lar üzerinde işlem yapan **generic fonksiyonlardır**, bu fonksiyonların adlarının sonları aynıdır ama bu fonkaiyonlardan hangilerinin kullanılacağı kullanım yerine göre değişiklik gösterecektir. Mesela yazılarla işlem yaparken **Null terminated byte stream** dizilerle çalışırken `memcpy`, `memchr`, `memcmp` fonksiyonlarının kullanımına dikkat edilmesi gerekecektir.


#### `memset` Generic Fonksiyonu 



👇 Aşağıdaki programda `memset` fonksiyonu kullanımı hankkında bilgi edinilebilir.
```C
#include <stdio.h>
#include <string.h> // 'memset' fonksiyonu bu başlık dosyasında bulunuyor.
#include "nutility.h"

#define SIZE    20

// 'memset' fonksiyonu bir bellek bloğunun her bir byte'ını bir tam sayı değeriyle doldurur.
// Aşağıda 'memset' fonksiyonunun prototipi incelenebilir.
// vp  : Byte'ları set edilecek bellek bloğunun adresinin değeri.
// val : Her bir byte'ta yazılacak tam sayı değeri.
// sz  : Bellek bloğunun toplamda kaç byte olduğu bilgisi.
// Return value: Bellek bloğundaki her bir byte'ı set edilen nesnenin adres değeri.
// void* memset(void* vp, int val, size_t sz);

int main(void)
{
    int x = 246343;

    printf("x = %d\n", x);

    memset(&x, 0, sizeof x); // 'x' nesnesinin değeri 0 yapılıyor çünkü nesnenin tüm byte'larına 0 değeri yazılıyor.

    printf("x = %d\n", x);
}
```


❗❗❗ **To Clear a Memory Block**: Bir bellek bloğunun tüm bitlerinin sıfır yapılmasıdır. Bu işlemi yapmak için `memset` fonksiyonu kullanılabilir.



👇 Aşağıdaki programda `memset` fonksiyonu ile `int` türünden bir nesnenin tüm byte'larına 255 değeri atandığında ilgili nesnenin değerinin ne olacağı incelenebilir.
```C
#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    20

int main(void)
{
    int x = 246343;

    printf("x = %d\n", x);

    memset(&x, 255, sizeof x); // 'x' nesnesinin tüm bitleri "1" yapılıyor. 'x' nesnesinin türü 'int' olduğu için işaretli bir tam sayı türü ve bu durumda tüm bitler 1 olur ve bu da '-1' değerine karşılık gelir.

    printf("x = %d\n", x);
}
```



👇 Aşağıdaki programda `memset` fonksiyonu ile `int` türünden bir nesnenin tüm byte'larına 1 değeri atandığında ilgili nesnenin değerinin ne olacağı incelenebilir.
```C
#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    20

int main(void)
{
    int x = 246343;

    printf("x = %d\n", x);

    memset(&x, 1, sizeof x); // 'x' nesnesinin tüm byte değerlei "0000'0001" yapılıyor.

    printf("x = %d\n", x);
}
```




👇 Aşağıdaki programda `memset` generic fonksiyonunun **gerçekleştiriminin(implementation)** nasıl yapıldığı incelenebilir.
```C
#include <stdio.h>
//#include <string.h>
#include "nutility.h"

#define SIZE    20

// Kendi yazdığımız 'my_memset' fonksiyonu 'memset' fonksiyonunun yaptığı işin aynısını yapan bir gerçekleştirimdir. 
// vp  : Byte'ları set edilecek bellek bloğunun adresinin değeri.
// val : Her bir byte'ta yazılacak tam sayı değeri.
// sz  : Bellek bloğunun toplamda kaç byte olduğu bilgisi.
void* my_memset(void* vp, int val, size_t sz)
{
    char* p = (char*)vp;

    while(sz--)
        *p++ =(char)val;

    return vp;
}

int main(void)
{
    int x = 246343;

    printf("x = %d\n", x);

    memset(&x, 1, sizeof x); // 'x' nesnesinin tüm byte değerleri "0000'0001" yapılıyor.

    printf("x = %d\n", x);
}
```


>❔
> 
> Sorulan soru; 
> 
> byte duzeyinde nasil butun bitleri ayni anda set edebiliyor? Low-level bir dilin teker teker bitleri set etmesi/kopyalamasi gerekmez mi?
> 
> Cevap;
> 
> Hayır, `memset` fonksiyonu bitler üzerinde işlem yapmıyor, byte'lar üzerinde işlem yapmaktadır.



👇 Aşağıdaki program `memset` fonksiyonu kullanılarak `"aaaabbbbccccdddd"` karakter dizisinin şu yazıya `"aaaaXXXXccccdddd"` nasıl çevrildiğini anlamak için incelenebilir.
```C
#include <stdio.h>
#include <string.h>
#include "nutility.h"

int main(void)
{
    char str[] = "aaaabbbbccccdddd";
    puts(str);
    memset(str + 4, 'X', 4);
    puts(str);
    
    // Aşağıda yazının son dört karakterinin '!' yapılmak istenmiştir, burada bir hata olursa düzelt
    memset(str + asize(str) - 1 - 4, '!', 4);
    puts(str);
}
```



👇 Aşağıdaki programda bir `int` dizinin tüm elemanlarının değerinin "0" yapmak için `memset` fonksiyonunun nasıl kullanılacağı incelenebilir.
```C
#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    100

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    // memset(ar, 0, SIZE * sizeof(int)); // Buradaki 'memset' fonksiyon çağrısı aşağıdaki fonksiyon çağrısıyla aynıdır.
    memset(ar, 0, sizeof ar);

    print_array(ar, SIZE);
}
```


#### `memcpy` Generic Fonksiyonu 

`memcpy` fonksiyonu bir bellek bloğunu başka bir bellek bloğuna kopyamak için kullanılır. </br>
`memcpy` fonksiyonu kopyaladığı nesnenin türünü bilmez yani bu bilgiden habersizdir.



👇 Aşağıdaki programda `memcpy` generic fonksiyonunun prototipi incelenebilir ve en temel haliyle `memcpy` fonksiyonunun nasıl kullanılabileceği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    20

// 'memcpy' fonksiyonu bir bellek bloğunun tüm byte'larını birinci parametreye adresi gönderilen bloğa kopyalar.
// Aşağıda 'memset' fonksiyonunun prototipi incelenebilir.
// vpdest       : Kopyalama yapılacak olan bellek bloğunun adresi.
// vpsource     : Kopyalanacak kaynak verinin blunduğu nesnenin adresi.
// sz           : Kaç byte kopyalanacağı bilgisi.
// Return value : Değer kopyalama yapılan nesnenin adres değeri('vpsource' adresi geriye dönülür).
void* c_memcpy(void* vpdest, const void* vpsource, size_t sz);

int main(void)
{
    double d1 = 124.3534323;
    double d2;

    // Aşağıdaki iki kod satırı da sonuç olarak aynı işlemi yapmaktadır(yani 'd1' değişkeninin değerini 'd2' değişkenine atamaktadır)
    //d2 = d1;
    memcpy(&d2, &d1, sizeof(double));

    printf("d1 = %f\n", d1);
    printf("d2 = %f\n", d2);
}
```


⚠️ Standard C fonksiyonları ile yapılabilecek işlemler için kod yazılmamalıdır, hazır olan fonksiyonlar kullanılmalıdır, bu şekilde programın daha kolay okunması, programın daha kolay değiştirilebilir olması sağlanmış olur.



👇 Aşağıdaki programda `int` türünden bir dizinin nasıl başka bir diziye kopyalanabildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    100

void* c_memcpy(void* vpdest, const void* vpsource, size_t sz);

int main(void)
{
    int a[SIZE];
    int b[SIZE];

    randomize();
    set_array_random(a, SIZE);
    print_array(a, SIZE);

    memcpy(b, a, sizeof a);
    print_array(b, SIZE);
}
```



👇 Aşağıdaki programda bir diziden başka bir diziye dizilerin belirli indekslerinden başlayarak belirli sayıda dizi elemanının nasıl kopyalanabileceği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    100

void* c_memcpy(void* vpdest, const void* vpsource, size_t sz);

int main(void)
{
    int a[SIZE];
    int b[SIZE] = { 0 };

    randomize();
    set_array_random(a, SIZE);
    print_array(a, SIZE);

    int idx_a, idx_b, n;

    printf("a disinde hangi indeksten baslayarak? : ");
    scanf("%d", &idx_a);

    printf("b disinde hangi indeksten baslayarak? : ");
    scanf("%d", &idx_b);

    printf("kac eleman kopyalansin: ");
    scanf("%d", &n);

    memcpy(b + idx_b, a + idx_a, n * sizeof(int));

    print_array(a, SIZE);
    print_array(b, SIZE);
}
```



👇 Aşağıdaki programda `memcpy` generic fonksiyonunun **gerçekleştiriminin(implementation)** nasıl yapıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    100

// 'memcpy' fonksiyonu bir bellek bloğunun tüm byte'larını birinci parametreye adresi gönderilen bloğa kopyalar.
// Aşağıda 'memset' fonksiyonunun prototipi incelenebilir.
// vpdest       : Kopyalama yapılacak olan bellek bloğunun adresi.
// vpsource     : Kopyalanacak kaynak verinin blunduğu nesnenin adresi.
// sz           : Kaç byte kopyalanacağı bilgisi.
// Return value : Değer kopyalama yapılan nesnenin adres değeri('vpsource' adresi geriye dönülür).
void* c_memcpy(void* vpdest, const void* vpsource, size_t sz)
{
    // 'void*' pointer türü pointer aripmetiğinde kullanılamayacağına göre bu türleri 'byte' türünü tesil edebilecek olan bir tür olan 'char' türüne dönüştürüyoruz.
    char* pdest = (char*)vpdest;
    const void* psource = (const void*)vpsource;

    while(sz--)
        *pdest++ = *psource++;

    return vpdest;
}

int main(void)
{
    int a[SIZE];
    int b[SIZE];

    randomize();
    set_array_random(a, SIZE);
    print_array(a, SIZE);

    int idx_a, idx_b, n;

    printf("a disinde hangi indeksten baslayarak? : ");
    scanf("%d", &idx_a);

    printf("b disinde hangi indeksten baslayarak? : ");
    scanf("%d", &idx_b);

    printf("kac eleman kopyalansin: ");
    scanf("%d", &n);

    c_memcpy(b + idx_b, a + idx_a, n * sizeof(int));

    print_array(a, SIZE);
    print_array(b, SIZE);
}
```


⚠️⚠️⚠️ `const Type` türünden `Type` türüne yapılan açıktan(explicit) tür dönüşümleri doğrudan **ub** değildir, **ub** olması için tür dönüşümü yapılan `const` nesnenin değerinin değiştirilmesi gerekir.



👇 Aşağıdaki programda `memcpy` fonksiyonu ile karakter dizilerinin(yani yazıların) belirli kısımlarının nasıl kopyalanabileceği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    20

int main(void)
{
    char s1[] = "AAAABBBBCCCC";
    char s2[] = "XXXXYYYYWWWW";

    puts(s1);
    puts(s2);

    memcpy(s2 + 4, s1 + 4, 4);

    puts(s1);
    puts(s2);


    memcpy(s2 + 8, s1, 4);

    puts(s1);
    puts(s2);
}
```


⚠️ Bundan sonrasını anlayabilmek için `string` fonkisyonlar konusunda anlatılanların hatırlanması gerekecektir.



👇 Aşağıdaki programda "**Overlapped**" durumundan dolayı, `strcpy` fonksiyonunun nasıl "**ub**" oluşturacak şekilde kullanıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    100

int main(void)
{
    char str[SIZE] = "sevcan";

    strcpy(str + 3, str); // Burada yapılan işlem 'Overlapped' bloklar üzerinde işlem yapıldığı için burada 'ub' vardır.

    puts(str);
}
```


🚀 **Overlapped bellek blokları**: İşlem yapılan iki farklı göstericinin adres değerleri aynıysa ya da dizilerle çalışılırken dizilerin adresleri kesişiyorsa oluşan bu duruma verilen isimdir.



🚀 **restrict anahtar sözcüğü**: Bu anahtar sözcük kullanılarak aynı fonksiyona gönderilen pointer parametrelerin değerlerinin aynı olmayacağı ya da bellek bloklarının çakışmayacağına dair bir kesinlik olduğu belirtilmiş olur, bu bilgiyi derleyici kullanır ve bu bilgiyi daha iyi şekilde makine kodunun üretilmesi sağlanmış olur.


`restrict` anahtar sözcüğünün kullanılması sadece derleyiciye yardım eden bir bildirimdir, `restrict` paramentreleri olan fonksiyonlara **Overlapped bellek blokları** olmayan adres değerine sahip argümanların geçilmesi sorumluluğu o fonksiyonlara çağrı yapacak olan koddadır.


### `memmove` Generic Fonksiyonu 

`memcpy` ve `memmove` fonksiyonları temelde aynı işi yapmaktadır ve bildirimleri çok benzerdir, aradaki fark `memcpy` fonksiyonunun **Overlapped bellek blokları** üzerindeki davranışının tanımsız olması, `memmove` fonksiyonunun **Overlapped bellek blokları** üzerindeki davranışının tanımlı olmasıdır.

`memcpy` ve `memmove` fonksiyonlarının prototype'ları C99 standardında aşağıdaki gibidir;
- `void* memcpy(void* restrict vpdest, const void* restrict vpsource, size_t sz);`
- `void* memmove(void* vpdest, const void* vpsource, size_t sz);`



👇 Aşağıdaki programda `memmove` fonksiyonu ile **Overlapped bellek blokları** üzerindeki kopyalama işleminin "**ub**" olmaksızın nasıl yapıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    100

int main(void)
{
    char str[SIZE] = "sevcan";
    memmove(str + 3, str, strlen(str) + 1); // Bu fonksiyon çağrısındaki son argümanın 'strlen(str) + 1' sonundaki '+ 1'in nedeni yazının '\0' karakterini de kopyalayabilmek içindir.

    puts(str);
}
```



👇 Aşağıdaki programda `memcpy` ve `memmove` fonksiyonlarının kullanımı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    100

int main(void)
{
    int a[SIZE];

    randomize();
    set_array_random(a, SIZE);
    print_array(a, SIZE);

    memcpy(a + 20, a, 40 * sizeof(int)); // Bu fonksiyon çağrısı 'ub'ye neden olur.

    memmove(a + 20, a, 40 * sizeof(int)); // Bu fonksiyon çağrısında 'ub' yoktur.
}
```


⚠️ `memmove` fonksiyonunun **gerçekleştirimi(implementation)** bu derste yazılmayacak, başka bir derste gösterilecekmiş.


🧠 `memmove` fonksiyonu genellikle şu şekilde tanımlanmaktadır;
- Adresler büyüklük küçüklük karşılaştırmasına sokuluyor, böylece kopyalamanın yönü belirleniyor(**Overlapped bellek blokları** olduğunda kopyalama baştan sona doğru mu yoksa sondan başa doğru mu olmalı o belirleniyor).


### memchr Generic Fonksiyonu 

`strchr` fonksiyonu bir yazıda bir karakter arıyor, `memchr` fonksiyonu bir bellek bloğunda bir byte arıyor yani yazı aramak zorunlu değil. </br>
`memchr` fonksiyonunun adı "**Memory Character**" sözcüklerinin kısaltmasından geliyor.



👇 Aşağıdaki programda `memchr` fonksiyonunun bildirimi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    100

// 'memchr' fonksiyonu bir bellek bloğunun içinde bir byte'ı aramak için kullanılıyor, bu fonksiyon bir yazıda bir karakter aramak için de kullanılabilir.
// Aşağıda 'memchr' fonksiyonunun prototipi incelenebilir.
// vp              : İçinde arama yapılacak bellek bloğunun adresi(başlangıç adresi).
// val             : Aranacak değer.
// sz              : İçinde arama yapılacak bellek bloğunun büyüklüğü(byte olarak).
// Return value    : Aranılan değer bulunursa ilk bulunan değerin dizideki adresi, eğer bulunamazsa NULL pointer değer geriye dönecektir.
// void* memchr(const void* vp, int val, size_t sz);

int main(void)
{
    unsigned char buf[] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 1, 1, 1};

    unsigned char* p = (unsigned char*) memchr(buf, 9, sizeof buf);

    if(p)
        printf("bulundu idx = %d\n", p - buf);
    else
        printf("bulunamadı\n");
}
```


>❔
> 
> Sorulan soru; 
> 
> Yukarıdaki soruyla ilgili bir soru.
> byte byte ariyor dediniz, char gibi 1 bytetan degil de int ten olussaydi peki
> 
> Cevap;
> 
> `int` türü 4 byte'lık bloklarda tutulan ayrı bir formatta veri olduğu için `memchr` fonksiyonu ile `int` türü aranamaz, `memchr` fonksiyonu ile sadece bir byte'lık bir değer aranabilir.



👇 Aşağıdaki programda bir yazının ortasından başlayıp `memchr` fonksiyonu ile nasıl bir karakterin aranabileceği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    100

// void* memchr(const void* vp, int val, size_t sz);

int main(void)
{
    char str[] = "necati cavit selin ayhan";

    char* p = (char*)memchr(str + 6, 'a', 10);

    if(p){
        printf("bulundu idx = %d\n", p - str);
        puts(p);
    }
}
```


>❔
> 
> Sorulan soru; 
> 
> Demek istedigim int veya baska bir boyutta olsa byte byte bakip birsey donebilir miydi?
> 
> Cevap;
> 
> Dönmeye dönersiniz ama onun bir anlamı olmaz, mesela `int` türünde 0 değerini `memchr` ile aratılsa `int` türünden nesnenin byte'larından biri 0 ise onun adresini dönecektir ama bu adres değeri bir işe yaramayacaktır.



👇 Aşağıdaki programda `memchr` generic fonksiyonunun **gerçekleştiriminin(implementation)** nasıl yapıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    100

// 'memchr' fonksiyonu bir bellek bloğunun içinde bir byte'ı aramak için kullanılıyor, bu fonksiyon bir yazıda bir karakter aramak için de kullanılabilir.
// Aşağıda 'memchr' fonksiyonunun prototipi incelenebilir.
// vp              : İçinde arama yapılacak bellek bloğunun adresi(başlangıç adresi).
// val             : Aranacak değer.
// sz              : İçinde arama yapılacak bellek bloğunun büyüklüğü(byte olarak).
// Return value    : Aranılan değer bulunursa ilk bulunan değerin dizideki adresi, eğer bulunamazsa NULL pointer değer geriye dönecektir.
void* c_memchr(const void* vp, int val, size_t sz)
{
    const char* p = (const char*) vp;

    while(sz--){
        if(*p == val)
            return (Char*) p;
        ++p;
    }

    return NULL;
}

int main(void)
{
    char str[] = "necati cavit selin ayhan";

    char* p = (char*)c_memchr(str + 6, 'a', 10);

    if(p){
        printf("bulundu idx = %d\n", p - str);
        puts(p);
    }
}
```


### `memcmp` Generic Fonksiyonu 

Bizi zorlayacak bir fonksiyon. </br>
`strcmp` fonksiyonu "**lexicographical compare**" yöntemine göre iki yazıyı karşılaştırıp birinci parametre büyükse pozitif değer, ikinci parametre büyükse negatif değer ve iki yazı eşitse "0" değerini döndürmektedir. </br>
`strcmp` fonksiyonundaki karşılaştırma yaklaşımı bir çok yerde karşımıza çıkacağı için iyi bilinmesi önemlidir. </br>
`memcmp` fonksiyonu kendisine gönderilen iki pointer değişkeni byte byte karşılaştırmaktadır, bu karşılaştırma "**lexicographical compare**" yöntemine göre yapılmaktadır. </br>

`strcmp` ve `memcmp` fonksiyonlarının bildirimleri aşağıdaki gibidir;
- `strcmp(const char* p1, const char *p2);`
- `memcmp(const void* p1, const void *p2, size_t sz);`


`memcmp` fonksiyonu ile aşağıdaki gibi iki bellek bloğunun karşılaştırması yapıldığında ilk bellek bloğundaki üçüncü byte değeri daha büyük olduğu tespit edileceği için geriye pozitif bir değer döndürülecektir.

| İlk parametre değeri | İkinci parametre değeri |
|:--------------------:|:-----------------------:|
|1001'0001             |   1001'0001             |
|0001'0000             |   0001'0000             |
|1111'0001             |   1000'0000             |
|1001'0001             |   1001'0001             |


**Endianness(Big-Endian & Little-Endian)**: Tanımı ya buraya



👇 Aşağıdaki programda `memcpy` fonksiyonu ile iki `int` türünden değişkenin byte byte karşılaştırmasının nasıl yapıldığı incelenebilir, buradaki karşılaştırma işaretli tam sayı olarak karşılaştırma işlemi değildir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    100

int main(void)
{
    int x = 134658;
    int y = -524658;

    int ret = memcpy(&x, &y, sizeof(int));

    if(ret > 0){
        printf("%d > %d\n", x, y);
    }
    else if(ret < 0){
        printf("%d < %d\n", x, y);
    }
    else{
        printf("%d = %d\n", x, y);
    }
}
```


> ❔
> Sorulan soru
> İkisi float olsa tolerans mevzusu gundeme gelir mi, yoksa esitligi tespit edebilir mi?
>
> Cevap;
>
> Sadece iki float sayının tüm bitleri aynıysa eşitlik karşılaştırmasında kullanılabilir ama tek bitte bile veri kaybı olmuşsa eşitlik bozulacaktır. </br>
> Onladıklı sayılarda **not a number** bir değer var bunun için başka bir karşılaştırma yapılması gerekiyor, başka bir derste buna değinilebilir.



👇 Aşağıdaki programda `memcpy` fonksiyonu ile iki int türünden değişkenin byte byte karşılaştırmasının nasıl yapıldığı incelenebilir, buradaki karşılaştırma işaretli tam sayı olarak karşılaştırma işlemi değildir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    100

int main(void)
{
    int x = -1;
    int y = 1;

    int ret = memcpy(&x, &y, sizeof(int));

    if(ret > 0){
        printf("%d > %d\n", x, y);
    }
    else if(ret < 0){
        printf("%d < %d\n", x, y);
    }
    else{
        printf("%d = %d\n", x, y);
    }
}
```



👇 Aşağıdaki programda iki farklı dizinin elemanlarının eşitlik karşılaştırmasının `memcmp` fonksiyonuyla nasıl yapıldıği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    10

int main(void)
{
    int a[SIZE];
    int b[SIZE];

    randomize();
    set_array_random(a, SIZE);
    memcmp(b, a, sizeof a);

    if(!memcmp(a, b, sizeof a))
        printf("evet esit");
    else 
        printf("hayi esit degil");

    a[3]++;
    
    if(!memcmp(a, b, sizeof a))
        printf("evet esit");
    else 
        printf("hayi esit degil");
}
```


❗❗❗ `memcmp` fonksiyonu ile tek byte'a sığan karakter kodlamalarında yapılan karşılaştırmalar "**lexicographical compare**" yöntemine göre yapılacaktır.



👇 Aşağıdaki programda yazıların `memcmp` fonksiyonuyla belirli bir kısımlarının nasıl karşılaştırılabileceği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    10

int main(void)
{
    char s1[] = "ahmet ergin aksoy";
    char s2[] = "cettin ersoy turhan";

    if(memcmp(s1 + 6, s2 + 7, 5) < 0)
        printf("dogru\n");    
}
```


***
==================================================

✦✦✦✦✦ 11.01-11.21 birinci ara verildi. ✦✦✦✦✦

==================================================
***



👇 Aşağıdaki programda `memcmp` generic fonksiyonunun **gerçekleştiriminin(implementation)** nasıl yapıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    100

// 'memcmp' fonksiyonu kendisine gönderilen iki pointer değişkeni byte byte karşılaştırmaktadır, bu karşılaştırma 'lexicographical compare' yöntemine göre yapılmaktadır.
// Aşağıda 'memcmp' fonksiyonunun prototipi incelenebilir.
// vp1             : Karşılaştırma yapılacak birinci bellek bloğunun adresi.
// vp2             : Karşılaştırma yapılacak ikinci bellek bloğunun adresi.
// sz              : Karşılaştırma yapılacak bellek bloğunun büyüklüğü(byte olarak).
// return value    : 'lexicographical compare' yöntemine göre karşılaştırma yapılır. İlk parametrenin değeri büyükse pozitif, küçükse negatif, iki pointer'ın gösterdiği nesnelerin byte değerleri eşitse '0' değeri döndürülür.
int memcmp(const void* vp1, const void* vp2, size_t sz)
{
    // C dilinin standardında 'memcmp' fonksiyonunun karşılaştırma yapılacak 'void*' pointerların 'unsigned char*' türüne çevrilerek işlem yapılmasını belirtmektedir.
    const unsigned char* p1 = (const unsigned char*)vp1;
    const unsigned char* p2 = (const unsigned char*)vp2;

    while(sz--){
        if(*p1 != *p2)
            return *p1 > *p2 ? 1 : -1;
        ++p1, ++p2;
    }

    return 0;
}

int main(void)
{
    
}
```



🧭 Şu ana kadar `string.h` başlık dosyasındaki bellek üzerindeki byte değerleri ile işlem yapan "**memory**" sözcüğünün kısaltması olan "**mem**" ile başlayan beş adet fonksiyon aşağıdaki gibidir;
- `memset`: Bir bellek bloğunun her bir byte'ını bir tam sayı değeriyle doldurur(set ediyor).
- `memcpy`: Bir bellek bloğunu bir yerden başka bir yere kopyalar.
- `memmove`: Bir bellek bloğunu bir yerden başka bir yere kopyalar. 
- `memchr`: Bir bellek bloğunda bir byte'ın değerini aramak için kullanılıyor.
- `memcmp`: İki bellek bloğunu karşılaştırıyor.


⚠️ Şu andan itibaren konunun yarısını tamamladık ve konular biraz daha zorlaşacak.



Bir dizide "**lineer search(doğrudal arama)**" yapan adı `search_val` olan bir generic fonksiyon tasarlayınız, tanımını yazınız ve test ediniz.
- 👇 Aşağıdaki programda yukarıda istenilen `search_val` fonksiyonunun nasıl gerçekleştirildiği ve test edildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "nutility.h"

#define SIZE    100

// vpa          : İçinde arama yapılacak dizinin adresi.
// size         : İçinde arama yapılacak dizinin eleman sayısı.
// sz           : İçinde arama yapılacak dizinin elemanlarının sizeof değeri.
// key          : Aranacak değeri tutan nesnenin adresi.
// return value : Dizide aranılan değere sahip ilk tespit edilen nesnenin adresi, bulunamazsa 'NULL' değer döndürülür.
void* search_val(const void* vpa, size_t size, size_t sz, const void* key)
{
    const char* p = (const char*) vpa;

    for(size_t i = 0; i < size; ++i){
        if(!memcmp(p + i * sz, key, sz))
            return (char*)(p + i * sz);
    }

    return NULL;
}

int main(void)
{
    int ar[] = { 2, 5, 6, 7, 8, 3, 5, 8, 9, 10, 1, 4 };
    int key = 1;

    int* p = (int*)search_val(ar, asize(ar), 3, key);

    if(p){
        printf("bulundu = %d, index = %d\n", *p, p - ar);
    }
    else{
        printf("buunamadi\n");
    }
}
```


>❔
> 
> Sorulan soru; 
> 
> hocam çok temel düzelye bir login programı yazacak olursak şifre araması böyle bir fonsiyon yazarsak  kullanılabilir değil mi?
> Hocam hemen düzeltiyorum 😄 temel düzeyde bir login program yazıcaz kullanıcının parolası doğru mu sorusuna cevap olarak bu yazdığımız fonksiyonu kullanabilir miyiz?
> 
> Cevap;
> 
> Şifreyle parola terimleri yanlış kullanıldığı sık oluyormuş, bu terimleri doğru bağlamlarda kullanmak gerekiyor.



⚠️ Pointer konusunun ilk bölümü şu anda tamamlanmış oldu, buradan sonki bölüm daha zor!

## Pointer Konusunun 2. Kısmı(İlk Kısımdakinden Daha Zor Konular İçermektedir) 


🧭 Küçükten büyüğe doğru sıralama yapacak generic olan(türden bağımsız olarak) sıralama fonksiyonun yazılması istense böyle bir fonksiyonu yazılabilir mi;
- Başlangıçta bu sorunun cevabı evet olacak çünkü ilk başta "**dizinin adresini**", "**dizinin boyutu(elaman sayısını)**" ve "**dizinin tek bir elemanının byte değeri**" alınsa küçükten büyüğe doğru türü bilinmeyen bir dizinin "booble-sort" algoritmasıyla sıralanabileceği düşünülecektir.
- Sonrasında bu sorunun cevabı hayır olacak çünkü "booble-sort" algoritmasıyla ya da başka bir algoritmayla dizinin elemanlarının türünü bilmediğimiz bir durumda işaretli işaretsiz sayılarda ya da 'user defind type' ya da çok özel nesneler için `memcmp` fonksiyonu ile karşılaştırma yapmak bize her zaman doğru sonuç vermeyecektir.
- En son bu sorunun cevabı yeniden evet olacak çünkü generic olarak sıralama yapacak fonksiyon "**dizinin adresini**", "**dizinin boyutu(elaman sayısını)**", "**dizinin tek bir elemanının byte değerini**" ve "**sıralamayı yapacak olan fonksiyonun adresini**" değerlerini alarak yazılabilir.



❗❗❗ **void pointers** konusundan sonra işlenecek olan **function pointers** konusu C'nin en önemli bir kaç aracından biri olmasının dışında programlama dillinden bağımsız olarak tüm programlama dilleri için çok önemli bir araçtır. **Function pointers** aracı kullanılarak bir fonksiyon başka bir fonksiyona bir fonksiyon gönderebilir. Bir fonksiyon bir fonksiyonun çağıracağı fonksiyonu o fonksiyona geçeceği bir **function pointer** argümanla belirleyebilir.

🧠 **Callback Function**: Programlama dilinden bağımsız olarak kullanılan bir terimdir, bu terim bir fonksiyon bir fonksiyonun çağıracağı fonksiyonu o fonksiyona geçeceği bir **function pointer** argümanla belirleyebildiği durumu ifade etmektedir.

🚀 **Callback function** aracı ile bir fonksiyonun bir fonksiyona bir fonksiyon göndermesi çok sık kullanılmaktadır, hemen hemen her programda özellikle de gömülü sistem programlamada çok sık kullanılan araçlardandır.

C dili 3. kuşak bir dil olsada, C dili 3. kuşak(yüksek seviyeli) dillerin düşük seviyeli kısmında yer almaktadır.



❗❗❗ Pointer'lar konusu "**Object Pointers**" ve "**Funciton Pointers**" olarak ikiye ayrılmaktadır, biz buraya kadar sadece "**Object Pointers**" konusuyla ilgili konuları gördük, bir sonraki hafta "**Funciton Pointers**" konusuna geçilebilecek ve bu konu aşağı yukarı 5 saat kadar sürecektir.


❗❗❗ Adres değer tutan değişkenler pointer değişkenlerdir, özel olarak bir fonksiyonun adresini tutan değişkenler "**funciton pointer**" türünden değişken olarak adlandırılıyor.


❗❗❗ `qsort` fonksiyonu türden bağımsız olarak yani generic olarak sıralama yapan `stdlib.h` başlık dosyasında yer alan standart bir C fonksiyonudur, bu fonksiyon çok sık kullanılmaktadır.



👇 Aşağıdaki programda `qsort` fonksiyonunun prototipi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>

// 'qsort' fonksiyonu türden bağımsız olarak dizinin elemanlarının sıralanması işlemini yapan fonksiyon.
// _Base            : Türden bağımsız olarka sıralacak dizinin adresi.
// _NumOfElements   : Dizinin eleman sayısı.
// _SizeOfElements  : Dizinin tek bir elemanının 'sizeof' değeri(yani byte olarak kapladığı alan).
// _ConpareFunction : Sıralama işleminin yapacak fonksiyonun adres değeri.
void qsort(void* _Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCtrNonSecureSearchSorthCompareFunciton _ConpareFunction);

int main(void)
{

}
```


>❔
> 
> Sorulan soru; 
> 
> Asıl fonksiyon tur bilgisine agnostik, ama call-back fonksiyon agnostik degil, dogru mu?
> 
> Cevap;
> 
> Evet.



👇 Aşağıdaki programda `qsort` fonksiyonuyla bir dizinin nasıl sıralandığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h> // 'qsort' fonksiyonunun bildirimi bu başlık dosyasında.
#include "nutility.h"

#define SIZE    100

// 'icmp' fonksiyonu 'qsort' fonksiyonuna gönderilecek olan, sıralamanın nasıl yapılacağını belirlecek fonksiyondur.
int icmp(const void* vp1, const void* vp2)
{
    return *(const int*)vp1 - *(const int*)vp2;
}

int main(void)
{
    int a[SIZE];

    randomize();
    set_array_random(a, SIZE);
    printf_array(a, SIZE);

    qsort(a, SIZE, sizeof(int), &icmp); // Burada 'qsort' fonksiyonuna '&icmp' adres değeriyle birlikte 'icmp' adındaki fonksiyon sıralama kriteri olarak gönderiliyor.
}
```


***
==================================================

✦✦✦✦✦ 12.07-12.17 ikinci ara verildi. ✦✦✦✦✦

==================================================
***


📌 **void pointer** ve **function pointer** konuları birbiriyle ilişkili olduğu için aradan önce bu duruma değinilmiştir, **function pointer** aracını kullanmayan **generic funciton**'lar vardır, **function pointer** aracını sadece **generic funciton**'larda kullanılan bir araç değildir çok daha genel kullanımı olan bir araçtır.

❗❗❗ **void pointer** türüyle ilgili aşağıdaki bilgiler bilinmelidir;
- `void*` herhangi türden bir adres tutan bir pointer değişkendir.
- `NULL` değer alabilir. 
- `void*` bir tür olduğu gibi `const void*` türü de vardır.
-  Adres döndüren bir fonksiyonun geri dönüş türü `void*` türü olabilir.
- Dinamik bellek yönetiminde kullanılacak fonksiyonlarının(`malloc`, `calloc` vb.) geri dönüş türü `void*` türüdür.
- Sistem programlama tarafında(Unix/Linux, Windows sistem programlamada) kullanılan fonksiyonların çoğunun geri dönüş türleri `void*` türüdür.

⚠️ **void pointer** arada sırada kullanılan bir araç değildir neredeyse her C programında kullanılmaktadır. 


### `void**` Türü 


❗ `void*` bir türdür ve **generic function**'larda kullanılmaktadır, `void**` türü de vardır;
- `void**` türü de kullanılan bir türdür.
- `void*` **generic pointer** adres türüdür ama `void**` türü **generic pointer** adres türü değildir(profesyonel olarak C diliyle çalışan kişilerden de C mülakatlarında bazen `void**` türünün **generic pointer** adres türü olduğunu söyleyenler olabiliyormuş).



👇 Aşağıdaki programda `void**` türüyle ilgili bazı durumlar incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <stdio.h>
#include "nutility.h"

#define SIZE    100

int main(void)
{
    int x = 5;
    double d = 123.42;

    int* ptr = &x;
    double* dptr = &d;
    void* vptr = &x;

    // '&ptr' ifadesinin türü 'int**' türüdür.
    // '&dptr' ifadesinin türü 'double**' türüdür.
    // '&vptr' ifadesinin türü 'void**' türüdür.

    //void** vp1 = &x; // Buradaki atama işlemi yanlıştır, C++ dilinde sözdizim hatasıdır(syntax error).
    //void** vp2 = &ptr; // Buradaki atama işlemi yanlıştır, C++ dilinde sözdizim hatasıdır(syntax error).
    void** vp = &vp; // Buradaki atama işlemi doğrudur.

    // '*vp =' demek 'vptr =' demektir.
}
```


>❔
> 
> Sorulan soru?
> 
> generic bir pointer adresinin adresi midir?
> 
> Cevap;
> 
> Buradaki ifade şekli doğru değil, `void*` türünden değişkenin adresi olan bir türdür demek doğrudur.



❗❗❗👇 Aşağıdaki programda `void**` türüne değer atamayla ilgili doğru ve yanlış atama işlemleri incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <stdio.h>
#include "nutility.h"

#define SIZE    100

int main(void)
{
    int x = 5;
    double dval = 3.534;
    int* ptr = &x;
    void* vptr = &x;
    void** vp = &vptr;

    // '*vp =' demek 'vptr =' demektir.
    *VP = &dval; // Buradaki atama doğrudur çünkü atama 'vptr' türüne yapılmaktadır ve 'void*' türü herhangi bir türden adresi tutabilir.


    //void** vptr = &x; // Buradaki ilk değer verme işlemi yanlıştır çünkü 'void**' türü sadece 'void*' türünden nesnelerin adreslerini tutabilir, C++ dilinde sözdizim hatasıdır(syntax error).
    //void** vptr = &dval; // Buradaki ilk değer verme işlemi yanlıştır çünkü 'void**' türü sadece 'void*' türünden nesnelerin adreslerini tutabilir, C++ dilinde sözdizim hatasıdır(syntax error). 
    void** vptr = &vp;
}
```



👇 Aşağıdaki programda `void**` türüne değer atamayla ilgili doğru ve yanlış atama işlemleri incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <stdio.h>
#include "nutility.h"

#define SIZE    100

int main(void)
{
    int x = 5;
    double dval = 3.6;
    void* vp = &x;
    int* ip = &x;

    //void** vptr = &x; // Buradaki ilk değer verme işlemi yanlıştır çünkü 'void**' türü sadece 'void*' türünden nesnelerin adreslerini tutabilir, C dilinde derleyici uyarı verir, C++ dilinde sözdizim hatası(syntax error) oluşur.
    //void** vptr = &ip; //Buradaki ilk değer verme işlemi yanlıştır çünkü 'void**' türü sadece 'void*' türünden nesnelerin adreslerini tutabilir, C dilinde derleyici uyarı verir, C++ dilinde sözdizim hatası(syntax error) oluşur.
    void** vptr = &vp; // Bu atama işlemi doğrudur, 'void**' türü sadece 'void*' türünden değişkenlerin adresini tutabilir.
}
```


>❔
> 
> Sorulan soru; 
> 
> `void** vptr = &(&x);` R-value'dan dolayi gecersiz degil mi?
> 
> Cevap;
> 
> `&(&x)` ifadesinde `&` operatörü operandı sadece "L-value" kategorisinden olabileceği için ve `&x` ifadesinin kategorisi de "R-value" olduğu için `&(&x)` ifadesi sözdizim hatasıdır(syntax error).
>  
> "Değişkenin adresinin adresi" tümcesi hatalıdır, "Değişkenin adresini tutan değişkenin adresi" tümcesi doğrudur.
> 
> C dilinde çalışma zamanında bir değişkenin adresi değiştirilemez, değişkenlerin adreslerinin ne olacağına yazılmış olan C programı karar vermiyor.


❗❗❗ `void**` türünden bir değişken sadece `void*` türünden bir değişkenin adresini tutmak için kullanılıyor bundan başka hiç bir amacı yoktur ama `void**` türünün bir çok kullanım alanı vardır.



👇 Aşağıdaki programda `void**` türünün kullanım senaryolarından biri, çok basit bir şekilde incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <stdio.h>
#include "nutility.h"

#define SIZE    100

//Aşağıdaki 'foo' foonksiyonu kendisini çağıracak koda output parameter olarak aldığı 'void** vptr' parametresi üzerinden geriye 'void*' türünden bir nesnenin adresini döndürebilir.
int foo(int x, int y, void** vptr)
{
    // *vptr = herhangi bir türden adres;
}

int main(void)
{
    void* vp;
    
    foo(12, 43, &vp);
}
```



❗❗❗ 👇 Aşağıdaki program `void**` türünden bir değişkenin hangi değerleri tutup hangilerini tutamayacağını anlamak için incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <stdio.h>
#include "nutility.h"

#define SIZE    100

int main(void)
{
    int* p1 = NULL;
    double* p2 = NULL;
    void* vp = NULL;
    void** vptr = NULL;
    int** iptr = NULL;

    void* p;
    int x = 5;
    ++x;

    // Aşağıdaki atamaların hepsi doğrudur;
    p = p1;
    p = &p1;
    p = p2;
    p = &p2;
    p = vp;
    p = &vp;
    p = vptr;
    p = &vptr;
    p = iptr;
    p = &iptr;
    p = &p;


    void** px;
    int x = 5;
    ++x;

    // Aşağıdaki atamaların sadece iki tanesi doğrudur gerisi hatalıdır;
    //px = p1;
    //px = &p1;
    //px = p2;
    //px = &p2;
    px = vp; // Bu atama doğrudur.
    px = &vp; // Bu atama doğrudur.
    //px = vptr;
    //px = &vptr;
    //px = iptr;
    //px = &iptr;
    //px = &px;
}
```



👇 Aşağıdaki programda `void*` türünden bir dizinin nasıl tanımlandığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <stdio.h>
#include "nutility.h"

#define SIZE    100

int main(void)
{
    int x = 0;
    double d = 2.3;
    char str[] = "adil";
    void* vptr = NULL;
    int* ip = NULL;

    void* p[10] = { &x, &d, str, vptr, &vptr, ip, &ip }; // Bu şekilde bir dizi ilklendirme sözdizimi kullanılabilir.
}
```



👇 Aşağıdaki programda fonksiyonların geri dönüş türlerinin ne olabileceği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <stdio.h>
#include "nutility.h"

#define SIZE    100

int f1(void);
int* f2(void);
int** f3(void);
int*** f4(void);
void f5(void);
void* f6(void);
void** f7(void);

int main(void)
{
    void** a[10]; // 'void**' türünden elemanları olan diziler de tanımlanır ama kullanım alanları çok sınırlıdır. 
}
```


## Function Pointers Giriş 

C dilinde göstericiler iki türe ayrılmaktadır;
1. **Object Pointers**: Değişkenlerin adresleri.
2. **Function Pointers**: Fonksiyonların adresleri.

Fonksiyonların adreslerinin türlerinin ne olacağına dilin tasarımını yapanlar(mülküyetsiz dillerde bir komisyon, mülküyetli dillerde bir firmanın kendi çalışan kadrosu) karar vermektedir.

C dilinde fonksiyon adreslerinin türleri aşağıdaki bilgilere göre belirlenmektedir;
- Fonksiyonların parametre değişkeni sayısı.
- Fonksiyonların parametre değişkenlerinin herbirinin türü.
- Geri dönüş değerinin türü.


👇 Aşağıdaki programda bildirilmiş(declare) olan bazı fonksiyonların adreslerinin türlerinin aynı mı yoksa farklı mı olacağı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <stdio.h>
#include "nutility.h"

// Aşağıdaki 'foo' ve 'bom' fonksiyonlarının adreslerinin türü aynıdır.
int foo(int);
int bom(int);

// Aşağıdaki 'bar' ve 'baz' fonksiyonlarının adreslerinin türü farklıdır.
double bar(double);
double baz(int, int);

int main(void)
{

}
```


C ve C++ dillerinde fonksiyonlara ilişkin iki farklı adres türü vardır;
1. **Function Type**: Bir fonksiyonun türü şu şekilde "**GERİ_DÖNÜŞ_TÜRÜ(PAREMETRELERİNİN_TÜRÜ)**" belirleniyor.
    - `int foo(int);` fonksiyonunun türü `int(int)` türüdür.
    - `long bom(int, double);` fonksiyonunun türü `long(int, double)` türüdür.
    - "strcmp" fonksiyonunun türü `int(const char*, const char*)` türüdür.
2. **Funciton Pointer Type**: Bir fonksiyonunun adresinin türü şu şekilde "**GERİ_DÖNÜŞ_TÜRÜ (*)(PAREMETRELERİNİN_TÜRÜ)**" belirleniyor.
    - `int foo(int);` fonksiyonunun fonksiyon adresi türü yani `&foo` ifadesinin türü `int (*)(int)` türüdür.
    - `int func(int, double, int);` fonksiyonunun fonksiyon adresi türü yani `&func` ifadesinin türü `int (*)(int, double, int)` türüdür.
    - C dilinin standart fonksiyonlarından olan `strlen` fonksiyon adresinin türü `size_t (*)(const char*)` türüdür.
    - C dilinin standart fonksiyonlarından olan `isupper` fonksiyon adresinin türü `int (*)(int)` türüdür.
    - C dilinin standart fonksiyonlarından olan `strcmp` fonksiyon adresinin türü `int (*)(const char*, const char*)` türüdür.


❗❗❗ Bir fonksiyonun geri dönüş değerinin türü farklı(fonksiyon çağrısının türü de diyebiliriz), bir fonksiyonun kendi türü farklı, bir fonksiyonun adresinin türü farklı şeylerdir! 


Ders sonu ...
