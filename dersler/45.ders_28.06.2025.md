# 45.Ders 28.06.2025 ğŸ•˜

Derse 7(09:03)-10(09:09)-11(10:01)-10(10:35)-11(10:45)-11(11:01)-11(11:45)-11(12:07)-10(12:59) kiÅŸi katÄ±ldÄ±.
---


## Structor Objects and Addresses(YapÄ± Nesneleri ve Adresler) 


ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir yapÄ± tÃ¼rÃ¼nÃ¼n ve o yapÄ± tÃ¼rÃ¼nÃ¼n gÃ¶stericisinin bellekte ne kadarlÄ±k bir byte kapladÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>

struct Person{
    int id;
    int age;
    double wage;
    char name[20];
    char surname[20];
};

int main(void)
{
    struct Person per;
    struct Person* ptr = &per; // Buradaki 'ptr' deÄŸiÅŸkeni 'struct Person' tÃ¼rÃ¼nden bir nesnenin adresini tutacaÄŸÄ± iÃ§in tÃ¼rÃ¼ 'struct Person*' tÃ¼rÃ¼nden olan bir 'object pointer' varlÄ±ktÄ±r.

    printf("sizeof(int*) = %zu\n", sizeof(int*));

    printf("sizeof(struct Person) = %zu\n", sizeof(struct Person));
    printf("sizeof(per) = %zu\n", sizeof(per)); // Burada kullanÄ±lan 'sizeof(per)' ile 'sizeof(struct Person)' ifadesi(expression) aynÄ± deÄŸeri Ã¼retecektir.

    printf("sizeof(struct Person*) = %zu\n", sizeof(struct Person*));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir yapÄ± nesnesinin gÃ¶stericisi Ã¼zerinden o yapÄ±nÄ±n Ã¼yelerine nasÄ±l eriÅŸilebildiÄŸi incelenebilir.
```C
#include <stdio.h>

struct Person{
    int id;
    int age;
    double wage;
    char name[20];
    char surname[20];
};

int main(void)
{
    struct Person per;

    struct Person* ptr = &per;

    //*ptr.wage; // Derleyici burada sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur Ã§Ã¼nkÃ¼ operatÃ¶r Ã¶nceliÄŸinden dolayÄ± '.' operatÃ¶rÃ¼ Ã¶ncelikli olacaÄŸÄ± iÃ§in buradaki ifade '*(ptr.wage)' olarak yorumlanacak ve '*' operatÃ¶rÃ¼ne adres dÄ±ÅŸÄ±nda bir operand verilmek istendiÄŸi iÃ§in sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.
    (*ptr).wage; // Burada yapÄ± nesnesinin gÃ¶stericisi Ã¼zerinden yapÄ±nÄ±n Ã¼yelerine eriÅŸim iÃ§in '.' operatÃ¶rÃ¼nÃ¼n nasÄ±l kullanÄ±labileceÄŸi gÃ¶rÃ¼lebilir, fakat bu ÅŸekilde yazÄ±nca yapÄ±nÄ±n Ã¼yelerine eriÅŸmek iÃ§in Ã¼Ã§ operatÃ¶r kullanÄ±lmasÄ± gerekiyor, bunu daha kÄ±sa olarak aÅŸaÄŸÄ±daki gibi ifade edebiliriz.
    ptr->wage; // Burada '->' operatÃ¶rÃ¼nÃ¼n sol operatÃ¶rÃ¼nÃ¼n bir yapÄ± nesnesinin adresi olmak zorundadÄ±r, saÄŸ operandÄ±nÄ±n ise yapÄ± nesnesinin Ã¼yelerinden birinin adÄ± olmak zorunda.
}
```



â—â—â— `->` operatÃ¶rÃ¼nÃ¼n sol operatÃ¶rÃ¼nÃ¼n **bir yapÄ± nesnesinin adresi** olmak zorundadÄ±r.


â—â—â— `->` operatÃ¶rÃ¼nÃ¼n sol operandÄ± bir yapÄ± nesnesinin adresini tutan bir pointer deÄŸiÅŸken olmak zorunda deÄŸildir, sol operand **bir yapÄ± nesnesinin adresi** olmak zorundadÄ±r, adres olan herhangi bir **L-value** ya da **R-value** ifade sol operand olabilir, burayÄ± anlamak Ã§ok Ã¶nemlidir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `->` operatÃ¶rÃ¼nÃ¼n sol operandÄ±nÄ±n neler olabileceÄŸi incelenebilir.
```C
#include <stdio.h>

struct Person{
    int id;
    char name[20];
    char surname[20];
};

int main(void)
{
    struct Person per = { 5612, "ad", "soyad" };

    // AÅŸaÄŸÄ±daki gibi iki farklÄ± biÃ§imde bir yapÄ± nesnesi elemanlarÄ±na eriÅŸilebilir.
    (&per)->id = 8754;
    per.id = 342;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `struct Person` tÃ¼rÃ¼nden bir dizi nesnesinin adÄ±nÄ±n kullanÄ±ldÄ±ÄŸÄ±nda **array to pointer conversion** uygulanmasÄ±ndan dolayÄ± dizi adÄ±nÄ±n dizinin ilk elemanÄ±nÄ±n adresine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼ldÃ¼ÄŸÃ¼ incelenebilir.
```C
#include <stdio.h>

struct Person{
    int id;
    char name[20];
    char surname[20];
};

int main(void)
{
    struct Person per ar[5];

    // AÅŸaÄŸÄ±daki iki statamnet legal'dir, kullanÄ±mÄ± doÄŸrudur ve aynÄ± anlama gelmektedir.
    ar-> = 123;
    ar[0].id = 123;

    // AÅŸaÄŸÄ±daki iki statamnet legal'dir, kullanÄ±mÄ± doÄŸrudur ve aynÄ± anlama gelmektedir.
    (ar + 3)->id = 45;
    ar[3].id = 45;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir fonksiyon Ã§aÄŸrÄ±sÄ±yla oluÅŸturulan ifadelerin tÃ¼rlerinin ne olduÄŸu ve bir fonksiyon Ã§aÄŸrÄ±sÄ± ifadesinin farklÄ± biÃ§imde nasÄ±l kullanÄ±labileceÄŸi incelenebilir.
```C
#include <stdio.h>

struct Person{
    int id;
    char name[20];
    char surname[20];
};

int foo1(void);
int* foo2(void);
struct Person* foo3(void);

int main(void)
{
    foo1(); // Buradaki 'foo1()' ifadesinin tÃ¼rÃ¼ 'int' tÃ¼rÃ¼dÃ¼r.
    foo2(); // Buradaki 'foo2()' ifadesinin tÃ¼rÃ¼ 'int*' tÃ¼rÃ¼dÃ¼r.
    foo(); // Buradaki 'foo2()' ifadesinin tÃ¼rÃ¼ 'struct Person*' tÃ¼rÃ¼dÃ¼r.

    // AÅŸaÄŸÄ±daki iki statement ta aynÄ± anlama gelmektedir.
    foo()->id = 2342; // '()' ve '->' operatÃ¶rleri birinci Ã¶ncelik seviyesinde ve Ã¶ncelik yÃ¶nÃ¼ soldan saÄŸa doÄŸru olduÄŸu iÃ§in ilk Ã¶nce fonksiyon Ã§aÄŸrÄ± operatÃ¶rÃ¼nÃ¼ iÅŸletecek ardÄ±ndan yapÄ± Ã¼yesine eriÅŸim operatÃ¶rÃ¼ iÅŸletecek makine kodu oluÅŸturulacaktÄ±r.
    (*foo()).id = 2342; // Buradaki bir bir statement ile neredeyse hiÃ§ karÅŸÄ±laÅŸÄ±lmayacaktÄ±r ama dilin kurallarÄ±nÄ±n iyi Ã¶ÄŸrenilebilmesi iÃ§in gÃ¶sterilmiÅŸtir.
}
```


ğŸ“Œ C programlarÄ±nda yapÄ± nesnesi adresi dÃ¶ndÃ¼ren fonksiyonlarla Ã§ok sÄ±k karÅŸÄ±laÅŸacaktÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir yapÄ± tÃ¼rÃ¼nÃ¼n bellek boyutunun ne olduÄŸu incelenebilir.
```C
#include <stdio.h>

struct Person{
    int id;
    char name[16];
    char surname[20];
    char address[24];
};

struct Person* foo(void);

int main(void)
{
    printf("sizeof(struct Person) = %zu\n", sizeof(struct Person));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir yapÄ± tÃ¼rÃ¼nden elemanlarÄ± olan dizinin herbir elemanÄ±nÄ±n bellekte hangi adreste yeralacaÄŸÄ± Ã§alÄ±ÅŸma zamanÄ±nda incelenebilir.
```C
#include <stdio.h>

struct Nec{
    int x, y, z, t;
};

struct Person* foo(void);

int main(void)
{
    printf("sizeof(struct Nec) = %zu\n", sizeof(struct Nec));

    struct Nec ar[10];

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile 'struct Nec' tÃ¼rÃ¼nden nesnelere sahip olan dizinin herbir elemanÄ±nÄ±n bellek adresinin ne olduÄŸu Ã§alÄ±ÅŸma zamanÄ±nda gÃ¶rÃ¼lebilir.
    for(int i = 0; i < 10; ++i){
        printf("%p %p \n", &ar[i], ar + i);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir yapÄ± tÃ¼rÃ¼nden elemanlarÄ± olan dizinin herbir elemanÄ±nÄ±n bellekte hangi adreste yeralacaÄŸÄ± Ã§alÄ±ÅŸma zamanÄ±nda incelenebilir.
```C
#include <stdio.h>

struct Nec{
    int x, y, z, t;
};

struct Person* foo(void);

int main(void)
{
    printf("sizeof(struct Nec) = %zu\n", sizeof(struct Nec));

    struct Nec ar[10];
    struct Nec* ptr = ar;

    for(int i = 0; i < 10; ++i){
        printf("%p %p %p \n", &ar[i], ar + i, ptr++); // ÃœÃ§ ifade de aynÄ± adresi gÃ¶sterecektir, burayÄ± anlamak Ã¶nemlidir.
    }
}
```


## YapÄ± Nesneleriyle Ä°lgili Ä°ÅŸlem Yapan Fonksiyonlar 

OkuyacaÄŸÄ±mÄ±z ve yazacaÄŸÄ±mÄ±z C kodlarÄ±nda yapÄ± nesneleriyle ilgili kodlar olacaktÄ±r, yapÄ±larÄ±n kullanÄ±lmadÄ±ÄŸÄ± C projelerinin olma ihtimali Ã§ok dÃ¼ÅŸÃ¼ktÃ¼r, bu nedenden dolayÄ± yapÄ± nesnelerini iyi Ã¶ÄŸrenmek gerekmektedir.


### Bir Fonksiyonun Parametrelerinin Bir YapÄ± Nesnesi OlduÄŸu Durumlar

ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir yapÄ± tÃ¼rÃ¼nÃ¼ kullanan `print_invoice` fonksiyonunun bildiriminin nasÄ±l olduÄŸu incelenebilir.
```C
#include <stdio.h>

// accounting.h

struct Invoice{
    int no;
    // ...
};

void print_invoice(const struct Invoice*);
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program yapÄ± tÃ¼rÃ¼nden bir nesne alan ve yapÄ± tÃ¼rÃ¼nÃ¼n gÃ¶stericisi tÃ¼rÃ¼nden bir nesne alan fonksiyon kullanÄ±mlarÄ±ndaki farklarÄ±n anlaÅŸÄ±lmasÄ± iÃ§in incelenebilir.
```C
#include <stdio.h>

struct Person {
    int id;
    char name[20];
    char surname[20];
};


// AÅŸaÄŸÄ±daki gibi 'struct' nesnesi alan bir fonksiyon oluÅŸturulmasÄ± Ã§oÄŸu zaman tercih edilmez Ã§Ã¼nkÃ¼ buradaki fonksiyon her Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ±nda yapÄ± nesnesinin bellek bloÄŸu kadarlÄ±k bir kopyalama maliyeti olur.
void print_person_v1(struct Person x)
{
    printf("%d %s %s\n", x.id, x.name, x.surname);
}

// AÅŸaÄŸÄ±daki fonksiyonda 'struct Person' tÃ¼rÃ¼nden bir yapÄ± nesnesinin adresi parametre olarak alÄ±nmaktadÄ±r, bu kullanÄ±mda kopyalama maliyeti her durumda(yapÄ± nesnesi ne olursa olsun) sabit olarak sistemdeki(projenin Ã¼zerinde Ã§alÄ±ÅŸacaÄŸÄ± mimari) gÃ¶sterici tÃ¼rlerinin byte boyutu kadardÄ±r. 
void print_person_v2(const struct Person *ptr)
{
    printf("%d %s %s\n", ptr->id, ptr->name, ptr->surname);
}


int main(void)
{
    struct Person per = { 1234, "ad", "soyad" };
    print_person_v1(per); // BÃ¶yle bir fonksiyon Ã§aÄŸrÄ±sÄ± kopyalama maliyetinden dolayÄ± tercih edilmez.

    print_person_v2(&per); // Buradaki fonksiyon Ã§aÄŸrÄ±sÄ±nda kopyalama maliyeti sadece pointer tÃ¼rÃ¼nÃ¼n boyutu kadardÄ±r.
}
```



â—â—â— Bir fonksiyonun parametresi bir yapÄ± tÃ¼rÃ¼ olabilir fakat bu durumda ilgili fonksiyonun bir yapÄ± nesnesiyle Ã§aÄŸÄ±rÄ±lmasÄ± gerekir yani bu bir **call by value** Ã§aÄŸrÄ±sÄ±dÄ±r ve parametresi bir yapÄ± tÃ¼rÃ¼nden olan bir fonksiyona yapÄ±lan Ã§aÄŸrÄ±da tek geÃ§erli argÃ¼man ifadesi aynÄ± tÃ¼rden bir yapÄ± nesnesi olabilir, bu da bir blok kopyalamasÄ±na neden olur.



ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki gibi bellek boyutu fazla olmayan `struct Point` tÃ¼rÃ¼nÃ¼n bellek boyutu incelenebilir, buradaki yapÄ± tÃ¼rÃ¼ gibi bellek boyutu fazla olmayan tÃ¼rlerden nesneleri parametre olarak alan fonksiyon bildirimlerinin yazÄ±lmasÄ±nda kopyalama maliyeti olmayacaktÄ±r, kopyalama maliyeti bellek boyutu bÃ¼yÃ¼k yapÄ± tÃ¼rlerinde olmaktadÄ±r.
```C
#include <stdio.h>

struct Point {
    float f1;
    float f2;
};

int main(void)
{
    printf("sizeof(struct Point) = %zu\n", sizeof(struct Point));
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda C++ dilinde yazÄ±lmÄ±ÅŸ olan programda `std::my19937` tÃ¼rÃ¼nden bir nesnenin bellek boyutunun 5000 byte olduÄŸu incelenebilir. Buradaki program herhangi bir tÃ¼rÃ¼n bellek boyutunun Ã§ok bÃ¼yÃ¼k olabileceÄŸini gÃ¶rmek iÃ§in yazÄ±lmÄ±ÅŸtÄ±r.
```C++
#include <stdio.h>
#include <random>

void foo(std::my19937);

int main(void)
{
    printf("sizeof(my19937) = %zu\n", sizeof(std::my19937)); // Burada 'std::my19937' bellek boyutunun '5000' olduÄŸu gÃ¶rÃ¼lecektir.

    std::my19937 eng;
    foo(eng); // Burada 5000 byte bÃ¼yÃ¼klÃ¼ÄŸÃ¼ndeki bellek bloÄŸu kopyalanacaktÄ±r, bu maliyet Ã§ok fazla.
}
```


ğŸ“Œ Bazen C dilinde derin bilgiye sahip olmayan kiÅŸiler aynÄ± iÅŸi yapan C ya da C++ programÄ± ve baÅŸka bir programlama dilindeki programÄ± karÅŸÄ±laÅŸtÄ±rabiliyor ve yaptÄ±klarÄ± karÅŸÄ±laÅŸtÄ±rmadan C diliyle yazÄ±lmÄ±ÅŸ programÄ±nÄ±n daha yavaÅŸ Ã§alÄ±ÅŸtÄ±ÄŸÄ± sonucuna varabiliyor ama burada yazÄ±lan C programÄ±nÄ±n performanslÄ± olacak ÅŸekilde yazÄ±lmama ihtimali Ã§ok yÃ¼ksek, mesela bellek bloÄŸu kopyalama durumlarÄ±na dikkat edilmediyse C programÄ±nÄ±n yavaÅŸ Ã§alÄ±ÅŸma durumu oluÅŸabilir.

Bir yapÄ± nesnesi bir fonksiyona kopyalanarak ya da o yapÄ± nesnesinin adres deÄŸeri ile gÃ¶nderilebilir, `void print_person(struct Person);` burada yapÄ± nesnesi kopyalanacaktÄ±r ama `void set_random_person(struct Person *p);` burada yapÄ± nesnesinin adresi fonksiyona geÃ§iliyor.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda kopyalama maliyeti dÃ¼ÅŸÃ¼k ÅŸekilde yapÄ± nesnelerinin fonksiyonlarla nasÄ±l kullanÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

struct Person {
    int id;
    char name[20];
    char surname[20];
};

// AÅŸaÄŸÄ±daki fonksiyon 'p' adÄ±nda 'struct Person*' gÃ¶sterici tÃ¼rÃ¼nden argÃ¼man alan mutater bir fonksiyondur, fonksiyonun toplam kopyalama maliyeti '3 * (gÃ¶sterici deÄŸiÅŸkenlerin bellek byte bÃ¼yÃ¼klÃ¼ÄŸÃ¼)' 
void set_person(struct Person* p, int id, const char* pname, const char* psurname)
{
    p->id = id;
    strcpy(p->name, pname);
    strcpy(p->surname, psurname);
}

// AÅŸaÄŸÄ±daki 'print_person' adÄ±ndaki fonksiyon dÄ±ÅŸarÄ±dan alacaÄŸÄ± 'const struct Person*' tÃ¼rÃ¼nden nesnenin gÃ¶sterdiÄŸi adresteki 'struct Person' nesnesinin Ã¼yelerinin bilgilerini yazÄ± formatÄ±nda 'standad output'a gÃ¶nderir.
void print_person(const struct Person* ptr)
{
    printf("%d %s %s\n", ptr->id, ptr->name, ptr->surname);
}

int main(void)
{
    struct Person per;
    set_person(&per, 2412, "cavit", "kara");
    print_person(&per);

    set_person(&per, 2412, "eren", "gÃ¼ven");
    print_person(&per);
}
```

ğŸ“Œ C dili kendi doÄŸasÄ± gereÄŸi donanÄ±ma yakÄ±n bir dil olmasÄ±ndan dolayÄ± fonksiyonlara sÄ±klÄ±kla yapÄ± nesnelerinin adreslerinin, fonksiyonlarÄ±n adreslerinin geÃ§iliyor olduÄŸu gÃ¶rÃ¼lecektir, bu yÃ¶nÃ¼yle C dilinde yapÄ±labilen soyutlama bir Ã§ok dile gÃ¶re daha kÄ±sÄ±tlÄ±dÄ±r. Fakat C dili dÃ¼nyada en Ã§ok kullanÄ±lan programlama dilidir.


### Bir Fonksiyonun Geri DÃ¶nÃ¼ÅŸ DeÄŸerinin Bir YapÄ± Nesnesi OlduÄŸu Durumlar 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `create_person` adÄ±ndaki fonksiyonun geri dÃ¶nÃ¼ÅŸ tÃ¼rÃ¼nÃ¼n yapÄ± tÃ¼rÃ¼ olabildiÄŸi gÃ¶rÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

struct Person {
    int id;
    char name[20];
    char surname[20];
};

// AÅŸaÄŸÄ±daki gibi 'struct' nesnesi alan bir fonksiyon Ã§oÄŸu zaman tercih edilmez Ã§Ã¼nkÃ¼ yapÄ± nesnesinin bellek bloÄŸu kadarlÄ±k bir kopyalama maliyeti vardÄ±r.
void set_person(struct Person* p, int id, const char* pname, const char* psurname)
{
    p->id = id;
    strcpy(p->name, pname);
    strcpy(p->surname, psurname);
}

void print_person(const struct Person* ptr)
{
    printf("%d %s %s\n", ptr->id, ptr->name, ptr->surname);
}


struct Person create_person(void);

int main(void)
{
    struct Person per;
    
    // some code here ...

    per = create_person(); // Burada iki tane atama nesne kopyalama yapÄ±lmaktadÄ±r, biri fonksiyondan dÃ¶nen deÄŸerin kopyalanmasÄ± ve diÄŸeri 'per' deÄŸiÅŸkenine yapÄ±lan kopyalama iÅŸlemi. Derleyiciler ilk deÄŸer verme durumlarÄ±nda iki tane kopyalama varsa onu tek bir kopyalamaya dÃ¼ÅŸÃ¼recek ÅŸekilde iyileÅŸtirme yapÄ±lmaktadÄ±r.
    /*
        // return expt; // Fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸeri fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±lan yere gÃ¶nderilecektir.

        struct Person ret = expt; // Fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸerinin fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±lan yere kopyalanmasÄ± iÅŸlemi ilk kopyalama iÅŸlemidir.
        per = ret; // Fonksiyondan dÃ¶nen deÄŸer 'per' nesnesine kopyalanÄ±yor, bu da ikinci kopyalama iÅŸlemidir.
    */
}
```


ğŸ§  Derleyiciler ilk deÄŸer verme iÅŸlemlerinde fonksiyon Ã§aÄŸrÄ±larÄ±ndan dÃ¶nen deÄŸerler ilk deÄŸer olarak nesnelere verildiÄŸinde burada yapÄ±lacak olan iki tane atama iÅŸlemini tek atama iÅŸlemine dÃ¶nÃ¼ÅŸtÃ¼rebiliryorlar ama ilk deÄŸer verme iÅŸlemi dÄ±ÅŸÄ±nda bunu yapmÄ±yorlar diye anladÄ±m.


â­ FonksiyonlarÄ±n geri dÃ¶nÃ¼ÅŸ tÃ¼rÃ¼nÃ¼n `struct Person foo(void);` bu fonksiyon bildirimindeki gibi yapÄ± tÃ¼rÃ¼ olma olasÄ±lÄ±ÄŸÄ± kopyalama maliyetinin olmasÄ±ndan dolayÄ± dÃ¼ÅŸÃ¼ktÃ¼ ancak ufak bellek boyutuna sahip nesneler iÃ§in karÅŸÄ±laÅŸÄ±labilir. </br>
â­ C dilinde yazÄ±lmÄ±ÅŸ olan programlarda fonksiyonlarÄ±n geri dÃ¶nÃ¼ÅŸ tÃ¼rÃ¼nÃ¼n `struct Person* bar(void);` bu fonksiyon bildirimindeki gibi yapÄ± nesnesi adresi tÃ¼rÃ¼ olduÄŸu durumlarla Ã§ok sÄ±k karÅŸÄ±laÅŸÄ±lacaktÄ±r.


â—â—â— DiÄŸer derslerden de bildiÄŸimiz gibi, bir fonksiyondan geriye dÃ¶ndÃ¼rÃ¼len deÄŸerin **otomatic storage duration** oluÅŸu **ub** durumuna neden olacaktÄ±r ve bÃ¶yle bir kullanÄ±mdan kaÃ§Ä±nÄ±lmalÄ±dÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda geriye bir yapÄ± nesnesinin adresini dÃ¶ndÃ¼ren bir fonksiydan geriye dÃ¶ndÃ¼rÃ¼len yapÄ± nesnesinin **otomatic storage duration** olmasÄ± durumunun tanÄ±msÄ±z davranÄ±ÅŸ olduÄŸu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

struct Person {
    int id;
    char name[20];
    char surname[20];
};

// AÅŸaÄŸÄ±daki fonksiyondan geriye dÃ¶ndÃ¼rÃ¼len yapÄ± nesnesi otomatic Ã¶mÃ¼rlÃ¼dÃ¼r bu nedenle 'ub' durumu oluÅŸmasÄ±na neden olur, bu biÃ§imde bir fonksiyon yazÄ±lmamalÄ±dÄ±r.
struct Person* create_person(int id, const char* pname, const char* psurname)
{
    struct Person ret;

    ret.id = id;
    strcpy(ret.name, pname);
    strcpy(ret.surname, psurname);

    return &ret; // Burada adresi dÃ¶ndÃ¼rÃ¼len nesne 'otomatic Ã¶mÃ¼rlÃ¼' bir nesne olduÄŸu iÃ§in bu adresin bir ÅŸekilde fonksiyonu Ã§aÄŸÄ±ran yerde kullanÄ±lmasÄ± tanÄ±msÄ±z davranÄ±ÅŸa neden olacaktÄ±r.
}

void print_person(const struct Person* ptr)
{
    printf("%d %s %s\n", ptr->id, ptr->name, ptr->surname);
}

int main(void)
{
    struct Person* per = create_person(4232, "suha", "dincer"); // 'create_person' fonksiyonundan geriye dÃ¶ndÃ¼rÃ¼len nesne 'otomatic Ã¶mÃ¼rlÃ¼' bir nesnedir.
    print_person(per); // Buradaki 'per' gÃ¶sterici nesnesi 'dangling pointer' durumundadÄ±r. Microsoft derleyicisi burada 'warnging C4172: returning address of local variable or temporary : ret' uyarÄ±sÄ±nÄ± verecektir.
}
```


ğŸ§  Derleyicilerin uyarÄ± iletilerini "**Treat warning as a error**" gibi bir anahtar(switch) oluyor, bu anahtarÄ± aÃ§arak uyarÄ±larÄ±n da hata olmasÄ± saÄŸlanmÄ±ÅŸ olur.



â—â—â— YapÄ± nesnesi adresi dÃ¶ndÃ¼ren fonksiyonlar tanÄ±msÄ±z davranÄ±ÅŸa neden olmamak iÃ§in aÅŸaÄŸÄ±daki Ã¶mÃ¼r Ã¶zelliÄŸine sahip bir nesne dÃ¶ndÃ¼rebilir;
1. Static Ã¶mÃ¼rlÃ¼ nesne adresi dÃ¶ndÃ¼rebilir.
    1. Static Ã¶mÃ¼rlÃ¼ gloabal deÄŸiÅŸken adresi dÃ¶ndÃ¼rebilir.
    2. Static Ã¶mÃ¼rlÃ¼ local deÄŸiÅŸken adresi dÃ¶ndÃ¼rebilir.
2. Dinamik Ã¶mÃ¼rlÃ¼ nesne adresi dÃ¶ndÃ¼rebilir.
3. Ã‡aÄŸÄ±ran koddan alÄ±nan nesne adresini dÃ¶ndÃ¼rebilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda geriye **static storage duration** Ã¶zellikteki bir yapÄ± nesnesi dÃ¶ndÃ¼ren fonksiyonlarÄ±n kullanÄ±mÄ± incelenebilir, bu fonksiyonlardan geriye dÃ¶ndÃ¼rÃ¼len yapÄ± nesnelerinin kullanÄ±lmasÄ±nda bir sorun oluÅŸmamaktadÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

struct Person {
    int id;
    char name[20];
    char surname[20];
};

struct Person ret;

// AÅŸaÄŸÄ±daki fonksiyondan geriye dÃ¶ndÃ¼rÃ¼len yapÄ± nesnesi static Ã¶mÃ¼rlÃ¼ global nesnedir, bu fonksiyonun kullanÄ±mÄ±nda hata yoktur.
struct Person* create_person1(int id, const char* pname, const char* psurname)
{
    ret.id = id;
    strcpy(ret.name, pname);
    strcpy(ret.surname, psurname);

    return &ret;
}


// AÅŸaÄŸÄ±daki fonksiyondan geriye dÃ¶ndÃ¼rÃ¼len yapÄ± nesnesi static Ã¶mÃ¼rlÃ¼ local nesnedir, bu fonksiyonun kullanÄ±mÄ±nda hata yoktur.
struct Person* create_person2(int id, const char* pname, const char* psurname)
{
    static Person ret_local;

    ret_local.id = id;
    strcpy(ret_local.name, pname);
    strcpy(ret_local.surname, psurname);

    return &ret_local;
}

void print_person(const struct Person* ptr)
{
    printf("%d %s %s\n", ptr->id, ptr->name, ptr->surname);
}

int main(void)
{
    struct Person* per = create_person1(4232, "suha", "dincer");
    print_person(per);
    
    struct Person* per = create_person2(4232, "sulhan", "dereci");
    print_person(per);
}
```


**Factory Function**: Kendisine Ã§aÄŸrÄ± yapan koda yani bir dinamik Ã¶mÃ¼rlÃ¼ nesne oluÅŸturup, o nesneyi yeni deÄŸer ya da deÄŸerlerle donatÄ±p geriye dÃ¶nen fonksiyonlara fabriya konksiyonu deniliyor. [Buradan fabrika fonksiyonu ile ilgili diÄŸer bakÄ±ÅŸ aÃ§Ä±sÄ±ndan fikir edinilebilir](https://chatgpt.com/share/6862a524-4eb8-800a-89c3-704825d7a9d8).



ğŸ‘‡ AÅŸaÄŸÄ±daki programda dinamik bellek ile yapÄ± nesnesi Ã¼retecek olan bir fonksiyonda bellekten yer alÄ±nÄ±rken hata olmasÄ± durumunda ne yapÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

struct Person {
    int id;
    char name[20];
    char surname[20];
};

// AÅŸaÄŸÄ±daki fonksiyondan geriye dÃ¶ndÃ¼rÃ¼len yapÄ± nesnesi dinamik Ã¶mÃ¼rlÃ¼dÃ¼r.
struct Person* create_person(int id, const char* pname, const char* psurname)
{
    struct Person* ptr = (struct Person*)malloc(sizeof(struct Person));

    // Bellekten yer ayÄ±rma iÅŸlemi baÅŸarÄ±sÄ±z olduÄŸunda Ã§oÄŸu durumda fonksiyonu Ã§aÄŸÄ±ran koda 'NULL pointer' dÃ¶ndÃ¼rÃ¼lÃ¼r.
    if(!ptr){
        return NULL;
    }

    ptr->id = id;
    strcpy(ptr->name, pname);
    strcpy(ptr->surname, psurname);

    return ptr;
}

void print_person(const struct Person* ptr)
{
    printf("%d %s %s\n", ptr->id, ptr->name, ptr->surname);
}

int main(void)
{
    struct Person* pd = create_person(4232, "suha", "dincer"); // 'create_person' fonksiyonundan geriye dÃ¶ndÃ¼rÃ¼len dinamik nesnenin serbest bÄ±rakÄ±lmasÄ± sorumluluÄŸu fonksiyonu Ã§aÄŸÄ±ran kodun sorumluluÄŸundadÄ±r.
    print_person(pd);

    free(pd);
}
```


ğŸ“Œ Kursun sonlarÄ±nda programlamanÄ±n en Ã¶nemli konularÄ±ndan biri olan hatalarÄ±n iÅŸlenmesi(hata nedir, hatalar hangi kategorilere ayrÄ±lÄ±r, **excepsion** nedir, **error handing** nedir, hatalarÄ± yÃ¶netmek iÃ§in hangi teknikler kullanÄ±lÄ±r) konusu incelenecektir, dersler varsayÄ±lan kurs sÃ¼resinde tamamlanamazsa ek ders yapÄ±lacak.



â—â—â— Bir Fonksiyonun iÅŸini yapmasÄ± sÄ±rasÄ±nda hata alÄ±nÄ±rsa ne yapmak gerekir;
1. Bir Fonksiyonun iÅŸini yapamamasÄ± nedeni bir kodlama hatasÄ± mÄ±?
    - Evet ise => Kodlama hatasÄ±nÄ± bulup dÃ¼zeltmek ve yeniden programÄ± derlemek gerekmektedir, bu tÃ¼rden hatalara teknik olarak **programing errors** denilmektedir.
    - Peki, kodlama hatalarÄ±nÄ± nasÄ±l bulacaÄŸÄ±z;
        - **Static assertion**
        - **Runtime assertion**
2. **Runtime errors**, Ã§alÄ±ÅŸma zamanÄ±nda oluÅŸan hatalardÄ±r, bu hatalar kodda bir hata olmamasÄ±na raÄŸmen dÄ±ÅŸsal nedenlerden dolayÄ± programda oluÅŸan hatalardÄ±r, bu tÃ¼rden hatalara C#, Java, C++ gibi dillerde **exception** deniliyor.
    C dilinde standardÄ±nda hatalarÄ± yÃ¶netmek iÃ§in bir araÃ§ seti olmadÄ±ÄŸÄ± iÃ§in hata yÃ¶netimi Ã§oÄŸunlukla fonksiyonu Ã§aÄŸÄ±ran koda bÄ±rakÄ±lmaktadÄ±r. </br>
    C dilinin bir fonksiyonda hata olduÄŸunda aÅŸaÄŸÄ±daki yÃ¶ntemlerle oluÅŸan hata Ã§aÄŸÄ±ran koda bildirilmektedir ki fonksiyonu Ã§aÄŸÄ±ran kod oluÅŸan hatayÄ± iÅŸleyebilsin;
    1. Geri dÃ¶nÃ¼ÅŸ deÄŸeri yoluyla bildirilebilir.
    2. Global bir deÄŸiÅŸkenin deÄŸerini deÄŸiÅŸtirerek bildirilebilir.
    3. Kendisine gÃ¶nderilen bir adresteki hata taÅŸÄ±yacak nesneyi deÄŸiÅŸtirerek bildirilebilir.



**Propagate**: Programda oluÅŸan bir hatanÄ±n yayÄ±lmasÄ±nÄ± ifade eden bir terimdir.



ğŸ“Œ C dili kÃ¼Ã§Ã¼k bir dil olduÄŸu iÃ§in C dilinin standard kÃ¼tÃ¼phanesini kullanarak C programlarÄ±nda hata yÃ¶netimini yapmak zordur Ã¶zellikle de **function call chain** kullanÄ±mÄ± durumlarÄ±nda. C++, Java, C# gibi dillerde hata yÃ¶netimi **exception handing** olarak adlandÄ±rÄ±lan dilin bir aracÄ± ile yapÄ±lmaktadÄ±r.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 11.00-11.22 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


ğŸ‘‡ AÅŸaÄŸÄ±daki programda geriye dinamik Ã¶mÃ¼rlÃ¼ nesne adresi dÃ¶ndÃ¼ren `create_person` fonksiyonuna Ã§aÄŸrÄ± yapÄ±larak oluÅŸturulan yapÄ± nesnelerinin bir diziyenin elemanlarÄ±nda tutulmasÄ± ve en son dizide tutulan dinamik Ã¶mÃ¼rlÃ¼ nesnelrin bellek alanlarÄ±nÄ±n serbest bÄ±rakÄ±lmasÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

struct Person {
    int id;
    char name[20];
    char surname[20];
};

// AÅŸaÄŸÄ±daki fonksiyondan geriye dÃ¶ndÃ¼rÃ¼len yapÄ± nesnesi dinamik Ã¶mÃ¼rlÃ¼dÃ¼r.
struct Person* create_person(int id, const char* pname, const char* psurname)
{
    struct Person* ptr = (struct Person*)malloc(sizeof(struct Person));

    // Bellekten yer ayÄ±rma iÅŸlemi baÅŸarÄ±sÄ±z olduÄŸunda Ã§oÄŸu durumda fonksiyonu Ã§aÄŸÄ±ran koda 'NULL pointer' dÃ¶ndÃ¼rÃ¼lÃ¼r.
    if(!ptr){
        return NULL;
    }

    ptr->id = id;
    strcpy(ptr->name, pname);
    strcpy(ptr->surname, psurname);

    return ptr;
}

void print_person(const struct Person* ptr)
{
    printf("%d %s %s\n", ptr->id, ptr->name, ptr->surname);
}

int main(void)
{
    struct Person* pd[5];
    
    pd[0] = create_person(244, "mesut", "arslan");
    pd[1] = create_person(224, "vuralcan", "akdeniz");
    pd[2] = create_person(234, "kamal", "aliyev");
    pd[3] = create_person(254, "asli", "ozer");
    pd[4] = create_person(246, "aneta", "aral");

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼de dizinin elemanlarÄ±nda tutulan yapÄ± nesnelerinin adreslerini 'print_person' fonksiyonuna yapÄ±lan Ã§aÄŸrÄ±da argÃ¼man olarak geÃ§erek o yapÄ± nesneleri yazdÄ±rÄ±lmaktadÄ±r. 
    for(int i = 0; i < 5; ++i){
        print_person(pd[i]);
    }

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼de dinamik Ã¶mÃ¼rlÃ¼ nesnelerin bellek adresleri serbest bÄ±rakÄ±lmaktadÄ±r.
    for(int i = 0; i < 5; ++i){
        free(pd[i]);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `const` yapÄ± nesnesi dÃ¶ndÃ¼ren `foo` adÄ±ndaki fonksiyon incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

struct Person {
    int id;
    char name[20];
    char surname[20];
};

struct Person per;

// AÅŸaÄŸÄ±daki 'foo' fonksyonunundan dÃ¶nen yapÄ± nesnesi sadece okuma amaÃ§lÄ± kullanÄ±lmasÄ± gerektiÄŸi geri dÃ¶nÃ¼ÅŸ deÄŸerinin 'const' olmasÄ±ndan anlaÅŸÄ±lmaktadÄ±r.
const struct Person* foo(void)
{
    static struct Person per = { 12313, "necati", "ergin" };

    // some code here ...

    return &per;
}

// AÅŸaÄŸÄ±daki fonksiyondan geriye dÃ¶ndÃ¼rÃ¼len yapÄ± nesnesi dinamik Ã¶mÃ¼rlÃ¼dÃ¼r.
struct Person* create_person(int id, const char* pname, const char* psurname)
{
    struct Person* ptr = (struct Person*)malloc(sizeof(struct Person));

    // Bellekten yer ayÄ±rma iÅŸlemi baÅŸarÄ±sÄ±z olduÄŸunda Ã§oÄŸu durumda fonksiyonu Ã§aÄŸÄ±ran koda 'NULL pointer' dÃ¶ndÃ¼rÃ¼lÃ¼r.
    if(!ptr){
        return NULL;
    }

    ptr->id = id;
    strcpy(ptr->name, pname);
    strcpy(ptr->surname, psurname);

    return ptr;
}

void print_person(const struct Person* ptr)
{
    printf("%d %s %s\n", ptr->id, ptr->name, ptr->surname);
}

int main(void)
{
    const struct Person *p = foo(); 

    print_person(p);
}
```



C mÃ¼lakatlarÄ±nda aÅŸaÄŸÄ±daki gibi kullanÄ±cÄ±dan alÄ±nan deÄŸerlere gÃ¶re dinamik nesneler Ã¼retilmesi gereken durumlar iÃ§in program yazÄ±lmasÄ± istenmektedir. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki matris **pointer to pointer** ve **dynamic memory management** konularÄ±yla ilgilidir, aÅŸaÄŸÄ±daki programdan kullanÄ±cÄ±dan Ã§alÄ±ÅŸma zamanÄ±nda alÄ±nacak olan satÄ±r ve sÃ¼tun adedine gÃ¶re bir matris oluÅŸturup o matrisi standart Ã§Ä±ktÄ± akÄ±mÄ±na nasÄ±l gÃ¶nderildiÄŸi incelenebilir. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã¼retilmesi istenilen matris iki boyutlu dizi olacak biÃ§imde yazÄ±lmÄ±ÅŸtÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "nutility.h"
#include <conio.h> // Standart bir modÃ¼l deÄŸil

int main(void)
{
    printf("matrisin satir ve sutun sayisini girin: ");
    size_t row, col;

    scanf("%zu%zu", &row, &col);

    int** pd = (int**)malloc(row * sizeof(int*)); // Burada matrisin satÄ±rlarÄ±nÄ± oluÅŸturacak olan elemanlarÄ± 'int' tÃ¼rÃ¼nden dizi nesnesi olan 'int**' tÃ¼rÃ¼nden 'pd' deÄŸiÅŸkeni tanÄ±mlanÄ±yor.
    if(!pd){
        printf("bellek yetersiz!\n");
        return 1;
    }

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile 'pd' dizisinin her bir elemanÄ± iÃ§in bellekten dinamik olarak yer ayrÄ±lÄ±p 
    for(size_t i = 0; i < row; ++i){
        pd[i] = (int*)malloc(col * sizeof(int));
        if(!pd[i]){
            printf("bellek yetersiz!\n");
            return 2;
        }
    }

    randomize();

    for(size_t i = 0; i < row; ++i){
        for(size_t k = 0; k < col; ++k){
            pd[i][k] = rand() % 10;
        }
    }

    for(size_t i = 0; i < row; ++i){
        for(size_t k = 0; k < col; ++k){
            printf("%d", pd[i][k]);
        }
        printf("\n");
    }


    // Dikkat, matrisin satÄ±rlarÄ± esasÄ±nda bellekte ardÄ±ÅŸÄ±k deÄŸildir!

    // 'pd' dizisinin elemanlarÄ± olan, elemanlarÄ± 'int' tÃ¼rÃ¼nden olan diziler bellekte sÄ±ralÄ± deÄŸildir(Ã§Ã¼nkÃ¼ matrisin her bir satÄ±rÄ±nÄ±n nesnesi iÃ§in ayrÄ± ayrÄ± bellekten alan tahsis edildi), bu nedenle de aÅŸaÄŸÄ±daki dÃ¶ngÃ¼ tanÄ±msÄ±z davranÄ±ÅŸ iÃ§ermektedir.
    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼nÃ¼n Ã§alÄ±ÅŸma mantÄ±ÄŸÄ±nÄ± anlamak zor geliyorsa, bu kÄ±smÄ± Ã§alÄ±ÅŸtÄ±rÄ±p ekrana basÄ±lan deÄŸerleri incelersen pd[0] dizisinin son elemanÄ±ndan sonraki deÄŸerlerin garipleÅŸtiÄŸini gÃ¶receksin.
    // int* ptr = pd[0];
    // int n = row * col;
    // while(n--){
    //     printf("%d", *ptr++);
    //     _getch();
    // }

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile 'pd' adÄ±ndaki elemanlarÄ± dinamik dizi olan dizi nesnenin dinamik dizi elemanlarÄ±nÄ±n bellek alanlarÄ± tek tek serbest bÄ±rakÄ±lÄ±yor.
    for(size_t i = 0; i < row; ++i){
        free(pd[i]);
    }

    free(pd); // Burada da 'pd' adÄ±ndaki 'dynamic pointer array'in kendisi serbest bÄ±rakÄ±lÄ±yor.
}
```



C mÃ¼lakatlarÄ±nda aÅŸaÄŸÄ±daki gibi kullanÄ±cÄ±dan alÄ±nan deÄŸerlere gÃ¶re dinamik nesneler Ã¼retilmesi gereken durumlar iÃ§in program yazÄ±lmasÄ± istenmektedir. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki matris **pointer to pointer** ve **dynamic memory management** konularÄ±yla ilgilidir, aÅŸaÄŸÄ±daki programdan kullanÄ±cÄ±dan Ã§alÄ±ÅŸma zamanÄ±nda alÄ±nacak olan satÄ±r ve sÃ¼tun adedine gÃ¶re bir matris oluÅŸturup o matrisi standart Ã§Ä±ktÄ± akÄ±mÄ±na nasÄ±l gÃ¶nderildiÄŸi incelenebilir. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã¼retilmesi istenilen matris tek boyutlu dizi olacak biÃ§imde yazÄ±lmÄ±ÅŸtÄ±r ama iki boyutlu bir diziymiÅŸ gibi kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "nutility.h"
#include <conio.h> // Standart bir modÃ¼l deÄŸil

int main(void)
{
    printf("matrisin satir ve sutun sayisini girin: ");
    size_t row, col;

    scanf("%zu%zu", &row, &col);

    int* pd = (int*)malloc(row * col * sizeof(int)); // Burada bellekten tek parÃ§a bellek kÄ±smÄ± ediniliyor.

    if(!pd){
        printf("bellek yetersiz!\n");
        return 1;
    }


    for(size_t i = 0; i < row; ++i){
        for(size_t k = 0; k < col; ++k){
            pd[i * col + k] = rand() % 10; // Burada dizi elemanÄ±nÄ±n indislerine deÄŸerleri atanÄ±yor.
        }
    }

    // some code here ...

    for(size_t i = 0; i < row; ++i){
        for(size_t k = 0; k < col; ++k){
            printf("%d", pd[i * col + k]);
        }
        printf("\n");
    }

    // AÅŸaÄŸÄ±daki gibi bir kod yazabiliriz, burada bir yanlÄ±ÅŸlÄ±k yoktur.
    //int* ptr = pd;
    //size_t n = row * col;
    //while(n--){
    //    printf("%d", *ptr++);
    //    _getch();
    //}

    free(pd);  
}
```



ğŸ‘† YukarÄ±da yazÄ±lmÄ±ÅŸ olan iki program da Ã¶zÃ¼nde bir matrisi gerÃ§ekleme iÅŸlemini yapÄ±yor ama gidiÅŸ yollarÄ± farklÄ±, nasÄ±l bir yÃ¶ntemle programÄ±n yazÄ±lacaÄŸÄ±na aÅŸaÄŸÄ±daki gibi nedenler gÃ¶z Ã¶nÃ¼ne alÄ±narak karar verilmelidir;
- KullanÄ±lan bellek miktarÄ± mÄ± daha Ã¶nemli.
- Daha hÄ±zlÄ± Ã§alÄ±ÅŸmasÄ± mÄ± daha Ã¶nemli
- Matris olduÄŸu iÃ§in iki boyutlu dizi olarak kullanabilmek mi Ã¶nemli.
- **Fragmentation** olan bir bellekte Ã§alÄ±ÅŸÄ±lacaksa **fragmentation**'a dayanÄ±klÄ± bir kod yazÄ±lmasÄ± mÄ± Ã¶nemli.



ğŸ‘‡ AÅŸaÄŸÄ±daki program yukarÄ±da kullanÄ±lan iki farklÄ± yÃ¶ntemin bir hibritinin nasÄ±l yazÄ±labileceÄŸini anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "nutility.h"
#include <conio.h> // Standart bir modÃ¼l deÄŸil

int main(void)
{
    printf("matrisin satir ve sutun sayisini girin: ");
    size_t row, col;

    scanf("%zu%zu", &row, &col);

    int* pd = (int*)malloc(row * col * sizeof(int*)); // Burada bellekten tek parÃ§a bellek kÄ±smÄ± ediniliyor.

    if(!pd){
        printf("bellek yetersiz!\n");
        return 1;
    }


    for(size_t i = 0; i < row; ++i){
        for(size_t k = 0; k < col; ++k){
            pd[i * col + k] = rand() % 10; // Burada dizi elemanÄ±nÄ±n indislerine deÄŸerleri atanÄ±yor.
        }
    }


    int** pp = malloc(row * sizeof(int)); // Burada matrisin satÄ±rlarÄ±nÄ± tutacak boyutta tek bir bellek bloÄŸu ediniliyor, bu bellek bloÄŸunun elemanlarÄ± ilk edinilen bellek bloÄŸunda buluna adresleri matrisin her bir satÄ±rÄ±nÄ±n baÅŸlangÄ±Ã§ adresini tutmak iÃ§in kullanÄ±lacak.
    if(!pd){
        printf("bellek yetersiz!\n");
        return 2;
    }

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile ilk baÅŸta edinilmiÅŸ tek parÃ§a bellek bloÄŸu matrisin her bir satÄ±rÄ±nÄ± temsil edecek biÃ§imde 'pp' dizisinin elemanÄ± yapÄ±lÄ±yor.
    for(size_t i = ; i < row; ++i){
        pp[i] = pd + i * col;
    }

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile dizinin elemanlarÄ±na 'pp' nesnesi aracÄ±lÄ±ÄŸÄ±yla sanki bir iki boyutlu bir diziymiÅŸ gibi eriÅŸilip yazdÄ±rÄ±lmaktadÄ±r.
    for(size_t i = 0; i < row; ++i){
        for(size_t k = 0; k < col; ++k){
            printf("%d", pp[i][k]);
        }
        printf("\n");
    }

    // Sondan baÅŸa doÄŸru edinilen bellek parÃ§alarÄ± iade ediliyor.
    free(pp);
    free(pd);
}
```


> Sorulan soru?
> 
> iki ok arasindaki elemanlarin adreslerine erisebilir miyim?
> 
> Cevap;
> 
> Burada aslÄ±nda n. satÄ±rÄ±n k. elemanÄ±na eriÅŸilebiliyor mu diye soruluyor, evet eriÅŸilebilir, anlamak iÃ§in yukarÄ±da yazÄ±lmÄ±ÅŸ olan Ã¼Ã§ programÄ±n iyi anlaÅŸÄ±lmÄ±ÅŸ olmasÄ± gerkiyor.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.07-12.17 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***

### YapÄ±larÄ± Kullanan KÃ¼tÃ¼phenelerin Ã–zellikleri


**YapÄ±larÄ±(structure)** kullanarak hizmet veren kÃ¼tÃ¼pheneleri temelde **C tarzÄ± kÃ¼tÃ¼phaneler** ve **OOP tarzÄ± kÃ¼tÃ¼pheneler** olarak ikiye ayÄ±rabiliriz. Sistem programlama, gÃ¶mÃ¼lÃ¼ sistem programlama, networking alanÄ±nda kullanÄ±lmaktadÄ±r.


KÃ¼tÃ¼pheneleri aÅŸaÄŸÄ±daki gibi ikiye ayÄ±rabiliriz(Necati Ergin bu biÃ§imde bir sÄ±nÄ±flandÄ±rma yapÄ±yormuÅŸ, genel olarak kullanÄ±lan bir yaklaÅŸÄ±m deÄŸil); 
1. C tarzÄ± kÃ¼tÃ¼pheneler. 
    Bu tÃ¼rden kÃ¼tÃ¼pheneler kullanÄ±lacaksa aÅŸaÄŸÄ±dakilerin bilinmesi gerekecektir; 
    1. YapÄ±nÄ±n tÃ¼m elemanlarÄ± onu kullanacak olan programcÄ± tarafÄ±ndan bilinmek zorundadÄ±r.
    2. ProgramcÄ± yapÄ±nÄ±n elemanlarÄ±nÄ±n alabileceÄŸi deÄŸerler Ã¼zerindeki kÄ±sÄ±tlamalarÄ± bilmek zorundadÄ±r.
    3. programcÄ± yapÄ±nÄ±n elemanlarÄ±nÄ±n arasÄ±nda baÄŸÄ±mlÄ±lÄ±klar varsa bunlarÄ±n bilinmek zorundadÄ±r.

    ğŸ‘‡ AÅŸaÄŸÄ±daki yapÄ± bildirimlerini kullanÄ±rken sorumluluk o yapÄ±larÄ± kullanan programcÄ±dadÄ±r.
    ```C
    #include <stdio.h>

    struct Image {
        size_t width;
        size_t heigth;
        int color;
        double density;
    }

    // ProgramcÄ± aÅŸaÄŸÄ±daki yapÄ±yÄ± kullanacaÄŸÄ± zaman yapÄ± Ã¼yelerinin birbiriyle olan iliÅŸkisini bilmelidir ve Ã¼yelerin deÄŸerlerinin tutarlÄ± olmasÄ±nÄ±n tÃ¼m sorunluluÄŸu yapÄ±yÄ± kullanan programcÄ±dadÄ±r.
    struct Triangle {
        double adge1;
        double adge2;
        double adge3;
        double area;
    }
    ```

2. OOP tarzÄ± kÃ¼tÃ¼pheneler. 
    Bu tÃ¼rden kÃ¼tÃ¼pheneler aÅŸaÄŸÄ±daki gibi bir yaklaÅŸÄ±m sergiler;
    1. ElemanlarÄ±mÄ± gÃ¶r ama onlara dokunma
    2. ElamanlarÄ±ma istesen de dokunamazsÄ±n, yapÄ±nÄ±n elemanlarÄ± o yapÄ±yÄ± kullanacak programcÄ±dan gizleniyor.

    `void*` tÃ¼rÃ¼nden deÄŸiÅŸkenleri kullanarak bir yapÄ±nÄ±n elemanlarÄ±nÄ± dÄ±ÅŸarÄ±dan gizleyebiliriz ve tek yol bu da deÄŸil. </br>
    OOP tarzÄ± kÃ¼tÃ¼pheneleri kullanÄ±rken Ã§oÄŸunlukla yapÄ±nÄ±n Ã¼yeleriyle ilgili derin bilgiye sahip olmak gerekmediÄŸi iÃ§in kÃ¼tÃ¼pheneyi kullanan programcÄ± iÃ§in kullanÄ±mÄ± daha kolaydÄ±r.

    ğŸ‘‡ AÅŸaÄŸÄ±daki yapÄ± bildirimlerinde yapÄ±nÄ±n elemanÄ± dÄ±ÅŸarÄ±dan gizlenmiÅŸtir.
    ```C
    // `void*` tÃ¼rÃ¼nden deÄŸiÅŸkenleri kullanarak bir yapÄ±nÄ±n elemanlarÄ±nÄ± dÄ±ÅŸarÄ±dan gizleyebiliriz.
    struct Image {
        void* vptr;
    }
    ```

    ```C
    #include <stdio.h>

    int main(void)
    {
        FILE fx;

        fx._Placeholder; // Standart kÃ¼tÃ¼phenenin kendisinde olan 'FILE' yapÄ±sÄ±ndaki '_Placeholder' Ã¼ye 'void*' tÃ¼rÃ¼nden olduÄŸu iÃ§in dÄ±ÅŸarÄ±dan gizlenmiÅŸtir, bu Ã¼yenin ne olduÄŸu dÄ±ÅŸarÄ±dan belli deÄŸil ve bundan dolayÄ± da herhengi bir iÅŸlemde kullanÄ±lamaz.
    }
    ```


    
    ğŸ‘‡ AÅŸaÄŸÄ±daki sÃ¶zde kodda `Date` yapÄ± nesnesinin, `set_date` ve `get_month` OOP tarzÄ± bir kÃ¼tÃ¼phenenin Ã¼yeleri olduÄŸu birdurumda nasÄ±l iÅŸlemler yapÄ±labileceÄŸi incelenebilir. YapÄ±lan fonksiyon Ã§aÄŸrÄ±larÄ±nda sadece fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±lÄ±yor baÅŸka bilgilerle ilgilenilmiyor.
    ```C
    #include <stdio.h>

    struct Date {
        // ...
        int x, y, z;
    }

    int main(void)
    {
        struct Date mydate;
        set_date(&mtdate, 4, 7, 1999); // OOP tarzÄ± kÃ¼tÃ¼phenin Ã¼yesi olan 'set_date' fonksiyonuna Ã§aÄŸrÄ± yapÄ±larak 'mydate' nesnesinin elemanlarÄ±na deÄŸer atanÄ±yor.
        
        get_month(&mtdate); // OOP tarzÄ± kÃ¼tÃ¼phenin Ã¼yesi olan 'get_month' fonksiyonuna Ã§aÄŸrÄ± yapÄ±larak argÃ¼man olarak geÃ§ilen '&mydate' ile ilgili nesnenin ay bilgisi alÄ±nmÄ±ÅŸ oluyor.
    }
    ```


C tarzÄ± yaklaÅŸÄ±m kullanÄ±ldÄ±ÄŸÄ±nda hizmet veren kÃ¼tÃ¼phane deÄŸiÅŸtiÄŸinde o kÃ¼tÃ¼pheneyi kullanrak hiÃ§met alan kodlarÄ±n da deÄŸiÅŸmesi gerekecektir. </br>
OOP tarzÄ± yaklaÅŸÄ±m C dilinde uygulamak iÃ§in Ã§oÄŸunlukla `void*` tÃ¼rÃ¼ kullanÄ±lÄ±yor ve bunun iÃ§in de dinamik bellek yÃ¶netimi yapmak gerekeceÄŸi iÃ§in maliyeti daha yÃ¼ksek olmaktadÄ±r. </br>
C dilinde OOP tarzÄ± yaklaÅŸÄ±mÄ± kullanmak iÃ§in diÄŸer dillerde olan(C++, Java, C# vb.) programlama araÃ§larÄ± yok, bu da C dilinde OOP tarzÄ± yaklaÅŸÄ±mÄ± uygulamayÄ± zorlaÅŸtÄ±rmaktadÄ±r. </br>
OOP tarzÄ± yaklaÅŸÄ±m kullanÄ±ldÄ±ÄŸÄ±nda bu yaklaÅŸÄ±m koda ayrÄ± bir soyutlama katmanÄ± eklemektedir C programlarÄ± Ã§oÄŸunlukla sistem programlamada kullanÄ±ldÄ±ÄŸÄ± iÃ§in o domainde soyutlamalarÄ±n mÃ¼mkÃ¼n olduÄŸu kadar az olmasÄ± yaklaÅŸÄ±mÄ±ndan dolayÄ± da pek tercih edilmemektedir. </br>
C tarzÄ± yaklaÅŸÄ±m kullanÄ±ldÄ±ÄŸÄ±nda yazÄ±lacak C programlarÄ±nÄ±n Ã§alÄ±ÅŸma maliyeti daha dÃ¼ÅŸÃ¼k olacaÄŸÄ± iÃ§in C dilinin standart kÃ¼tÃ¼phanesindeki modÃ¼llerde ve bir Ã§ok Ã¼Ã§Ã¼ncÃ¼ taraf kÃ¼tÃ¼phanede bu yaklaÅŸÄ±m kullanÄ±lÄ±yor.


ğŸ“Œ C tarzÄ± yaklaÅŸÄ±mla yazÄ±lmÄ±ÅŸ kÃ¼tÃ¼phaneye en temel misal C dilinin standart kÃ¼tÃ¼phenesinin bir bileÅŸeni olan `time` modÃ¼lÃ¼dÃ¼r, yarÄ±nki derste bu modÃ¼l incelenecektir.


## YapÄ± DeÄŸiÅŸkenlerinin TanÄ±mlanmasÄ±nda KullanÄ±lan SÃ¶zdizimi 

YapÄ± deÄŸiÅŸkenlerinin tanÄ±mlanmasÄ±nda kullanÄ±lan Ã¶nceden deÄŸinilmeyen bir sÃ¶zdizimi(syntax) kullanÄ±mÄ±nÄ± inceleyelim.



ğŸ‘‡ AÅŸaÄŸÄ±daki program parÃ§asÄ±nda Ã¶nceden bilinen biÃ§imde bir yapÄ± tanÄ±mÄ±nÄ±n global alanda nasÄ±l yapÄ±ldÄ±ÄŸÄ± gÃ¶rÃ¼lebilir.
```C
// 1. yapÄ± bildirimi yolu
struct Nec {
    int x, y;
    double d1, d2;
};

struct Nec n1, n2, n3;
```

ğŸ‘‡ AÅŸaÄŸÄ±daki program parÃ§asÄ±nda, yukarÄ±daki yapÄ± bildiriminin nasÄ±l daha kÄ±sa biÃ§imde yazÄ±labileceÄŸi gÃ¶rÃ¼lebilir.
```C
// 2. yapÄ± bildirimi yolu, burada yapÄ±nÄ±n bildirimi ve o yapÄ± tÃ¼rÃ¼nden nesnelerin tanÄ±mlanmasÄ± tek seferde yapÄ±lmaktadÄ±r.
struct Nec {
    int x, y;
    double d1, d2;
} n1, n2, n3;
```


ğŸ§  YapÄ± deÄŸiÅŸkenleri hem global alanda(file scope) hem de fonksiyon gÃ¶vdelerinde(function scope) bildirilebilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki program parÃ§asÄ±nda yapÄ± tÃ¼rÃ¼nden deÄŸiÅŸken bildiriminde nasÄ±l ilk deÄŸer verilebileceÄŸi gÃ¶rÃ¼lebilir.
```C
// 3. yapÄ± bildirimi yolu, burada yapÄ± bildirimi, yapÄ± tÃ¼rÃ¼nde deÄŸiÅŸkenlerin tanÄ±mÄ± ve yapÄ± tÃ¼rÃ¼nden deÄŸiÅŸkenlere ilk deÄŸer verme iÅŸlemleri tek seferde yapÄ±lmkatadÄ±r.
struct Nec {
    int x, y;
    double d;
} n1 = { 3, 7, 2.3 }, n2 = { 4, 7, 1.9 };
```


ğŸ‘‡ AÅŸaÄŸÄ±daki program parÃ§asÄ±nda yapÄ± deÄŸiÅŸkenlerinden gÃ¶sterici tÃ¼rÃ¼nden deÄŸiÅŸkenlerin bildirimleriminin nasÄ±l iki tÃ¼rlÃ¼ yapÄ±labileceÄŸi incelenebilir.
```C
// Ä°lk kullanÄ±m biÃ§imi.
//struct Nec {
//    int x, y;
//    double d;
//} nec, * pnec = &nec;


// Ä°kinci kullanÄ±m biÃ§imi, buradaki bildirim ile yukarÄ±daki bildirim aynÄ±dÄ±r.
struct Nec {
    int x, y;
    double d;
};

struct Nec nec, *pnec = &nec;
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda C ve C++ dillerinde yapÄ± bildiirmleri ve tanÄ±mlamalarÄ±nÄ±n nasÄ±l yapÄ±lÄ±p yapÄ±lamadÄ±ÄŸÄ± incelenebilir.
```C
// 'Nec' adÄ±(identifier) 'structure tag' olarak adlandÄ±rÄ±lÄ±yor.
struct Nec {
    int x, y;
};

int main(void)
{
    Nec mynec; // C dilinde geÃ§ersiz(illegal) yapÄ± tÃ¼rÃ¼nden deÄŸiÅŸken tanÄ±mlamasÄ± ama C++ dilinde geÃ§erli(legal).
    struct Nec mynec; // C dilinde geÃ§erli(legal) yapÄ± tÃ¼rÃ¼nden deÄŸiÅŸken tanÄ±mlamasÄ±.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program parÃ§asÄ±nda **structure tag** kullanÄ±lmadan yapÄ± bildiriminin nasÄ±l yapÄ±ldÄ±ÄŸÄ± gÃ¶rÃ¼lebilir, bu tÃ¼r yapÄ±lara **anonymous structure** deniliyor.
```C
// C dilininde aÅŸaÄŸÄ±daki gibi 'tag' bilgisi olmayan yapÄ±lar tanÄ±mlanabilir.
// AÅŸaÄŸÄ±daki gibi yapÄ± bildiriminde, okuyucu ve derleyiciye ilgili yapÄ± tÃ¼rÃ¼nden Ã¼Ã§ deÄŸiÅŸken ve bir tane gÃ¶sterici dÄ±ÅŸÄ±nda baÅŸka bir deÄŸiÅŸken olmayacaÄŸÄ± bildirilmiÅŸ olur.
struct {
    int x, y;
} p1, p2, p3, *ptr = &p1;
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir yapÄ±nÄ±n tÃ¼r eÅŸ adÄ± ile birlikte nasÄ±l kullanÄ±ldÄ±ÄŸÄ± gÃ¶rÃ¼lebilir.
```C
struct Data {
    int a, b, c;
};

typedef struct Data Data; // Burada 'struct Data' tÃ¼rÃ¼nden 'Data' adÄ±nda tÃ¼r eÅŸ adÄ± bildirimi yapÄ±lÄ±yor, bu ÅŸekilde sadece 'Data' adÄ± kullanÄ±larak 'struct Data' tÃ¼rÃ¼ kullanÄ±lmÄ±ÅŸ olacak.

int main(void)
{
    Data mydate; // C dilinde 'typedef' bildirimi ile bu biÃ§imde sadece yapÄ± adÄ±nÄ± ile ilgili yapÄ±yÄ± kullanabiliriz.
}
```


Ders sonu ...
