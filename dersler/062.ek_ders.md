# 62.Ek Ders
---


## Abstract Data Structure(Soyut Veri YapÄ±larÄ±) ğŸŒŸ

Bu baÅŸlÄ±k altÄ±nda **kuyruk(queue)** ve **yÄ±ÄŸÄ±n(stack)** soyut veri yapÄ±sÄ±nÄ± inceleyeceÄŸiz. </br>
Programlamayla tanÄ±ÅŸanlarÄ±n en Ã§ok aklÄ±nda **FIFO(Fist in fist out)** ve **LIFO(Last in first out)** terimleri kalmaktadÄ±r.

**Kuyruk(queue)** soyut veri yapÄ±sÄ±nda bir liste vardÄ±r ve bu yapÄ±da ilk giren ilk Ã§Ä±kar(**FIFO**) mantÄ±ÄŸÄ± uygulanmaktadÄ±r, mesela bir ÅŸey almak iÃ§in beklenilen kuyruklar(sinama kuyruÄŸu, bilet kuyruÄŸu vb.) **FIFO** olan kuyruk tÃ¼rleridir. </br>
Programlamada en Ã§ok kullanÄ±lan soyut veri yapÄ±sÄ± **kuyruk(queue)** veri yapÄ±sÄ±dÄ±r. </br>
Bir de **Ã¶ncelik kuyruÄŸu(priority queue)** denilen baÅŸka bir soyut veri yapÄ±sÄ± var, bu soyut veri yapÄ±sÄ±nda Ã¶nceliÄŸi en yÃ¼ksek olan kuyruktan ilk Ã§Ä±kmaktadÄ±r.

**YÄ±ÄŸÄ±n(stack)** soyut veri yapÄ±sÄ±nÄ±nda ilk giren ilk Ã§Ä±kmaktadÄ±r, mesela sÄ±radan bir zeminde duran bir tabak yÄ±ÄŸÄ±nÄ±nÄ±n en Ã¼stÃ¼ne bir tabak koyduÄŸumuzda en zahmetsiz olarak en Ã¼stteki tabaÄŸÄ± alÄ±yoruz.

â—â—â— Ã–zellikle **Ã¶zyinelemeli(recursion)** algoritmalar **yÄ±ÄŸÄ±n(stack)** veri yapÄ±sÄ± kullanÄ±larak iteratif biÃ§ime sokulabiliyor ve bÃ¶ylece Ã¶zyinelemeli algoritma iteratif biÃ§ime getirilmiÅŸ olur.


### **Kuyruk(queue)** Veri YapÄ±sÄ± 

**Enqueue**: KuyruÄŸa dahil etmek anlamÄ±na gelen bir terimdir.

**Dequeue**: Kuyruktan Ã§Ä±kartmak anlamÄ±na gelen bir terimdir.

AyrÄ±ca **deque** adÄ±ndan ayrÄ± bir veri yapÄ±sÄ± da vardÄ±r, Ã§oÄŸunlukla gerÃ§ekleÅŸtirim dinamik dizilerin dizisi biÃ§iminde gerÃ§ekleÅŸtiriliyor, bu soyut veri yapÄ±sÄ±nda baÅŸtan ve sondan eklemeler $O(1)$ zaman kamaÅŸÄ±klÄ±ÄŸÄ±ndadÄ±r, indeks ile eriÅŸimde $O(1)$ zaman kamaÅŸÄ±klÄ±ÄŸÄ±ndadÄ±r.
BazÄ± durumlarda **deque** soyut veri yapÄ±sÄ± **dynamic array** soyut veri yapÄ±sÄ±na ciddi bir muadil olabiliyor.

EÄŸer **gerÃ§ekleÅŸtirimi(implementation)** de kapsÄ±yorsa o zaman ona **veri yapÄ±sÄ±(data structure)** deniliyor ama sadece **arayÃ¼zÃ¼(interface)** tanÄ±mÄ±na **veri yapÄ±sÄ±(data structure)** denilmiyor. </br>
Mesela **kuyruk(queue)** ve **yÄ±ÄŸÄ±n(stack)**, **FIFO(Fist in fist out)** ve **LIFO(Last in first out)** terimleri birer arayÃ¼zdÃ¼r, birer zihinsel modeldir ve o iÅŸlemin nasÄ±l yapÄ±lacaÄŸÄ±na dair bir bilgi iÃ§ermez.

Bir **kuyruk(queue)** soyut veri yapÄ±sÄ±nÄ±n farklÄ± farklÄ± yollarla gerÃ§ekleÅŸtirimi yapÄ±labilir, biz de burada seÃ§eceÄŸimiz bir yÃ¶ntemle gerÃ§ekleÅŸtirimini yapacaÄŸÄ±z.


### Soyut Kuyruk Veri YapÄ±sÄ±nÄ±n Dizi ile GerÃ§ekleÅŸtirimi(Abstract Queue Data Structure Implementation with Array) ğŸŒŸ 

Bu tÃ¼r gerÃ§ekleÅŸtirimlerde Ã§oÄŸunlukla ilk Ã¶nce handle olarak kullanÄ±lacak olan yapÄ± tÃ¼rÃ¼nÃ¼ oluÅŸturuyoruz, bÃ¶ylece handle sistemnini kullandÄ±ÄŸÄ±mÄ±zda birden fazla farklÄ± kuyruk veri yapÄ±sÄ± oluÅŸturulabilir durumda olacaktÄ±r.


âœï¸ Burada `queue.h` baÅŸlÄ±k dosyasÄ±nÄ± aÅŸaÄŸÄ±daki gibi ekliyoruz, **kuyruk(queue)** veri yapÄ±sÄ±nÄ±n gerÃ§ekleÅŸtiriminde kullanÄ±lacak olan baÅŸlÄ±k dosyasÄ±nÄ± aÅŸaÄŸÄ±daki gibi yazÄ±yoruz.
```C
#pragma once
// #ifndef QUEUE_H
// #define QUEUE_H

#include <stddef.h> // 'size_t' tÃ¼r eÅŸ adÄ±nÄ±n bildirimini iÃ§eren en hafif baÅŸlÄ±k dosyasÄ± eklendi.
#include <stdbool.h> // 'bool', 'true', 'false' gibi object-like makrolarÄ± kullanabilmek iÃ§in eklenmiÅŸtir.


typedef int DATATYPE;

// Queue  : 'struct tag_queue' yapÄ± tÃ¼rÃ¼nÃ¼n eÅŸ adÄ±.
// *HQueue: 'struct tag_queue' yapÄ± tÃ¼rÃ¼nden nesnelerin adresi olan tÃ¼rÃ¼n eÅŸ adÄ±.
typedef struct tag_queue {
    DATATYPE* m_queue;
    size_t m_head; // Push index deÄŸeri.
    size_t m_tail; // Pop index deÄŸeri.
    size_t m_size; // Kuyrukta tutulmakta olan Ã¶ÄŸe sayÄ±sÄ± deÄŸerini tutacak olan yapÄ± Ã¼yesi.
    size_t m_cap; // Kuyrukta tutulabilecek en fazla Ã¶ÄŸe sayÄ±sÄ± deÄŸerini tutacak olan yapÄ± Ã¼yesi.
} Queue, *HQueue;


// Yeni bir kuyruk veri yapÄ±sÄ± oluÅŸturan fonksiyon.
HQueue create_queue(size_t cap);

// KuyruÄŸa 'call by value' yÃ¶ntemiyle Ã¶ÄŸe ekleme iÅŸlemini yapan fonksiyon.
bool push(HQueue hqueue, DATATYPE val);

// KuyruÄŸa 'call by reference' yÃ¶ntemiyle Ã¶ÄŸe ekleme iÅŸlemini yapan fonksiyon.
bool push_p(HQueue hqueue, const DATATYPE* val);

// Kuyruktan silerek Ã¶ÄŸe Ã§Ä±kartan ve o Ã¶ÄŸenin bilgisini output argÃ¼man(val) ile geriye dÃ¶ndÃ¼ren fonksiyon.
bool pop(HQueue hqueue, DATATYPE* val);

// KuyruÄŸun alabileceÄŸi Ã¶ÄŸe sayÄ±sÄ±nÄ± yÃ¼kseltmek iÃ§in kullanÄ±lan fonksiyon.
bool incrice_capacity(HQueue hqueue, size_t new_cap);

// Kuyruktaki tÃ¼m Ã¶ÄŸeleri silmek iÃ§in kullanÄ±lan fonksiyon.
void clear(HQueue hqueue);

// Kuyruk nesnesini silmek iÃ§in kullanÄ±lan fonksiyon.
void destroy_queue(HQueue hqueue);


// KuyruÄŸun boÅŸ olup olmadÄ±ÄŸÄ± bilgisini geriye dÃ¶ndÃ¼ren inline fonksiyon.
static inline bool is_empty(HQueue hqueue)
{
    return hqueue->m_size == 0;
}

// Kuyrukta o anda bulunan Ã¶ÄŸe sayÄ±sÄ± bilgisini geriye dÃ¶ndÃ¼ren inline fonksiyon.
static inline size_t get_size(HQueue hqueue)
{
    return hqueue->m_size;
}

// Kuyrukta bulunabilecek olan en fazla Ã¶ÄŸe sayÄ±sÄ± bilgisini geriye dÃ¶ndÃ¼ren inline fonksiyon.
static inline size_t get_capacity(HQueue hqueue)
{
    return hqueue->m_cap;
}


// #endif
```



âœï¸ Burada `queue.c` kaynak dosyasÄ±nÄ± aÅŸaÄŸÄ±daki gibi ekliyoruz, **kuyruk(queue)** veri yapÄ±sÄ±nÄ±n gerÃ§ekleÅŸtiriminde kullanÄ±lacak olan kaynak dosyayÄ± aÅŸaÄŸÄ±daki gibi yazÄ±yoruz.
```C
#include "queue.h"
#include <stddef.h> // 'size_t' tÃ¼r eÅŸ adÄ±nÄ±n bildirimini iÃ§eren en hafif baÅŸlÄ±k dosyasÄ± eklendi.
#include <stdbool.h> // 'bool', 'true', 'false' gibi object-like makrolarÄ± kullanabilmek iÃ§in eklenmiÅŸtir.


// Yeni bir kuyruk veri yapÄ±sÄ± oluÅŸturan fonksiyon. 
HQueue create_queue(size_t cap)
{
    // 'struct tag_queue' veri yapÄ±sÄ± nesnesi iÃ§in bellekten yer ayrÄ±lÄ±yor.
    HQueue hqueue = (HQueue)malloc(sizeof(Queue));
    if(!hqueue)
        return NULL;

    // 'struct tag_queue' veri yapÄ±sÄ± nesnesinin verileri tutacak olan 'm_queue' pointer Ã¼yesine adresi verilcek olan dizi iÃ§in bellekten yer ayrÄ±lÄ±yor.
    if((hqueue->m_queue = (DATATYPE*)malloc(cap * sizeof(DATATYPE))) == NULL) {
        free(hqueue);
        return NULL;
    }

    hqueue->m_cap = cap; // 'struct tag_queue' veri yapÄ±sÄ± nesnesinin kapasite deÄŸeri atanÄ±yor.
    hqueue->m_size = 0; // 'struct tag_queue' veri yapÄ±sÄ± nesnesinin o anki Ã¶ÄŸe sayÄ±sÄ± deÄŸeri atanÄ±yor.
    hqueue->m_head = hqueue->m_tail = 0; // 'm_head' ve 'm_tail' deÄŸerleri '0' olarka atanÄ±yor.

    return hqueue;
}


// KuyruÄŸa 'call by value' yÃ¶ntemiyle Ã¶ÄŸe ekleme iÅŸlemini yapan fonksiyon. 
bool push(HQueue hqueue, DATATYPE val)
{
    // EÄŸer 'size' deÄŸeri 'capacity' deÄŸerine eÅŸitse ekleme iÅŸlemi yapÄ±lamamalÄ±dÄ±r.
    // Burada 'capacity' deÄŸerinin client-code tarafÄ±ndan bilinÃ§li olarak yapÄ±lmasÄ±nÄ± istediÄŸimiz iÃ§in 'capacity' deÄŸerini gerektiÄŸinde burada arttÄ±rmÄ±yoruz.

    if(hqueue->m_size == hqueue->m_cap)
        return false;

    hqueue->m_queue[hqueue->m_tail] = val; // KuyruÄŸa eklenen Ã¶ÄŸe, ilgili kuyruÄŸun 'm_queue' dizisinin 'm_tail' deÄŸerli indeksine ekleniyor.
    ++hqueue->m_tail; // Ä°lgili kuyruÄŸun 'm_tail' deÄŸeri bir arttÄ±rÄ±lÄ±yor. 
    hqueue->m_tail %= hqueue->m_cap; // Buradaki iÅŸlemin nedeni ÅŸu, burada yapÄ±lan kuyruk gerÃ§ekleÅŸtiriminde Ã¶ÄŸeler bir dizide tutulacak biÃ§imde yapÄ±ldÄ± ve dizideki Ã¶ÄŸe sayÄ±sÄ± dizinin en fazla alabileceÄŸi eleman sayÄ±sÄ±ndan fazla olmadÄ±ÄŸÄ± sÃ¼rece dÃ¶ngÃ¼sel olarak yeni Ã¶ÄŸe eklenebilir olmasÄ± istenmesinden kaynaklanmaktadÄ±r.
    ++hqueue->m_size; // Ekleme iÅŸleminden dolayÄ± kuyruktaki Ã¶ÄŸe sayÄ±sÄ± bir attÄ±ÄŸÄ± iÃ§in ilgili kuyruÄŸun 'm_size' deÄŸeri bir arttÄ±rÄ±lÄ±yor.
}


// KuyruÄŸa 'call by reference' yÃ¶ntemiyle Ã¶ÄŸe ekleme iÅŸlemini yapan fonksiyon. 
bool push_p(HQueue hqueue, const DATATYPE* val)
{
    // EÄŸer 'size' deÄŸeri 'capacity' deÄŸerine eÅŸitse ekleme iÅŸlemi yapÄ±lamamalÄ±dÄ±r.
    // Burada 'capacity' deÄŸerinin client-code tarafÄ±ndan bilinÃ§li olarak yapÄ±lmasÄ±nÄ± istediÄŸimiz iÃ§in 'capacity' deÄŸerini gerektiÄŸinde burada arttÄ±rmÄ±yoruz.

    if(hqueue->m_size == hqueue->m_cap)
        return false;

    hqueue->m_queue[hqueue->m_tail] = *val; // KuyruÄŸa eklenen Ã¶ÄŸe, ilgili kuyruÄŸun 'm_queue' dizisinin 'm_tail' deÄŸerli indeksine ekleniyor.
    ++hqueue->m_tail; // Ä°lgili kuyruÄŸun 'm_tail' deÄŸeri bir arttÄ±rÄ±lÄ±yor. 
    hqueue->m_tail %= hqueue->m_cap; // Buradaki iÅŸlemin nedeni ÅŸu, burada yapÄ±lan kuyruk gerÃ§ekleÅŸtiriminde Ã¶ÄŸeler bir dizide tutulacak biÃ§imde yapÄ±ldÄ± ve dizideki Ã¶ÄŸe sayÄ±sÄ± dizinin en fazla alabileceÄŸi eleman sayÄ±sÄ±ndan fazla olmadÄ±ÄŸÄ± sÃ¼rece dÃ¶ngÃ¼sel olarak yeni Ã¶ÄŸe eklenebilir olmasÄ± istenmesinden kaynaklanmaktadÄ±r.
    ++hqueue->m_size; // Ekleme iÅŸleminden dolayÄ± kuyruktaki Ã¶ÄŸe sayÄ±sÄ± bir attÄ±ÄŸÄ± iÃ§in ilgili kuyruÄŸun 'm_size' deÄŸeri bir arttÄ±rÄ±lÄ±yor.
}


// Kuyruktan silerek Ã¶ÄŸe Ã§Ä±kartan ve o Ã¶ÄŸe bilgisini output argÃ¼man(val) ile geriye dÃ¶ndÃ¼ren fonksiyon. 
bool pop(HQueue hqueue, DATATYPE* val)
{
    if(is_empty(hqueue))
        return false;

    *val = hqueue->m_queue[hqueue->m_head];
    ++hqueue->m_head;
    hqueue->m_head %= hqueue->m_cap;
    --hqueue->m_size;

    return true;
}


// KuyruÄŸun alabileceÄŸi Ã¶ÄŸe sayÄ±sÄ±nÄ± yÃ¼kseltmek iÃ§in kullanÄ±lan fonksiyon. 
bool incrice_capacity(HQueue hqueue, size_t new_cap)
{
    if(new_cap <= hqueue->m_cap)
        return false;

    DATATYPE *pnew_queue = (DATATYPE*)malloc(new_cap * sizeof(DATATYPE));
    if(!pnew_queue)
        return false;

    size_t head = hqueue->m_head;

    for(size_t i = 0; i < hqueue->m_cap; ++i) {
        pnew_queue[i] = hqueue->m_queue[head++];
        head %= hqueue->m_cap;
    }

    hqueue->m_head = 0;
    hqueue->m_tail = hqueue->m_size;
    hqueue->m_cap = new_cap;

    free(hqueue->m_queue);
    hqueue->m_queue = pnew_queue;

    return true;
}

// Kuyruktaki tÃ¼m Ã¶ÄŸeleri silmek iÃ§in kullanÄ±lan fonksiyon. 
void clear(HQueue hqueue)
{
    hqueue->m_size = 0;
    hqueue->m_head = 0;
    hqueue->m_tail = 0;
}

// Kuyruk nesnesini silmek iÃ§in kullanÄ±lan fonksiyon. 
void destroy_queue(HQueue hqueue)
{
    free(hqueue->m_queue); // YapÄ± nesnesindeki tek gÃ¶sterisi olan yapÄ± Ã¼yesinin bellek alanÄ± geri veriliyor.
    free(hqueue); // YapÄ± nesnesindeki kendisinin bellek alanÄ± geri veriliyor.
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 20.37-20.49 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


**Kuyruk(queue)** veri yapÄ±sÄ±nÄ±n gerÃ§ekleÅŸtirimini **dinamic array** veri yapÄ±sÄ±nÄ± kullanarak yaptÄ±k, yazdÄ±ÄŸÄ±mÄ±z **kuyruk(queue)** veri yapÄ±sÄ±nÄ±n nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± aÅŸaÄŸÄ±dan inceleyebiliriz;

**Kuyruk(queue)** veri yapÄ±sÄ±ndan yapÄ±lan iÅŸlemler aÅŸaÄŸÄ±dan takip edilebilir;


|  AdÄ±m        | KuyruÄŸun Capacity DeÄŸeri  | KuyruÄŸun Durumu          | YapÄ±lan iÅŸlem                                |   Head GÃ¶stesici Indeks DeÄŸeri    | Tail GÃ¶stesici Indeks DeÄŸeri   | 
|:------------:|:-------------------------:|:------------------------:|:--------------------------------------------:|:---------------------------------:|:------------------------------:| 
|  1           | 5                         | * * * * *                |  BaÅŸlangÄ±Ã§ durumu                            | 0                                 | 0                              | 
|  2           | 5                         | 4 * * * *                |  `push(handler, 4)` iÅŸlemi sonrasÄ± durum     | 0                                 | 1                              | 
|  3           | 5                         | 4 6 * * *                |  `push(handler, 6)` iÅŸlemi sonrasÄ± durum     | 0                                 | 2                              | 
|  4           | 5                         | * 6 * * *                |  `pop(handler, val)` iÅŸlemi sonrasÄ± durum    | 1                                 | 2                              | 
|  5           | 5                         | * 6 8 * *                |  `push(handler, 8)` iÅŸlemi sonrasÄ± durum     | 1                                 | 3                              | 
|  6           | 5                         | * 6 8 2 *                |  `push(handler, 2)` iÅŸlemi sonrasÄ± durum     | 1                                 | 4                              | 
|  7           | 5                         | * * 8 2 *                |  `pop(handler, val)` iÅŸlemi sonrasÄ± durum    | 2                                 | 4                              | 
|  8           | 5                         | * * 8 2 1                |  `push(handler, 1)` iÅŸlemi sonrasÄ± durum     | 2                                 | 0                              | 
|  9           | 5                         | * * * 2 1                |  `pop(handler, val)` iÅŸlemi sonrasÄ± durum    | 3                                 | 0                              | 
|  10          | 5                         | 5 * * 2 1                |  `push(handler, 5)` iÅŸlemi sonrasÄ± durum     | 3                                 | 1                              | 
|  11          | 5                         | 5 * * * 1                |  `pop(handler, val)` iÅŸlemi sonrasÄ± durum    | 4                                 | 1                              | 
|  12          | 5                         | 5 * * * *                |  `pop(handler, val)` iÅŸlemi sonrasÄ± durum    | 0                                 | 1                              | 



1. AdÄ±m: BaÅŸlangÄ±Ã§ durumu.
    - Capacity: 5
    - `0 1 2 3 4`   --> Indeks deÄŸerleri
    - `H _ _ _ _`   --> Head GÃ¶stesici
    - `* * * * *`   --> Kuyruktaki verilerin gÃ¶rÃ¼nÃ¼mÃ¼
    - `T _ _ _ _`   --> Tail GÃ¶stesici

2. AdÄ±m: `push(handler, 4)` iÅŸlemi sonrasÄ± durum.
    - Capacity: 5
    - `0 1 2 3 4`   --> Indeks deÄŸerleri
    - `H _ _ _ _`   --> Head GÃ¶stesici
    - `4 * * * *`   --> Kuyruktaki verilerin gÃ¶rÃ¼nÃ¼mÃ¼
    - `_ T _ _ _`   --> Tail GÃ¶stesici


3. AdÄ±m: `push(handler, 6)` iÅŸlemi sonrasÄ± durum.
    - Capacity: 5
    - `0 1 2 3 4`   --> Indeks deÄŸerleri
    - `H _ _ _ _`   --> Head GÃ¶stesici
    - `4 6 * * *`   --> Kuyruktaki verilerin gÃ¶rÃ¼nÃ¼mÃ¼
    - `_ _ T _ _`   --> Tail GÃ¶stesici


4. AdÄ±m: `pop(handler, val)` iÅŸlemi sonrasÄ± durum.
    - Capacity: 5
    - `0 1 2 3 4`   --> Indeks deÄŸerleri
    - `_ H _ _ _`   --> Head GÃ¶stesici
    - `* 6 * * *`   --> Kuyruktaki verilerin gÃ¶rÃ¼nÃ¼mÃ¼
    - `_ _ T _ _`   --> Tail GÃ¶stesici


5. AdÄ±m: `push(handler, 8)` iÅŸlemi sonrasÄ± durum.
    - Capacity: 5
    - `0 1 2 3 4`   --> Indeks deÄŸerleri
    - `_ H _ _ _`   --> Head GÃ¶stesici
    - `* 6 8 * *`   --> Kuyruktaki verilerin gÃ¶rÃ¼nÃ¼mÃ¼
    - `_ _ _ T _`   --> Tail GÃ¶stesici


6. AdÄ±m: `push(handler, 2)` iÅŸlemi sonrasÄ± durum.
    - Capacity: 5
    - `0 1 2 3 4`   --> Indeks deÄŸerleri
    - `_ H _ _ _`   --> Head GÃ¶stesici
    - `* 6 8 2 *`   --> Kuyruktaki verilerin gÃ¶rÃ¼nÃ¼mÃ¼
    - `_ _ _ _ T`   --> Tail GÃ¶stesici


7. AdÄ±m: `pop(handler, val)` iÅŸlemi sonrasÄ± durum.
    - Capacity: 5
    - `0 1 2 3 4`   --> Indeks deÄŸerleri
    - `_ _ H _ _`   --> Head GÃ¶stesici
    - `* * 8 2 *`   --> Kuyruktaki verilerin gÃ¶rÃ¼nÃ¼mÃ¼
    - `_ _ _ _ T`   --> Tail GÃ¶stesici


8. AdÄ±m: `push(handler, 1)` iÅŸlemi sonrasÄ± durum.
    - Capacity: 5
    - `0 1 2 3 4`   --> Indeks deÄŸerleri
    - `_ _ H _ _`   --> Head GÃ¶stesici
    - `* * 8 2 1`   --> Kuyruktaki verilerin gÃ¶rÃ¼nÃ¼mÃ¼
    - `T _ _ _ _`   --> Tail GÃ¶stesici(Bu adÄ±mda koddaki `%` iÅŸleminden dolayÄ± Tail gÃ¶stericisinin indeks deÄŸeri "0" oluyor)


9. AdÄ±m: `pop(handler, val)` iÅŸlemi sonrasÄ± durum.
    - Capacity: 5
    - `0 1 2 3 4`   --> Indeks deÄŸerleri
    - `_ _ _ H _`   --> Head GÃ¶stesici
    - `* * * 2 1`   --> Kuyruktaki verilerin gÃ¶rÃ¼nÃ¼mÃ¼
    - `T _ _ _ _`   --> Tail GÃ¶stesici


10. AdÄ±m: `push(handler, 5)` iÅŸlemi sonrasÄ± durum.
    - Capacity: 5
    - `0 1 2 3 4`   --> Indeks deÄŸerleri
    - `_ _ _ H _`   --> Head GÃ¶stesici
    - `5 * * 2 1`   --> Kuyruktaki verilerin gÃ¶rÃ¼nÃ¼mÃ¼
    - `_ T _ _ _`   --> Tail GÃ¶stesici


11. AdÄ±m: `pop(handler, val)` iÅŸlemi sonrasÄ± durum.
    - Capacity: 5
    - `0 1 2 3 4`   --> Indeks deÄŸerleri
    - `_ _ _ _ H`   --> Head GÃ¶stesici
    - `5 * * * 1`   --> Kuyruktaki verilerin gÃ¶rÃ¼nÃ¼mÃ¼
    - `_ T _ _ _`   --> Tail GÃ¶stesici


12. AdÄ±m: `pop(handler, val)` iÅŸlemi sonrasÄ± durum.
    - Capacity: 5
    - `0 1 2 3 4`   --> Indeks deÄŸerleri
    - `H _ _ _ _`   --> Head GÃ¶stesici(Bu adÄ±mda koddaki `%` iÅŸleminden dolayÄ± Head gÃ¶stericisinin indeks deÄŸeri "0" oluyor)
    - `5 * * * *`   --> Kuyruktaki verilerin gÃ¶rÃ¼nÃ¼mÃ¼
    - `_ T _ _ _`   --> Tail GÃ¶stesici



ğŸ‘‡ AÅŸaÄŸÄ±daki programda yazdÄ±ÄŸÄ±mÄ±z kuyruk modÃ¼lÃ¼nÃ¼ sÄ±nama iÅŸlemleri iÃ§in yazÄ±lmÄ±ÅŸ olan program incelenebilir.
```C
#include <stdit.h>
#include <stdio.h>
#include "queue.h"


int main(void)
{
    // 'h' adÄ±nda bir deÄŸiÅŸkene kuyruk nesnesi atama iÅŸlemini yapÄ±yoruz.
    HQueue h = create_queue(10);
    if(h == NULL) {
        frintf(stderr, "cannot create queue.\n");
        return 1;
    }

    // Kuyruk nesnesine yedi elemanÄ±na dÃ¶ngÃ¼ ile ekleniyor.
    for(int i = 0; i < 7; ++i) {
        if(!push(h, i)) {
            fprintf(stderr, "cannot push the value to the queue.\n");
            return 2;
        }

        printf("the value %d pushed.\n", i);
    }

    // Kuyruktan 'pop' iÅŸlemiyle eleman siliniyor.
    int val;
    for(int i = 0; i < 5; ++i) {
        pop(h, &val);
        printf("%d poped from the queue.\n", val);
    }

    printf("queue has %zu elements.\n", get_size(h));

    
    // Kuyruk nesnesine altÄ± tane eleman dÃ¶ngÃ¼ ile ekleniyor.
    for(int i = 0; i < 6; ++i) {
        if(!push(h, i)) {
            fprintf(stderr, "cannot push the value to the queue.\n");
            return 2;
        }

        printf("the value %d pushed.\n", i);
    }


    (void)getchar(); // Process burada durdurulacak.
}
```


YukarÄ±da soyut kuyruk veri yapÄ±sÄ±nÄ± **dynamic array** kullanarak gerÃ§ekleÅŸtirdik ama baÄŸlÄ± listeyle de gerÃ§ekleÅŸtirme yapabiliriz, </br>
baÄŸlÄ± listeyle gerÃ§ekleÅŸtirmek hem daha kolay hem de daha Ã§ok tercih edilen bir yÃ¶ntemdir.


### Soyut Kuyruk Veri YapÄ±sÄ±nÄ±n BaÄŸlÄ± Liste ile GerÃ§ekleÅŸtirimi(Abstract Queue Data Structure Implementation with Linked List) ğŸŒŸ 

âœï¸ Burada `queue.h` baÅŸlÄ±k dosyasÄ±nÄ± aÅŸaÄŸÄ±daki gibi ekliyoruz, **kuyruk(queue)** veri yapÄ±sÄ±nÄ±n gerÃ§ekleÅŸtiriminde kullanÄ±lacak olan baÅŸlÄ±k dosyasÄ±nÄ± aÅŸaÄŸÄ±daki gibi yazÄ±yoruz.
```C
#pragma once
// #ifndef QUEUE_H
// #define QUEUE_H

#include <stddef.h> // 'size_t' tÃ¼r eÅŸ adÄ±nÄ±n bildirimini iÃ§eren en hafif baÅŸlÄ±k dosyasÄ± eklendi.
#include <stdbool.h> // 'bool', 'true', 'false' gibi object-like makrolarÄ± kullanabilmek iÃ§in eklenmiÅŸtir.


typedef int DATATYPE; // DÃ¼ÄŸÃ¼mde tutulacak olan tÃ¼r.


typedef struct NODE {
    DATATYPE mval;
    struct NODE* mpnext;
} NODE;


// Queue  : 'struct tag_queue' yapÄ± tÃ¼rÃ¼nÃ¼n eÅŸ adÄ±.
// *HQueue: 'struct tag_queue' yapÄ± tÃ¼rÃ¼nden nesnelerin adresi olan tÃ¼rÃ¼n eÅŸ adÄ±.
typedef struct tag_queue {
    NODE* mphead; // Kuyruk veri yapÄ±sÄ±nÄ±n ilk dÃ¼ÄŸÃ¼mÃ¼nÃ¼n adres bilgisini tutan yapÄ± Ã¼yesi.
    NODE* mptail; // Kuyruk veri yapÄ±sÄ±nÄ±n son dÃ¼ÄŸÃ¼mÃ¼nÃ¼n adres bilgisini tutan yapÄ± Ã¼yesi.
    size_t msize; // Kuyruk veri yapÄ±sÄ±nÄ±n eleman sayÄ±sÄ±nÄ± tutan yapÄ± Ã¼yesi.
} Queue, *HQueue;


// Yeni bir kuyruk veri yapÄ±sÄ± oluÅŸturan fonksiyon.
HQueue create_queue(void);

// Kuyruk nesnesini silmek iÃ§in kullanÄ±lan fonksiyon.
void destroy_queue(HQueue);

// KuyruÄŸa 'call by value' yÃ¶ntemiyle Ã¶ÄŸe ekleme iÅŸlemini yapan fonksiyon.
bool push(HQueue h, DATATYPE val);

// KuyruÄŸa 'call by reference' yÃ¶ntemiyle Ã¶ÄŸe ekleme iÅŸlemini yapan fonksiyon.
bool push_p(HQueue h, const DATATYPE* val);

// Kuyruktan silerek Ã¶ÄŸe Ã§Ä±kartan ve o Ã¶ÄŸenin bilgisini output argÃ¼man(val) ile geriye dÃ¶ndÃ¼ren fonksiyon.
bool pop(HQueue h, DATATYPE* val);

// Kuyruktaki tÃ¼m Ã¶ÄŸeleri silmek iÃ§in kullanÄ±lan fonksiyon.
void clear(HQueue h);


// KuyruÄŸun boÅŸ olup olmadÄ±ÄŸÄ± bilgisini geriye dÃ¶ndÃ¼ren inline fonksiyon. 
static inline bool is_empty(HQueue h)
{
    return h->m_size == 0;
}

// Kuyrukta o anda bulunan Ã¶ÄŸe sayÄ±sÄ± bilgisini geriye dÃ¶ndÃ¼ren inline fonksiyon.  
static inline size_t get_size(HQueue h)
{
    return h->m_size;
}


// #endif
```



âœï¸ Burada `queue.c` kaynak dosyasÄ±nÄ± aÅŸaÄŸÄ±daki gibi ekliyoruz, **kuyruk(queue)** veri yapÄ±sÄ±nÄ±n gerÃ§ekleÅŸtiriminde kullanÄ±lacak olan kaynak dosyayÄ± aÅŸaÄŸÄ±daki gibi yazÄ±yoruz.
```C
#include "queue.h"
#include <stdlib.h>
#include <stdio.h> 


// Yeni bir kuyruk veri yapÄ±sÄ± oluÅŸturan fonksiyon. 
HQueue create_queue(void)
{
    // 'struct tag_queue' veri yapÄ±sÄ± nesnesi iÃ§in bellekten yer ayrÄ±lÄ±yor.
    HQueue h = (HQueue)malloc(sizeof(Queue));
    if(!h)
        return NULL;

    h->mphead = h->mptail = NULL;
    h->msize = 0;

    return h;
}


// KuyruÄŸa 'call by value' yÃ¶ntemiyle Ã¶ÄŸe ekleme iÅŸlemini yapan fonksiyon. 
bool push(HQueue h, DATATYPE val)
{
    // Yeni bir dÃ¼ÄŸÃ¼m oluÅŸturuyoruz.
    NODE* pnewnode = (NODE*)malloc(sizeof(NODE));
    if(!pnewnode)
        return false;

    // Yeni oluÅŸturulan dÃ¼ÄŸÃ¼mÃ¼n Ã¼yelerinin deÄŸerlerini atÄ±yoruz.
    pnewnode->mval = val;
    pnewnode->mpnext = NULL; // Yeni eklenen dÃ¼ÄŸÃ¼m son dÃ¼ÄŸÃ¼m olacaÄŸÄ± iÃ§in bu dÃ¼ÄŸÃ¼mÃ¼n 'mpnext' gÃ¶stericisinin deÄŸeri 'NULL' yapÄ±lÄ±yor.
     
    if(h->mptail)
        h->mptail->mpnext = pnewnode; // Kuyruk nesnesinin 'mptail' nesnesi mevcutsa, bu nesne artÄ±k sondan bir Ã¶nceki dÃ¼ÄŸÃ¼m olacaÄŸÄ± iÃ§in kendinden sonraki dÃ¼ÄŸÃ¼m yeni oluÅŸturulan dÃ¼ÄŸÃ¼m yapÄ±lÄ±yor.
    else
        h->mphead = pnewnode; // Kuyruk nesnesinin 'mptail' nesnesi 'NULL' ise kuyruk nesnesinin 'mphead' nesnesi de boÅŸ demektir ve yeni dÃ¼ÄŸÃ¼m kuyruk nesnesinin 'mphead' nesnesi yapÄ±lÄ±yor.

    h->mptail = pnewnode; // Yeni eklenen dÃ¼ÄŸÃ¼m son dÃ¼ÄŸÃ¼m olmasÄ± gerektiÄŸi iÃ§in gerekli atama iÅŸlemi yapÄ±lÄ±yor.
    ++h->msize; // Kuyruk nesnesinin eleman sayÄ±sÄ± bir arttÄ±rÄ±lÄ±yor.
    
    return true;
}


// KuyruÄŸa 'call by reference' yÃ¶ntemiyle Ã¶ÄŸe ekleme iÅŸlemini yapan fonksiyon. 
bool push_p(HQueue h, const DATATYPE* val)
{
    // Yeni bir dÃ¼ÄŸÃ¼m oluÅŸturuyoruz.
    NODE* pnewnode = (NODE*)malloc(sizeof(NODE));
    if(!pnewnode)
        return false;

    // Yeni oluÅŸturulan dÃ¼ÄŸÃ¼mÃ¼n Ã¼yelerinin deÄŸerlerini atÄ±yoruz.
    pnewnode->mval = *val;
    pnewnode->mpnext = NULL; // Yeni eklenen dÃ¼ÄŸÃ¼m son dÃ¼ÄŸÃ¼m olacaÄŸÄ± iÃ§in bu dÃ¼ÄŸÃ¼mÃ¼n 'mpnext' gÃ¶stericisinin deÄŸeri 'NULL' yapÄ±lÄ±yor.

    if(h->mptail)
        h->mptail->mpnext = pnewnode; // Kuyruk nesnesinin 'mptail' nesnesi mevcutsa, bu nesne artÄ±k sondan bir Ã¶nceki dÃ¼ÄŸÃ¼m olacaÄŸÄ± iÃ§in kendinden sonraki dÃ¼ÄŸÃ¼m yeni oluÅŸturulan dÃ¼ÄŸÃ¼m yapÄ±lÄ±yor.
    else
        h->mphead = pnewnode; // Kuyruk nesnesinin 'mptail' nesnesi 'NULL' ise kuyruk nesnesinin 'mphead' nesnesi de boÅŸ demektir ve yeni dÃ¼ÄŸÃ¼m kuyruk nesnesinin 'mphead' nesnesi yapÄ±lÄ±yor.

    h->mptail = pnewnode; // Yeni eklenen dÃ¼ÄŸÃ¼m son dÃ¼ÄŸÃ¼m olmasÄ± gerektiÄŸi iÃ§in gerekli atama iÅŸlemi yapÄ±lÄ±yor.
    ++h->msize; // Kuyruk nesnesinin eleman sayÄ±sÄ± bir arttÄ±rÄ±lÄ±yor.
    
    return true;
}


// Kuyruktan silerek Ã¶ÄŸe Ã§Ä±kartan ve o Ã¶ÄŸe bilgisini output argÃ¼man(val) ile geriye dÃ¶ndÃ¼ren fonksiyon. 
bool pop(HQueue h, DATATYPE* val)
{
    // GÃ¶nderilen kuyruk listesi boÅŸsa ve Ã§Ä±kartÄ±labilecek bir dÃ¼ÄŸÃ¼m yoksa geriye false dÃ¶ndÃ¼rÃ¼lecek.
    if(!h->mphead)
        return false;
    
    NODE* node = h->mphead; // serbest bÄ±rakmak iÃ§in ilk dÃ¼ÄŸÃ¼mÃ¼n adresi dÃ¼ÄŸÃ¼m tÃ¼rÃ¼nden bir pointer deÄŸiÅŸkene alÄ±nÄ±yor.
    *val = node->mval; // Ã‡aÄŸÄ±ran kodun fonksiyona geÃ§tiÄŸi adrese kuyruktan Ã§Ä±kartÄ±lacak olan dÃ¼ÄŸÃ¼mÃ¼n taÅŸÄ±dÄ±ÄŸÄ± deÄŸer atanÄ±yor.

    // EÄŸer ilk dÃ¼ÄŸÃ¼mden bir sonraki dÃ¼ÄŸÃ¼m 'NULL' pointer ise kuyruk nesnesinin 'mptail' pointer'Ä± 'NULL' pointer yapÄ±lÄ±yor.
    if(!node->mpnext) // 'if(h->msize == 1)' olarak ta yazÄ±labilir.
        h->mptail = NULL;

    h->mphead = node->mpnext; // Kuyruk nesnesinin ilk dÃ¼ÄŸÃ¼mÃ¼ siliineceÄŸi iÃ§in ilk dÃ¼ÄŸÃ¼m silinecek dÃ¼ÄŸÃ¼mden sonraki dÃ¼ÄŸÃ¼m olacak biÃ§imde ayarlanÄ±yor.
    --h->msize; // Ä°ÅŸlem yapÄ±lan kuyruk nesnesindeki dÃ¼ÄŸÃ¼m sayÄ±sÄ± deÄŸeri bir azaltÄ±lÄ±yor.
    
    free(node); // Kuyruk nesnesinden silinen dÃ¼ÄŸÃ¼mÃ¼n bellek alanÄ± iade ediliyor.

    return true;
}


// Kaynak dosya dÄ±ÅŸÄ±ndan Ã§aÄŸrÄ±lamayan ve tÃ¼m dÃ¼ÄŸÃ¼mleri silmek iÃ§in kullanÄ±lacak olan fonksiyon. 
static void free_all_nodes(HQueue h)
{
    NODE* pnode = h->mphead; // Kuyruk nesnesinin ilk dÃ¼ÄŸÃ¼mÃ¼nÃ¼n adresi bir pointer deÄŸiÅŸkene atanÄ±yor.

    // Kuyruk nesnesindeki tÃ¼m dÃ¼ÄŸÃ¼mleri gezecek olan dÃ¶ngÃ¼.
    while(pnode) { // 'pnode' pointer'Ä±nÄ±n deÄŸeri 'NULL' olana kadar dÃ¶ngÃ¼ dÃ¶necek.
        NODE* ptemp = pnode; // Ä°lgili dÃ¼ÄŸÃ¼mÃ¼n bellek bloÄŸunun iade edilmesi iÃ§in ilgili dÃ¼ÄŸÃ¼m baÅŸka bir pointer deÄŸiÅŸkene alÄ±nÄ±yor.
        pnode = pnode->mpnext; // 'pnode' dÃ¼ÄŸÃ¼mÃ¼nden bir sonraki dÃ¼ÄŸÃ¼mÃ¼n adresi 'pnode' gÃ¶stericisine alÄ±nÄ±yor.
        free(ptemp); // Ä°lgili dÃ¼ÄŸÃ¼mÃ¼n bellek bloÄŸu iade ediliyor.
    }
}


// Kuyruktaki tÃ¼m dÃ¼ÄŸÃ¼mleri silmek iÃ§in kullanÄ±lan fonksiyon. 
void clear(HQueue h)
{
    free_all_nodes(h); // Kuyruk nesnesindeki tÃ¼m dÃ¼ÄŸÃ¼mlerin bellek alanlarÄ± iade ediliyor.
    
    // Ä°lgili kuyruk nesnesinin boÅŸaltÄ±lmasÄ± iÃ§in kuyruk nesnesinin Ã¼yelerinin deÄŸerleri ayarlanÄ±yor.
    h->mphead = NULL;
    h->mptail = NULL;
    h->msize = 0;
}

// Kuyruk nesnesini silmek iÃ§in kullanÄ±lan fonksiyon. 
void destroy_queue(HQueue h)
{
    free_all_nodes(h); // Kuyruk nesnesindeki tÃ¼m dÃ¼ÄŸÃ¼mlerin bellek alanlarÄ± iade ediliyor.
    free(h); // YapÄ± nesnesindeki kendisinin bellek alanÄ± geri veriliyor.
}

```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda yazdÄ±ÄŸÄ±mÄ±z kuyruk modÃ¼lÃ¼nÃ¼ sÄ±nama iÅŸlemleri iÃ§in yazÄ±lmÄ±ÅŸ olan program incelenebilir.
```C
#include <stdit.h>
#include <stdio.h>
#include "queue.h"


int main(void)
{
    // 'h' adÄ±nda bir deÄŸiÅŸkene kuyruk nesnesi atama iÅŸlemini yapÄ±yoruz.
    HQueue h = create_queue();

    // Kuyruk nesnesine on tane dÃ¼ÄŸÃ¼m dÃ¶ngÃ¼ ile ekleniyor.
    for(int i = 0; i < 10; ++i) {
        push(h, i);
        printf("%d pushed!\n", i);
    }

    printf("size = %zu\n", get_size(h));
    
    int val;

    while(!ia_empty(h)) {
        pop(h, &val);
        printf("%d poped!\n", val);
        (void)getchar(); // Burada process'in akÄ±ÅŸÄ± kullanÄ±cÄ± bir tuÅŸa bazÄ±ncaya kadar bekletilecek.
    }
}
```


### Soyut YÄ±ÄŸÄ±n Veri YapÄ±sÄ±nÄ±n Dizi ile GerÃ§ekleÅŸtirimi(Abstract Stack Data Structure Implementation with Array) ğŸŒŸ 

**FIFO(Fisr In First Out)** mekanizmasÄ± **Queue** veri yapÄ±sÄ±nda kullanÄ±lmaktadÄ±r. </br>
**LIFO(Last In First Out)** mekanizmasÄ± **Stack** veri yapÄ±sÄ±nda kullanÄ±lmaktadÄ±r.



MÃ¼lakatlarda veri yapÄ±larÄ±yla ilgili olarak sÄ±k sorulan bir soru aÅŸaÄŸÄ±daki gibidir. </br> 
**Parantez uyumu(Brackets match)** algoritmasÄ±yla ilgili olarak verilen bir metindeki `()`,`[]`,`{}`,`<>` parantezlerinin doÄŸru olarak aÃ§Ä±lÄ±p kapatÄ±ldÄ±ÄŸÄ±nÄ±n sÄ±namasÄ±nÄ± yapan programÄ± yazÄ±nÄ±z? </br>
`<([5] - [3])> {{[<c> <f>]}}` girdisi iÃ§in doÄŸru sonucu dÃ¶nÃ¼lmeli, buradaki sÄ±namayÄ± yapacak olan fonksiyonu sen uÄŸraÅŸarak yazmalÄ±sÄ±n.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 21.45-22.00 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


**YÄ±ÄŸÄ±n(stack)** soyut veri yapÄ±sÄ±nÄ±n gerÃ§ekleÅŸtirimi oldukÃ§a kolaydÄ±r.



âœï¸ Burada `stack.h` baÅŸlÄ±k dosyasÄ±nÄ± aÅŸaÄŸÄ±daki gibi ekliyoruz, **yÄ±ÄŸÄ±n(stack)** veri yapÄ±sÄ±nÄ±n gerÃ§ekleÅŸtiriminde kullanÄ±lacak olan baÅŸlÄ±k dosyasÄ±nÄ± aÅŸaÄŸÄ±daki gibi yazÄ±yoruz.
```C
#pragma once
// #ifndef QUEUE_H
// #define QUEUE_H

#include <stddef.h> // 'size_t' tÃ¼r eÅŸ adÄ±nÄ±n bildirimini iÃ§eren en hafif baÅŸlÄ±k dosyasÄ± eklendi.
#include <stdbool.h> // 'bool', 'true', 'false' gibi object-like makrolarÄ± kullanabilmek iÃ§in eklenmiÅŸtir.

typedef int DATATYPE;

// STACK  : 'struct tag_stack' yapÄ± tÃ¼rÃ¼nÃ¼n eÅŸ adÄ±.
// *HSTACK: 'struct tag_stack' yapÄ± tÃ¼rÃ¼nden nesnelerin adresi olan tÃ¼rÃ¼n eÅŸ adÄ±.
typedef struct tag_stack {
    DATATYPE* mpstack; // Burada yÄ±ÄŸÄ±na eklenecek olan Ã¶ÄŸeleri tutmak iÃ§in dizi veri yapÄ±sÄ± kullanÄ±lacak.
    size_t mcap;
    size_t msize;
} STACK, *HSTACK;


HSTACK create_stack(size_t cap);

void destroy_stack(HSTACK);

bool push(HSTACK, DATATYPE);

bool push_p(HSTACK, const DATATYPE*);

bool top(HSTACK, DATATYPE*);

bool pop(HSTACK, DATATYPE*);

void clear(HSTACK);

static inline size_t get_size(HSTACK h)
{
    return h->msize;
}

static inline size_t is_empty(HSTACK h)
{
    return h->msize;
}

// #endif
```



âœï¸ Burada `stack.c` kaynak dosyasÄ±nÄ± aÅŸaÄŸÄ±daki gibi ekliyoruz, **yÄ±ÄŸÄ±n(stack)** veri yapÄ±sÄ±nÄ±n gerÃ§ekleÅŸtiriminde kullanÄ±lacak olan kaynak dosyayÄ± aÅŸaÄŸÄ±daki gibi yazÄ±yoruz.
```C
#include "stack.h"


// YÄ±ÄŸÄ±na nesnesi oluÅŸturmak iÃ§in kullanÄ±lan fonksiyon. 
HSTACK create_stack(size_t cap)
{
    HSTACK h = (HSTACK) malloc(sizeof(HSTACK)); // YÄ±ÄŸÄ±n nesnesi iÃ§in bellekten yer ayrÄ±lÄ±yor.
    if(!h)
        return NULL;

    h->mpstack = (DATATYPE*)malloc(cap * sizeof(DATATYPE));  // YÄ±ÄŸÄ±n nesnesinin tutacaÄŸÄ± verinin tutulabilmesi iÃ§in bellekten yer ayrÄ±lÄ±yor.
    if(!h->mpstack) {
        free(h);
        return NULL;
    }

    h->mcap = cap; // YÄ±ÄŸÄ±nÄ±n tutakileceÄŸi en fazla deÄŸer ilgili yÄ±ÄŸÄ±n nesnesine atanÄ±yor.
    h->msize = 0; // Ä°lk baÅŸta yÄ±ÄŸÄ±nda tutulan Ã¶ÄŸe olmayacaÄŸÄ± iÃ§in '0' olarak veriliyor.
}


// YÄ±ÄŸÄ±n nesnelerinin bellekten silinmesi iÃ§in kullanÄ±lan fonksiyon. 
void destroy_stack(HSTACK h)
{
    free(h->mpstack);
    free(h);
}


// YÄ±ÄŸÄ±na yeni Ã¶ÄŸe eklemek iÃ§in kullanÄ±lan fonksiyon. 
bool push(HSTACK h, DATATYPE val)
{
    if(h->msize == h->mcap) {
        return false;
    }

    h->mpstack[h->msize] = val; // Ä°lgili deÄŸer yÄ±ÄŸÄ±na ekleniyor.
    ++h->msize; // YÄ±ÄŸÄ±ndaki Ã¶ÄŸe sayÄ±sÄ±nÄ± tutan deÄŸer bir arttÄ±rÄ±lÄ±yor.

    return true;
}


// YÄ±ÄŸÄ±na yeni Ã¶ÄŸe eklemek iÃ§in kullanÄ±lan fonksiyon. 
bool push_q(HSTACK h, const DATATYPE* val)
{
    if(h->msize == h->mcap) {
        return false;
    }

    h->mpstack[h->msize] = *val; // Ä°lgili deÄŸer yÄ±ÄŸÄ±na ekleniyor.
    ++h->msize; // YÄ±ÄŸÄ±ndaki Ã¶ÄŸe sayÄ±sÄ±nÄ± tutan deÄŸer bir arttÄ±rÄ±lÄ±yor.

    return true;
}


// YÄ±ÄŸÄ±nÄ±n en tepesindeki deÄŸeri ilgili deÄŸeri yÄ±ÄŸÄ±ndan Ã§Ä±karmadan ilgili deÄŸeri dÃ¶ndÃ¼rmek iÃ§in kullanÄ±lan fonksiyon. .
bool top(HSTACK h, DATATYPE* val)
{
    // EÄŸer yÄ±ÄŸÄ±n boÅŸsa baÅŸarÄ±sÄ±n geriye dÃ¶nÃ¼lecek.
    if(is_empty(h))
        return false;

    *val = h->mpstack[h->msize - 1]; // YÄ±ÄŸÄ±nÄ±n en tepesindeki deÄŸerin ne olduÄŸunu geriye dÃ¶ndÃ¼rebilmek iÃ§in yapÄ±lan iÅŸlem.

    return true;
}


// YÄ±ÄŸÄ±nÄ±n en tepesindeki deÄŸeri ilgili deÄŸeri yÄ±ÄŸÄ±ndan Ã§Ä±kararak ilgili deÄŸeri dÃ¶ndÃ¼rmek iÃ§in kullanÄ±lan fonksiyon. .
bool pop(HSTACK h, DATATYPE* val)
{
    // EÄŸer yÄ±ÄŸÄ±n boÅŸsa baÅŸarÄ±sÄ±n geriye dÃ¶nÃ¼lecek.
    if(is_empty(h))
        return false;

    *val = h->mpstack[--h->msize]; // YÄ±ÄŸÄ±nÄ±n en tepesindeki deÄŸerin ne olduÄŸunu geriye dÃ¶ndÃ¼rebilmek iÃ§in yapÄ±lan iÅŸlem.

    return true;
}


// YÄ±ÄŸÄ±nÄ± boÅŸaltmak iÃ§in kullanÄ±lan fonksiyon. 
void clear(HSTACK h)
{
    h->msize = 0; // YÄ±ÄŸÄ±n nesnesinin 'msize' Ã¼yesinin deÄŸeri '0' yapÄ±larak yÄ±ÄŸÄ±n nesnsi boÅŸaltÄ±lmÄ±ÅŸ oluyor.
}

```


### Soyut YÄ±ÄŸÄ±n Veri YapÄ±sÄ±nÄ±n BaÄŸlÄ± Liste ile GerÃ§ekleÅŸtirimi(Abstract Stack Data Structure Implementation with Linked List) ğŸŒŸ


âœï¸ Burada `stack.h` baÅŸlÄ±k dosyasÄ±nÄ± aÅŸaÄŸÄ±daki gibi ekliyoruz, **yÄ±ÄŸÄ±n(stack)** veri yapÄ±sÄ±nÄ±n gerÃ§ekleÅŸtiriminde kullanÄ±lacak olan baÅŸlÄ±k dosyasÄ±nÄ± aÅŸaÄŸÄ±daki gibi yazÄ±yoruz.
```C
#pragma once
// #ifndef QUEUE_H
// #define QUEUE_H

#include <stddef.h> // 'size_t' tÃ¼r eÅŸ adÄ±nÄ±n bildirimini iÃ§eren en hafif baÅŸlÄ±k dosyasÄ± eklendi.
#include <stdbool.h> // 'bool', 'true', 'false' gibi object-like makrolarÄ± kullanabilmek iÃ§in eklenmiÅŸtir.

typedef int DATATYPE;

// DÃ¼ÄŸÃ¼m verisini tutacak olan yapÄ± tÃ¼rÃ¼nÃ¼n tanÄ±mÄ±.
typedef struct tag_note {
    DATATYPE mval;
    struct tag_note* mpnext;
} NODE;


// STACK  : 'struct tag_stack' yapÄ± tÃ¼rÃ¼nÃ¼n eÅŸ adÄ±.
// *HSTACK: 'struct tag_stack' yapÄ± tÃ¼rÃ¼nden nesnelerin adresi olan tÃ¼rÃ¼n eÅŸ adÄ±.
typedef struct tag_stack {
    NODE* mphead; // YÄ±ÄŸÄ±nÄ±n en tepesindeki dÃ¼ÄŸÃ¼mÃ¼n adresini tutacak olan yapÄ± Ã¼yesi.
    size_t msize; 
} STACK, *HSTACK;


HSTACK create_stack(size_t cap);

void destroy_stack(HSTACK);

bool push(HSTACK, DATATYPE);

bool push_p(HSTACK, const DATATYPE*);

bool top(HSTACK, DATATYPE*);

bool pop(HSTACK, DATATYPE*);

void clear(HSTACK);

static inline size_t get_size(HSTACK h)
{
    return h->msize;
}

static inline size_t is_empty(HSTACK h)
{
    return h->msize;
}

// #endif
```



âœï¸ Burada `stack.c` kaynak dosyasÄ±nÄ± aÅŸaÄŸÄ±daki gibi ekliyoruz, **yÄ±ÄŸÄ±n(stack)** veri yapÄ±sÄ±nÄ±n gerÃ§ekleÅŸtiriminde kullanÄ±lacak olan kaynak dosyayÄ± aÅŸaÄŸÄ±daki gibi yazÄ±yoruz.
```C
#include "stack.h"


// YÄ±ÄŸÄ±na nesnesi oluÅŸturmak iÃ§in kullanÄ±lan fonksiyon. 
HSTACK create_stack(size_t cap)
{
    HSTACK h = (HSTACK) malloc(sizeof(HSTACK)); // YÄ±ÄŸÄ±n nesnesi iÃ§in bellekten yer ayrÄ±lÄ±yor.
    if(!h)
        return NULL;

    h->mphead = NULL; // Ä°lk baÅŸta yÄ±ÄŸÄ±nda boÅŸ olacaÄŸÄ± iÃ§in 'mphead' deÄŸeri 'NULL' veriliyor.
    h->msize = 0; // Ä°lk baÅŸta yÄ±ÄŸÄ±nda tutulan Ã¶ÄŸe olmayacaÄŸÄ± iÃ§in '0' olarak veriliyor.

    return h;
}


// YÄ±ÄŸÄ±ndaki tÃ¼m dÃ¼ÄŸÃ¼mleri temizleyen fonkisyon. 
static free_all_nodes(HSTACK h)
{
    NODE* pnode = h->mphead;

    while(pnode) {
        NODE* ptemp = pnode;
        pnode = pnode->mpnext;
        free(ptemp);
    }
}


// YÄ±ÄŸÄ±n nesnelerinin bellekten silinmesi iÃ§in kullanÄ±lan fonksiyon. 
void destroy_stack(HSTACK h)
{
    free_all_nodes(h);
    free(h);
}


// YÄ±ÄŸÄ±na yeni dÃ¼ÄŸÃ¼m eklemek iÃ§in kullanÄ±lan fonksiyon. 
bool push(HSTACK h, DATATYPE val)
{
    NODE* pnewnode = (NODE*)malloc(sizeof(NODE));
    if(!pnewnode)
        return false;

    pnewnode->mval = val;
    pnewnode->mpnext = h->mphead;
    h->mphead = pnewnode;
    ++h->msize;

    return true;
}


// YÄ±ÄŸÄ±na yeni dÃ¼ÄŸÃ¼m eklemek iÃ§in kullanÄ±lan fonksiyon. 
bool push_p(HSTACK h, DATATYPE* val)
{
    NODE* pnewnode = (NODE*)malloc(sizeof(NODE));
    if(!pnewnode)
        return false;

    pnewnode->mval = *val;
    pnewnode->mpnext = h->mphead;
    h->mphead = pnewnode;
    ++h->msize;

    return true;
}


// YÄ±ÄŸÄ±nÄ±n en tepesindeki dÃ¼ÄŸÃ¼mÃ¼ ilgili dÃ¼ÄŸÃ¼mÃ¼ yÄ±ÄŸÄ±ndan Ã§Ä±karmadan dÃ¼ÄŸÃ¼mÃ¼n deÄŸerini dÃ¶ndÃ¼rmek iÃ§in kullanÄ±lan fonksiyon. .
bool top(HSTACK h, DATATYPE* val)
{
    // EÄŸer yÄ±ÄŸÄ±n boÅŸsa baÅŸarÄ±sÄ±n geriye dÃ¶nÃ¼lecek.
    if(is_empty(h))
        return false;

    *val = h->mphead->mval; // YÄ±ÄŸÄ±nÄ±n en tepesindeki deÄŸerin ne olduÄŸunu geriye dÃ¶ndÃ¼rebilmek iÃ§in yapÄ±lan iÅŸlem.

    return true;
}


// YÄ±ÄŸÄ±nÄ±n en tepesindeki dÃ¼ÄŸÃ¼mÃ¼ ilgili dÃ¼ÄŸÃ¼mÃ¼ yÄ±ÄŸÄ±ndan Ã§Ä±kararak dÃ¼ÄŸÃ¼mÃ¼n deÄŸerini dÃ¶ndÃ¼rmek iÃ§in kullanÄ±lan fonksiyon. .
bool pop(HSTACK h, DATATYPE* val)
{
    // EÄŸer yÄ±ÄŸÄ±n boÅŸsa baÅŸarÄ±sÄ±n geriye dÃ¶nÃ¼lecek.
    if(is_empty(h))
        return false;

    *val = h->mphead->mval; // YÄ±ÄŸÄ±nÄ±n en tepesindeki deÄŸerin ne olduÄŸunu geriye dÃ¶ndÃ¼rebilmek iÃ§in yapÄ±lan iÅŸlem.

    // YÄ±ÄŸÄ±n nesnesinden ilk dÃ¼ÄŸÃ¼mÃ¼ siliyoruz.
    NODE* ptemp = h->mphead;
    h->mphead = h->mphead->mpnext; // YapÄ± nesnesinin ilk dÃ¼ÄŸÃ¼mÃ¼ eski ilk dÃ¼ÄŸÃ¼mden bir sonraki dÃ¼ÄŸÃ¼m yapÄ±lÄ±yor.
    free(ptemp); // Silinen dÃ¼ÄŸÃ¼mÃ¼n bellek alanÄ± iade ediliyor.

    return true;
}


// YÄ±ÄŸÄ±nÄ± boÅŸaltmak iÃ§in kullanÄ±lan fonksiyon. 
void clear(HSTACK h)
{
    free_all_nodes(h);
    h->mphead = NULL;
    h->msize = 0;
}

```


Ders sonu ...
