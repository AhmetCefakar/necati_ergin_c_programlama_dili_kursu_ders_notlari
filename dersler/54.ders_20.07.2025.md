# 54.Ders 20.07.2025 🕘

Derse 4(09:01)-5(09:25)-6(09:48)-7(10:15)-6(10:55)-7(10:57) kişi katıldı.
---


## `remove` ve `rename` Fonksiyonları

`remove` fonksiyonunun prototipi `int remove(const char* filename);` biçimindedir, bu fonksiyon bir dosyayı silme işlemini gerçekleştirmektedir. Bu fonksiyon dosya silme işlemini başarılı biçimde yaparsa geriye `0` değerini döndürüyor, silme işlemi başarısız olursa `-1` değerini döndürüyor. </br>
`rename` fonksiyonunun prototipi `int rename(const char* oldname, const char* newnme);` biçimindedir, bu fonksiyon dosya adını değiştirme işlemini gerçekleştirmektedir. Bu fonksiyon bir dosyanın adını eğiştirme işlemini başarılı biçimde yaparsa geriye `0` değerini döndürüyor, bir dosyanın adını eğiştirme işleminde başarısız olursa `-1` değerini döndürüyor. </br>

İşletim sistemlerinin çoğunda bir dosyanın silinmesi için ve dosyanın adının değiştirilmesi için dosyanın kapalı olması gerekiyor, açık bir dosyanın silinmeye çalışılması ya da adının değiştirilmeye çalışılması işlemi başarısız olur, ama bu sonuçta programın üzerinde çaışacağı sisteme bağlıdır. 



👇 Aşağıdaki programda bir dosyayı silme işlemini yapan program incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int result = remove("METE_HAN.txt");

    printf("result = %d", result);

    if(result){
        printf("dosya silindi.\n");
    }
    else{
        printf("dosya silinemedi.\n");
    }
}
```



👇 Aşağıdaki programda bir dosyanın adının değiştirilmesi işlemini yapan program incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    if(rename("notlar.txt", "notes.txt")){
        printf("dosya adi degistirilemedi.\n");
    }
    else{
        printf("dosya adi degistirildi.\n");
    }
}
```


👇 Komut satırından çalıştırılan dosya "mete.exe" 1000 byte parçaya ayrılacak, mesela 14512 byte boyutundaki bir dosya 14 tane 1000 byte'lık ve bir tane 512 byte'lık dosyadan oluşacak, ardından bu parçaları birleştirecek bir program aşağıdaki gibi yazılabilir.



👇 Aşağıdaki programda bir dosyayı belirli boyutta parçalara bölen program incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

#define MAX_FILENAME_LEN    80

int main(int argc, char **argv)
{
    if(argc != 3){
        printf("kullanim: <dosbol> <dosya adi> <parca byte sayisi>\n");
        return 1;
    }
    
    FILE* fs = fopen(argv[1], "rb");
    if(!fs){
        printf("%s dosya acilamadi.\n", argv[1]);
        return 2;
    }

    int chunk = atoi(argv[2]);
    int file_count = 0;
    int byte_count = 0;
    int c;
    FILE* fd = NULL;
    char dest_file_name[MAX_FILENAME_LEN + 1];

    while((c = fgetc(fs)) != EOF){
        if(fd == NULL){
            sprintf(dest_file_name, "parca%03d.par", file_count + 1);
            fd = fopen(dest_file_name, "wb");

            if(!fd){
                printf("%s dosyasi olusturulamadi.\n", dest_file_name);
                fclose(fs);
                return 3;
            }

            ++file_count;
        }

        fputc(c, fd);

        ++byte_count;

        if(byte_count % chunk == 0){
            fclose(fd);
            fd = NULL;
        }
    }

    fclose(fs);
    if(fd)
        fclose(fd);

    printf("%d byte'lik %s adli dosya %d byte'lik %d parcaya bolundu.\n", byte_count, argv[1], chunk, file_count);
}
```



👇 Aşağıdaki programda parçalara bölünmüş bir dosyanın yeniden birleştirilmesi işlemini yapan program incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

#define MAX_FILENAME_LEN    80

int main(int argc, char **argv)
{
    if(argc != 2){
        printf("kullanim: <dosbil> <dosya adi>\n");
        return 1;
    }

    // Yazma amaçlı dosya oluşturuluyor, bu dosya birleştirme işlemiyle tek parça yapılacak dosyadır.
    FILE* fd = fopen(argv[1], "wb");
    if(!fd){
        printf("%s dosyasi olusturulamadi.\n", argv[1]);
        return 2;
    }
    
    FILE* fs;
    int file_count = 0;
    int byte_count = 0;
    char source_file_name[MAX_FILENAME_LEN + 1];
    int c;

    for(;;){ // Sonsuz döngü kullanıldı.
        sprintf(source_file_name, "parca%03d.par", file_count + 1);
        fs = fopen(source_filename, "rb");
        
        if(!fs)
            break;
        while((c = fgetc(fs)) != EOF){
            fputc(c, fd);
            ++byte_count;
        }

        fclose(fd);

        // Birleştirilen dosya parçası siliniyor.
        if(remove(source_filename)){
            printf("%s dosyasi silinemedi.\n", source_filename);
            fclose(fd);
            return 3;
        }

        ++file_count;
    }

    fclose(fd);
    printf("%d adet dosya %d byte'lik %s dosyasi olarak birlestirildi.\n", file_count, byte_count, argv[1]);
}
```

## `tmpnam` Fonksiyonu 

`tmpnam` fonksiyonunun prototipi `char* tmpnam(char*);` biçimindedir, bu fonksiyon rastgele eşsiz bir dosya adı bilgisi döndürür.

❗❗❗ Yazma amaçlı bir dosya oluşturulduğu zaman oluşturulan dizinde aynı ada sahip başka bir dosya olması durumunu önlemek için şu yollar denenebilir;
1. Öncelikle dosya okuma amaçlı açılmaya çalışılır, dosya açılmıyorsa dosyanın olmadığı anlamına gelebilir fakat bu yöntem %100 çalışmayacaktır çünkü dosya başka nedenlerden dolayı açılmayabilir.
2. İşletim sistemlerinin "**Unique Filename Generator**" olarak adlnadırılan bir dizinde dosya oluştururken var olan bir dosyayı ezmemek için bir dosya adı öneren bir fonksiyon bulunuyor, C dilinin standardında de işletim sisteminin bu fonksiyonunu sarmalayan `tmpnam` fonksiyonu vardır.


👇 Aşağıdaki programda parçalara bölünmüş bir dosyanın yeniden birleştirilmesi işlemini yapan program incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

#define MAX_FILENAME_LEN    80

int main(void)
{
    char filename[L_tmpnam]; // 'L_tmpnam' makrosu 'tmpnam' fonksiyonundan dönecen olan bir dosyanın adı olabilecek eşsiz bir yazının taşma hatası olmayacağı kadar büyük bir değerdir.

    tmpnam(filename); // Eşsiz bir dosya adı yazısı 'filename' dizisine yğklenecektir.

    puts(filename);
}
```

## Basit Bir Şifreleme Algoritması Kullanımı 

Bu başlık altında basit bir şifreleme algoritması ile bir dosyanın şifreleyelim.



👇 Aşağıdaki program basit bir şifreleme algoritmasıyla bir dosyanın nasıl şifrelendiğini anlamak için incelenebilir(aynı program şifre çözme işlemi de yapılabilmektedir).
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

#define MAX_FILENAME_LEN    80

int main(int argc, char **argv)
{
    if(argc != 3){
        printf("usage: <encfile> <filename> <psw>\n");
        return 1;
    }

    FILE* fs = fopen(argv[1], "rb");
    if(!fs){
        printf("cannot open file %s.\n", argv[1]);
        return 2;
    }

    char temp_file_name[L_tmpnam];
    tmpnam(temp_file_name);

    FILE* fd fopen(temp_file_name, "wb");
    if(!fd) {
        printf("cannot create temporary file!\n");
        fclose(fs);
        return 3;
    }

    unsigned int seed = (unsigned int)strtoul(argv[2], NULL, 10);
    srand(seed);

    int c;

    while((c =fgets(fs)) != EOF){
        fputc(c ^ rand(), fd);
    }

    fclose(fs);
    fclose(fd);

    if(remove(argv[1])){
        printf("%s dosyasi silinemedi.\n", argv[1]);
        _fcloseall(); // Standart olmayan ilgili process'in kullandığı tüm açık dosyaları kapatan fonksiyona çağrı yapılıyor.
        return 4;
    }
    
    if(rename(temp_file_name, argv[1])){
        printf("ad degisikligi yapilamadi.\n");
        _fcloseall(); // Standart olmayan ilgili process'in kullandığı tüm açık dosyaları kapatan fonksiyona çağrı yapılıyor.
        return 4;
    }
}
```


## `fprintf` Fonksiyonu ile Dosyadan Formatlı Okuma ve Yazma İşlemleri 

`fprintf` fonksiyonunun prototipi `int fprintf(FILE*, const char* pfm, ...);` biçimindedir, bu fonksiyon bir dosyaya formatlı olarak yazma işlemini yapmak için kullanılmaktadır.



👇 Aşağıdaki programda sade biçimde bir dosyaya formatlı yazma işleminin nasıl yapıldığı incelenbilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    FILE* fd = fopen("out.txt", "w");
    if(!fd){
        printf("dosya olusturulamadi.\n");
        return 1;
    }

    for(int i = 0; i < 10; ++i){
        fpintf(fd, "%d * %d = %d", i, i , i * i); // Dosyaya formatlı yazdırma işlemi yapılıyor.
    }

    fclose(fd);
}
```



👇 Aşağıdaki programda ilk bir milyon asal sayıyı "asal1000000.txt" adındaki bir dosyaya formatlı olarak her satırsa on asal sayı olacak biçimde yazdırılışı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int n;
    char filename[40];

    printf("ilk kac asal sayi:\n");
    scanf("%d", &n);
    sprintf(filename, "asal%d.txt", n);

    FILE* fd = fopen(filename, "w");

    if(!fd){
        printf("dosya olustutulamadi.\n");
        return 1;
    }

    int x = 2;
    int prime_count = 0;
    
    while(prime_count < n){
        if(isprime(x)){
            if(prime_count && prime_count % 10 == 0){
                fprintf(fd, "\n");    
            }
            
            fprintf(fd, "%12d ", x);
            ++prime_count;
        }
        ++x;
    }

    close(fd);
}
```



👇 Aşağıdaki programda üretilen rastgele kullanıcı bilgilerinin bir dosyaya nasıl kaydedildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

int main(void)
{    
    int n;
    char filename[40];

    printf("kac kayit.\n");
    scanf("%d", &n);
    sprintf(filename, "kayit%d.txt", n);

    FILE* fd = fopen(filename, "w");

    if(!fd){
        printf("dosya olustutulamadi.\n");
        return 1;
    }

    for(int i = 0; i < n; ++i){
        fprintf(fd, "%d %s %s %d\n", rand(), random_name(), random_surname(), rand() % 101);
    }

    close(fd);
}
```



👇 Aşağıdaki programda üretilen rastgele kullanıcı bilgilerinin bir dosyaya nasıl kaydedildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

int main(void)
{
    int n;
    char filename[40];

    printf("kac kayit.\n");
    scanf("%d", &n);
    sprintf(filename, "kayit%d.txt", n);

    FILE* fd = fopen(filename, "w");

    if(!fd){
        printf("dosya olustutulamadi.\n");
        return 1;
    }

    for(int i = 0; i < n; ++i){
        fprintf(fd, "%-8d %-16s %-20s %d\n", rand(), random_name(), random_surname(), rand() % 101);
    }

    close(fd);
}
```


***
==================================================

✦✦✦✦✦ 10.27-10.56 birinci ara verildi. ✦✦✦✦✦

==================================================
***


## `fscanf` Fonksiyonu 

`fscanf` fonksiyonunun prototipi `int fscanf(FILE*, const char* pfm, ...);` biçimindedir, bu fonksiyon dosyadan okuma işlemleri için kullanılmaktadır.

`scanf` fonksiyonu standart giriş akımından, `sscanf` fonksiyonu bellekten, `fscanf` fonksiyonu da dosyadan okuma yapmak için kullanılmaktadır.



👇 Aşağıdaki programda önceden oluşturulmuş ve içeriğinde asal sayılar bulunan bir dosyadan okuma işleminin nasıl yapıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

int main(void)
{
    FILE* fs = fopen("asal100.txt", "r");

    if(!fs){
        printf("cannot open file.\n");
        return 1;
    }

    int x, y, z;
    int result = fscanf(fs, "%d%d%d", &x, &y, &z);

    printf("result = %d\n", result);
    printf("x = %d\n", x);
    printf("x = %d\n", y);
    printf("x = %d\n", z);

    close(fs);
}
```



👇 Aşağıdaki programda önceden oluşturulmuş ve içeriğinde asal sayılar bulunan bir dosyadan tek tek bir tam sayı okunup standart çıktı akımına gönderilme işleminin nasıl yapıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // '_getch' kullanımı için eklendi.
#include "nutility.h"

int main(void)
{
    FILE* fs = fopen("asal100.txt", "r");

    if(!fs){
        printf("cannot open file.\n");
        return 1;
    }

    int x;

    while(fscanf(fs, "%d", &x) != EOF){
        printf("%d\n", x);
        _getch(); // Standart olmayan Microsoft derleyicisnin fonksiyonu.
    }    
}
```



👇 Aşağıdaki programda önceden oluşturulmuş ve içeriğinde kullanıcı bilgileri bulunan bir dosyadan her döngü adımında bir kullanıcı bilgisi okunup standart çıktı akımına gönderilme işleminin nasıl yapıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // '_getch' kullanımı için eklendi.
#include "nutility.h"

int main(void)
{
    FILE* fs = fopen("kayit500.txt", "r");

    if(!fs){
        printf("cannot open file.\n");
        return 1;
    }

    int id;
    char name[20];
    char surname[20];
    int grade;

    while(fscanf(fs, "%d%s%s%d", &id, name, surname, &grade) != EOF){
        printf("%-5d %-16s %-20s %d\n", id, name, surname, grade);
        _getch(); // Standart olmayan Microsoft derleyicisnin fonksiyonu.
    }    
}
```



👇 Aşağıdaki programda önceden oluşturulmuş ve içeriğinde kullanıcı bilgileri bulunan bir dosyadan her döngü adımında bir kullanıcı bilgisi okunup standart çıktı akımına gönderilme işleminin nasıl yapıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // '_getch' kullanımı için eklendi.
#include "nutility.h"

int main(void)
{
    FILE* fs = fopen("kayit500.txt", "r");

    if(!fs){
        printf("cannot open file.\n");
        return 1;
    }

    int id;
    char name[20];
    char surname[20];
    int grade;

    int grade_entry;
    char name_entry;

    printf("ad ve not girin: ");
    scanf("%s%d", name_entry, &grade_entry);

    while(fscanf(fs, "%d%s%s%d", &id, name, surname, &grade) != EOF){
        if(grade_entry == grade && !strcmp(name, name_entry)){
            printf("%-5d %-16s %-20s %d\n", id, name, surname, grade);
            _getch(); // Standart olmayan Microsoft derleyicisnin fonksiyonu.
        }
    }
}
```



Mülakat sorusu; </br>
👇 Aşağıdaki programda her satırda öğrenci bilgileriyle birlikte not bilgisi yeralan bir dosyadan okunan öğrencilerin bilgilerinin aldıkları notlara uygun dosyalara nasıl yazdırıldığı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // '_getch' kullanımı için eklendi.
#include "nutility.h"

int main(void)
{
    FILE* fa[101];
    char filename[20];

    FILE* fs = fopen("kayit1000000.txt", "r");
    if(!fs){
        printf("dosya acilmadi.\n");
        return 1;
    }

    // Aşağıdaki döngü öğrenci notlarına göre öğrencileri uygun dosyalara yazacak olan dosyaları oluşturmaktadır.
    for(int i = 0; i < 101; ++i){
        sprint(filename, "not%03d.txt", i);
        fa[i] = fopen(filename, "w");

        if(!fa[i]){
            printf("%s dosyasi olusmadi\n", filename);
            return 1;
        }
    }

    char id[13], name[17], surname[20];
    int grade; // Not bilgisini tutacak değişken.

    // Aşağıdaki döngü ile her bir öğrenci sahipolduğu not bilgisine göre uygun olan dosyaya yazılıyor.
    while(fscanf(fs, "%s%s%s%d", id, name, surname, &grade) != EOF){
        fprintf(fa[grade], "%-13s %-17s %-20s %d\n", id, name, surname, grade);
    }

    int result = fcloseall();

    printf("toplam %d dosya kapatildi.\n", result);
}
```



👇 Aşağıdaki programda bir dosyadan tam sayıların nasıl okunduğu incelenebilir, bu programda sonsuz döngüye giriliyor.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // '_getch' kullanımı için eklendi.
#include "nutility.h"

int main(void)
{
    FILE* f = fopen("out.txt", "r"); // 'out.txt' dosyasının içeriği '23 45 67 atilla 98 23 55 bora 77 456 yagiz 90 91 867 979'
    if(!f){
        printf("dosya acilmadi.\n");
        return 1;
    }

    int x;

    // Aşağıdaki döngü 'out.txt' dosyasının içeriğinden dolayı '67' değerini okuduktan sonra gelen bir sayı değil de bir yazı olduğu için 'fscanf 'fonksiyonu '0' sonucu dönüyor bundan dolayı da sonsuz döngüde kalıyor. 
    while(fscanf(f, "%d", &x) != EOF){
        printf("%d ", x);
    }

    fclose(f);
}
```



👇 Aşağıdaki programda bir dosyadan tam sayıların nasıl okunduğu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // '_getch' kullanımı için eklendi.
#include "nutility.h"

int main(void)
{
    FILE* f = fopen("out.txt", "r"); // 'out.txt' dosyasının içeriği '23 45 67 atilla 98 23 55 bora 77 456 yagiz 90 91 867 979'
    if(!f){
        printf("dosya acilmadi.\n");
        return 1;
    }

    int x;
    char buf[100]; // Okunan dosyada tam sayı olmayan değerlerin yazı olarak kaydedileceği dizi.

    while(1){
        int ret = fscanf(f, "%d", &x);
        
        if(ret == EOF){
            break;
        }

        if(ret == 0){
            fscanf(f, "%d", buf);
            printf("\n%s gecerli bir tam sayi degil.\n", buf);
        }
        else{
            printf("%d ", x);
        }
    }

    fclose(f);
}
```


## `fgetc` ve `fgets` Fonksiyonu ile Dosyadan Okuma İşlemleri 

`fgets` fonksiyonunun prototipi `int fgets(char*, int, FILE*);` biçimindedir.

Metin dosyalarından okuma yapmak için en az üç farklı yöntemimiz mevcut. 



👇 Aşağıdaki programda "main.c" dosyasının içeriği standart çıktı akımına gönderildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // '_getch' kullanımı için eklendi.
#include "nutility.h"

int main(void)
{
    FILE* f = fopen("main.c", "r");
    if(!f){
        printf("dosya acilmadi.\n");
        return 1;
    }
    
    int c;

    while((c = fgetc(f)) != EOF){
        putchar(c);
        _getch(); // Kullanıcıdan bir tuşa basması bekleniyor.
    }

    fclose(f);
}
```



👇 Aşağıdaki programda "main.c" dosyasının içeriği karakterler arasında bir boşluk vererek nasıl standart çıktı akımına gönderildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // '_getch' kullanımı için eklendi.
#include "nutility.h"

int main(void)
{
    FILE* f = fopen("main.c", "r");
    if(!f){
        printf("dosya acilmadi.\n");
        return 1;
    }
    
    int c;

    while((c = fgetc(f)) != EOF){
        printf("%c ", c);
        // _getch(); // Kullanıcıdan bir tuşa basması bekleniyor.
    }

    fclose(f);
}
```



👇 Aşağıdaki programda "main.c" dosyasının içeriği her karakterden iki tane olacak biçimde nasıl standart çıktı akımına gönderildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // '_getch' kullanımı için eklendi.
#include "nutility.h"

int main(void)
{
    FILE* f = fopen("main.c", "r");
    if(!f){
        printf("dosya acilmadi.\n");
        return 1;
    }
    
    int c;

    while((c = fgetc(f)) != EOF){
        printf("%c%c", c, c);
        // _getch(); // Kullanıcıdan bir tuşa basması bekleniyor.
    }

    fclose(f);
}
```



👇 Aşağıdaki programda "main.c" dosyasının içeriğinin boşluklar dikkate alınmadan nasıl standart çıktı akımına gönderildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // '_getch' kullanımı için eklendi.
#include <ctype.h>
#include "nutility.h"

int main(void)
{
    FILE* f = fopen("main.c", "r");
    if(!f){
        printf("dosya acilmadi.\n");
        return 1;
    }
    
    int c;

    while((c = fgetc(f)) != EOF){
        if(!isspace(c))
            putchar(c);
    }

    fclose(f);
}
```



👇 Aşağıdaki programda "main.c" dosyasının içeriğinin `fscanf` fonksiyonu ile boşluklarla ayrılır biçimde okunup nasıl standart çıktı akımına gönderildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // '_getch' kullanımı için eklendi.
#include <ctype.h>
#include "nutility.h"

int main(void)
{
    FILE* f = fopen("main.c", "r");
    if(!f){
        printf("dosya acilmadi.\n");
        return 1;
    }
    
    char buf[100];

    while(fscanf(f, "%s", buf) != EOF){
        puts(buf);
        _getch(); // Kullanıcıdan bir tuşa basması bekleniyor.
    }

    fclose(f);
}
```


`fgets` fonksiyonu satır satır dosyadan okuma yapmak için kullanılan bir fonksiyondur, dosyada okunacak stır kalmadığında geriye **NULL pointer** dönmektedir, okunacan satır bildirilen satır karakter sayısından büyükse bildirilen karakter sayısı kadar karakter değişkene atanacaktır.



👇 Aşağıdaki programda `fgets` fonksiyonu ile bir dosyadan satır satır okuma işleminin nasıl yapılacağı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // '_getch' kullanımı için eklendi.
#include <ctype.h>
#include "nutility.h"

#define BUFFER_SIZE     1000

int main(void)
{
    char buf[BUFFER_SIZE];

    FILE* fs = fopen("kayit500.txt", "r");
    if(!fs){
        printf("dosya acilamadi.\n");
        return 1;
    }

    while(fgets(buf, BUFFER_SIZE, fs)){
        printf("%s", buf);
    }

    fclose(fs);
}
```



👇 Aşağıdaki programda `fgets` fonksiyonu ile bir dosyadan satır satır okunan verinin `qsort` ile sıralanışı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h> // '_getch' kullanımı için eklendi.
#include <ctype.h>
#include "nutility.h"

int mycmp(const void* vp1, const void* vp2)
{
    return strcmp(*(const void**)vp1, *(const void**)vp2); 
}

int main(void)
{
    FILE* f = fopen("kayit500.txt", "r");
    if(!f){
        printf("dosya acilamadi.\n");
        return 1;
    }

    char** pd = NULL;
    int cnt = 0;

    while(fgets(buf, 1000, f)){
        char* p = _strdup(buf);
        pd = (char**)realloc(pd, (cnt + 1) * sizeof(char*));
    
        if(!pd){
            printf("bellek yetersiz!\n");
        }

        pd[cnt++] = p;
    }

    // Yukarıdaki döngü aşağıdaki gibi de yazılabilir.
    // while(fgets(buf, 1000, f)){
    //     pd = (char**)realloc(pd, (cnt + 1) * sizeof(char*));
    
    //     if(!pd){
    //         printf("bellek yetersiz!\n");
    //     }

    //     pd[cnt++] = _strdup(buf);
    // }


    // Bu satıra kadar yapılmış programın sınanması için yazılan kodlar.
    // printf("toplam satir sayisi %d\n", cnt);
    // for(int i = cnt - 1; i >= 0; ++i){
    //     printf("%s", pd[i]);
    // }

    // fclose(f);

    // for(int i = cnt - 1; i < cnt; ++i){
    //     free(pd[i]);
    // }

    // free(pd);

    qsort(pd, cnt, sizeof(*pd), &mycmp);

    for(int i = 0; i < cnt; ++i){
        printf("%s", pd[i]);
    }


    // some code here ...

    for(int i = 0; i < cnt; ++i){
        free(pd[i]);
    }

    free(pd);
}
```


Dosyalar ilkel bir veri tabanı olarak kullanılabiliyor, ufak uygulamalarda dosyaların veri saklamak için kullanılışı yangın bir yaklaşımdır.


***
==================================================

✦✦✦✦✦ 12.02-12.16 ikinci ara verildi. ✦✦✦✦✦

==================================================
***


## `fputs` Fonksiyonu 

`fputs` fonksiyonunun prototipi `int fputs(char*, int, FILE*);` biçimindedir, bu fonksiyon **null character** ile sonlanan yazıyı dosyaya yazmak için kullanılmaktadır.


👇 Aşağıdaki programda `fputs` fonksiyonu ile bir dosyadan satır satır okuma işleminin nasıl yapılacağı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <ctype.h>
#include "nutility.h"

#define BUFFER_SIZE     1000

int main(void)
{
    char str[] = "bugun 20 Temmuz 2025 Pazar.\n";

    FILE* f = fopen("out.txt", "w");
    if(!f){
        printf("dosya acilamadi.\n");
        return 1;
    }
    
    fputs(str, f);
    fputs(str, f);
    fputs(str, f);
    fputs(str, f);
    fputs(str, f);

    fclose(f);
}
```


## Formatsız Okuma Yazma İşlemleri 🌟 

Bu konu biraz vakit alacak. </br>
Bir dosyadaki byte'ların hiçbir karakter dönüşümü yapılmadan 1 0 dizisi olarak yazma ve okuma işlemlerine formatsız okuma yazma işlemleri denilmektedir. </br>
C standardında olan `fread` ve `fwrite` dosyadan belleğe ve bellekten dosyaya aktarım yapan fonkisyonlardır. </br>
`fread` fonksiyonu dosyadaki byte'ları belleğe aktarıyor, `fwrite` fonksiyonu bellekteki byte'ları dosyaya yazmak için kullanılıyor, bu iki fonksiyonun prototipi biraz karmaşıktır. </br>
Bu iki fonksiyonun da bildirimi `stdio.h` başlık dosyasındadır.


### `fread` ve `fwrite` Fonksiyonları

`fread` fonksiyonunun prototipi `size_t fread(void*, size_t sz, size_t n, FILE*);` biçimindedir. </br>
`fwrite` fonksiyonunun prototipi `size_t fwrite(const void*, size_t sz, size_t n, FILE*);` biçimindedir. 

Bir dosyaya okuma ya da yazma işlemi yapan fonksiyonlar hangi byte'tan itibaren bu işlemi yapacağını **dosya konum göstericisi(file pointer)** değerine bakarak belirlemektedir. </br>
`fread` ve `fwrite` fonksiyonları okuma ya da yazma işlemi yapacağı dosyanın hangi byte'ından itibaren işlem yapacağı bilgisini fonksiyona çağrı yapan koddan almazlar, **dosya konum göstericisi(file pointer)** değerine bakarak kara verilir. </br>
Dosyadan okuma ya da yazma işlemi yapan fonksiyonlar **dosya konum göstericisi(file pointer)** değerini değiştirmektedir. </br>
**Dosya konum göstericisi(file pointer)** değeri okuma ve yazma işlemlerinde ortak olarak kullanılan tek bir değerdir.


ilk bir milyon asal sayıyı formatsız olarak bir dosyaya yazdırınca yazdırma işleminin yapıldığı dosyanın büyüklüğü `1'000'000 * sizeof(int)` olacaktır.



👇 Aşağıdaki programda `fwrite` ile bir dosyaya formatsız olarak byte'ların yazdırılışı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <ctype.h>
#include "nutility.h"

#define BUFFER_SIZE     1000

int main(void)
{
    FILE* f = fopen("nec.dat", "wb");
    if(f == NULL){
        printf("dosya acilamadi.\n");
        return 1;
    }
    
    randomize();

    for(int i = 0; i < 100; ++i){
        int x = rand();
        fwrite(&x, sizeof(int), 1, f);
    }

    fclose(f);
}
```



👇 Aşağıdaki programda `fread` ile bir dosyadan formatsız olarak byte'ların nasıl okunduğu incelenebilir(yukarıdaki programda `nec.dat` dosyasına yazdırılan byte'lar okunuyor).
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <ctype.h>
#include "nutility.h"

#define BUFFER_SIZE     1000

int main(void)
{
    FILE* f = fopen("nec.dat", "rb");
    if(f == NULL){
        printf("dosya acilamadi.\n");
        return 1;
    }

    int x;

    while(fread(&x, sizeof x, 1, f))
        printf("%d\n", x);
    
    fclose(f);
}
```



👇 Aşağıdaki programda `fwrite` fonksiyonu ile dosyalara formatsız olarak byte'ların yazdırılışı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <ctype.h>
#include "nutility.h"

#define BUFFER_SIZE     1000

void creat_prime_numbers_file(const char* filename, int prime_count)
{
    FILE* f = fopen(filename, "wb");
    if(f == NULL){
        printf("dosya acilamadi.\n");
        return 1;
    }
    
    int prime_counter = 0;
    int x = 2;

    while(prime_counter < prime_count){
        if(isprime(x)){
            fwrite(&x, sizeof(int), 1, f);
            ++prime_counter;
        }
        ++x;
    }
    
    fclose(f);
}

int main(void)
{
    creat_prime_numbers_file("primes1000000.dat", 1'000'000);
    creat_prime_numbers_file("primes100000.dat", 100'000);
    creat_prime_numbers_file("primes10000.dat", 10'000);
    creat_prime_numbers_file("primes5000.dat", 5'000);

}
```


👇 Aşağıdaki programda `fwrite` fonksiyonu ile dosyalara formatsız olarak byte'ların yazdırılışı incelenebilir(burada `Person` türü yazdırılıyor).
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <ctype.h>
#include "nutility.h"
#include "peerson.h"

#define BUFFER_SIZE     1000

int main(void)
{
    printf("sizeof(Person) = %zu", sizeof(Person));

    FILE* f = fopen("people1000", "wb");
    if(!f){
        printf("dosya olustutulamadi.\n");
        return 1;
    }

    randomize();
    Person per;

    for(int i = 0; i < 1000; ++i){
        set_random_person(&per);
        fwrite(&per, sizeof(Person), 1, f);
    }

    fclose(f);
}
```



👇 Aşağıdaki programda `fread` fonksiyonu ile dosyalardan formatsız olarak tek seferde tek bir `int` türü kadar byte'ların nasıl okunduğu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <ctype.h>
#include "nutility.h"
#include "peerson.h"

#define BUFFER_SIZE     1000

int main(void)
{
    printf("sizeof(Person) = %zu", sizeof(Person));

    FILE* f = fopen("primes10000.dat", "rb");
    if(!f){
        printf("dosya acilamadi.\n");
        return 1;
    }

    int x;

    while(fread(&x, sizeof x, 1, f)){
        printf("%d ", x);
        _getch();
    }

    fclose(f);
}
```



👇 Aşağıdaki programda `fread` fonksiyonu ile dosyalardan formatsız olarak tek seferde on tane `int` türü kadar byte'ların nasıl okunduğu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <ctype.h>
#include "nutility.h"
#include "peerson.h"

#define BUFFER_SIZE     1000

int main(void)
{
    FILE* f = fopen("primes10000.dat", "rb");
    if(!f){
        printf("dosya acilamadi.\n");
        return 1;
    }

    int ar[10];
    
    while(fread(ar, sizeof(int), 10, f)){
        printf_array(ar, 10);
    }

    fclose(f);
}
```



👇 Aşağıdaki programda `fread` fonksiyonu ile dosyalardan formatsız olarak tek seferde bir tane `Person` türü kadar byte'ların nasıl okunduğu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <ctype.h>
#include "nutility.h"
#include "peerson.h"

#define BUFFER_SIZE     1000

int main(void)
{
    FILE* f = fopen("people10000.dat", "rb");
    if(!f){
        printf("dosya acilamadi.\n");
        return 1;
    }

    Person per;
    
    while(fread(&per, sizeof(int), 1, f)){
        printf_person(&per);
        _getch();
    }

    fclose(f);
}
```



👇 Aşağıdaki programda `fread` fonksiyonu ile dosyalardan formatsız olarak her seferinde bir tane `Person` türü kadar byte'ların nasıl okunduğu ve sadece belirli bir gün/ay değerinde doğanların standart çıktı akımına gönderilişi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <ctype.h>
#include "nutility.h"
#include "peerson.h"

#define BUFFER_SIZE     1000

int main(void)
{
    FILE* f = fopen("people10000.dat", "rb");
    if(!f){
        printf("dosya acilamadi.\n");
        return 1;
    }

    int day, mon;
    printf("ayin gunu ve ay degerini girin: ");
    scanf("%d%d", &day, &mon);

    Person per;
    
    while(fread(&per, sizeof(int), 1, f)){
        if(per.bdate.d_ == day && per.bdate.m_ = mon){
            print_person(&per);
            _getch();
        }
    }

    fclose(f);
}
```



Mülakatlarda sorulan soru: `fread` ve  `fwrite` fonksiyonlarını kullanarak dosya kopyalayan bir program yazınız? </br>
👇 Aşağıdaki programda `fread` ve  `fwrite` fonksiyonları kullanılarak yapılan dosya kopyalama işlemi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <ctype.h>
#include "nutility.h"
#include "peerson.h"

#define BUFFER_SIZE     1024

int main(int argc, char** argv)
{
    if(argc != 3){
        printf("usage: <fcopy> <source file name> <dest file name>\n");
        return 1;
    }

    FILE* fs = fopen(argv[1], "rb");
    if(!fs){
        printf("File %s cannot be opened.\n", argv[1]);
        return 1;
    }
    
    FILE* fd = fopen(argv[2], "wb");
    if(!fd){
        printf("File %s cannot be opened.\n", argv[2]);
        fclose(fs);
        return 1;
    }

    char buf[BUFFER_SIZE];
    size_t n;
    size_t total_size = 0;

    while((n = fread(buf, 1, BUFFER_SIZE, fs)) != 0){
        total_size += n;
        fwrite(buf, 1, n, fd);
    }

    fclose(fs);
    fclose(fd);

    printf("the file %s of %zu bytes copied as file %s\n", argv[1], total_size, argv[2]);
}
```


Ders sonu ...
