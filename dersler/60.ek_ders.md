# 60.Ek Ders
---


👇 Aşağıdaki programda bir önceki derste yazıldığında hata alınan bir programın doğru çalışan hali görülebilir, program birebir aynı olmayabilir ama bir önceki derste yazılan program da doğruydu muhtemelen.
```C
#include <stdio.h>
#include <time.h>

int main(void)
{
    struct tm tm = {
        .tm_year = 99,
        .tm_mon = 7,
        .tm_mday = 17,
        .tm_isdst = -1,
        .tm_hour = 3,
        .tm_min = 2,
        .tm_sec = 0,
    };

    const time_t now = time(NULL);
    const time_t t_quake = mktime(&tm);
    const time_t result = (time_t)difftime(now, t_quake);

    struct tm* pt = localtime(&result);

    printf("%d yil, %d ay, %d gun, %d saat, %d dakika, %d saniye\n",
           pt->tm_year - 70, pt->tm_mon + 1, pt->tm_mday, pt->tm_hour, pt->tm_min, pt->tm_sec);
}
```


## Pointer Hataları Devam


👇 Aşağıdaki programda en basit pointer hatalarından biri incelenebilir. 
```C

int main(void)
{
    int* ptr; // Buradaki 'ptr' değişkeni çöp değerdedir(indeterminant value), bu tür göstericilere standart olmayan biçimde 'wild pointer' da denilebiliyor.

    *ptr = 10; // Buradaki atama işlemi 'ptr' değişkeni çöp değerde olduğu için 'ub'dir.
}
``` 


👇 Aşağıdaki programda `p` göstericisine değer atanmadan kullanıldığı için **ub** durumu mevcuttur.
```C
#include <stdio.h>

int main(void)
{
    char* p;

    printf("bir yazi giriniz: ");
    scanf("%s", p);
}
``` 


👇 Aşağıdaki programda `p` göstericisine değer atanmadığından dolayı programda bir hata yoktur.
```C
#include <stdio.h>

int main(void)
{
    char str[100];
    char* p = str;

    printf("bir yazi giriniz: ");
    scanf("%s", p);

    printf("girilen deger: %s\n", p);
}
``` 


Dizilerin taşırılması **ub** durumuna neden olur.

👇 Aşağıdaki programda `p` göstericisine değer atanmadan kullanıldığı için **ub** durumu mevcuttur.
```C
#include <stdio.h>

int main(void)
{
    int ary[10];

    for(int i = 0; i <= 10; ++i){
        ary[i] = i; // Burada döngünün son turuna 'ary[10]' ile diziye ait olmayan bir elemana erişilmiş olur bu da dizi taşmasından dolayı 'ub' durumuna neden olur.
    }
}
``` 



👇 Aşağıdaki programda `p` göstericisinin gösterdiği adres değeri arttırıldıktan sonra oradaki değeri kullanmanın **ub** durumuna sebebiyet verdiği görülmelidir.
```C
#include <stdio.h>

int main(void)
{
    int x = 11;
    int* p = &x;

    *p++ = 21; // Buradaki statement'ta bir yanışlık yoktur ama bu statement'tan sonra 'p' göstericisinin gösterdiği adresteki değer okunmaya çalışılırsa bu 'ub' durumuna neden olur.

    *p; // Burada 'ub' durumu oluşur.
}
```



👇 Aşağıdaki programda `p` göstericisine değer atanmadan kullanıldığı için **ub** durumu mevcuttur.
```C
#include <stdio.h>

int main(void)
{
    int ary[10] = { 0 };
    &ary[10]; // Burada 'ub' yoktur çünkü sadece diziye dahil olmayan dizinin en son elemanından sonraki adres değerine erişiliyor, diziye dahil olmayan adresteki nesnenin değerine erişilmiyor.
}
```



👇 Aşağıdaki programda `p` göstericisinin gösterdiği adresteki nesnenin değerine en son erişildiği yerdeki **ub** durumu iyi anlaşılmalıdır. 
```C
#include <stdio.h>

int main(void)
{
    int x = 5;
    int* p = &x;

    int a = *p++; // Burada hatalı bir kullanım yoktur.
    int b = *p; // Burada bilinmeyen bir adrsteki değere erişildiği için 'ub' durumu oluşur.
}
```



👇 Aşağıdaki programda göstericilerle ilgili yapılabilecek hata incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int i = 45;
    int* p1, p2; // Burada 'p1'in türü 'int*' ama 'p2'nin türü 'int' türüdür.

    p1 = &i; // Burada 'p1' göstericisine 'i' 'int' değişkeninin adresi atanıyor.
    p2 = p1; // Burada 'p2' adındaki 'int' türünden değişkene 'int*' türünden bir adres atandığı için hatalara sebebiyet verebilecek bir durum oluşacaktır. 
}
```



👇 Aşağıdaki programda göstericilerle ilgili yapılabilecek hata incelenebilir, farklı türden göstericilerin birbirine atanması çoğunlukla **ub** durumu oluşmasına neden olur.
```C
#include <stdio.h>

int main(void)
{
    double dval = 123.6434;
    int* p = (int*)&dval; // Buradaki atama işleminde uyumsuz türden göstericiler birbirine atandığı için 'p'nin gösterdiği adresteki değeri kullanmak 'ub' durumuna nenden olur.
}
```



👇 Aşağıdaki programda aynı türden tam sayı türlerinin işaretli ve işaretsiz tür versiyonları arasında pointer'lar üzerinden yapılan tür dönüşümlerinin **ub** durumuna neden olmadığı ve kullanılan doğru bir yöntem olduğu görülebilir. </br>
- `unsigned int` --> `int`
- `unsigned short` --> `short`
- `unsigned long` --> `long`
- `unsigned long long` --> `long long`
```C
#include <stdio.h>

int main(void)
{
    unsigned int x = 213123;
    int* p = (int*)&x; // Buradaki tür dönüşüm işlemi legal ve doğrudur, böyle dönüşümler kullanılabilir.

    *p; // 'p' göstericisinin gösterdiği adresteki nesnenin değerine erişilip nesnenin değeri kullanılabilir.
}
```



👇 Aşağıdaki programda, C standardından çıkarılacak şu durumun "Her nesne bir char dizisiymiş gibi kullanılabilir" uygulanışı incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    unsigned int x = 213124;
    unsigned char *p = (unsigned char)&x; // Burada 'unsigned int' türünün adresinin 'unsigned char*' türünden bir pointer değişkene atanmaktadır.

    // Aşağıdaki gibi bir döngünün kurulması legal ve doğru bir kullanımdır.
    for(size_t i = 0; i < sizeof(x); ++i) {
        printf("%u \n", p[i]);
    }
}
```



👇 Aşağıdaki programda yapı nesnelerinin adreslerinin yapının ilk üyesinin(elemanının) adresi olma durumunun kullanımı incelenebilir.
```C
#include <stdio.h>

struct Nec {
    int a;
    double b;
    char str[16];
};

int main(void)
{
    struct Nec nec = { 123, 4.5, "metehan" };

    int* ip = (int*) &nec; // Buradaki gibi bir yapı nesnesi doğrudan ilk elemanının türüymüş gibi tür dönüşümü yapılarak kullanılabilir.

    printf("%d\n", *ip);

    *ip = 9999997;

    printf("nec.a = %d\n", nec.a);

    struct Nec* pn = (struct Nec*)ip;
    
    printf("%f\n", pn->d);
}
```



👇 Aşağıdaki program adreslerin karşılaştırılmasıyla o adreslerdeki yazıların karşılaştırmasının çok başka işlem olduğunu anlamak için incelenebilir.
```C
#include <stdio.h>
#include <string.h>

int main(void)
{
    char str1[] = "atilla";
    char str2[] = "atilla";

    // Aşağıdaki karşılaştırmada iki pointer'ın tuttuğu adresler karşılaştırılacağı için buradaki işlem her zaman 'false' olacaktır çünkü iki yazının adresi her zaman farklı olacaktır.
    if(str1 == str2) {
        printf("evet esit.\n");
    }
    else {
        printf("hayir esit degil.\n");
    }

    // Aşağıdaki karşılaştırmada iki göstericinin gösterdiği adresteki yazıları karşılaştırarak yapacaktır, 'strcmp' fonksiyonu kendisine geçilen iki yazıyı karşılaştırır.
    if(!strcmp(str1, str2)) {
        printf("evet esit.\n");
    }
    else {
        printf("hayir esit degil.\n");
    }
}
```



👇 Aşağıdaki program `string literal` bir nesnenin değerinin değiştirilmek istenmesinin **ub** durumuna neden olacağı görülmelidir.
```C
#include <stdio.h>

int main(void)
{
    char* pname = "necati"; // Bir pinter değişkene bir 'string literal' atanıyorsa o pointer üzerinden 'string literal' değiştirilmemelidir yoksa 'ub' durumu oluşur.

    pname[5] = '\0'; // Burada 'string literal' bir nesnenin değeri değiştirilmek istendiği için 'ub' durumu oluşur.
}
```



👇 ❗❗❗ Aşağıdaki program değerleri aynı olan iki farklı `string literal` nesnenin değerinin karşılaştırılması durumunun **unspecified behavior(belirsiz davranış)** olacağı görülmelidir.
```C
#include <stdio.h>

int main(void)
{
    char* p1 = "hulagu";
    char* p2 = "hulagu";

    // Dsrleyiciler standardın verdiği içinle değeri aynı olan iki farklı 'string literal' nesneyi tek bir bellek alanında tutabilir ya da ayrı bellek alanlarında tutabilir ve her zaman hangini yapacağı kendine kalmıştır bazen bir yolu bazen de diğer yolu seçebilir!
    if(p1 = p2) {
        printf("iki gosterici ayni adresi gosteriyor.\n");
    }
    else {
        printf("iki gosterici farkli adresi gosteriyor.\n");
    }
}
```



❗❗❗ Deneyimsiz programcıların en sık yaptığı hatalardan biri **otomatic storage duration** özellikteki bir nesnenin adresinin bir fonksiyondan geriye döndürülen adres değeri olması durumudur. </br>
👇 Aşağıdaki program yukarıdaki durumla ilgili olarak yazılmış olan fonksiyonlar incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

char* getname(void)
{
    char str[40];

    printf("ad girin: ");
    scanf("%s", str);

    return str; // Burada otomatik ömürlü bir nesne adresi döndürülüyor ama bu nesnenin ömrü bu fonksiyon bloğunda son buluyor.
}


char* getname01(void)
{
    static char str[40];

    printf("ad girin: ");
    scanf("%s", str);

    return str; // Burada statik ömürlü bir nesne adresi döndürülüyor ve bir yanlışlık yoktur.
}

// Burada geriye döndürülenek değer 'output' argüman olarak fonksiyon çağrısının yapıldığı yerden alınacaktır.
char* getname02(char* p)
{
    printf("ad girin: ");
    scanf("%s", p);

    return p; // Burada client kod tarafından fonksiyona geçilen nesne adresi döndürülüyor ve bir yanlışlık yoktur.
}


int main(void)
{
    char str[100];

    getname02(str);

    puts(str);
}
```



👇 Aşağıdaki program yapılabilecek olan bir hata türü incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x; // Burada 'x' değişkeni ömrüme çöp değer ile başlar ve bu değerin kullanılması 'ub' durumuna neden olur.
    int* ptr = &x;

    int y = *ptr;
}
```



👇 Aşağıdaki programda `restrict` parametreleri olan bir fonksiyona geçilen göstericilerin **overlapped bellek bloklarına** sahip olmaması durumunun ihlalinin **ub** durumuna neden olacağı görülmelidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int main(void)
{
    char str[100] = "bennur";

    strcpy(str + 3, str); // Burada 'ub' oluşur çünkü 'strcpy' fonksiyonunun parametreleri 'restrict' olduğu için bellek alanları kesişen diziler bu fonksiyona argüman olarak geçilmemelidir.
    puts(str);
}
```



❗❗❗ C mülakatlarında sıklıkla sorulan bir soru aşağıdaki gibidir. </br>
👇 Aşağıdaki programda **object-like makro**'lar ile değişken türlerinin belirlenmesindeki kritik durum incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

#define IPTR    int*

int main(void)
{
    int x = 11;
    IPTR p1, p2; // Buradaki statement 'int* p1, p2;' ile ve 'int* p1; int p2;' ile denktir ve 'p1' bir 'int*' türünden pointer ama 'p2' nesnesi 'int' türünden bir değişkendir.

    p1 = &x;
    p2 = p1; // Buradaki atama işlemi 'ub' durumuna neden olur.
}
```



👇 ❗❗❗ Aşağıdaki programda bir önceki programdan farklı olarak `typedef` olarak yaptığımız durumdaki farklılık özümsenmelidir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

typedef IPTR    int*

int main(void)
{
    int x = 11;
    IPTR p1, p2; // Buradaki statement 'int* p1; int* p2;' ile denktir ve 'p1' ve 'p2' 'int*' türünden pointer nesnedir.

    p1 = &x;
    p2 = p1; // Buradaki atama işlemi doğrudur.
}
```



❗❗❗ C mülakatlarının klasik sorularından biri aşağıdaki gibidir. </br>
👇 Aşağıdaki programda `typedef` olarak bildirilen bir türün `const` ile kullanımındaki detayın iyi bilinmesi gerekiyor.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

typedef IPTR    int*

int main(void)
{
    int x = 11;
    int y = 21;
    
    const IPTR ptr = &x; // Buradaki 'ptr' değişkeni 'low lavel const' değildir yani bu statement şuna 'const int* ptr = &x;' denk değildir, bu statement şuna 'int* const ptr = &x;' denktir.

    *ptr = 746; // Buradaki atama legal ve doğrudur.
    ptr = &y; // Burada sözdüzüm hatası alınır.
}
```



👇 Aşağıdaki programda **ub** durumuna neden olan çöy değerdeki nenselerle ilişkili durum incelenebilir, bu program bir öğrencinin sorusu üzerine yazılmıştır.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

typedef IPTR    int*

int main(void)
{
    int x;

    int a = x; // Burada 'ub' vardır çünkü 'x' nesnesi 'inditormenet value' değerdedir.

    int* ptr = &x; // Buradaki atama legaldir ama 'x' nesnesi çöp değerde olduğu için 'ptr' nesnesinin gösterdiği nesne olan 'x' nesnesinin değerine erişmek için yazılabilecek bir kod 'ub' durumuna nenden olur.
    int y = *ptr; // Burada 'ub' vardır, nedeni bir üst satırda açıklanmıştır.
}
```



👇 Aşağıdaki program bellekten yer ayırmak için kullanılan fonksiyonlardan `allocate_memory01` fonksiyonunun tasarımı ve kullanımı hatalı, `allocate_memory02` fonksiyonunun tasarımı ve kullanımı doğrudur.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include <stdlib.h>


void allocate_memory01(char* p, size_t n)
{
    p = (char*)malloc(n);
    if(!p) {
        printf("hata!\n");
        exit(EXIT_FAILURE);
    }
}


void allocate_memory02(char** p, size_t n)
{
    *p = (char*)malloc(n);
    if(!*p) {
        printf("hata!\n");
        exit(EXIT_FAILURE);
    }
}

int main(void)
{
    // Buradaki fonksiyon kullanımlarında 'pointer to pointer' ile 'pointer' kullanımı karıştırılmaktadır, bu hata durumuna çok sık rastlanmaktadır, bu ndenden dolayı dikkat edilmelidir.
    char* ptr;

    allocate_memory01(ptr, 100);

    allocate_memory02(&ptr, 100);
    free(*ptr);
}
```



👇 Aşağıdaki programdan **pointer** ve **pointer to pointer** kullanımın faarklarıyla ilgili bilgiler incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include <stdlib.h>


void foo(int* p)
{
    // '*p' ifadesi ile 'x' nesnesine erişilir.

}

void bar(int** p)
{
    // '*p' ifadesi ile 'ptr' nesnesine erişilir.
    // '**p' ifadesi ile 'x' nesnesine erişilir.
}


int main(void)
{
    int x = 23;
    int* ptr = &x;

    // Aşağıdaki
    foo(ptr);
    bar(&ptr); 
}
```



👇 Aşağıdaki programda **dangling pointer** durumundan kaynaklanan ve üretimde sık karşılaşılabilecek hata türü incelenebilir.
```C
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

typedef struct {
    char* mp_address;
    int m_id;
} Person;

int main()
{
    const char* pa1 = "Degirmen sok. No 17 Besiktas - Istanbul";
    //const char* pa2 = "sadegul sok. No 25 Kavaklidere - Ankara";
    Person per1;

    per1.mp_address = (char*)malloc(strlen(pa1) + 1);
    strcpy(per1.mp_address, pa1);
    per1.m_id = 43254;

    Person per2 = per1; // Buradaki 'struct' nesneleri arasında yapılan atama işlemi 'shadow copy' olarak yapıldığı için bu yapı nesnelerinin pointer üyelerinin sadece pointer değerleri kopyalanır bu da bu poşnter nesnelerin belleki aynı nesneyi gösterdiği anlamına gelir.
    free(per1.mp_address); // Burada 'per1' nesnesindeki 'mp_address' üyesinin ömrü sonlandırılıyor.

    puts(per2.mp_address); // Burada 'ub' vardır çünkü ilgili göstericinin gösterdiği nesne zaten yukarıda 'free' işlemine tabi tutuldu.
    free(per2.mp_address); // Burada 'ub' vardır çünkü ilgili göstericinin gösterdiği nesne zaten yukarıda 'free' işlemine tabi tutuldu.
}
```



👇 Aşağıdaki programda **shallow copy** yönteminden dolayı dosyalar üzerinden yapılan işlemlerde karşılaşılabilecek **dangling pointer** hata türü incelenebilir.
```C
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

typedef struct {
    FILE* fp;
    // ...
} Info;


int main()
{
    Info inf1;

    // some code here ...

    inf1.fp = fopen("somefile.txt", "r");

    // some code here ...
    
    Info inf2 = inf1;

    // some code here ...
    
    fclose(inf1.fp);

    inf2.fp; // Burada 'inf2' göstericisinin 'fp' üye değişkeni 'dangling pointer' durumundadır çünkü 'inf1.fp' nesnesi dosya kapatma işlemine tabi tutuldu ve 'inf1.fp' ve 'inf2.fp' aynı dosya nesnesini gösteriyordu.
}
```

❗❗❗ Eğer bir yapı nesnesine başka bir yapı nesnesi atanıyorsa bu atama işleminde yapıların üyeleri birbirine kopyalanır ama gösterici türünden nesnelerde sadece adres değerleri kopyalanır, buradaki kopyalama **shallow copy** biçimindeki kopyalamadır.



👇 Aşağıdaki programdaki hata incelenebilir.
```C
//dynamic memory mistakes

#include <stdlib.h>
#include <stdio.h>

int main(void)
{
    char str[] = "necati ergin";
    char* p = str;
    //...
    puts(p);
    free(p); // 'free' fonksiyonu sadece dinamik olarak elde edilen bellek bloklarını geri vermek için kullanılailir ama burada 'free' fonksiyonuna otomatik ömürlü bir nesne veriliyor.
}
```



👇 Aşağıdaki program `free` fonksiyonuna argüman olarak **NULL pointer** geçilmesinin özel bir durum olduğunun ve bu işlemin yapılabileceğinin anlaşılması için incelenebilir.
```C
//dynamic memory mistakes

#include <stdlib.h>
#include <stdio.h>

int main(void)
{
    char str[] = "necati ergin";
    char* p = str;
    //...
    puts(p);
    p = NULL;
    free(p); // Buradaki kullanımda bir hata ya da yanlışlık yoktur.
}
```



👇 Aşağıdaki programda `malloc` fonksiyonuyla bellekten bir yazıyı kopyalamak için yer ayrılırken yazının dizi sonu karakteri hesaba kayılmadığı için oluşacak **ub** durumu incelenebilir.
```C
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
    char str[] = "man plans and god laughs";

    char* pd = (char*)malloc(strlen(str)); // Burada yazının sonu '\0' karakteri hesaba katılmıyor.

    // some code here ...

    strcpy(pd, str); // Burada 'ub' vardır çünkü kaynak yazı kopyalamanın yapıldığı hedef yazıdan daha büyük. 

    puts(pd);
    free(pd);
}
```



C mülakatlarında sorulmuş bir soru aşağıdaki gibidir. </br>
👇 Aşağıdaki programdaki dinamik bellek alanlarını gösteren göstericilerden hangileri  `a` dizisinin kopyalanabileceği kadar geniş bir bellek alanına sahiptir?
```C
#include <stdlib.h>

int main(void)
{
    int a[10] = { 1, 2, 5, 7, 9, 3, 9, 12, 4, 6 };
    int* p = a;
    int(*pa)[10] = &a;

    // Aşağıdaki bellek ayırmalarından elde edilen bellek alanlarından hangilerine 'a' dizisi kopyalanabilir ve hangilerine kopyalanamaz.
    int* p1 = (int*)malloc(sizeof(p)); // 'sizeof(p)' ifadesinde 'p' bir gösterici nesne olduğundan dolayı bellek boyutu 32 bit mimaride '4', 64 bit mimaride '8' olur ama bize en az '10 * sizeof(int)' kadarlık bellek alanı gerekiyor!
    int* p2 = (int*)malloc(sizeof(*p)); // 'sizeof(*p)' ifadesinde '*p' ifadesinin türü 'int' türü olduğu için gerekli olan en az '10 * sizeof(int)' kadarlık bellek alanını karşılayamaz.
    int* p3 = (int*)malloc(sizeof(a)); // 'sizeof(a)' ifadesinde 'array to pointer conversion' uygulanmaz ve 'p3' göstericisinin gösterdiği bellek alanı tam olarak '10 * sizeof(int)' kadardır.
    int* p4 = (int*)malloc(sizeof(pa)); // 'sizeof(pa)' ifadesinde 'pa' bir pointer olduğu için sadece programın çalışacağı sistemdeki tek bir pointer'ın 'sizeof' değeri kadarlık bir yer kaplayacağı için gerekli olan en az '10 * sizeof(int)' kadarlık bellek alanını karşılayamaz. 
    int* p5 = (int*)malloc(sizeof(*pa)); // 'sizeof(*pa)' ifadesinde '*pa' bir 10 elemanlı 'int' dizisini göstermektedir bu nedenden dolayı 'array to pointer conversion' uygulanmaz ve gerekli olan en az '10 * sizeof(int)' kadarlık bellek alanını karşılar.
}
```



👇 Aşağıdaki programdaki **memory leak** hatası durumu incelenebilir ama burada **ub** yoktur.
```C
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
    //...
    size_t n = (rand() % 100 + 5) * 16;
    int* p = (int*)malloc(sizeof(int));
    //...
    if (!p) {
        printf("cannot allocate memory!");
        return 1;
    }
    //...
    int x = 20;
    p = &x;
    //...

    // 'p' göstericisiyle işlem bittikten sonra 'p' nesnesinin gösterdiği dinamik bellek alanının geri iade edilmesi gerekiyor.
}
```



👇 Aşağıdaki programdaki **dangling pointer** hatası durumu incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    size_t n;
    printf("enter the size of the array: ");
    (void)scanf("%zu", &n);

    int* pd = (int*)malloc(n * sizeof(int)); // Burada dinamik bir bellek alanı ayrılıyor.
    if (!pd) {
        printf(stdern, "cannot allocate memory: ");
        return 1;
    }

    int* p = pd; // dinamik bellek alanını gösteren pointer adresi 'p' göstericisine de kopyalanıyor, iki gösterici d eaynı bellek alanını gösteriyor şu anda.
    memset(pd, 0, n * sizeof(int));
    //...
    free(pd); // Buradan sonra aynı bellek bloklarını gösterdikleri için 'p' göstericisi 'dangling pointer' durumuna düşer.
    //...
    free(p);
}
```



👇 Aşağıdaki programdaki **dangling pointer** hatası durumu incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    size_t n;
    printf("enter the size of the array: ");
    (void)scanf("%zu", &n);

    int* pd = (int*)malloc(n * sizeof(int));
    if (!pd) {
        printf(stderr, "cannot allocate memory: ");
        return 1;
    }

    memset(pd, θ, n * sizeof(int));
    //...
    free(pd);

    int x = *pd; // Burada 'dangling pointer' hatası vardır.
}
```



👇 Aşağıdaki programdaki **memory leak** hatası durumu incelenebilir, buradaki gibi hatalarla sıklıkla karşılaşılmaktadır.
```C
#include <stdio.h>
#include <string.h>

int icmp(const void* vp1, const void* vp2)
{
    int i1 = *(const int*)vp1;
    int i2 = *(const int*)vp2;

    return i1 > i2 ? 1 :
        i1 < i2 ? -1 : 0;
}

int get_median(const int* p, size_t size)
{
    int* pd = (int*)malloc(size * sizeof(int)); // Burada dinamik olarak bellek bloğu ediniliyor.
    //...
    memcpy(pd, p, size * sizeof(int));
    qsort(pd, size, sizeof(*pd), &icmp);

    // Burada 'pd' için 'free' fonksiyonu çağrısı yapılması gerekiyor, yoksa 'memory leak' oluşur.

    return pd[size / 2];
}
```


***
==================================================

✦✦✦✦✦ 20.43-21.04 birinci ara verildi. ✦✦✦✦✦

==================================================
***


## Dinamik Dizi Veri Yapısı Gerçekleştirimi(Daynamic Array Data Structure Implementation) 🌟

Daha önce **dinamik dizi** veri yapısından bahsedilmişti ve en çok kullanılan veri yapısı olduğu belirtilmişti. </br>
Bu veri yapısının bellek genişli tamamen dolduktan sonra yeni bir eleman ekleneceği zaman bellekten yeni bir blok ayrılıp(**reallocation**) tüm veri o yeni bellek bloğuna taşınır. </br>
Bu veri yapısında sondan yapılan ekleme ve silme işlemleri "**Amortised constand time**" zaman almaktadır, sondan olmayan noktalardan yapılan ekleme ve silme işlemleri doğrusal karmaşıklıktadır($O(n)$).

C dilindeki yapılacak **dinamik dizi** gerçekleştiriminde dizide ne tutulacağına bağlı olarak kodun bazı yerlerinin değişmesi gerekmesinden kaynaklanan bir sorun vardı, bu değişikliğin nasıl yapılacağına sonradan değinilecektir.


```Text

Bir dinamik diziyi modelleyebilmek için, en az üç tane bilginin tutulması gerekiyor;
1. Dinamik dizinin başlangıç adresi.
2. Dizinin son elemanının adres bilgisi ya da dizinin eleman sayısını tutan bir tam sayı değeri. (Sondan ekleme yapılacağı için bu bilgi gerekli oluyor)
3. Dizinin en fazla alabileceği eleman sayısı değeri(dizinin erişebileceği o anki en yüksek eleman sayısı değeri)

Temsili Bellek Görünümü
+--------------------+ 
| Dinamik dizi adresi|  >>>>>>----------------> Dinamik dizinin başlangıç adresi.
+--------------------+ 
+--------------------+ 
| Veriyle dolu       |
+--------------------+ 
+--------------------+ 
| Veriyle dolu       |
+--------------------+ 
+--------------------+ 
| Veriyle dolu       |
+--------------------+ 
+--------------------+ 
| Veriyle dolu       |
+--------------------+
+--------------------+ 
| Veriyle dolu       |  >>>>>>----------------> Dinamik dizinin en son elemanının adresi.
+--------------------+ 
+--------------------+ 
|                    |
+--------------------+ 
+--------------------+ 
|                    |
+--------------------+ 
+--------------------+ 
|                    |  >>>>>>----------------> Dinamik dizinin o anki eleman yerleştirilebilecen en son adres değeri, dinamik dizinin azami büyüye bileceği konum.
+--------------------+ 
+--------------------+ 
|                    |
+--------------------+  

```


✍️ Burada `nvector.h` kütüphanesini aşağıdaki gibi ekliyoruz, C++ kütüphanesindeki vector sınıfına benzer bir gerçekleştirim yapılmıştır.
```C
// Yazılan 'nvector.h' dosyasına eklenenler.

#pragma once
// #ifndef NVECTOR_H
// #define NVECTOR_H

#include <stddef.h> // İlk başta 'size_t' türünü kullanabilmek için eklendi.
#include <stdbool.h> // 'bool', 'true', 'false' gibi object-like makroları kullanabilmek için eklenmiştir.

#define NOT_FOUND           ((size_t)(-1))
#define DEFAULT_CAPACITY    16 // Dinamik dizinin başlangıç azami eleman sayısı değeri.


/* FUNCTUONAL MACROS START*/

#define get_element(hvec, idx)      (hvec->mp[idx])

/* FUNCTUONAL MACROS END */


typedef int DATATYPE;
typedef int(*VALUECOMPARE)(const DATATYPE*, const DATATYPE*);


typedef struct  {
    DATATYPE* mp; // Ayrılacak(allocate) bellek alanı adresi.
    size_t msize; // Dinamik dizide bulunan o anki eleman sayısı. 
    size_t mcap; // Dinamik dizinin o anki erişebileceği en yüksek eleman sayısı.
} Vector, *HVector;


// Dinamik dizinin eleman sayısını geriye döndüren static fonksiyon.
static inline size_t get_size(HVector h)
{
    return h->msize;
}

// Dinamik dizinin erişebileceği en yüksek eleman sayısını geriye döndüren static fonksiyon.
static inline size_t get_capacity(HVector h)
{
    return h->mcap;
}

static bool is_empty(HVector h)
{
    // return h->mp == NULL;
    return h->msize ==0;
}


// Dinamik diziyi kullanmak için faydalanılacak olan .
HVector create_vector(void);
HVector create_vector_with_capacity(size_t cap);
HVector create_vector_from_array(const DATATYPE* pa, size_t size);
HVector create_vector_filled(size_t size, DATATYPE value);

void destroy_vector(HVector);

bool reserve(HVector h, size_t newcap);
bool push_back(HVector h, DATATYPE value);
bool pop_back(HVector);
bool insert(HVector h, size_t idx, DATATYPE value); // Dinamik diziye aradan eleman eklemek için kullanılan fonksiyon.
bool erase(HVector h, size_t idx); // Dinamik dizinin herhangi bir elemanını silmek için kullanılacak olan fonksiyon.
bool erase_first(HVector h, DATATYPE value, VALUECOMPARE fp); // Beliri bir değere sahip ilk öğeyi silen fonksiyon.
size_t erase_all(HVector h, DATATYPE value); // Beliri bir değere sahip tüm öğeleri silen fonksiyon, geriye silinen öğe sayısını döndürür.
size_t find(HVector h, DATATYPE value, VALUECOMPARE); // Beliri bir değere sahip olan elemanı dizide aramak için kullanılan fonksiyon, aranan değer bulunursa indeks değeri döndürülür bulunamazsa işaretsiz bir tam sayı türünün en büyük değeri döndürülür.
// size_t find(HVector h, DATATYPE value, int(*fp)(const DATATYPE*, const DATATYPE*)); // Beliri bir değere sahip olan elemanı dizide aramak için kullanılan fonksiyon, aranan değer bulunursa indeks değeri döndürülür bulunamazsa işaretsiz bir tam sayı türünün en büyük değeri döndürülür.
void shring_to_fit(HVector); // Dinamik dizinin erişebileceği en yüksek eleman sayısını düşürmek için kullanılan fonksiyon.
void clear(HVector); // Dinamik dizinin tüm elemanlarını silmek ve diziyi boşaltmak için kullanılan fonksiyon.

// #endif
```



✍️ Burada `nvector.c` kütüphanesini aşağıdaki gibi ekliyoruz, C++ kütüphanesindeki vector sınıfına benzer bir gerçekleştirim yapılmıştır.
```C
#include "nvector.h"
#include <stdlib.h> // İlk önce 'malloc' fonksiyonunu kullanabilmek için eklenmiştir.
#include <stdio.h> 
#include <string.h> // İlk önce 'memmove' fonksiyonunu kullanabilmek için eklenmiştir.

HVector create_vector_with_capacity(size_t cap)
{
    HVector h = (HVector)malloc(sizeof(Vector));
    if(!h) {
        fprintf(stderr, "cannot allocate memory!\n"); // DEBUG

        return h;
        // return NULL; // Yukarıdaki statement ile aynıdır.
    }

    h->msize = 0;
    h->mcap = cap;

    h->mp = (DATATYPE*)molloc(cap * sizeof(DATATYPE));
    if(!h->mcap) {
        fprintf(stderr, "cannot allocate memory!\n"); // DEBUG
        free(h);
        return NULL;
    }

    return h;
}



HVector create_vector(void)
{
    return create_vector_with_capacity(DEFAULT_CAPACITY);
}



HVector create_vector_from_array(const DATATYPE* pa, size_t size)
{
    HVector h = create_vector_with_capacity(size);
    if(!h) {
        return NULL;
    }

    memmove(h->mp, pa, size * sizeof(DATATYPE));

    h->msize = size;

    return h;
}



HVector create_vector_filled(size_t size, DATATYPE value)
{
    HVector h = create_vector_with_capacity(size);
    if(!h) {
        return NULL;
    }

    h->msize = size;

    for(size_t i = 0; i < size; ++i) {
        h->mp[i] = value;
    }

    return h;
}


bool reserve(HVector h, size_t newcap)
{
    if(newcap < h->mcap)
        return false;

    if(newcap == h->mcap)
        return true;

    DATATYPE* pd = (DATATYPE*)realloc(h->mp, newsize * sizeof(DATATYPE));
    if(!pd) {
        fprintf(stderr, "cannot reserve capacity\n"); // DEBUG
        return false;
    }

    h->mp = pd;
    h->mcap = newcap;

    return true;
}


// Sona ekleme işlemini yapan fonksiyon. 
bool push_back(HVector h, DATATYPE value)
{
    if(k->cap == h->msize && !reserve(h, h->mcap * 2)) {
        fprintf(stderr, "cannot allocate capacity\n"); // DEBUG
        return false;
    }

    h->mp[h->msize] = value;
    ++(h->msize); // '++h->msize;' ile aynıdır ama okunmayı kolaylaştırmak için öncelik parantezi kullanılabiliyor bu gibi durumlarda.

    return true;
}

// Sondan silme işlemini yapan fonksiyon. 
bool pop_back(HVector)
{
    // Gerçekten bir silme işlemi yapılmıyor, sadece dizideki eleman sayısı bir azaltılıyor.
    if(h->msize > 0) {
        --h->msize;
        return true;
    }

    return false;
}


// Dinamik diziye aradan eleman eklemek için kullanılan fonksiyon. 
bool insert(HVector h, size_t idx, DATATYPE value)
{
    // Araya öğe ekleme işleminde dizinin öğerelerinin bir ötelenmesi gerekecek.

    if(idx > h->msize)
        return false;

    if(k->cap == h->msize && !reserve(h, h->mcap * 2)) {
        fprintf(stderr, "cannot allocate capacity\n"); // DEBUG
        return false;
    }

    memmove(h->mp + idx + 1, h->mp + idx, (h->msize - idx) * sieof(DATATYPE)); // Burada dinamik dizinin öğeleri bir ileri öteleniyor.
    h->mp[idx] = value;
    ++h->msize; // Araya öğe ekleme işlemi sonrasında dizinin sahip olduğu eleman sayısı bir arttırılıyor.

    return true;
}


// Dinamik dizinin herhangi bir elemanını silmek için kullanılacak olan fonksiyon. 
bool erase(HVector h, size_t idx)
{
    if(idx >= h->msize) {
        return false;
    }

    memmove(h->mp + idx, h->mp  + idx + 1, (h->msize - idx - 1) * sizeof(DATATYPE)); // Burada dinamik dizinin öğeleri bir geri öteleniyor.

    --h->msize;
}

// Beliri bir değere sahip olan elemanı dizide aramak için kullanılan fonksiyon, aranan değer bulunursa indeks değeri döndürülür bulunamazsa işaretsiz bir tam sayı türünün en büyük değeri döndürülür. 
size_t find(HVector h, DATATYPE value, VALUECOMPARE fp)
{
    for(size_t i = 0; i < h->msize; ++i) {
        // Buradaki karşılaştırma sadece primitive türler için geçerlidir, 'complex type' değişkenler için uygun bir karşılaştırma yöntemi değildir.
        // if(h->mp[i] == value) {
        // }

        if(fp(h->mp[i], &value) == 0) {
            return i;
        }
    }

    return NOT_FOUND;
} 

// Beliri bir değere sahip ilk öğeyi silen fonksiyon. 
bool erase_first(HVector h, DATATYPE value, VALUECOMPARE fp)
{
    size_t idx = find(h, value, fp);
    if(idx != NOT_FOUND) {
        erase(h, idx);
        return true;
    }

    return false;
}

// Dinamik dizinin erişebileceği en yüksek eleman sayısını düşürmek için kullanılan fonksiyon. 
void shring_to_fit(HVector h)
{
    h->mp = (DATATYPE*)realloc(h->mp, h->msize * sizeof(DATATYPE)); // Dinemik dizinin bellketeki boyutu güncellendi ve ilk adresi yapının 'mp' üyesine atandı.
    h->mcap = msize; // Dinamik dizinin erişebileceği en büyük eleman sayısı o andaki elemen sayısı olarak belirleniyor.
}

// İlgili dinamik diziyi bellekten silen fonksiyon. 
void destroy_vector(HVector)
{
    free(h->mp);
    free(h);
}

// Dinamik dizinin tüm elemanlarını silmek ve diziyi boşaltmak için kullanılan fonksiyon. 
void clear(HVector h)
{
    h->msize = 0;
}


size_t erase_all(HVector h, DATATYPE value); // Beliri bir değere sahip tüm öğeleri silen fonksiyon, geriye silinen öğe sayısını döndürür.
```



👇 Aşağıdaki programda yazdığımız dinamik dizinin ilk sınama programı incelenebilir. 
```C
#include <nvector.h>
#include <nutikity.h>
#include <stdio.h>

void print_test(HVector h)
{
    printf("size     = %zu\n", get_size(h));
    printf("capacity = %zu\n", get_capacity(h));

    if(is_empty(h)) {
        printf("[]");
        return;
    }

    printf("[");
    for(size_t i = 0; i < get_size(h) - 1; ++i) {
        printf("%d, ", get_element(h, i))
    }
    printf("%d]\n", get_element(h, get_size(h) - 1));
}

int main(void)
{
    HVector handle = create_vector();

    print_test(handle);
}
```



👇 Aşağıdaki programda yazdığımız dinamik dizinin ikinci sınama programı incelenebilir. 
```C
#include <nvector.h>
#include <nutikity.h>
#include <stdio.h>

void print_test(HVector h)
{
    printf("size     = %zu\n", get_size(h));
    printf("capacity = %zu\n", get_capacity(h));

    if(is_empty(h)) {
        printf("[]");
        return;
    }

    printf("[");
    for(size_t i = 0; i < get_size(h) - 1; ++i) {
        printf("%d, ", get_element(h, i))
    }
    printf("%d]\n", get_element(h, get_size(h) - 1));
}

int main(void)
{
    HVector h = create_vector();


    for(int i = 0; i < h->mcap; ++i) {
        push_back(h, i);
    }

    print_test(h);
    push_back(h, 737);

    printf("\n~~~~~~~~~~~~~\n");

    print_test(h);
}
```


Ders sonu ...
