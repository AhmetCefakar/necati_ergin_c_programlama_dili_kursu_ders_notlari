# 58.Ek Ders
---


## Type Qualifiers (TÃ¼r Niteleyicileri)

`const`, `volatile`, `restrict` anahtar sÃ¶zcÃ¼kleri niteledikleri tÃ¼rlerin davranÄ±ÅŸÄ±nÄ± deÄŸiÅŸtirmek iÃ§in kullanÄ±lÄ±r. `restrict` anahtar sÃ¶zcÃ¼ÄŸÃ¼ dile C99 standardÄ± ile eklenmiÅŸtir.


### `volatile` Anahtar SÃ¶zcÃ¼ÄŸÃ¼

Bir nesne `volatile` olarak bildirildiÄŸinde o nesnenin program dÄ±ÅŸÄ±ndaki kaynaklar tarafÄ±ndan deÄŸiÅŸtirilebileceÄŸi bilgisini derleyiciye ve kodu okuyacak kiÅŸiye belirtmiÅŸ oluyoruz.

**Memory map input output** biÃ§iminde bir kavram var, Ã¶zellikle sistem programlama veya gÃ¶mÃ¼lÃ¼ sistem programlama tarafÄ±nda kullanÄ±lan cihazlarÄ±n donanÄ±mlarÄ±n **yazmaÃ§larÄ±(register)** var bunlar bellekte bazÄ± adreslere eÅŸlenmiÅŸ(mapping) durumda yani cihazla ilgili bir durum deÄŸiÅŸikliÄŸi olduÄŸunda bellekte bilinen bir adrese veri aktarÄ±lÄ±yor ve o adresteki veriye gÃ¶sterici bir deÄŸiÅŸken vasÄ±tasÄ± ile eriÅŸilebiliyor, yani elde bir adres var(bu adresler Ã§oÄŸunlukla object-like mokrolarla temsil ediliyor)

ğŸ‘‡ AÅŸaÄŸÄ±daki kod parÃ§asÄ±nda bir yazmaÅŸla iliÅŸkilendirilmiÅŸ bellek adresinin nasÄ±l kullanÄ±labileceÄŸine dair yÃ¼zeyel fikir edinilebilir.
```C
ADR_REG     (int*)0x1CAF; // DonanÄ±mda Ã¶zel bir anlamÄ± olan, bazÄ± yazmaÃ§larla baÄŸlanmÄ±ÅŸ adres deÄŸeri 'ADR_REG' adÄ±ndaki bir object-like makro ile temsilediliyor.

int* p = ADR_REG; // Burada Ã¶zel iÅŸlemler iÃ§in kullanÄ±lan adres deÄŸeri bir gÃ¶sterici deÄŸiÅŸkene alÄ±nÄ±yor sonrasÄ±nda baÅŸka iÅŸlemlerde kullanÄ±labilir.
```


ğŸš€ Mesela bir **kesmeler(interrupt)** de program dÄ±ÅŸÄ± kaynaklar vasÄ±tasÄ±yla deÄŸiÅŸkenlerin deÄŸiÅŸtirilebildiÄŸi durumlar olabilir, programda bir deÄŸiÅŸken var ve program dÄ±ÅŸÄ±ndan yazÄ±lÄ±msal ya da donanÄ±msal olarak bir kesme geliyor ve bu deÄŸiÅŸkenin deÄŸerini deÄŸiÅŸtirebildiÄŸi durumlar olabilir, bu durumu derleyicinin tespit etme imkanÄ± yoktur.

ğŸš€ Mesela bir **ileti(signal)** , bir programda bir global deÄŸiÅŸken olsun bu deÄŸiÅŸkenin deÄŸeri program dÄ±ÅŸÄ± bir kaynaktan gelen **iletiler(signal)** ile deÄŸiÅŸtirebilen, bu durumu derleyicinin tespit etme imkanÄ± yoktur.


â—â—â— Derleyiciler yazÄ±lmÄ±ÅŸ programlardan oluÅŸturulacak olan makine ve sistem kodlarÄ±nda yapacaklarÄ± **iyileÅŸtirmeleri(optimization)** sadece programÄ±n kaynak dosyalarÄ±ndaki kodlara bakarak yapmaktadÄ±r, bir programdaki bazÄ± **nesnelerin(object)**  deÄŸerleri program dÄ±ÅŸÄ±ndan deÄŸiÅŸtirilebiliyorsa derleyici bunu doÄŸrudan bilemez, bu gibi durumlarda bunu derleyiciye ilgili **nesneleri(object)** `volatile` olarak bildirerek belirtmek gerekecektir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programdan `volatile` bildiriminin kullanÄ±lÄ±ÅŸÄ± incelenebilir.
```C

int g = 10;

int main(void)
{
    // AÅŸaÄŸÄ±daki iki deÄŸiÅŸken bildirimi de aynÄ± anlama gelmektedir.
    int volatile x = 10;
    // volatile int x = 10;


    int* volatile ptr1 = &g; // Buradaki 'ptr1' gÃ¶sterici deÄŸiÅŸkeni 'volatile pointer to int' olarak nitelendirilmektedir. Burada 'ptr1' gÃ¶sterici deÄŸiÅŸkeninin tuttuÄŸu adres deÄŸerinin program dÄ±ÅŸÄ± kaynaklarca deÄŸiÅŸtirilebileceÄŸi belirtilmektedir.

    // AÅŸaÄŸÄ±daki 'ptr2' ve 'ptr3' gÃ¶stericileri aynÄ± iÅŸleve sahiptir.
    volatile int* ptr2 = &g; // Buradaki 'ptr2' gÃ¶sterici deÄŸiÅŸkeni 'pointer to volatile int' olarak nitelendirilmektedir. Burada 'ptr2' gÃ¶sterici deÄŸiÅŸkeninin gÃ¶sterdiÄŸi adresteki nesnenin deÄŸerinin program dÄ±ÅŸÄ± kaynaklarca deÄŸiÅŸtirilebileceÄŸi belirtilmektedir.
    int volatile * ptr3 = &g; // Buradaki 'ptr3' gÃ¶sterici deÄŸiÅŸkeni 'pointer to volatile int' olarak nitelendirilmektedir. Burada 'ptr3' gÃ¶sterici deÄŸiÅŸkeninin gÃ¶sterdiÄŸi adresteki nesnenin deÄŸerinin program dÄ±ÅŸÄ± kaynaklarca deÄŸiÅŸtirilebileceÄŸi belirtilmektedir.

    // AÅŸaÄŸÄ±daki 'ptr4' ve 'ptr5' gÃ¶stericileri aynÄ± iÅŸleve sahiptir.
    volatile int* volatile ptr4 = &g; // Buradaki 'ptr4' gÃ¶sterici deÄŸiÅŸkeni 'volatile pointer to volatile int' olarak nitelendirilmektedir. Hem 'ptr4' gÃ¶stericisinin gÃ¶sterdiÄŸi adres deÄŸeri hem de gÃ¶stericinin gÃ¶sterdiÄŸi o adresteki nesnenin deÄŸerinin program dÄ±ÅŸÄ± kaynaklar tarafÄ±ndan deÄŸiÅŸtirilebileceÄŸi belirtilmektedir.
    int volatile * volatile ptr5 = &g; // Buradaki 'ptr5' gÃ¶sterici deÄŸiÅŸkeni 'volatile pointer to volatile int' olarak nitelendirilmektedir. Hem 'ptr5' gÃ¶stericisinin gÃ¶sterdiÄŸi adres deÄŸeri hem de gÃ¶stericinin gÃ¶sterdiÄŸi o adresteki nesnenin deÄŸerinin program dÄ±ÅŸÄ± kaynaklar tarafÄ±ndan deÄŸiÅŸtirilebileceÄŸi belirtilmektedir.
}
```


ğŸ‘‡ AÅŸaÄŸÄ±da bir kod parÃ§asÄ±ndaki deÄŸiÅŸkenlerin program dÄ±ÅŸÄ± kaynaklar tarafÄ±ndan deÄŸiÅŸtirilebileceÄŸi bildirilmediÄŸinde nasÄ±l assembly kodu Ã¼retilebileceÄŸi incelenebilir.
```Text

// AÅŸaÄŸÄ±daki gibi bir kod parÃ§asÄ±nÄ±n iyileÅŸtirme yapÄ±larak nasÄ±l bir assembly kodu Ã¼retilebileceÄŸi aÅŸaÄŸÄ±da gÃ¶rÃ¼lebilir.
int a;
// some code here ...
int x = a + 10;
int y = a + 20;

// YukarÄ±daki iki satÄ±r kod aÅŸaÄŸÄ±daki gibi assembly koduna Ã§evrilebilir.
mov reg1, a
mov reg2, 10
add reg2, reg1
mov x, reg2
add reg1, 20
mov y, reg1
```



ğŸ‘‡ AÅŸaÄŸÄ±da bir kod parÃ§asÄ±ndaki deÄŸiÅŸkenlerin program dÄ±ÅŸÄ± kaynaklar tarafÄ±ndan deÄŸiÅŸtirilebileceÄŸi bildirildiÄŸinde nasÄ±l assembly kodu Ã¼retilebileceÄŸi incelenebilir.
```Text

// AÅŸaÄŸÄ±daki gibi bir kod parÃ§asÄ±nÄ±n iyileÅŸtirme yapÄ±larak nasÄ±l bir assembly kodu Ã¼retilebileceÄŸi aÅŸaÄŸÄ±da gÃ¶rÃ¼lebilir.
volatile int a;
// some code here ...
int x = a + 10;
int y = a + 20;

// YukarÄ±daki iki satÄ±r kod aÅŸaÄŸÄ±daki gibi assembly koduna Ã§evrilebilir.
mov reg1, a
mov reg2, 10
add reg2, reg1
mov x, reg2
#    ----> Burada 'a' deÄŸiÅŸkeni program dÄ±ÅŸÄ±ndan deÄŸiÅŸtirililebilir.
mov reg1, a
add reg1, 20
mov y, reg1
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program parÃ§asÄ±nda program dÄ±ÅŸÄ± bir kaynak tarafÄ±ndan deÄŸiÅŸtirilebilir olan bir deÄŸiÅŸkene gÃ¶re bir dÃ¶ngÃ¼nÃ¼n devam edip etmmesine karar verildiÄŸi kod incelenebilir.
```C
volatile int flag = 1; // Ã–zellikle gÃ¶mÃ¼lÃ¼ sistem programlama tarafÄ±nda eksik bilgiye sahip olan kiÅŸiler buradaki 'flag' deÄŸiÅŸkeni program dÄ±ÅŸÄ±ndan deÄŸiÅŸtirilebilir olsa bile, bu deÄŸiÅŸkeni 'volatile' olarak bildirmeyi dÃ¼ÅŸÃ¼nemeyebiliyormuÅŸ!

int main(void)
{
    while(flag){ // Bu dÃ¶ngÃ¼nÃ¼n her adÄ±mÄ±na baÅŸlamadan Ã¶nce 'flag' deÄŸiÅŸkeninin deÄŸerine bakÄ±lacak biÃ§imde makine kodu Ã¼retilecektir.
        // some code here ...
    }

}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program `volatile` bildiriminin kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include <signal.h> // 'signal' fonksiyonunu kullanabilmek iÃ§in eklendi.
#include <Windows.h> // 'Sleep' fonksiyonunu kullanabilmek iÃ§in eklendi.

volatile int keep_running = 1;

void handle_sigint(int sig);

int main(void)
{
    signal(SIGINT, handle_sigint);  // Handle Ctrl+C (SIGINT)
    while (keep_running) {          // Always check `keep_running`'s latest value
        printf("Running...\n");
        Sleep(1000);
    }
    printf("Exited safely!\n");
}

void handle_sigint(int sig)
{
    keep_running = 0;  // Signal handler changes `keep_running`
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program `volatile` ve `const` tÃ¼rlerdeki tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mlerinin yapÄ±lÄ±ÅŸÄ± incelenebilir.
```C
#include <stdio.h>
#include <signal.h>
#include <Windows.h>


int main(void)
{
    const int x1 = 10;
    int* p1 = &x1; // Bu kod geÃ§erli deÄŸildir Ã§Ã¼nkÃ¼ 'const int' tÃ¼rÃ¼nden bir deÄŸiÅŸkenin adresi 'int*' tÃ¼rÃ¼nden bir gÃ¶stericiye atanÄ±yor, tÃ¼r uyuÅŸmazlÄ±ÄŸÄ± var, C dili buna izin verir ama kullanÄ±mÄ± doÄŸru deÄŸildir.
    int* p2 = (int*)&x1; // Bu kod geÃ§erlidir, aÃ§Ä±k olarak tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapÄ±ldÄ±ÄŸÄ± iÃ§in.


    volatile int x2 = 21;
    int* p3 = &x2; // GeÃ§ersiz kod.
    volatile int* p4 = &x2; // GeÃ§erli kod.
    int* p5 = (int*)&x2; // GeÃ§erli kod.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `volatile` anahtar sÃ¶zcÃ¼ÄŸÃ¼ derleyicinin yapacaÄŸÄ± iyileÅŸtirmeleri engellemek iÃ§in de kullanÄ±labildiÄŸi gÃ¶rÃ¼lebilir.
```C
#include <stdio.h>
#include <time.h>

int main(void)
{
    // Alttaki kodda derleyici 'd' deÄŸiÅŸkeninin deÄŸerini sadece tek bir defa bellekten Ã§ekmektedir, bu da derleyicinin iyileÅŸtirme yaptÄ±dÄ±ÄŸÄ± anlamÄ±na gelmektedir.
    clock_t t = clock();
    double d = 0.0;
    for (int n = 0; n < 10000; ++n)
        for (int m = 0; m < 10000; ++m)
            d += d * n * m; // reads from and writes to a non-volatile
    printf("Modified a non-volatile variable 100m times. "
           "Time used: %.2f seconds\n",
           (double)(clock() - t) / CLOCKS_PER_SEC);

    // Alttaki kodda derleyici 'vd' deÄŸiÅŸkeninin deÄŸerini her adÄ±mda bellekten okuyacaktÄ±r, bu da derleyicinin iyileÅŸtirme yapmadÄ±ÄŸÄ± anlamÄ±na gelmektedir.
    t = clock();
    volatile double vd = 0.0;
    for (int n = 0; n < 10000; ++n)
        for (int m = 0; m < 10000; ++m) {
            double prod = vd * n * m; // reads from a volatile
            vd += prod;               // reads from and writes to a volatile
        }
    printf("Modified a volatile variable 100m times. "
           "Time used: %.2f seconds\n",
           (double)(clock() - t) / CLOCKS_PER_SEC);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir deÄŸiÅŸkenin aynÄ± zamanda hem `const` hem de `volatile` olarak bildirilebileceÄŸi incelenebilir. Bir deÄŸiÅŸkenin`const` olmasÄ± program iÃ§inden deÄŸiÅŸtirilemeyeceÄŸini belirtirken `volatile` o deÄŸiÅŸkenin deÄŸerinin program dÄ±ÅŸÄ±ndaki kaynaklar tarafÄ±ndan deÄŸiÅŸtirilebileceÄŸi anlamÄ±na gelmektedir.
```C
#include <stdio.h>
#include <time.h>

int g = 101;

int main(void)
{
    const volatile int x = 101;

    const int* volatile p = &g;
}
```


### `restrict` Anahtar SÃ¶zcÃ¼ÄŸÃ¼ 

`restrict` anahtar sÃ¶zcÃ¼ÄŸÃ¼ yalnÄ±zca gÃ¶sterici deÄŸiÅŸkenleri niteleyebilir(sadece **top-lavel** olarak kullanÄ±labilir), bunun dÄ±ÅŸÄ±nda kullanÄ±lmasÄ± sÃ¶zdizim hatasÄ±dÄ±r. `restrict` sÃ¶zcÃ¼ÄŸÃ¼ dile C99 standardÄ±yla birlikte eklenmiÅŸtir. </br>
`restrict` anahtar sÃ¶zcÃ¼ÄŸÃ¼yle bildirilmiÅŸ bir deÄŸiÅŸken derleyiciye ve okuyucuya ilgili blokta ilgili deÄŸiÅŸkeni gÃ¶steren tek gÃ¶stericinin olduÄŸunu o gÃ¶stericinin de `restrict` olarak bildirilen ilgili deÄŸiÅŸken olduÄŸu anlamÄ±na gelmektedir.


ğŸ‘‡ AÅŸaÄŸÄ±daki kod parÃ§asÄ±nda `restrict` kullanÄ±mÄ± incelnebilir.
```C
#include <stdio.h>
#include <time.h>

// AÅŸaÄŸÄ±daki fonksiyon parametresi olan parametrelerin 'restrict' olmalarÄ± derleyicinin daha rahat iyileÅŸtirme yapabilmesini saÄŸlayacaktÄ±r.
void foo(int* restrict p1, int* restrict p2)
{

}
```


**Pointer aliasing**: Birden fazla farklÄ± gÃ¶sterici deÄŸiÅŸkenlerin aynÄ± nesneyi gÃ¶sterdiÄŸi durumlarÄ± belirtmek iÃ§in kullanÄ±lan bir terimdir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **pointer aliasing** durumundan dolayÄ± derleyicinin aynÄ± gÃ¶sterici ile dereferencing iÅŸleminin tek deÄŸil iki ayrÄ± makine kodu ile aynÄ± deÄŸeri iki defa bellekten Ã§ekeceÄŸi gÃ¶rÃ¼lmelidir.
```C
#include <stdio.h>
#include <time.h>

double g = 1;

void func(int* p1, int* p2, const int* p)
{
    // Derleyici iki defa '*p' iÅŸlemini yapacaktÄ±r, Ã§Ã¼nkÃ¼ 'p' gÃ¶stericisinin gÃ¶sterdiÄŸi adresteki deÄŸer balka yerlerden deÄŸiÅŸtirilebilir.
    *p1 += *p;
    *p2 += *p;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `restrict` bildirilen parametrelerin derleyicinin Ã¼reteceÄŸi makine kodlarÄ±nÄ± etkileyecetir.
```C
#include <stdio.h>
#include <time.h>

double g = 1;

void func(int* restrict p1, int* restrict p2, const int* restrict p)
{
    // Derleyici bir defa '*p' iÅŸlemini yapacaktÄ±r, Ã§Ã¼nkÃ¼ 'p' gÃ¶stericisinin gÃ¶sterdiÄŸi adresteki deÄŸer sadece bu fonksiyonun kapsamÄ± iÃ§inde deÄŸiÅŸtirilebilir olarak 'restrict' anahtar sÃ¶zcÃ¼ÄŸÃ¼yle bildirilmiÅŸtir.
    *p1 += *p;
    *p2 += *p;
}
```


â—â—â— `restrict` anahtar sÃ¶zcÃ¼ÄŸÃ¼ kullanÄ±ldÄ±ÄŸÄ±nda **ub** oluÅŸmamasÄ±nÄ±n saÄŸlanmasÄ± kodu yazan programcÄ±ya aittir, `restrict` bildirilen iki farklÄ± gÃ¶stericinin aynÄ± nesneyi gÃ¶stermemesi programcÄ±nÄ±n sorumluluÄŸundadÄ±r, yoksa **ub** durumu oluÅŸur.



â—â—â— C++ dilinde `restrict` anahtar sÃ¶zcÃ¼ÄŸÃ¼ yoktur Ã§Ã¼nkÃ¼ bu anahtar sÃ¶zcÃ¼k C++ dilinin bÃ¼nyesine uygun olmamasÄ±ndan dolayÄ±dÄ±r ama derleyiciler bu anahtar sÃ¶zcÃ¼ÄŸÃ¼n iÅŸlevselliÄŸine benzer **extension**'lar saÄŸlamaktadÄ±r.


ğŸ“Œ `strcpy` ve `strcpy_s` fonksiyonlarÄ±nÄ±n parametreleri C99 standardÄ±ndan sonra `restrict` yapÄ±lmÄ±ÅŸtÄ±r bu nedenle bu fonksiyonlara gÃ¶nderile dizilerin kesiÅŸiminin olmamasÄ± gerekiyor yoksa **ub** durumu oluÅŸur.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 20.30-20.40 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


## C99 StandardÄ±yla Dile Eklenen Ã–zellikler

BazÄ± derslerde C99 ile dile gelen yenilikleri yÃ¶zeysel olarak inceledik ama derinlemesine incelememiÅŸtik burada derinlemesine inceleyeceÄŸiz.


### VLA(Variable Length Array) 

**VLA** Ã¶zelliÄŸi yani DeÄŸiÅŸken boyutlu diziler ile tanÄ±mlanan dizilerin eleman sayÄ±sÄ±nÄ± belirten ifadeleri sabit ifadesi olmak zorunda deÄŸildir, **VLA** Ã¶zelliÄŸi dile C99 ile eklenmiÅŸ ve C11 ile Ã¶zelliÄŸin saÄŸlanÄ±p saÄŸlanmama tercihi derleyicilere bÄ±rakÄ±lmÄ±ÅŸtÄ±r.

Microsoft derleyicisi **VLA** Ã¶zelliÄŸine destek vermemektedir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **VLA** kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 7;

    int ary1[x]; // VLA desteÄŸi varsa legal bir 'defination statement'.

    int ary2[x] = { 3, 4, 5, 6, 7, 7, 8 }; // VLA desteÄŸi varsa bile ilk deÄŸer verme sÃ¶zdizimi illegaldir.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **VLA** Ã¶zelliÄŸinden yararlanarak deÄŸiÅŸken eleman sayÄ±sÄ±na sahip bir static dizi nasÄ±l kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>

void func(int n)
{
    int a[n];
    // static int a2[n]; // Bu statement'ta sÃ¶zdizim hatasÄ± oluÅŸur ve illegal'dir Ã§Ã¼nkÃ¼ VLA ile tanÄ±mlanan diziler 'static' Ã¶mÃ¼rlÃ¼ olamaz.

    printf("sizeof(a) = %zu", sizeof(a));
    printf("size a = %zu", sizeof(a) / sizeof(a[0]));

    for(int i = 0; i < n; ++i){
        a[i] = i;
    }

    // ...

    for(int i = 0; i < n; ++i){
        printf("%d ", a[i]);
    }
    printf("\n");
}

int main(void)
{
    func(5);
    func(9);
    func(13);
}
```

â—â—â— **VLA** Ã¶zelliÄŸiyle oluÅŸturulan dizilerin **storage duration** durumlarÄ± **outomatic storage duration** olmaktadÄ±r, bu tÃ¼rden deÄŸiÅŸkenler belleÄŸin **stack** alanÄ±nda yeralÄ±r.

â—â—â— **VLA** bir dizi **outomatic** Ã¶mÃ¼rlÃ¼ olmak zorundadÄ±r, **static** Ã¶mÃ¼rlÃ¼ olamaz.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda dinamik bellek yÃ¶netimi ile deÄŸiÅŸken elemanlÄ± dizilerin kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "nutility.h" // 'asize' makrosunun kullanÄ±labilmesi iÃ§in eklendi.

int dcmp(const void* vp1, const void* vp2)
{
    typedef const double* CDPTR;

    *(CDPTR)vp1 > *(CDPTR)vp2 ? 1 : 
    *(CDPTR)vp1 < *(CDPTR)vp2 ? -1 : 0; 
}

double get_median(const double* pa, size_t size)
{
    double* pd = malloc(size * sizeof(double));
    if(pd == NULL){
        fprintf(strerr, "bellek yetersiz.\n");
        exit(EXIT_FAILURE);
    }

    memcpy(pd, pa, size * sizeof(double));
    qsort(pd, size, sizeof(*pd), dcmp);

    double ret = pa[size / 2];

    free(pd);

    return ret;
}

int main()
{
    double a[] = { 1.2, 5.6, 3.3, 2.6, 1.56, 7.73, 3.45, 3.56, 4.23 };

    double median = get_median(a, asize(a));

    printf("medina = %f\n", median);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **VLA** ile deÄŸiÅŸken elemanlÄ± dizilerin kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "nutility.h" // 'asize' makrosunun kullanÄ±labilmesi iÃ§in eklendi.

int dcmp(const void* vp1, const void* vp2)
{
    typedef const double* CDPTR;

    *(CDPTR)vp1 > *(CDPTR)vp2 ? 1 : 
    *(CDPTR)vp1 < *(CDPTR)vp2 ? -1 : 0; 
}

double get_median(const double* pa, size_t size)
{
    double ar[size]; // Burada 'VLA' aracÄ±ndan yararlanÄ±lÄ±yor.

    memcpy(ar, pa, size * sizeof(double));
    qsort(ar, size, sizeof(*ar), dcmp);

    double ret = pa[size / 2];

    return ret;
}

int main()
{
    double a[] = { 1.2, 5.6, 3.3, 2.6, 1.56, 7.73, 3.45, 3.56, 4.23 };

    double median = get_median(a, asize(a));

    printf("medina = %f\n", median);
}
```




ğŸ‘‡ AÅŸaÄŸÄ±daki programda 
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    int ary[4] = { 3, 7, 9, 2 };

    int (*p)[4] = &ary;

    for(int i = 0; i < 4; ++i){
        printf("%d\n", (*p)[i]);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda eÄŸer derleyici **VLA** destekliyorsa **variable length** array iÃ§in **variable pointer** da oluÅŸturulabileceÄŸi gÃ¶rÃ¼lebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void foo(int n)
{
    int ary[n];

    int (*p)[n] = &ary; 

    for(int i = 0; i < n; ++i){
        (*p)[i] = i;
    }

    for(int i = 0; i < n; ++i){
        printf("%d\n", (*p)[i]);
    }

    printf("\n", );
}

int main()
{
    foo(5);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **VLA** ile iki boyutlu bir dizinin tanÄ±mlanabileceÄŸi gÃ¶rÃ¼lebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void foo(int row, int col)
{
    int ar[row][col];
    int val = 0;

    for(int i = 0; i < row; ++i){
        for(int k = 0; k < col; ++k){
            ar[i][k] = val++;
        }
    }

    // some code here ...

    for(int i = 0; i < row; ++i){
        for(int k = 0; k < col; ++k){
            printf("%d", ar[i][k]);
        }
        printf("\n");
    }
}

int main()
{
    foo(5, 3);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **VLA** ile **variable pointer** bir dizinin tanÄ±mlanabileceÄŸi gÃ¶rÃ¼lebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void foo(int row, int col)
{
    int ar[row][col];
    
    int (*p)[row][col] = &ar;
}

int main()
{
    foo(5, 3);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki boyutlu dizinin kendisi deÄŸiÅŸken boyutlu olmasa da deÄŸiÅŸken boyutlu bir dizinin pointer oluÅŸturarak dizinin kendisine dinamik olarak bellek edinilebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void foo(int row, int col)
{
    int ar[row][col];
    
    int (*p)[row][col] = &ar;
}

int main()
{
    size_t row, col;

    printf("matrisin stir ve sutun sayisini girin: ");
    scanf("%zu%zu", &row, &col);

    int (*p)[row][col] = malloc(sizeof(*p)); // Burada dizinin kendisi dinamik olarak bellekten yer ayrÄ±lÄ±p oluÅŸturulmaktadÄ±r.

    // some code here ...

    for(size_t i = 0; i < row; ++i){
        for(size_t k = 0; k < col; ++k){
            (*p)[i][k] = rand() % 10;
        }
    }

    for(size_t i = 0; i < row; ++i){
        for(size_t k = 0; k < col; ++k){
            printf("%d", (*p)[i][k]);
        }
        printf("\n");
    }

    free(pd);
}
```


### Compound Literals 

C++ dilinde yoktur, C diline C99 standardÄ±yla eklenmiÅŸtir.

Bir dizi ya da bir yapÄ± tÃ¼rÃ¼nden nesne kullanÄ±lacaÄŸÄ±nda 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **Compound Literals** Ã¶zelliÄŸi kullanÄ±mÄ± incelenebilir.
```C
#include <time.h>
#include <stdio.h>
#include "date.h"

void func(int* p);

int main()
{
    func(&(int) { 13 }); // Burda 'compound literal' vardÄ±r.

    struct tm* p = localtime(&(time_t){ time(0) }); // Burda 'compound literal' vardÄ±r.

    print_array((int[5])  { 3, 6, 7, 4, 3 }, 5); // Burda 'compound literal' vardÄ±r.


    int* p = (int[]){ 2, 5, 7, 8, 1 }; // Burda 'compound literal' vardÄ±r.
    *p = 21;
    p[4] = 89;

    print_array(p, 5);
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 20.36-20.47 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **Compound Literals** Ã¶zelliÄŸinin **designated initialization** ile kullanÄ±mÄ± incelenebilir.
```C
#include <time.h>
#include <stdio.h>
#include "date.h"

typedef struct{
    char name[20];
    int age;
    double wage;
} Person;


void func(const Person*);

int main()
{
    int* p1 = (int[]){ [2] = 5, [7] = 9, [3] = 7 }; // Burda 'compound literal' aracÄ± 'designated initialization' aracÄ± ile birlikte kullanÄ±lmÄ±ÅŸtÄ±r.

    p = (Person){ "umay", 41, 45.78 };

    func(&(Person) { "timur", 45, 56.76 }); // Burda 'compound literal' aracÄ± kullanÄ±lmÄ±ÅŸtÄ±r.
    func(&(Person) { .name = "tarkan", .age = 101, .wage = 5.76 }); // Burda 'compound literal' aracÄ± 'designated initialization' aracÄ± ile birlikte kullanÄ±lmÄ±ÅŸtÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **Compound Literals** aracÄ±nÄ±n kullanÄ±mÄ± incelenebilir.
```C
#include <time.h>
#include <stdio.h>
#include "date.h"

typedef struct{
    char name[20];
    int id;
    double wage;
} Person;


int main()
{
    Person ary[10];

    ary[5] = (Person) { "ulgen", 792206523, 45.54354 };

    Person* p = &(Person){ "ulgen", 292326523, 95.554 };
    p->name[0] = 'e'; // Buradaki kod legal'dir ve burada 'ub' yoktur.
    
    char* pc = (char[]){ "korhan" }; // Burda 'compound literal' aracÄ± kullanÄ±lmÄ±ÅŸtÄ±r.
}
```




ğŸ‘‡ AÅŸaÄŸÄ±daki programda **Compound Literals** aracÄ±nÄ±n kullanÄ±mÄ± incelenebilir.
```C
#include <time.h>
#include <stdio.h>
#include "date.h"

void bar(int* p, int size);

void foo(int x, int y, int z)
{
    // int ar[] = { x, y, z };
    // bar(ar, 3);

    bar((int[]) { x, y, z }, 3);
}

int main()
{


}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **Compound Literals** aracÄ±nÄ±n kullanÄ±mÄ± incelenebilir.
```C
#include <time.h>
#include <stdio.h>
#include "date.h"


typedef struct {
    int x, y, z;

} Point;


void foo(int x, int y, int z)
{
    Point p;

    p = (Point){x, y, z };
}

int main()
{

}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **Compound Literals** aracÄ±nÄ±n kullanÄ±mÄ± incelenebilir.
```C
#include <time.h>
#include <stdio.h>
#include "date.h"
#include "nutility.h"


int main()
{
    int* p;

    if(1) {
        p = (int[]) { 1, 3, 2 }; // Burada derleyici Ã¼Ã§ elemanlÄ± bir dizi oluÅŸturacaktÄ±r, bu dizi otomatic Ã¶mÃ¼rlÃ¼dÃ¼r.
    }

    print_array(p, 3); // Burada 'dangling pointer' vardÄ±r, 'p' gÃ¶stericisine sadece ilgili blokta geÃ§erli olan otomatic Ã¶mÃ¼rlÃ¼dÃ¼r bir nesne atandÄ±ÄŸÄ± iÃ§in blok dÄ±ÅŸÄ±nda bu nesne hayatta olmadÄ±ÄŸÄ± iÃ§in.
}
```




ğŸ‘‡ AÅŸaÄŸÄ±daki programda **Compound Literals** aracÄ±nÄ±n kullanÄ±mÄ± incelenebilir. 
```C
#include <time.h>
#include <stdio.h>
#include "date.h"


typedef struct {
    int mx, my;
} Point;


void drawpixel(Point);


void drawline(void)
{
    for(int i = 0; i < 10; ++i) {
        drawpixel(&(Pointer) { i, i });
    }
}
```


### Flexible Array Member(Esnek Dizi ElemanÄ±) 

C99 ile dile eklenmiÅŸ olan bir araÃ§tÄ±r.

Ã–zellikle yapÄ±larÄ±n kullanÄ±mÄ±nda ihtiyaÃ§ duyulan ÅŸÃ¶yle bir sorun var, bir yapÄ±nÄ±n Ã¼yelerinden biri eleman sayÄ±sÄ± derleme ananda belli olmayan bir dizi olduÄŸunda bu dizinin oluÅŸturulmasÄ± sorunudur.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda 
```C
#include <stdio.h>
#include "nutility.h"

struct Student {
    char name[20];
    char surname[20];
    int id;
    int* pgrades;
};


int main()
{
    Student* ps = (Student*) malloc(sizeof(Student)); // YapÄ± nesnesini barÄ±ndÄ±rmak iÃ§in bellekten yer ayrÄ±lÄ±yor.

    int n = 5;
    ps->pgrades = (int*) malloc(n * sizeof(int));

    free(ps->pgrades);
    free(ps);
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programdan bir yapÄ±nÄ±n elemanÄ±nÄ±n nasÄ±l **Flexible Array Member** olarak tanÄ±mlandÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

struct Student {
    int id;
    char name[16];
    char surname[20];
    int grades[]; // Bu eleman 'Flexible Array Member'dÄ±r. Bu yapÄ± Ã¼yesi ilgili yapÄ±nÄ±n doÄŸrudan bir Ã¼yesi deÄŸildir.
};

int main()
{
    printf("sizeof(struct Student) = %zu\n", sizeof(struct Student)); // Burada yapÄ± nesnesinin bellek boyutumu '40 byte' olduÄŸu gÃ¶rÃ¼lecektir.

}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan bir yapÄ±nÄ±n elemanÄ±nÄ±n nasÄ±l **Flexible Array Member** olarak sadece yapÄ±nÄ±n son elemanÄ± olabileceÄŸi incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

struct Student {
    int id;
    char name[16];
    int grades[]; // Bu eleman 'Flexible Array Member'dÄ±r. Bu yapÄ± Ã¼yesi yapÄ±nÄ±n son elemanÄ± olmamasÄ± sÃ¶zdizim hatasÄ±dÄ±r.
    char surname[20];
};


// Bir yapÄ±nÄ±n sadece bir tane 'Flexible Array Member' Ã¼ye elemanÄ± olabilir, birden fazla olursa sÃ¶zdizim hatasÄ±dÄ±r.
struct Data {
    int x, y;
    double d;
    int ary1[]; // Bu eleman 'Flexible Array Member' olarak kullanÄ±lmak istenmiÅŸ.
    int ary2[]; // Bu eleman 'Flexible Array Member' olarak kullanÄ±lmak istenmiÅŸ.
};


int main()
{

}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan bir yapÄ±nÄ±n elemanÄ±nÄ±n nasÄ±l **Flexible Array Member** olarak bildirilip kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "nutility.h"

typedef struct {
    int id;
    char name[16];
    int grades[]; // Bu eleman 'Flexible Array Member'dÄ±r.
} Student;

int main()
{
    int no_of_exams;

    printf("kac not: ");
    scanf("%d", &no_of_exams);

    Student* p = malloc(sizeof(Student) + (no_of_exams * sizeof(int))); // YapÄ± nesnesi iÃ§in bellek ayrÄ±lÄ±yor.

    // some code here  ...

    p->id = 78324;
    strcpy(p->name, "Ulku");

    for(int i = 0; i < no_of_exams; ++i) {
        p->grades[i] = rand() % 100;
    }


    Student mystudent = *p; // Bu statement legaldir, 'p' gÃ¶stericisinin gÃ¶sterdiÄŸi nesnenin 'grades' Ã¼yesi dÄ±ÅŸÄ±ndaki Ã¼yelerine 'mystudent' nesnesi Ã¼zerinden eriÅŸilebilir.
    free(p);

    printf("ad = %s\n", mystudent.name);
    printf("id = %s\n", mystudent.id);

    for (int i = 0; i < no_of_exams; ++i) {
        printf("%d ", mystudent.grades[i]); // Burada 'ub' vardÄ±r Ã§Ã¼nkÃ¼ yapÄ± nesneleri birbirine atandÄ±ÄŸÄ±nda **Flexible Array Member** Ã¼yeler iki nesne arasÄ±nda atanmamaktadÄ±r.
    }
}
```


â—â—â— YapÄ± nesneleri birbirine ilk deÄŸer verdiÄŸinde ya da bir yapÄ± nesnesi baÅŸka bir yapÄ± nesnesine atandÄ±ÄŸÄ±nda **Flexible Array Member** Ã¼yeler atanmayacaktÄ±r. AtamanÄ±n yapÄ±labilmeis iÃ§in kopyalama yapÄ±lacak olan yapÄ± nesnesi iÃ§in bellekten yer ayrÄ±ldÄ±ktan sonra `memcpy` fonksiyonu kullanÄ±lmalÄ±dÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan bir yapÄ±nÄ±n elemanÄ±nÄ±n **Flexible Array Member** olan elemanÄ±nÄ±n `memcpy` fonksiyonunu kullanarak kopyalanabildiÄŸi incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "nutility.h"


typedef struct {
    int id;
    char name[16];
    int grades[]; // Bu eleman 'Flexible Array Member'dÄ±r.
} Student;

int main()
{
    int no_of_exams;

    printf("kac not: ");
    scanf("%d", &no_of_exams);

    size_t storage_size = sizeof(Student) + (no_of_exams * sizeof(int));

    Student* p1 = malloc(storage_size); // YapÄ± nesnesi iÃ§in bellek ayrÄ±lÄ±yor.

    // some code here  ...

    p1->id = 78324;
    strcpy(p1->name, "Ulku");

    for(int i = 0; i < no_of_exams; ++i) {
        p1->grades[i] = rand() % 100;
    }

    Student* p2 = malloc(storage_size);

    memcpy(p2, p1, storage_size);

    printf("%d %s\n", p2->id, p1->name);
    
    for(int i = 0; i < no_of_exams; ++i) {
        ptintf("%d ", p2->grades[i]);
    }    
}
```


Ders sonu ...
