# 6.Ders 26.01.2025 ğŸ•˜

Derse 22(09:00)-32(09:12)-34(10:10)-34(12:10) kiÅŸi katÄ±ldÄ±.

## VarlÄ±k TanÄ±mlama KapsamlarÄ±(scope)

â—â—â— Birden fazla varlÄ±ÄŸÄ±n adlarÄ±nÄ±n aynÄ± olabilmesi iÃ§in **scope**'larÄ±nÄ±n farklÄ± olmasÄ± gerekiyor.

ğŸ‘‡ AÅŸaÄŸÄ±daki programda aynÄ± adÄ±n farklÄ± **kapsamlarda(scope)** bildirimleri incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int x = 1;

void foo()
{
    printf("1.x = %d", x);

    int x = 5;

    printf("2.x = %d", x);
    {
        printf("3.x = %d", x);
        int x = 7;
        printf("4.x = %d", x);
        {
            printf("5.x = %d", x);
            int x = 13;

            printf("6.x = %d", x);
        }
        printf("7.x = %d", x);
    }
    printf("8.x = %d", x);
}

void bar()
{
    int x;

}
```

**Name Collagen**: Ad Ã§akÄ±ÅŸmasÄ± demektir ve aynÄ± **kapsam(scope)** iÃ§erisinde birden fazla aynÄ± adda varlÄ±k tanÄ±mÄ± varsa gerÃ§ekleÅŸen bir durumdur.

ğŸ§­ C ve C++ dilerinde "**Name Lookup**" iÅŸlemini derleyici tarafÄ±ndan aÅŸaÄŸÄ±daki kurallara gÃ¶re yapÄ±lmaktadÄ±r;
1. Ä°sim arama belirli bir sÄ±raya gÃ¶re yapÄ±lÄ±r. Derleyici her bir **kapsam(scope)** iÃ§inde kullanÄ±lan adlarÄ± ararken ilk Ã¶nce ilgili kapsamdan baÅŸlar bulamazsa dÄ±ÅŸ kapsamlara doÄŸru geniÅŸleyerek arama iÅŸlemini yapar, adlar sadece tanÄ±mlandÄ±klarÄ± kapsamda tanÄ±mlandÄ±klarÄ± satÄ±rdan itibaren kullanÄ±labilirdir.
2. Aranan ad bulunduÄŸunda ad arama sona erer(yani devam etmez).
3. Ä°Ã§ iÃ§i bloklarda aynÄ± adlÄ± varlÄ±k kullanÄ±ldÄ±ÄŸÄ±nda derleyici adÄ±n kullanÄ±ldÄ±ÄŸÄ± bloktan baÅŸlayarak kullanÄ±lan adÄ± aranmaya baÅŸlanacaktÄ±r ve ilk bulunan tanÄ±mlamadan sonra "**Name Lookup**" iÅŸlemine son verilir.


ğŸ‘‡ AÅŸaÄŸÄ±daki program **name-lookup** iÅŸleminin nasÄ±l yapÄ±ldÄ±ÄŸÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int x; // 'x' adÄ±nda bir

int main(void)
{
    {
        // some code here

        {
            int x(void); // 'x' adÄ±nda bir fonksiyon bildirimi

            x = 5; // Derleyici burada sÃ¶zdizim hatasÄ±(syntax error) verecektir Ã§Ã¼nkÃ¼ 'Name-lookup' iÅŸlemindne dolayÄ± 'x' adÄ±nÄ± bir fonksiyon olarak gÃ¶recektir.
        }
    }
}
```

â—â—â— **Name-lookup** iÅŸlemi eÄŸer bir iÃ§ blok iÃ§inde kullanÄ±lmÄ±ÅŸsa ad arama iÅŸlemi ilk Ã¶nce bulunulan bloktaki ilgili varlÄ±k adÄ±nÄ±n ilk kullanÄ±ldÄ±ÄŸÄ± yerden baÅŸlayarak ilgili bloÄŸun en baÅŸÄ±na kadar yapÄ±lÄ±r, bu iÅŸlem adÄ±n bildirimi bulunana kadar her blok iÃ§in yapÄ±lÄ±r, en son **file scope** alanÄ±nda varlÄ±k adÄ±nÄ±n geÃ§tiÄŸi fonksiyonun en baÅŸÄ±ndan dosyanÄ±n baÅŸÄ±na kadar olan alanda aranÄ±r.



"**Name hiding**" terimi farklÄ± blok seviyelerinde birden fazla aynÄ± ada sahip varlÄ±k olduÄŸunda "**Name Lookup**" iÅŸlemi bulunulan **scope** iÃ§erisinden baÅŸladÄ±ÄŸÄ± iÃ§in yukarÄ± seviyedeki aynÄ± adlÄ± varlÄ±klara eriÅŸilememesi durumunu ifade etmek iÃ§in kullanÄ±lÄ±yor. </br>
AÅŸaÄŸÄ±daki tanÄ±mlarÄ±n hepsi aynÄ± durum iÃ§in kullanÄ±lmaktadÄ±r. 
- **Name hiding(Ä°smin gizlenmesi)**
- **Name masking(Ä°smin Maskelenmesi)**
- **Name Shadowing(Ä°smin gÃ¶lgeleme)**



Necati Ergin, C ve C++ mÃ¼lakatlarÄ±nÄ± yaparken ilk baÅŸtan Ã§ok basit sorular ile baÅŸlayÄ±p doÄŸru cevaplarÄ± alabilirse sorularÄ± zorlaÅŸtÄ±rarak mÃ¼lakata devam ediyormuÅŸ, bu temel sorulardan biri ğŸ‘‡ aÅŸaÄŸÄ±daki gibidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
  int printf = 6; // Derleyici bu statement iÃ§in hata vermeyecektir
  
  // Derleyici aÅŸaÄŸÄ±daki statement iÃ§in compile-time anÄ±nda 'printf is not a function' hatasÄ± verecektir. 
  // Bunun nedeni 'Name Lookup' iÅŸleminde 'printf'in bir 'int' deÄŸiÅŸken olarak kabul edilmesidir.
  printf("Hello Word!");
}
```

â— C dilinde derleyici dilin standart kÃ¼tÃ¼phanesindeki varlÄ±klarÄ±n adlarÄ±nÄ± bilmez, bir C dosyasÄ± oluÅŸturulduÄŸunda dosyanÄ±n baÅŸÄ±nda `#include` ile Ã¶n iÅŸlemci komutlarÄ± ile eklenen "**.h**" dosyalarÄ±ndaki varlÄ±klar derleyici tarafÄ±ndan dikkate alÄ±nÄ±r, fakat ğŸ‘† yukarÄ±daki kod misalinde olduÄŸu gibi "**Name Lookup**" iÅŸlemi bulunulan **scope** iÃ§erisinden baÅŸladÄ±ÄŸÄ± iÃ§in standar kÃ¼tÃ¼phanedeki bir fonksiyon adÄ± baÅŸka bir varlÄ±k iÃ§in kullanÄ±labilir.

ğŸ‘‡ AÅŸaÄŸÄ±daki program C++ dilindeki `::` operatÃ¶rÃ¼(scope resolution operator) ile nasÄ±l global alandaki **name hiding** iÅŸleminden dolayÄ± eriÅŸilemez olan ada eriÅŸilebileceÄŸi incelenebilir.
```C++
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int x = 10;

int main(void)
{
    int x = 7;
  
    ::x += x; // Global alandaki 'x' deÄŸiÅŸkeninin deÄŸeri '17' olacaktÄ±r. '::' operatÃ¶rÃ¼ global alandaki 'x' deÄŸerine eriÅŸebilmek iÃ§in kullanÄ±lÄ±yor, C dilinde '::' operatÃ¶rÃ¼ yoktur.
  
    printf("x = %d\n", ::x); // Bu satÄ±r Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda ekrana '17' yazdÄ±rÄ±lÄ±r.
    printf("x = %d\n", x); // Bu satÄ±r Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda ekrana '7' yazdÄ±rÄ±lÄ±r.
}
```

ğŸ‘‡ AÅŸaÄŸÄ±daki program **name-lookup**, **name-hiding** ve **scope** kavramlarÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int x = 1;

void foo()
{
    printf("[8] x = %d", x);
}

int main(void)
{
    printf("[1] x = %d", x);
    int x = 3;
    printf("[2] x = %d", x);
    {

        printf("[3] x = %d", x);
        int x = 5;
        printf("[4] x = %d", x);
        
        {
            int x = 7;
            printf("[5] x = %d", x);
        }
        printf("[6] x = %d", x);
    }
    printf("[7] x = %d", x);
    foo();
}
```



**Nested Block**: Ä°Ã§ iÃ§e geÃ§miÅŸ olan bloklardan iÃ§te kalan bloklar iÃ§in kullanÄ±lan bir terimdir.

**Enclosing Block**: Ä°Ã§ iÃ§e geÃ§miÅŸ olan bloklardan iÃ§te kalan bloÄŸu kapsayan blok iÃ§in kullanÄ±lan bir terimdir.


## Functions(Kursun 1. Ã‡eyreÄŸinin en Ã¶nemli konusu) 

Bu konuya 8-12 saat arasÄ±nda zaman ayrÄ±lacak.

"**Function**" terimi diÄŸer dillerdeki "**method, procedure, subroutine, vb.**" terimlerin karÅŸÄ±lÄ±ÄŸÄ±dÄ±r.

ğŸ“Œ Function ile ilgili tanÄ±mlar aÅŸaÄŸÄ±daki gibidir;
1. "**To declare a function(Fonksiyon bildirmek)**" tanÄ±mÄ± "**Function declaration(Fonksiyon bildirimi)**" iÅŸlemini yapmaktadÄ±r. `void foo(int x);` bu bir **Function declaration**.
2. "**To define a function(Fonksiyon tanÄ±mlamak)**" tanÄ±mÄ± "**Function definition(Fonksiyon tanÄ±mÄ±)**" iÅŸlemini yapmaktadÄ±r. Fonksiyonu gÃ¶vdesiyle birlikte yazma iÅŸlemidir.
3. "**To call a function(Fonksiyona Ã§aÄŸrÄ± yapmak)**" tanÄ±mÄ± "**Function call(Fonksiyon Ã§aÄŸrÄ±sÄ±)**" iÅŸlemini yapmaktadÄ±r. Mevcut olan bir fonksiyona yapÄ±lan Ã§aÄŸrÄ±lardÄ±r.



ğŸ§  Fonksiyonlarla ilgili aÅŸaÄŸÄ±daki ayrÄ±mÄ± iyi bilmek gerekiyor
1. Fonksiyon Ã§aÄŸrÄ±larÄ± yapÄ±ldÄ±ÄŸÄ±nda gÃ¶nderilen deÄŸerler varsa bunlara "**Argument**" denilmektedir. `int sum = add(v_1, v_2);` burada **v_1** ve **v_2** "**argument**" olarak adlandÄ±rÄ±lÄ±r.
2. Fonksiyon bildiriminde kullanÄ±lan fonksiyonun alacaÄŸÄ± deÄŸerlerin tanÄ±mlarÄ±na "**Parameter**" denilmektedir. `int add(int n_1, int n_2);` burada **n_1** ve **n_2** "**parameter**" olarak adlandÄ±rÄ±lÄ±r.


ğŸ“Œ C dilinde bir fonksiyon kendisini Ã§aÄŸÄ±ran yere Ã¼Ã§ farklÄ± ÅŸekilde deÄŸer dÃ¶ndÃ¼rebilir, sÄ±ralama kullanÄ±m sÄ±klÄ±ÄŸÄ± Ã§ok olandan az olana doÄŸru yapÄ±lmÄ±ÅŸtÄ±r, bunlar;
1. **Return value** ile fonksiyonu Ã§aÄŸÄ±ran yere deÄŸer iletilebilir.
2. **Call by reference** ile fonksiyonu Ã§aÄŸÄ±ran yere deÄŸer iletilebilir(fonksiyonun Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ± yerden fonksiyona bir deÄŸiÅŸkenin adresi gÃ¶nderilir ve fonksiyon geriye dÃ¶nÃ¼lecek deÄŸeri bu adrese yazar)
3. **Global variable (deÄŸiÅŸkenler)** ile fonksiyonu Ã§aÄŸÄ±ran yere deÄŸer iletilebilir(sadece aynÄ± dosya ile sÄ±nÄ±rlÄ± olarak) 


ğŸš€ C ve C++ dillerinde tarihsel sÃ¼reÃ§te bir konuyu anlatmak iÃ§in kullanÄ±lacak ve net bir anlamÄ± olmayan fonksiyonlarÄ±n adlarÄ± sÄ±klÄ±kla "func, foo, bar, baz, vb." olarak verilmektedir.


ğŸ‘‡ AÅŸaÄŸÄ±daki program C dilinde sade bir fonksiyon nasÄ±l tanÄ±mlandÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

// 'return value type' function_name(function_parameters){ // 'function_main_block' } ÅŸeklinde bir fonksiyon tanÄ±mlanmaktadÄ±r, aÅŸaÄŸÄ±da sade bir fonksiyon tanÄ±mÄ± incelenebilir.
int func(int x, int y)
{
    // code
}

double get_circle_area(double radius)
{
    // code here
}
```


â—â—â— Bir fonksiyon aÅŸaÄŸÄ±daki Ã¶zelliklere sahiptir;
- Fonksiyonlar bir geri dÃ¶nÃ¼ÅŸ deÄŸerine sahiptir, bir fonksiyon deÄŸer dÃ¶ndÃ¼rmediÄŸinde bile "**void**" deÄŸer dÃ¶ndÃ¼rÃ¼r(aslÄ±nda **void** bir tÃ¼rdÃ¼r).
- FonksiyonlarÄ±n adlarÄ± vardÄ±r.
- Fonksiyonlar parametre alabilirler.
- `function_name(parameters);` buradaki bildirimde fonksiyonun adÄ± "**function_name**" ve alacaÄŸÄ± deÄŸerlere de "**parameters**" denilmektedir, "**parameters**"lar "**(..)**" ÅŸeklinde **parametre parantezi** iÃ§erisinde yer alÄ±r.


â—â—â— **void type** ile ilgili olarak aÅŸaÄŸÄ±daki bilgiler Ã¶nemlidir.
- **void** bir tÃ¼rdÃ¼r(type).
- Bir deÄŸiÅŸkenin tÃ¼rÃ¼ **void** olamaz.
- Bir **ifadenin(expression)** tÃ¼rÃ¼ **void** olabilir.
- **void** tÃ¼rden bir **ifadenin(expression)** deÄŸeri yoktur.
- `void foo();`, `void bar(int v1, double v2);` vb. ÅŸeklinde geri dÃ¶nÃ¼ÅŸ tÃ¼rÃ¼ **void** olarak bildirilen fonksiyonlara **void function** denilmektedir.


### Implicit int(Default-int) Rule 

C dilinin **C99** standardÄ±ndan Ã¶nce(**C89**) "**implicit int**" denilen bir kural vardÄ±. AslÄ±nda bu kural **C99** ile dilden kaldÄ±rÄ±ldÄ± fakat derleyicilerin Ã§ok bÃ¼yÃ¼k Ã§oÄŸunluÄŸu eksiden yazÄ±lmÄ±ÅŸ kodlarÄ±n geÃ§erliliÄŸini korumak iÃ§in halen bu kuralÄ± uygular(geriye doÄŸru uyumluluÄŸun desteklenmesine "**backwards compatible**" denilmektedir).

"**implicit int**" kuralÄ± adÄ±nda bir kural vardÄ±r ve bu kural bir deÄŸiÅŸken tÃ¼rÃ¼ kullanÄ±lmasÄ± gereken yerde bu deÄŸiÅŸken tÃ¼rÃ¼ kullanÄ±lmadÄ±ÄŸÄ±nda bu tÃ¼rÃ¼ "**int**" tÃ¼rÃ¼ olarak kabul eder. 
**C99** ve sonraki standartlarda C dilinde yazÄ±lan yazÄ±lÄ±mlarda "**implicit int**" olacak ÅŸekilde kodlama yapmamak gerekir. 
C++ dilinin hiÃ§bir standardÄ±nda "**implicit int**" kuralÄ± yoktur.

ğŸ‘‡ AÅŸaÄŸÄ±daki program "**implicit int**" kuralÄ±ndan dolayÄ± `foo` fonksiyonunun Ã§oÄŸu C derleyicisi tarafÄ±ndan nasÄ±l yorumlandÄ±ÄŸÄ± incelenebilir(bu kod misali Ã§alÄ±ÅŸtÄ±rÄ±lmak iÃ§in deÄŸil incelemek iÃ§indir).
```C
// Bizim yazdÄ±ÄŸÄ±mÄ±z fonksiyon tanÄ±mÄ±
foo(int x)
{
    return x * x;
}

// YukarÄ±daki gibi geri dÃ¶nÃ¼ÅŸ deÄŸeri yazÄ±lmamÄ±ÅŸ olan 'foo' fonksiyonunun geri dÃ¶nÃ¼ÅŸ deÄŸeri 'int' olarak aÅŸaÄŸÄ±daki gibi yorumlanacaktÄ±r
int foo(int x)
{
    return x * x;
}
```


â—â—â— AÅŸaÄŸÄ±daki bilgiler dikkate alÄ±narak fonksiyon bildirimleri ve tanÄ±mlarÄ± yapÄ±lmalÄ±dÄ±r. 
- C dilinde parametre almayan fonksiyonlar yazarken `type foo(void){...}` ÅŸeklinde tanÄ±mlamak doÄŸrudur. 
- C++ dilinde parametre almayan fonksiyonlar yazarken `type foo(){...}` ÅŸeklinde tanÄ±mlamak doÄŸrudur.

**Void Function**: Geri dÃ¶nÃ¼ÅŸ deÄŸeri olmayan(yani geri dÃ¶nÃ¼ÅŸ deÄŸeri **void** olan) fonksiyonlardÄ±r. Mesela `void foo(void);` ya da `void foo(int x);` fonksiyon bildirimleri "**void function**" olarak adlandÄ±rÄ±lmaktadÄ±r. `int foo(void);` fonksiyonu "**void function**" deÄŸildir. 


ğŸ‘‡ AÅŸaÄŸÄ±daki program **implicit-int** kuralÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

main(void) // 'main' fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸeri 'int' olarak kabul edilir, burada 'implicit-int' kuralÄ± uygulanmaktadÄ±r ama bu kullanÄ±m tavsiye edilmemektedir.
{
    printf("'implicit int' used 'main' function.");

    return 1;
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.31-10.52 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


### FonksiyonlarÄ±n Bildirimleri ve TanÄ±mlarÄ±

C dilinde fonksiyon adlandÄ±rmalarÄ± da deÄŸiÅŸken adlarÄ±nda olduÄŸu gibi kÃ¼Ã§Ã¼k harf yoÄŸun olarak yapÄ±lmalÄ±dÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki program fonksiyonlarÄ±n parametrelerinin geÃ§erli olduÄŸu **kapsamÄ±(scope)** anlamak iÃ§in inceleyebilirsin.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

// AÅŸaÄŸÄ±daki fonksiyon tanÄ±mÄ±ndaki 'x' fonksiyon parametresinin geÃ§erli olduÄŸu 'kapsam(scope)' aralÄ±ÄŸÄ± 'block scope'tur, yani fonksiyonun gÃ¶vdesi olan 'block scope'tur.
void foo(int x)
{
    double x = 4.5; // Buradaki deÄŸiÅŸken bildirimi illegal olcaktÄ±r Ã§Ã¼nkÃ¼ 'x' adÄ±nda bir varlÄ±k 'foo' fonksiyonunda tanÄ±mlÄ±dÄ±r, aynÄ± kapsamda(scope) bir ad sadece bir kere bildirilebilir.
}

int main(void)
{
    printf("Hello Word!");
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki program bir fonksiyondaki **kapsam(scope)** aralÄ±klarÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

// AÅŸaÄŸÄ±daki fonksiyon tanÄ±mÄ± 'legal'dir Ã§Ã¼nkÃ¼ 'foo' fonksiyonunun scope'u 'file scope' ve fonksiyonun parametresi olan 'foo' adÄ±nÄ±n scope'u 'block scope'tur.
void foo(int foo)
{
    foo++;

    printf("foo = %d", foo);
}
```



â”AÅŸaÄŸÄ±daki programdaki `int x = x;` legal ve doÄŸru mudur diye mÃ¼lakatlarda Ã§ok soruluyormuÅŸ. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki "main" kodunda **name hiding** vardÄ±r, global alandaki "x" deÄŸiÅŸkeni "main" fonksiyonu iÃ§erisinde **name hiding** iÅŸlemine uÄŸruyor.</br>
`int x = x;` satÄ±rÄ±nda **ub** vardÄ±r, **ub** durumu "x" deÄŸiÅŸkeninin tanÄ±mlandÄ±ÄŸÄ± yerde kendisine kendi deÄŸeri atanmÄ±ÅŸ olduÄŸu iÃ§in oluÅŸuyor.
```C
#include <stdio.h>

int x = 10;

int main(void)
{
  int x = x; // Burada 'ub' durumu var, burada bildirilen x adÄ±na verilen ilk deÄŸer kedisi olduÄŸu iÃ§in 'ub' durumu oluÅŸuyor.
}
```



â—â—â— FonksiyonlarÄ±n parametreleri "**automatic**" Ã¶mÃ¼rlÃ¼ olmak zorundadÄ±r, fakat fonksiyon bloÄŸunda(gÃ¶vdesinde) "**static**" Ã¶mÃ¼rlÃ¼ deÄŸiÅŸkenler tanÄ±mlanabilir. Global deÄŸiÅŸkenler de "**static**" Ã¶mÃ¼rlÃ¼ olmak zorundadÄ±r.

â—â—â— C ve C++ dillerinde Bir fonksiyon iÃ§in de baÅŸka bir fonksiyon tanÄ±mlanmasÄ±na izin verilmemektedir yani **nested function** kullanÄ±mÄ± gibi bir kullanÄ±m yoktur.

â—â—â— Bir deÄŸiÅŸken global alanda ya da "**static**" olarak tanÄ±mlandÄ±ÄŸÄ±nda program Ã§alÄ±ÅŸma sÃ¼resi boyunca bu deÄŸiÅŸken hafÄ±zada yer kaplayacaktÄ±r. Bir "**static**" deÄŸiÅŸkenin memory(bellek)'de mevcut olmasÄ± ona ulaÅŸabileceÄŸimiz anlamÄ±na gelmiyor.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda hem global hem de her bir fonksiyon iÃ§inde **static** Ã¶mre sahip "value1" adÄ±nda deÄŸiÅŸken tanÄ±mlamasÄ± yapÄ±lÄ±yor, bu durumda derleyiciden derleyiciye deÄŸiÅŸmeyecek ÅŸekilde her bir **static** "value1" deÄŸiÅŸkeni tanÄ±mÄ±nda program Ã§alÄ±ÅŸma sÃ¼resi boyunca bellekten silinmeyecek ÅŸekilde ayrÄ± ayrÄ± "value1" deÄŸeri oluÅŸturulacaktÄ±r ve her bir fonksiyon "value1" deÄŸerine eriÅŸmek istediÄŸinde kendi fonksiyonunun **block scope** iÃ§indeki "value1" deÄŸeri iÃ§in bellekte oluÅŸturulan deÄŸere eriÅŸecektir. 
Fonksiyonlar iÃ§inde tanÄ±mlanmÄ±ÅŸ olan "value1" deÄŸerlerinin program Ã§alÄ±ÅŸÄ±rken ne zaman bellekte yer kaplayacak ÅŸekilde oluÅŸturulacaklarÄ± kullanÄ±lan derleyiciden derleyiciye gÃ¶re deÄŸiÅŸiklik gÃ¶sterecektir ama fonksiyonlar programÄ±n herhangi bir anÄ±nda illa Ã§aÄŸÄ±rÄ±lacaklarsa ya da Ã§aÄŸÄ±rÄ±lmama durumlarÄ± da varsa bu iki farklÄ± duruma gÃ¶re buradaki tanÄ±mlanan **static** deÄŸiÅŸkenlerin bellekte oluÅŸturulmasÄ± gereksiz olabilir.
```C
int value1 = 12;

void foo()
{
    static int value1 = 10;
    ++value1;
}

void foo2()
{
    static int value1 = 11;
    ++value1;
}

void foo3()
{
    static int value1 = 14;
    ++value1;
}
```


â— Bir fonksiyonun global bir deÄŸiÅŸkeni kullanmasÄ± baÅŸka bir dosyadan o fonksiyonun kullanÄ±labilirliÄŸini olumsuz etkileyeceÄŸi iÃ§in bu durumdan kaÃ§Ä±nÄ±lmalÄ±dÄ±r.

â— Kod tekrarlarÄ± bir yazÄ±lÄ±mÄ±n kalitesiz yazÄ±ldÄ±ÄŸÄ± anlamÄ±na gelmektedir, tekrarlÄ± kodlar olduÄŸunda bu kodlarÄ±n tek bir yerde yer almasÄ± iÃ§in fonksiyona alÄ±nmasÄ± doÄŸru olan yaklaÅŸÄ±mdÄ±r, bu ÅŸekilde kodun bakÄ±mÄ± da kolaylaÅŸacaktÄ±r.

â— Debugger programlarÄ±(yazÄ±lÄ±mlarÄ±) ayrÄ± programlardÄ±r ve kod Ã§alÄ±ÅŸtÄ±rÄ±lÄ±rken adÄ±m adÄ±m kodlarÄ±n Ã§alÄ±ÅŸtÄ±rmasÄ±na izin vererek hatalarÄ± tespit etmek iÃ§in kullanÄ±lmaktadÄ±r.

**Function Call Chair**: Programlarda bir fonksiyonun kendi iÃ§inde iÃ§ iÃ§e farklÄ± fonksiyonlarÄ± Ã§aÄŸÄ±rdÄ±ÄŸÄ± durumlarÄ± ifade etmek iÃ§in kullanÄ±lÄ±yor, "**foo1 => foo2 => foo3 => foo4**" gÃ¶sterimi buna misal verilebilir.

Fonksiyonlar logic(mantÄ±ksal) olarak kodlarÄ±n diÄŸer kodlardan yalÄ±tÄ±lmasÄ±nÄ± saÄŸlar, bu ÅŸekilde kodlarÄ±n bakÄ±mÄ± kolaylaÅŸÄ±r, hata ayÄ±klama kolaylaÅŸÄ±r ve yeniden kullanÄ±labilirlik(re-useablelty) saÄŸlanmÄ±ÅŸ olur.


### FonksiyonlarÄ±n Geri DeÄŸer DÃ¶ndÃ¼rmesi 

â—â—â— C dilinin cÃ¼mlelerine "**Statement(Deyim)**" denilmektedir, "**Statement(Deyim)**"lar farklÄ± tÃ¼rlere sahiptir. Bir "**Statement(Deyim)**" en temelde ""**Declaration Statement(Deyim)**"" ya da dÃ¼z "**Statement(Deyim)**" olarak iki farklÄ± baÅŸlÄ±ÄŸa ayrÄ±lÄ±r. 

ğŸ§­ DÃ¼z "**Statement(Deyim)**" aÅŸaÄŸÄ±da listelenen tÃ¼rlere ayrÄ±lmaktadÄ±r; 
1. **Expression Statemen**: 
2. **Null Statemen**: 
3. **Compound Statemen**: 
4. **Control Statemen**: ProgramÄ±n akÄ±ÅŸ yÃ¶nÃ¼ Ã¼zerinde akÄ±ÅŸ yÃ¶nÃ¼nÃ¼ deÄŸiÅŸtirebilen, Ã¶nceden belirlenmiÅŸ bir **sÃ¶zdizimine(syntax)** sahip ve bu **sÃ¶zdizim(syntax)** uyarÄ±nca en az bir anahtar sÃ¶zcÃ¼k iÃ§eren deyimlerdir. AÅŸaÄŸÄ±da **Control Statemen** tÃ¼rleri listelenmiÅŸtir.
    - `if`
    - `while`, `do while`, `for`
    - `switch`, `goto`
    - `break`, `continue` 
    - `return`



"**return statement(deyim)** ikiye ayrÄ±lÄ±r;
1. "**return;**" bu kullanÄ±m "**ifadesiz return deyimi**" ya da "**yalÄ±n return deyimi**" olarak belirtilebilir ve sadece **void** fonksiyonlarda fonksiyondan geriye dÃ¶nmek iÃ§in kullanÄ±lÄ±r.
2. "**return value;**" bu kullanÄ±m "**ifadeli return deyimi**" olarak nitelendirilmektedir.

ğŸ‘‡ AÅŸaÄŸÄ±daki program **return statement** kullanÄ±mlarÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include<stdio.h>

int main(void)
{
    int x = 5;
    int y = 10;

    return x + y;
    //return (x + y); // YukarÄ±daki 'return statement' ile buradaki gibi kullanÄ±lmasÄ± aynÄ± anlama gelmektedir.
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki program `sizeof` operatÃ¶rÃ¼nÃ¼n operantÄ±nÄ± parantez iÃ§inde alÄ±p almama durumu **sÃ¶zdizim(syntax)** kuralÄ±na gÃ¶re nasÄ±l deÄŸiÅŸtiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include<stdio.h>

int main(void)
{
    int x = 5;

    int a = sizeof(int); // Burada kullanÄ±lan parantez '()' **sÃ¶zdiziminin(syntax)** parantezidir, kullanÄ±lmazsa sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.
    int b = sizeof(x); // Burada kullanÄ±lan parantez '()' Ã¶ncelik parantezidir yani kullanÄ±lmasa da olurdu, 'int b = sizeof x;' statement ta aynÄ± anlama gelir.
}
```


**Void** deÄŸer dÃ¶nen bir fonksiyonda sadece fonksiyon bloÄŸunun sonunda tek bir adet "**return;**" **statement(deyim)** kullanÄ±lÄ±yorsa bu deyim kullanÄ±lmasÄ± ile kullanÄ±lmamasÄ± arasÄ±nda fark yoktur.

ğŸ“Œ FonksiyonlarÄ±n geriye deÄŸer dÃ¶ndÃ¼rmesi durumunu belirtmek iÃ§in ÅŸu cÃ¼mleler kurulabilir;
1. "Fonksiyon falanca deÄŸerini dÃ¶ndÃ¼rÃ¼yor" 
2. "Fonksiyon falanca deÄŸerine geri dÃ¶nÃ¼yor(C derneÄŸinde kullanÄ±lan tanÄ±mlama)"
3. "Function returns value" tanÄ±mÄ± Ä°ngilizcede kullanÄ±lÄ±yor.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda tanÄ±mlanan `foo` adÄ±ndaki **void function** iÃ§erisinde **return;** deyimi olmadan da kullanÄ±labiliyor ve bu durumda fonksiyon bloÄŸunda en son statement'Ä± Ã§alÄ±ÅŸtÄ±rdÄ±ktan sonra fonksiyondan geriye dÃ¶nÃ¼lecektir.
```C
void foo(void)
{
    // statement_1;
    // statement_2;
    // statement_3;
    // statement_4;
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `foo` fonksiyonu Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ±nda gÃ¶nderilen "x" parametresinin deÄŸerine gÃ¶re Ã§alÄ±ÅŸtÄ±racaÄŸÄ± sayÄ±rlar deÄŸiÅŸecektir.
```C
void foo(int x)
{
    // statement_1;
    // statement_2;

    if(x > 120)
        return;

    // statement_3;
    // statement_4;
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda geri dÃ¶nÃ¼ÅŸ deÄŸerinin `int` tÃ¼rÃ¼nden olmasÄ± gerekirken **yalÄ±n return deyimi** ile fonksiyondan Ã§Ä±kÄ±lmak istendiÄŸinde **ub** durumu oluÅŸacaktÄ±r, bu kullanÄ±mda derleyiciler **sÃ¶zdizim hatasÄ±(syntax error)** verebilir ya da sadece uyarÄ± mesajÄ± verebilir.
```C
int func(int x)
{
    // statement_1;
    // statement_2;
    
    return;
}
```



â— C dilinde bir fonksiyondan geriye sadece bir tane deÄŸer dÃ¶ndÃ¼rÃ¼lebilir, bir fonksiyon Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ± yere birden fazla deÄŸer dÃ¶ndÃ¼remez.
 
â— Bir fonksiyon iÃ§erisinde birden fazla farklÄ± yerde `return` deyimi kullanÄ±labilir.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.01-12.10 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


ğŸš€ **One-liner function**: Tek bir satÄ±r olarak yazÄ±labilir durumdaki fonksiyonlar iÃ§in kullanÄ±lan terimdir.

ğŸ‘‡ AÅŸaÄŸÄ±daki programda **one-liner function** incelenebilir.
```C
// 'sum' function is a 'one-liner' function
int sum(int x, int y)
{
    retun x + y;
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda yer alan iki farklÄ± `max2` fonksiyonu Ã¶zÃ¼nde aynÄ± Ã§alÄ±ÅŸacaktÄ±r, buradaki aynÄ± Ã§alÄ±ÅŸma durumunu anlayabilmek gerekiyor.
```C
int max2(int x, int y)
{
    if(x > y)
        return x;
    else
        return y;
}

int max2(int x, int y)
{
    if(x > y)
        return x;
  
    return y;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã¼Ã§ tane tam sayÄ±dan en bÃ¼yÃ¼ÄŸÃ¼nÃ¼ geriye dÃ¶ndÃ¼ren fonksiyonun nasÄ±l sade ÅŸekilde yazÄ±lacaÄŸÄ± incelenebilir.
```C
int max3(int x, int y int z)
{
    int max = x;

    if(y > max)
        max = y

    if(z > max)
        maz = z

    return max;
}
```



âš ï¸ YazÄ±lÄ±mda deÄŸer hesaplayan fonksiyonlara ad verirken "find" adÄ± verilmemelidir Ã§Ã¼nkÃ¼ bu sÃ¶zcÃ¼k "arayarak bulmak" anlamÄ±na gelmektedir bunun yerine "get" kullanÄ±mÄ± daha doÄŸrudur.


ğŸ‘‡ AÅŸaÄŸÄ±daki "abs" fonksiyonu kendisine gÃ¶nredilen bir sayÄ±nÄ±n mutlak deÄŸerini geriye dÃ¶ndÃ¼ren bir **pure function**'dÄ±r.
```C
int abs(int x)
{
    if(x < 0)
        return -x;

    return x;
}
```


ğŸš€ **Pure Function**: Bu terimi programlamada genelgeÃ§er olarak kullanÄ±lmaktadÄ±r, bu tanÄ±mlama bir fonksiyonun dÄ±ÅŸarÄ±sÄ±ndaki herhangi bir deÄŸiÅŸkenin deÄŸerini deÄŸiÅŸtirmeyen sadece kendi iÃ§inde tanÄ±mlanmÄ±ÅŸ olan deÄŸiÅŸkenleri kullanan fonksiyonlar iÃ§in kullanÄ±lÄ±r. KÄ±saca bir "**Pure Function**" "Program State(ProgramÄ±n Durumu)" Ã¼zerinden deÄŸiÅŸikliÄŸe neden olmayan fonksiyondur.



ğŸ‘‡ AÅŸaÄŸÄ±daki `ndigit` fonksiyonu kendisine gÃ¶ndetilen bir tam sayÄ±nÄ±n basamak sayÄ±sÄ±nÄ± geriye dÃ¶nmektedir, buradaki fonksiyondaki kodlar ÅŸimdi anlaÅŸÄ±lmayabilir ama ilerleyen derslerde anlaÅŸÄ±lacaktÄ±r.
```C
int ndigit(int x)
{
    if(x == 0)
        return 1;
    
    int digit_count = 0; // Buradaki deÄŸiÅŸken bildirimi kendisinden Ã¶nce statement olduÄŸu iÃ§in C89 standardÄ±nda legal deÄŸildir.

    while(x != 0){
        ++digit_count;
        x /= 10; // '/=' operatÃ¶rÃ¼ 'compound assignment operator' olarak adlandÄ±rÄ±lmaktadÄ±r.
    }

    return digit_count;
}
```


â—â—â— **SÃ¶zdizim(syntax)** hatalarÄ± ile mantÄ±ksal hatalar birbirinden farklÄ±dÄ±r. Derleyici **SÃ¶zdizim(syntax)** hatalarÄ±nÄ± **compile-time** anÄ±nda yakalayacaktÄ±r fakat bir **logic error** derleyici tarafÄ±ndan yakalanmasÄ± pek mÃ¼mkÃ¼n deÄŸildir, bir **logic error** **debuging** ile Ã§Ã¶zÃ¼lebilir.

â—â—â— HiÃ§ Ã§alÄ±ÅŸmayacak bir kod yazÄ±ldÄ±ÄŸÄ±nda buna "**Unreachable Code**" denilmektedir.

ğŸ‘‡ AÅŸaÄŸÄ±daki programda **unreachable code** incelenebilir.
```C
int max2(int x, int y)
{
  x--;
  y++;
  
  return y;

  return x; // Buradaki kod 'Unreachable Code' durumundadÄ±r Ã§Ã¼nkÃ¼ program akÄ±ÅŸÄ± buraya hiÃ§bir zaman gelmeyecektir.
}
```


#### FonksiyonlarÄ±n Geri DÃ¶nÃ¼ÅŸ DeÄŸerleri Ne Olabilir 

1. FonksiyonlarÄ±n geri dÃ¶nÃ¼ÅŸ deÄŸerleri hesaplanan bir deÄŸer olabilir. Ã‡oÄŸunlukla bir fonksiyonun varlÄ±k nedeni dÃ¶ndÃ¼rÃ¼len deÄŸerin hesaplanmasÄ±dÄ±r.
2. BazÄ± fonksiyonlarÄ±n geri dÃ¶nÃ¼ÅŸ deÄŸeri true/false olabiliyor bu tÃ¼r fonksiyonlar **Test Function**, **Query Function**, **Pradicate Function(Ã¶zellikle C++ dilinde bu ÅŸekilde adlandÄ±rÄ±lÄ±yor)** olarak adlandÄ±rÄ±lmaktadÄ±r.

"**test Function**", "**Query Function**", "**Predicate Function(Ã¶zellikle C++'ta)**" ÅŸeklinde adlandÄ±rÄ±lan fonksiyonlar "bool" tÃ¼rÃ¼nden deÄŸer olabilir.
- Fakat C dilini C89 standardÄ±nda "bool" tÃ¼rÃ¼ olmadÄ±ÄŸÄ± iÃ§in "bool" dÃ¶ndÃ¼recek fonksiyonlar C dilinde geleneksel olarak `int` tÃ¼rÃ¼nden deÄŸer dÃ¶ndÃ¼recek ÅŸekilde kullanÄ±lÄ±yor, burada "0" deÄŸer dÃ¶nÃ¼yorsa sonuÃ§ "false" diÄŸer tÃ¼m durumlarda sonuÃ§ "true" olarak yorumlanmalÄ±dÄ±r. 
- "**_Bool**" tÃ¼rÃ¼ C99'dan sonra dile dahil edilmiÅŸtir bu nedenle C kodu yazarken kullanÄ±lan logic deÄŸiÅŸken C89 standardÄ±nda da derlenebilmesi iÃ§in `int` tÃ¼rÃ¼ olarak tercih edildiÄŸi durumlar yaygÄ±ndÄ±r. Neco'da eÄŸer C ile kodlama yapÄ±yorsa logic durumlardaki deÄŸer tÃ¼rÃ¼ olarak `int` kullanmayÄ± tercih ediyormuÅŸ.

âš ï¸ C dilinde bir "**test Function**"dan geriye dÃ¶nen deÄŸer geleneksek olarak "**Zero non-zero(0 ya da 0'dan farklÄ± bir deÄŸer)**" olarak kullanÄ±lÄ±yor ve "0" deÄŸerinin anlamÄ± "false", sÄ±fÄ±rdan faklÄ± herhangi bir deÄŸerin anlamÄ± "true" olarak yorumlanÄ±r.

âš ï¸ C++ dilinde logic durumlarÄ±(1/0 durumlarÄ±) tutmak iÃ§in her zaman **bool** tÃ¼rÃ¼ kullanÄ±lmalÄ±dÄ±r.


Ders sonu ...
