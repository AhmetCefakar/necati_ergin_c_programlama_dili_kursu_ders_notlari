# 41.Ders 14.06.2025 ğŸ•˜

Derse 7(09:01)-9(09:04)-11(09:011)-13(09:28)-14(10:07)-15(10:45)-14(11:23)-12(11:49)-11(12:18)-12(12:28)-12(12:45) kiÅŸi katÄ±ldÄ±.
---


## Dynamic Memory Managament Devam

`malloc`, `calloc`, `realloc` fonksiyonlarÄ±yla ayrÄ±lmÄ±ÅŸ olan bellek alanlarÄ±nÄ±n ilgili bellek alanlarÄ±yla yapÄ±lan iÅŸlemler bittikten sonra `free` fonksiyonuyla iade edilmesi gerekiyor.
`malloc`, `calloc`, `realloc` fonksiyonlarÄ±yla alÄ±nan bellek alanÄ± sadece ilgili process iÃ§in geÃ§erlidir, process sonlandÄ±ÄŸÄ±nda o process'in yaprÄ±ÄŸÄ± tÃ¼m iÅŸlemler sÄ±fÄ±rlanÄ±r buna ayrÄ±lan bellek bloklarÄ± da dahildir ama iyi bir kodlama yaklaÅŸÄ±mÄ± olarak `main` fonksiyonu sonlanmadan Ã¶nce ayrÄ±lan tÃ¼m bellek bloklarÄ±nÄ±n `free` fonksiyonu ile iade edilmelidir.


### `free` Fonksiyonu Devam 

Bildirimi `stdlib.h` baÅŸlÄ±k dosyasÄ±nda ve prototipi `void free(void*);` ÅŸeklindedir.


#### `free` Fonksiyonunun KullanÄ±mÄ±nda SÄ±k YapÄ±lan Hatalar Devam 


1. Program sonlanmadan Ã¶nce ayrÄ±lan bellek bloklarÄ±nÄ±n geri verilmemesi(`free` fonksiyonunun Ã§aÄŸÄ±rÄ±lmamasÄ±) iyi bir kodlama alÄ±ÅŸkanlÄ±ÄŸÄ± deÄŸildir.

2. `free` Fonksiyonunyla geriye verilen bir bellek alanÄ±na eriÅŸmeye Ã§alÄ±ÅŸmak onu kullanmaya Ã§alÄ±ÅŸmak **ub**'ye neden olur. 

    ğŸ‘‡ AÅŸaÄŸÄ±daki programda **dangling pointer** durumu incelenebilir.
    ```C
    #include <stdio.h>
    #include <stdlib.h>
    #include "nutility.h"

    int main(void)
    {
        size_t n;
        printf("dizinin boyutu ne olsun: ");
        scanf("%zu", &n);

        //int* p = malloc(n * sizeof(int)); // C++ dilinde bu kullanÄ±m sÃ¶zdizim hatasÄ±dÄ±r(syntax error) Ã§Ã¼nkÃ¼ 'void*' tÃ¼rÃ¼nden 'int*' tÃ¼rÃ¼ne atama yapÄ±lÄ±yor.
        int* p = (int*)malloc(n * sizeof(int)); // Kodun daha net anlaÅŸÄ±labilmesi iÃ§in bu ÅŸekilde kullanÄ±lmasÄ± doÄŸru olacaktÄ±r. 

        // 'p == NULL' yazmak yerine '!p' ÅŸeklinde bir kullanÄ±m idiomatic olarak daha Ã§ok tercih edilmektedir.
        if(!p){
            printf("bellek yetersiz!\n");
            exit(EXIT_FAILURE);
        }

        set_array_random(p, n);
        print_array(p, n);

        free(p);
        // Bu noktadan sonra 'p' bir 'dangling pointer'
        print_array(p, n); // Bu fonksiyon Ã§aÄŸrÄ±sÄ± 'dangling pointer' olan 'p' deÄŸiÅŸkeninin kullanÄ±lmasÄ±ndna dolayÄ± 'ub' durumuna neden olur.
    }
    ```

    ğŸ‘‡ AÅŸaÄŸÄ±daki programda **dangling pointer** durumu incelenebilir.
    ```C
    #include <stdio.h>
    #include <stdlib.h>
    #include "nutility.h"

    int main(void)
    {
        size_t n;
        printf("dizinin boyutu ne olsun: ");
        scanf("%zu", &n);

        //int* p = malloc(n * sizeof(int)); // C++ dilinde bu kullanÄ±m sÃ¶zdizim hatasÄ±dÄ±r(syntax error) Ã§Ã¼nkÃ¼ 'void*' tÃ¼rÃ¼nden 'int*' tÃ¼rÃ¼ne atama yapÄ±lÄ±yor.
        int* p = (int*)malloc(n * sizeof(int)); // Kodun daha net anlaÅŸÄ±labilmesi iÃ§in bu ÅŸekilde kullanÄ±lmasÄ± doÄŸru olacaktÄ±r. 

        // 'p == NULL' yazmak yerine '!p' ÅŸeklinde bir kullanÄ±m idiomatic olarak daha Ã§ok tercih edilmektedir.
        if(!p){
            printf("bellek yetersiz!\n");
            exit(EXIT_FAILURE);
        }

        set_array_random(p, n);
        print_array(p, n);

        free(p);
        // Bu noktadan sonra 'p' bir 'dangling pointer'
        p = NULL; // Dikkat, buradaki kullanÄ±m idiyomotik bir statement'tÄ±r.

        print_array(p, n); // Bu fonksiyon Ã§aÄŸrÄ±sÄ± 'dangling pointer' olan 'p' deÄŸiÅŸkeninin kullanÄ±lmasÄ±ndna dolayÄ± 'ub' durumuna neden olur.
    }
    ```

    Neden **dangling pointer** kullanÄ±mÄ± oluÅŸuyor diye dÃ¼ÅŸÃ¼nÃ¼lÃ¼rse, C dilinde en sÄ±k karÅŸÄ±laÅŸÄ±lan **dangling pointer** hatalarÄ±nÄ±n nedeni bir bellek alanÄ±nÄ± birden fazla gÃ¶stericinin gÃ¶sterdiÄŸi durumlardÄ±r, bir gÃ¶sterici kaynaÄŸÄ± iade ettiÄŸinde diÄŸer gÃ¶stericiler bundan habersizse bellek alanÄ±nÄ±n iade edildiÄŸinden habersiz gÃ¶stericilerin ilgili bellek alanÄ±nÄ± kullanmaya Ã§alÄ±ÅŸmasÄ± **ub** durumuna neden olacaktÄ±r. 
    KÄ±saca kaynaklarÄ±n paylaÅŸÄ±mlÄ± olarak kullanÄ±lmasÄ± durumunda(shared) **dangling pointer** hatalarÄ±yla karÅŸÄ±laÅŸÄ±lma olasÄ±lÄ±ÄŸÄ± yÃ¼kselmektedir.


3. **Double deletion(Double free)** olarak adlandÄ±rÄ±lan Ã¶nceden iade edilmiÅŸ bellek bloÄŸunun yeniden iade edilmek istenmesi durumu **ub** durumuna neden olacaktÄ±r. 

    ğŸ‘‡ AÅŸaÄŸÄ±daki programda **dangling pointer** kullanÄ±lmasÄ±nÄ±n **ub** durumuna neden olduÄŸu incelenebilir.
    ```C
    #include <stdio.h>
    #include <stdlib.h>
    #include "nutility.h"

    int main(void)
    {
        size_t n;
        printf("dizinin boyutu ne olsun: ");
        scanf("%zu", &n);

        //int* p1 = malloc(n * sizeof(int)); // C++ dilinde bu kullanÄ±m sÃ¶zdizim hatasÄ±dÄ±r(syntax error) Ã§Ã¼nkÃ¼ 'void*' tÃ¼rÃ¼nden 'int*' tÃ¼rÃ¼ne atama yapÄ±lÄ±yor.
        int* p1 = (int*)malloc(n * sizeof(int)); // Kodun daha net anlaÅŸÄ±labilmesi iÃ§in bu ÅŸekilde kullanÄ±lmasÄ± doÄŸru olacaktÄ±r. 

        // 'p1 == NULL' yazmak yerine '!p1' ÅŸeklinde bir kullanÄ±m idiomatic olarak daha Ã§ok tercih edilmektedir.
        if(!p1){
            printf("bellek yetersiz!\n");
            exit(EXIT_FAILURE);
        }

        int* p2 = p1;

        set_array_random(p1, n);
        print_array(p1, n);

        free(p1); // Bu fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±ldÄ±ktan sonra 'p' gÃ¶stericisine eriÅŸilmek istenmesi 'dangling pointer' olacaktÄ±r.

        // some code here ...

        free(p2); // Burada 'p2' gÃ¶stericisinin gÃ¶sterdiÄŸi alanÄ±ndaki belleÄŸin Ã¶nceden iade edilmesinden dolayÄ± burada yeniden iade edilmek istenmesinin 'ub' durumuna neden olur.
    }
    ```

4. Dinamik bellek fonksiyonlarÄ± ile(`malloc`, `calloc`, `realloc`) edinilmiÅŸ bellek bloklarÄ±nÄ±n adreslerinin dÄ±ÅŸÄ±nda `free` fonksiyonuna baÅŸka bir adresin geÃ§ilmesi **ub** durumuna neden olur.

    ğŸ‘‡ AÅŸaÄŸÄ±daki programda `free` fonksiyonu ile `malloc`, `calloc`, `realloc` fonksiyonlarÄ±yla edinilmiÅŸ bir belleÄŸin adresi olmamasÄ±ndan kaynaklanan **ub** durumu incelenebilir.
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include <stdlib.h>,
    #include "nutility.h"

    int main(void)
    {
        int a[100] = { 0 };
        int* p = a;
        int n = 20;
        int* pd = (int*)malloc(n * sizeof(int));

        free(p); // Bu fonksiyon Ã§aÄŸrÄ±sÄ± hatalÄ±dÄ±r Ã§Ã¼nkÃ¼ 'p' 'malloc, calloc, realloc' fonksiyonuyla edinilen bir bellek alanÄ± olmadÄ±ÄŸÄ± iÃ§in 'ub' durumuna neden olacaktÄ±r.
    }
    ```


â—â—â— Programlama dillerinden baÄŸÄ±msÄ±z olarak en tehlikeli hata adlarÄ± birbirine yakÄ±n olarak verilmiÅŸ olan deÄŸiÅŸken adlarÄ±nÄ±n karÄ±ÅŸtÄ±rÄ±larak birbirlerinin yerlerine kullanÄ±lmasÄ±dÄ±r, C dilinde bu hatalarla daha sÄ±k karÅŸÄ±laÅŸÄ±lmkatadÄ±r.


5. `malloc`, `calloc`, `realloc` fonkisyonlarÄ±yla edinilmiÅŸ olan bellek bloklarÄ±nÄ±n bir kÄ±smÄ±nÄ±n geri verilmek iÃ§in `free` fonksiyonunun kullanÄ±lmasÄ± **ub** durumuna neden olacaktÄ±r.

    
    ğŸ‘‡ AÅŸaÄŸÄ±daki programda `malloc` fonksiyonuyla edinilen bir bellek bloÄŸunun yarÄ±sÄ±nÄ±n `free` fonksiyonuyla iade edilmesindne dolayÄ± oluÅŸacak olan **ub** durumu incelenebilir.
    ```C
    #include <stdio.h>
    #include <stdlib.h>
    #include "nutility.h"

    int main(void)
    {
        size_t n;
        printf("dizinin boyutu ne olsun: ");
        scanf("%zu", &n);

        int* p = (int*)malloc(n * sizeof(int)); // Kodun daha net anlaÅŸÄ±labilmesi iÃ§in bu ÅŸekilde kullanÄ±lmasÄ± doÄŸru olacaktÄ±r. 

        // 'p == NULL' yazmak yerine '!p' ÅŸeklinde bir kullanÄ±m idiomatic olarak daha Ã§ok tercih edilmektedir.
        if(!p){
            printf("bellek yetersiz!\n");
            exit(EXIT_FAILURE);
        }

        set_array_random(p, n);
        print_array(p, n);

        free(p + n / 2); // Buradaki iÅŸlem yanlÄ±ÅŸtÄ±r 'ub' durumuna neden olur Ã§Ã¼nkÃ¼ bir bellek bloÄŸunun yarÄ±sÄ±nÄ±n iade edilmesi iÃ§in iÅŸlem yapÄ±lÄ±yor, bunun iÃ§in 'realloc' fonksiyornu kullanÄ±lmalÄ±ydÄ±.
    }
    ```


#### `free` Fonksiyonuna NULL Pointer GeÃ§ilmesi


â—â—â— `free` fonksiyonuna **NULL** pointer geÃ§ilmesi **ub** deÄŸildir, bu iÅŸlem bir iÅŸe yarÄ±yor mu diye dÃ¼ÅŸÃ¼nÃ¼lÃ¼rse bir iÅŸe de yaramamamaktadÄ±r, bu iÅŸlemin yararÄ± ya da zararÄ± yoktur(bu gibi durumlar programlama dillerinde **no-op** iÅŸlem olarak adlandÄ±rÄ±lÄ±r)


ğŸ‘‡ AÅŸaÄŸÄ±daki program `free` fonksiyonuna **NULL Pointer** deÄŸer geÃ§ildiÄŸinde nasÄ±l davrandÄ±ÄŸÄ±nÄ± gÃ¶rmek iÃ§in incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

// Derleyiciler 'free' fonksiyonunu aÅŸaÄŸÄ±dakine benzer ÅŸekilde yazarlar, 'NULL Pointer' gelince hiÃ§bir ÅŸey yapmadan fonksiyonu sonlandÄ±rÄ±rlar.
//void free(void* vp)
//{
//    if(vp == NULL)
//        return;
//
//    // some code here ...
//}

int main(void)
{
    size_t n;
    printf("dizinin boyutu ne olsun: ");
    scanf("%zu", &n);

    int* p = (int*)malloc(n * sizeof(int)); // Kodun daha net anlaÅŸÄ±labilmesi iÃ§in bu ÅŸekilde kullanÄ±lmasÄ± doÄŸru olacaktÄ±r. 

    // 'p == NULL' yazmak yerine '!p' ÅŸeklinde bir kullanÄ±m idiomatic olarak daha Ã§ok tercih edilmektedir.
    if(!p){
        printf("bellek yetersiz!\n");
        exit(EXIT_FAILURE);
    }

    set_array_random(p, n);
    print_array(p, n);

    // AÅŸaÄŸÄ±daki iki 'free' fonksiyon Ã§aÄŸrÄ±sÄ±nda hiÃ§bir iÅŸlem yapÄ±lmayacaktÄ±r ve bu 'ub' deÄŸildir.
    free(NULL);
    free(0);
}
```



**NULL Pointer Conversion**: Derleyicinin bir pointer'a "0" tam sayÄ± sabitinin **NULL Pointer** deÄŸerine sahip olarak yorumlanacaÄŸÄ± durumudur. Derleyiciler "0" deÄŸeri bir pointer deÄŸiÅŸkene atandÄ±ÄŸÄ±nda **NULL Pointer** olarak davranmaktadÄ±r.


### `free` Fonksiyonu ve Adres DÃ¶ndÃ¼ren Fonksiyonlar


Bu dersin en Ã¶nemli kÄ±sÄ±mlarÄ±ndan biri; <br/>
Bir fonksiyon iÅŸini yapma sÃ¼recinde dinamik Ã¶mÃ¼rlÃ¼ nesne(ler) oluÅŸturur ve nesne(ler)nin adresini dÃ¶ndÃ¼rÃ¼r.

ğŸ§­ Adres dÃ¶ndÃ¼ren fonkaiyonlar, aÅŸaÄŸÄ±dakileri dÃ¶ndÃ¼rebilir;
1. Static Ã¶mÃ¼rlÃ¼ nesne adresi dÃ¶ndÃ¼rebilir.
    - **Global deÄŸiÅŸken** adresi.
    - **Static Ã¶mÃ¼rlÃ¼** yerel deÄŸiÅŸken adresi.
    - **String literal** nesnelerin adresi.
2. Ã‡aÄŸÄ±ran koddan alÄ±nan adresi dÃ¶ndÃ¼rebilir.
3. Dinamik Ã¶mÃ¼rlÃ¼ bir nesne adresi dÃ¶ndÃ¼rebilir(bunun iÃ§in ileride Ã¶ÄŸreneceÄŸimiz bir konu denilmiÅŸti, ÅŸimdi o ilerisine gelmiÅŸ olduk).



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bellekten yer ayÄ±ran `create_random_array` fonksiyonunun dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ deÄŸerin fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±lan kapsam(scope) iÃ§inden nasÄ±l iade edildiÄŸi incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

// AÅŸaÄŸÄ±daki fonksiyon bellekten ayÄ±rdÄ±ÄŸÄ± belleÄŸi kendisi geri iade edemez belleÄŸi fonksiyon Ã§aÄŸrÄ±sÄ± yapan kodun iade etmesi gerekiyor.
int* create_random_array(size_t size)
{
    int* p = (int*)malloc(size * sizeof(int));

    for(size_t i = 0; i < size; ++i){
        p[i] = rand() % 100;
    }

    return p;
}

int main(void)
{
    randomize();
    int* p = create_random_array(20);

    set_array_random(p, 20);
    print_array(p, 20);


    // some code here ...

    free(p); // Burada 'create_random_array' fonksiyonundan dÃ¶nen adres alanÄ± iade ediliyor.
}
```


Prototipi `int* foo();` olan `foo` fonksiyonu nasÄ±l bir nesne adresini geriye dÃ¶ndÃ¼rebilir;
1. Static Ã¶mÃ¼rlÃ¼.
2. Fonksiyona gÃ¶nderilen adresin kendisi.
3. Dinamik Ã¶mÃ¼rlÃ¼ nesne adresi.



Adres dÃ¶ndÃ¼ren bir fonksiyon bildiriyorsanÄ±z mutlaka ÅŸu bilgileri iÃ§eren dokÃ¼mantasyon saÄŸlayÄ±nÄ±z;
1. **Static** mi yoksa **dynamic** Ã¶mÃ¼rlÃ¼ nesne adresi mi dÃ¶ndÃ¼rÃ¼ldÃ¼ÄŸÃ¼ belirtilmelidir.
2. **NULL pointer** dÃ¶ndÃ¼rÃ¼lme ihtimali olup olmadÄ±ÄŸÄ± belirtilmelidir. 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `foo` ve `bar` fonksiyonlarÄ±nÄ±n tanÄ±mlarÄ± gÃ¶rÃ¼lmediÄŸi ve bu bilginin dÃ¶kÃ¼mente edilmediÄŸi durumda fonksiyonlardan dÃ¶nen nesnenin Ã¶mrÃ¼nÃ¼n ne olduÄŸunu nasÄ±l Ã¶ÄŸrenilebileceÄŸi incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

int* bar(void)
{
    static int ar[20];

    for(size_t i = 0; i < 20; ++i){
        ar[i] = rand() % 100;
    }

    return p;
}

int* foo(void)
{
    int* p = (int*)malloc(20 * sizeof(int));

    for(size_t i = 0; i < 20; ++i){
        p[i] = rand() % 100;
    }

    return p;
}

int main(void)
{
    randomize();
    
    // Bir fonksiyondan dÃ¶nen adresin Ã¶mrÃ¼nÃ¼ anlamak iÃ§in birden fazla defa o fonksiyona istek yapÄ±labilir, bunun sonucunda elde edilen iki adres kÄ±yaslanÄ±r;
    // EÄŸer adreseler aynÄ± ise o zaman geriye dÃ¶ndÃ¼rÃ¼len nesneler 'static' Ã¶mÃ¼rlÃ¼dÃ¼r.
    // EÄŸer adreseler farklÄ± ise o zaman geriye dÃ¶ndÃ¼rÃ¼len nesneler 'dynamic' Ã¶mÃ¼rlÃ¼dÃ¼r.
    int* p11 = bar();
    int* p12 = bar();
    printf("%p %p\n", p11, p12);


    int* p21 = bar();
    int* p22 = bar();
    printf("%p %p\n", p21, p22);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**Bir yazÄ±nÄ±n kullanÄ±lmasÄ± gerekiyor(yazÄ±yÄ± deÄŸiÅŸtirmek gerekiyor) ama o yazÄ± bize ait olmadÄ±ÄŸÄ± iÃ§in o yazÄ±nÄ±n kopyasÄ±nÄ± alÄ±p yazÄ±nÄ±n kopyasÄ± Ã¼zerinde iÅŸlem yapÄ±labilir.**" cÃ¼mlesindeki ihtiyacÄ±n nasÄ±l karÅŸÄ±lanabileceÄŸi incelenebilir. </br>
Bir Ã§ok derleyici "**String Duplucate**" sÃ¶zcÃ¼klerinden gelen `strdup` adÄ±ndaki bir yazÄ±nÄ±n kopyasÄ±nÄ± oluÅŸturan bir fonksiyon saÄŸlamaktadÄ±r.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "nutility.h"
#include <ctype.h>

char* mystrdup(const char* p)
{
    char* pd = (char*)malloc(strlen(p) + 1);

    if(!pd)
        return pd;

    return strcpy(pd, p);
}

int main(void)
{
    char str[100];

    printf("bir yazi girin: ");
    sgets(str);

    char* p = mystrdup(str);

    for(int i = 0; p[i] != '\0'; ++i)
        p[i] = (char)toupper(p[i]);

    puts(str);
    puts(p);

    free(p); 
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki yazÄ±yÄ± birleÅŸtiren bir fonksiyonun nasÄ±l yazÄ±lacaÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "nutility.h"
#include <ctype.h>

#define SIZE    100

char* concat_v1(const char* p1, const char* p2)
{
    char* pd = (char*)malloc(srtlen(p1) + srtlen(p2) + 1);

    if(!pd)
        return pd;

    strcpy(pd, p1);
    strcat(pd, p2);

    return pd;
}

char* concat_v2(const char* p1, const char* p2)
{
    char* pd = (char*)malloc(srtlen(p1) + srtlen(p2) + 1);

    if(!pd)
        return pd;

    return strcat(strcpy(pd, p1), p2); // Bu ÅŸekildeki kullanÄ±m idiomatic bir kullanÄ±mdÄ±r.
}

int main(void)
{
    char s1[SIZE];
    char s2[SIZE];

    printf("birinci yaziyi girin: ");
    sgets(s1);
    
    printf("ikinci yaziyi girin: ");
    sgets(s2);

    char* p = concat_v2(s1, s2);

    printf("(%s) + (%s) = (%s)\n", s1, s2, p);

    _strrev(p); // Standart olmayan VS derleyicisinde olan, yazÄ±yÄ± ters Ã§eviren fonksiyon.
    _strupr(p); // Standart olmayan VS derleyicisinde olan, YazÄ±yÄ± bÃ¼yÃ¼k harfe Ã§eviren fonksiyon.

    printf("(%s) + (%s) = (%s)\n", s1, s2, p);

    free(p);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda yazÄ±yÄ± bÃ¼yÃ¼k ya da kÃ¼Ã§Ã¼k harf yapan fonksiyonlarÄ±n nasÄ±l yazÄ±labileceÄŸi incelenebilir.
```C    
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "nutility.h"
#include <ctype.h>
#include <Mindows.h>
#include <conio.h>

#define SIZE    100

// Kendi yazdÄ±ÄŸÄ±mÄ±z, bir yazÄ±nÄ±n tÃ¼m harflerini bÃ¼yÃ¼k harfe Ã§eviren fonksiyon.
char* mystrupr(const char* p)
{
    char* ptemp = p;
    while(*p){
        *p = (char)toupper(*p);
        ++p;
    }

    return ptemp;
}

// Kendi yazdÄ±ÄŸÄ±mÄ±z, bir yazÄ±nÄ±n tÃ¼m harflerini kÃ¼Ã§Ã¼k harfe Ã§eviren fonksiyon.
char* mystrlwr(const char* p)
{
    char* ptemp = p;
    while(*p){
        *p = (char)tolower(*p);
        ++p;
    }

    return ptemp;
}

char* concat(const char* p1, const char* p2)
{
    char* pd = (char*)malloc(srtlen(p1) + srtlen(p2) + 1);

    if(!pd)
        return pd;

    return strcat(strcpy(pd, p1), p2);
}

int main(void)
{
    char str[] = "to be or not to be";

    while(1){
        printf("%s", str);
        mystrupr(str);
        printf("%s", str);
        system("cls");
        _getch();
        mystrlwr(str);
        printf("%s", str);
        system("cls");
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **memory leak** sorunu var, programÄ± inceleyip nedenini iyi anlamak Ã¶nemlidir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "nutility.h"
#include <ctype.h>

#define SIZE    100

char* concat(const char* p1, const char* p2)
{
    char* pd = (char*)malloc(srtlen(p1) + srtlen(p2) + 1);

    if(!pd)
        return pd;

    return strcat(strcpy(pd, p1), p2);
}

int main(void)
{
    char s1[SIZE] = "necati";
    char s1[SIZE] = "ergin";
    char s1[SIZE] = "aslan";

    char *p =  concat(concat(s1, s2), s3); // Burada iÃ§ 'concat' fonksiyon Ã§aÄŸrÄ±sÄ±nda ayrÄ±lan bellek alanÄ±nÄ± tutan bir pointer olmadÄ±ÄŸÄ± iÃ§in bu alanÄ± serbest bÄ±rakamayacaÄŸÄ±mÄ±z iÃ§in 'memory leak' sorunu oluÅŸacaktÄ±r.

    puts(p);

    free(p);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **memory leak** sorunu yoktur, buradaki nedenin iyi anlaÅŸÄ±lmasÄ± Ã¶nemlidir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "nutility.h"
#include <ctype.h>

#define SIZE    100

char* concat(const char* p1, const char* p2)
{
    char* pd = (char*)malloc(srtlen(p1) + srtlen(p2) + 1);

    if(!pd)
        return pd;

    return strcat(strcpy(pd, p1), p2);
}

int main(void)
{
    char s1[SIZE] = "necati";
    char s1[SIZE] = "ergin";
    char s1[SIZE] = "aslan";

    char *p1 =  concat(s1, s2);
    char *p2 =  concat(s1, s3); 

    puts(p1);
    puts(p2);

    free(p1);
    free(p2);
}
```



C ve C++ dillerinin standartlarÄ± belirli sÃ¼relerde yenileniyor ama geriye doÄŸru uyumluluk(**backward compatibility**) durumunun da belirli seviyede sÃ¼rdÃ¼rÃ¼lmesi gerekiyor, geriye doÄŸru uyumluluÄŸa daha Ã§ok derleyiciler Ã¶nem vermektedir;

ğŸ§  Neden C ve C++ dillerinde yeni standartlar oluÅŸturuluyor;
1. Dile yapÄ±lan eklemelerden dolayÄ±.
    - Dilin temel **sÃ¶zdizimine(syntax)** yeni eklemeler yapÄ±ldÄ±ÄŸÄ± iÃ§in, ekleme dilin **Core Syntax**'Ä±na yapÄ±lÄ±yor.
    - Dilin **Standard Library**'sine eklemeler yapÄ±ldÄ±ÄŸÄ± iÃ§in.
2. Dilde olan yapÄ±lardan bazÄ±larÄ± dilden kaldÄ±rÄ±labileceÄŸi iÃ§in **Deprecate(Deprecation)** yapÄ±lmasÄ±ndan dolayÄ±, bu ÅŸekilde dili kullananlara bu dilden kaldÄ±rÄ±labilme konusunda bilgi verilmiÅŸ olur.
3. Dilden kaldÄ±rÄ±lan Ã¶ÄŸelerden dolayÄ±.


ğŸ§  C ve C++ dilleriyle yazÄ±lacak olan projelerde dilin hangi standardÄ±nÄ±n kullanÄ±lacaÄŸÄ±na karak verilirken bir kaÃ§ durum dikkate alÄ±nÄ±r;
1. Eski standartlarla yazÄ±lmÄ±ÅŸ olan kodlar kullanÄ±lacaksa bu projenin dilin hangi standardÄ±na gÃ¶re yazÄ±lacaÄŸÄ±na karar verirken Ã¶nemlidir.
2. Yeni standartlarÄ±nÄ± kullanÄ±rken bazÄ± riskler mevcuttur, az kullanÄ±lan bir standart olduÄŸu iÃ§in karÅŸÄ±laÅŸÄ±labilecek sorunlar olabilir.
3. O standartla projeyi yazacan olan prÄ±gramcÄ±larÄ±n yetenekleri.


### `calloc` Fonksiyonu 

`malloc` ve `calloc` fonksiyonlarÄ± tek bir fark dÄ±ÅŸÄ±nda aynÄ±dÄ±r, `calloc` fonksiyonu bellekten ayÄ±rdÄ±ÄŸÄ± bellek bloÄŸunun tÃ¼m byte'larÄ±nÄ± "0" yaparak ayÄ±rmaktadÄ±r. "`calloc` = `malloc` + `memset(p, 0)`" olarak ifade edilebilir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `malloc` fonksiyonuyla elde edilen bellek bloÄŸundaki byte'larÄ±n **inditerminate value(Ã§Ã¶p deÄŸer)** olduÄŸu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>,
#include "nutility.h"

int main(void)
{
    size_t n;
    printf("dizinin boyutu ne olsun: ");
    scanf("%zu", &n);
    int* p = (int*)malloc(n * sizeof(int));

    if((p == NULL){
        printf("bellek yetersiz!\n");
        exit(EXIT_FAILURE);
    }

    //set_array_random(p, n);

    print_array(p, n); // Burada 'p' bellek bloÄŸundaki deÄŸerler Ã§Ã¶p deÄŸerdedir.

    free(p); // Bu fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±ldÄ±ktan sonra 'p' gÃ¶stericisine eriÅŸilmek istenmesi 'dangling pointer' olacaktÄ±r.
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `malloc` ile ayrÄ±lan bellek bloÄŸunun nasÄ±l `memset` fonksiyonuyla temizlendiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>,
#include "nutility.h"
#include <string.h> // 'memset' fonksiyonunu kullanmak iÃ§in eklenmiÅŸtir.

int main(void)
{
    size_t n;
    printf("dizinin boyutu ne olsun: ");
    scanf("%zu", &n);
    int* p = (int*)malloc(n * sizeof(int));

    if((p == NULL){
        printf("bellek yetersiz!\n");
        exit(EXIT_FAILURE);
    }

    memset(p, 0, n * sizeof(int)); //  'p' bellek bloÄŸundaki byte'lar '0' olarak gÃ¼ncelleniyor.

    print_array(p, n);

    free(p); // Bu fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±ldÄ±ktan sonra 'p' gÃ¶stericisine eriÅŸilmek istenmesi 'dangling pointer' olacaktÄ±r.
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `calloc` fonksiyonuyla nasÄ±l temizlenmiÅŸ bellek alanÄ± elde edildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>,
#include "nutility.h"

int main(void)
{
    size_t n;
    printf("dizinin boyutu ne olsun: ");
    scanf("%zu", &n);
    int* p = (int*)calloc(n, sizeof(int));

    if((p == NULL){
        printf("bellek yetersiz!\n");
        exit(EXIT_FAILURE);
    }

    print_array(p, n);

    free(p); // Bu fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±ldÄ±ktan sonra 'p' gÃ¶stericisine eriÅŸilmek istenmesi 'dangling pointer' olacaktÄ±r.
}
```



ğŸ“Œ MÃ¼lakatlarÄ±da sorulan Ã¶nemli bir durum ÅŸudur: `malloc` fonksiyonu "0" argÃ¼manÄ± ile Ã§aÄŸrÄ±lÄ±rsa ne olur? </br>
Bu durum derleyiciye baÅŸlÄ±dÄ±r(**implementation defined behavior**) ve aÅŸaÄŸÄ±daki iki durum sÃ¶z konusudur;
1. `malloc` fonksiyonu ya **NULL pointer** dÃ¶ndÃ¼rÃ¼r.
2. `malloc` fonksiyonu geriye bir adres dÃ¶ndÃ¼rebilir, burada `malloc` fonksiyonundan dÃ¶nen adresin `free` fonksiyonuna geÃ§ilmesi **ub** deÄŸildir ama o adresin **dereference** iÅŸlemine tabi tutulmasÄ± **ub** durumuna neden olur.
ğŸ‘‡ AÅŸaÄŸÄ±daki programda `malloc` fonksiyonu "0" argÃ¼manÄ± ile Ã§aÄŸrÄ±lmasÄ± sonucunda ne deÄŸer dÃ¶neceÄŸi incelenebilir, kullnÄ±alan derleyiciye gÃ¶re sonuÃ§ farklÄ± olacaktÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"
#include <string.h>

int main(void)
{
    int* p = (int*)malloc(0);

    if(p == NULL){
        printf("malloc NULL pointer dondurdu!\n");
    }
    else{
        printf("malloc'un dondurdugu adres %p\n", p);
    }

    // printf("%d\n", *p); // Buradaki kodda 'ub' vardÄ±r.
    free(p); // Burada 'ub' yoktur.
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 11.02-11.22 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


### `realloc` Fonksiyonu

â—â—â— `realloc` fonksiyonuyla ilgili aÅŸaÄŸÄ±daki bilgiler Ã¶nemlidir; </br>
`realloc` fonksiyonunun adÄ± "**Re Allocate**" sÃ¶zcÃ¼klerinden gelmektedir. </br>
`malloc`,`calloc` ya da `realloc` fonksiyonlarÄ±yla edinilmiÅŸ bellek alanlarÄ±nÄ±n boyutunun deÄŸiÅŸtirilmesi iÃ§in kullanÄ±lmaktadÄ±r. </br>
`malloc`,`calloc` ya da `realloc` fonksiyonlarÄ± dÄ±ÅŸÄ±nda edinilen bir bellek adresi `realloc` fonksiyonuna geÃ§ilirse **ub** durumuna neden olmaktadÄ±r. </br>
`realloc` fonksiyonunu baÅŸarÄ±sÄ±z olursa eski bellek bloÄŸunun adresi kullanÄ±labilir durumda kalmaktadÄ±r. </br>
`realloc` fonksiyonu ayrÄ±lan bellek alanÄ±nÄ± bÃ¼yÃ¼tmek iÃ§in kullanÄ±lÄ±yorsa bellek bloÄŸunu deÄŸiÅŸtirmeyebilir ya da deÄŸiÅŸtirebilir, bunun kararÄ±na arkada kullanÄ±lan algoritma karar verir, biz mÃ¼dahale edemiyoruz. </br>
`realloc` fonksiyonu bellek alanÄ±nÄ±n boyutunu deÄŸiÅŸtirdiÄŸinde(arttÄ±rdÄ±ÄŸÄ±nda ya da azalttÄ±ÄŸÄ±nda) eÄŸer bellek bloÄŸunun konumu deÄŸiÅŸtiriliyorsa, bellek alanÄ±ndaki byte'larÄ± kopyalama iÅŸlemi yapÄ±lacaktÄ±r. </br>
`realloc` fonksiyonu bellek bloÄŸunu bÃ¼yÃ¼ttÃ¼ÄŸÃ¼nde bÃ¼yÃ¼tÃ¼len bellek bloÄŸundaki byte'lar **indeterminate value** durumundadÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `realloc` fonksiyonunun prototipinin nasÄ±l olduÄŸu incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"
#include <string.h>

// 'realloc' fonksiyonunun protptipi aÅŸaÄŸÄ±daki gibidir.
// vp       : Bellek boyutu deÄŸiÅŸtirilecek olan bellek bloÄŸu adres deÄŸeri.
// newsize  : Bellek boyutu deÄŸiÅŸikliÄŸi sonrasÄ±nda oluÅŸturulacak olan yeni bellek bloÄŸunun byte olarak bÃ¼yÃ¼klÃ¼ÄŸÃ¼.
void* realloc(void* vp, size_t newsize);

int main(void)
{

}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `realloc` fonksiyonunun nasÄ±l kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"
#include <string.h>

int main(void)
{
    size_t n;
    printf("kac elemanli bir dizi olsun: ");
    scanf("%zu", &n);

    int* pd = (int*)malloc(n * sizeof(int)); 

    if(pd == NULL){
        printf("bellek yetersiz\n");
        return(1);
    }

    randomize();
    set_array_random(pd, n);
    print_array(pd, n);

    size_t n_add;
    printf("kac eleman daha eklenecek: ");
    scanf("%zu", &n_add);

    pd = realloc(pd, (n + n_add) * sizeof(int));
    if(pd == NULL){
        printf("bellek yetersiz\n");
        return(1);
    }

    print_array(pd, n + n_add); // Burada 'realloc' fonksiyonuyla geniÅŸletilen bellek alanlarÄ±ndaki deÄŸerler Ã§Ã¶p deÄŸerde olduÄŸu iÃ§in burada 'ub' vardÄ±r.

    set_array_random(pd + n, n_add); // Burada 'pd + n' argÃ¼manÄ±ndan dolayÄ± sadece 'realloc' fonksiyonuyla geniÅŸletilen bellek alanÄ±ndaki 'int' deÄŸerleri rastgele deÄŸerlerle dolduruluyor.
    print_array(pd, n + n_add);

    free(pd);
}
```


>â”
> 
> Sorulan Soru?
> 
> Normalde ub mi cÃ¶p degerle print array cagirmak mÄ±?
> 
> Cevap;
> 
> Ã‡Ã¶p deÄŸer kullanan her kod **ub**'dir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `realloc` fonksiyonu kullanÄ±ldÄ±ktan sonra adresin deÄŸiÅŸip deÄŸiÅŸmediÄŸi incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"
#include <string.h>

int main(void)
{
    size_t n;
    printf("kac elemanli bir dizi olsun: ");
    scanf("%zu", &n);

    int* pd = (int*)malloc(n * sizeof(int)); 

    if(pd == NULL){
        printf("bellek yetersiz\n");
        return(1);
    }

    printf("malloc'un dondurdugu adres: %p \n", pd);
    randomize();
    set_array_random(pd, n);
    print_array(pd, n);

    size_t n_add;
    printf("kac eleman daha eklenecek: ");
    scanf("%zu", &n_add);

    pd = realloc(pd, (n + n_add) * sizeof(int));
    if(pd == NULL){
        printf("bellek yetersiz\n");
        return(1);
    }
    printf("realloc'un dondurdugu adres: %p \n", pd);

    set_array_random(pd + n, n_add); // Burada 'pd + n' argÃ¼manÄ±ndan dolayÄ± sadece 'realloc' fonksiyonuyla geniÅŸletilen bellek alanÄ±ndaki 'int' deÄŸerleri rastgele deÄŸerlerle dolduruluyor.
    //print_array(pd, n + n_add);

    free(pd);
}
```



â—â—â— `realloc` fonksiyonuyla ilgili olarak Ã¶ÄŸretilen iki Ã¶nemli tÃ¼mce aÅŸaÄŸÄ±daki gibidir;
1. "**Reallocation taken time.**", bu tÃ¼mce bize ÅŸunu sÃ¶yler: `realloc` fonksiyonu iÅŸini yaparken bellek bloÄŸunu bir yerden baÅŸka bir yere taÅŸÄ±rsa, bu iÅŸlemde bÃ¼yÃ¼k bellek bloklarÄ±nÄ±n kopyalanmasÄ± sÄ±rasÄ±nda ciddi bir zamansal maliyeti oluÅŸturacaktÄ±r.
2. "**Reallocation invalid pointer**", bu tÃ¼mce bize ÅŸunu sÃ¶yler: `realloc` fonksiyonu baÅŸarÄ±lÄ± olduÄŸunda bellek bloÄŸunu bir yerden baÅŸka bir yere taÅŸÄ±rsa ve ilgili bellek bloÄŸundaki herhangibir adresi gÃ¶steren gÃ¶stericiler varsa o gÃ¶stericiler **dangling pointer** durumuna dÃ¼ÅŸecektir, bu duruma Ã§ok dikkat edilmelidir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `realloc` fonksiyonu kullanÄ±ldÄ±ktan sonra adresin deÄŸiÅŸip deÄŸiÅŸmediÄŸi incelenebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"
#include <string.h>

int main(void)
{
    size_t n;
    printf("kac elemanli bir dizi olsun: ");
    scanf("%zu", &n);

    int* pd = (int*)malloc(n * sizeof(int));
    if(pd == NULL){
        printf("bellek yetersiz\n");
        return(1);
    }
    int* px = pd;

    randomize();
    set_array_random(pd, n);
    //print_array(pd, n);

    size_t n_add;
    printf("kac eleman daha eklenecek: ");
    scanf("%zu", &n_add);

    pd = realloc(pd, (n + n_add) * sizeof(int));
    if(pd == NULL){
        printf("bellek yetersiz\n");
        return(1);
    }
    
    set_array_random(pd + n, n_add);
    //print_array(px, n + n_add); // Burada 'realloc' fonksiyonu 'pd' gÃ¶stericisinin gÃ¶sterdiÄŸi bellek bloÄŸunu baÅŸka bir yere taÅŸÄ±dÄ±ÄŸÄ±nda 'ub' durumu oluÅŸur, bu nedenle bu ÅŸekilde bir kod yazÄ±lmamalÄ±dÄ±r.
    print_array(pd, n + n_add);

    free(pd);
}
```


>â”
> 
> SorduÄŸum Soru?
> 
> `realloc` fonksiyonu bellek alanÄ±nÄ± kÃ¼Ã§Ã¼ltmek iÃ§in kullanÄ±ldÄ±ÄŸÄ±nda bellek bloÄŸunun adresi hiÃ§bir zaman deÄŸiÅŸtirilmiyor deÄŸil mi, yoksa bu durumda da bellek bloÄŸu deÄŸiÅŸebildiÄŸi durumlar olabiliyor mu(mantÄ±klÄ± olan ilk durum gibi duruyor)?
> 
> Cevap;
> 
> C standardÄ± bu durumda bile bellek konumunun deÄŸiÅŸtirilebileceÄŸini sÃ¶ylÃ¼yor. </br>



â—â—â— `realloc` fonksiyonunun ilk parametresine **NULL pointer** geÃ§ildiÄŸinde `realloc` fonksiyonu `malloc` fonksiyonu gibi davranacaktÄ±r, bu durum **ub**'ye neden olmaz. Mesela `reallock(NULL, n * sizeof(int));` fonksiyon Ã§aÄŸrÄ±sÄ± `malloc(n * sizeof(int));` fonksiyon Ã§aÄŸrÄ±sÄ±na dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmektedir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `realloc` fonksiyonunun ilk parametresine **NULL pointer** argÃ¼man geÃ§ildiÄŸinde bu Ã§aÄŸrÄ±nÄ±n neye denk olduÄŸu gÃ¶rÃ¼lebilir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "nutility.h"

int main(void)
{
    realloc(NULL, 1000); // Buradaki fonksiyon Ã§aÄŸrÄ±sÄ± 'malloc(1000);' ile aynÄ±dÄ±r.
}
```



Ã‡ok iyi bir fikir olmasa da bir dinamik diziyi dÃ¶ngusel bir yapÄ±da dÃ¶ngÃ¼nÃ¼n her turunda 1 eleman daha bÃ¼yÃ¼telim. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda yukarÄ±da aÃ§Ä±klanan cÃ¼mleye uygun yazÄ±lmÄ±ÅŸtÄ±r, her dÃ¶ngÃ¼de bellek bloÄŸu `int` tÃ¼rÃ¼nÃ¼n byte deÄŸeri kadar arttÄ±rÄ±lÄ±yor, bu programÄ±n yazÄ±lma amacÄ± `realloc` fonksiyonunun kullanÄ±mÄ±nÄ± gÃ¶rmektir.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "nutility.h"
#include <conio.h>

int main(void)
{
    int c;
    int ival;
    int* pd = NULL; // 'int' dizisi olarak kullanÄ±lacak olan bellek bloÄŸunun baÅŸlangÄ±Ã§ adresini tutacak gÃ¶sterici deÄŸiÅŸken.
    int cnt = 0;

    while(1){
        printf("tam sayi girecek misin? ");
        while((c = _getch()) != 'e' && c != 'h')
        ; // null statement
        
        printf("%c\n", c);
        if(c == 'h')
            break;
        
        printf("tam sayiyi girin : ");
        ival = rand();
        printf("%d\n", ival);

        pd = (int*)realloc(pd, (cnt + 1) * sizeof(int)); // Her dÃ¶ngÃ¼ turunda bellek bloÄŸu 'int' tÃ¼rÃ¼nÃ¼n byte boyutu kadar arttÄ±rÄ±lÄ±yor.
        if(pd == NULL){
            printf("bellek yetersiz\n");
            return(1);
        }
        pd[cnt++] = ival; // 'pd' bellek bloÄŸunun dÃ¶ngÃ¼nÃ¼n o anki turunda karÅŸÄ±lÄ±k geldiÄŸi elemana girilen deÄŸerdir.
    }

    if(cnt == 0){
        printf("hic giris yapmadiniz.\n ");
        return 0;
    }

    printf("toplam %d sayi girdiniz.\n", cnt);

    print_array(pd, cnt);
    free(pd);
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.16-12.25 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


## Fragmentation 

Dinamik bellek yÃ¶netiminde kullanÄ±lan sisteme baÄŸlÄ± olarak en sÄ±k sorun yaÅŸanÄ±lan ÅŸey **fragmentation**'dÄ±r. </br>
**fragmentation** sÃ¶zcÃ¼ÄŸÃ¼ndeki **fragment** parÃ§a anlamÄ±na gelemktedir ve **fragmentation** sÃ¶zcÃ¼ÄŸÃ¼ de parÃ§alara ayrÄ±lma anlamÄ±na gelmektedir. </br>
`malloc`,`calloc`,`realloc` gibi standart C fonksiyonlarÄ± iÅŸletimin sisteminin sistem fonksiyonlarÄ±nÄ± Ã§aÄŸÄ±rmaktadÄ±r ve bu fonksiyonlar ilgili process iÃ§in ayrÄ±lmÄ±ÅŸ olan bellek bloÄŸune **Heap(C++ dÃ¼nyasÄ±nda Free Store)** olarak adlandÄ±rÄ±lan bellek alanÄ±ndan yer ayÄ±rmaktadÄ±r. </br>
Bir process Ã§alÄ±ÅŸÄ±rken **Heap(C++ dÃ¼nyasÄ±nda Free Store)** alanÄ± dinamik bellek alanÄ± tahsisatÄ± iÅŸlemlerinde her iÅŸlem iÃ§in yekpare bellek kÄ±sÄ±mlarÄ± ayrÄ±ldÄ±ÄŸÄ±ndan dolayÄ± bir sÃ¼re sonra **Heap(C++ dÃ¼nyasÄ±nda Free Store)** alanÄ± parÃ§alÄ± bir yapÄ±ya dÃ¶nÃ¼ÅŸecektir, iÅŸte bellek alanÄ±nÄ±n bÃ¶yle parÃ§alÄ± hale gelmesi sÃ¼recine **fragmentation** deniliyor. </br>


â—â—â— Process yaÅŸam sÃ¼reci boyunca kendisine ayrÄ±lan heap alanÄ±nda process'in Ã¶dÃ¼nÃ§ alacaÄŸÄ± bellek kÄ±sÄ±mlarÄ±, Ã¼zerinde Ã§alÄ±ÅŸÄ±lan iÅŸletim sisteminin sistem Ã§aÄŸrÄ±larÄ± yapÄ±larak ayrÄ±lmaktadÄ±r ve process Ã¶ldÃ¼ÄŸÃ¼nde bu bellek alanlarÄ± iade edilmiÅŸ olmaktadÄ±r Ã§Ã¼nkÃ¼ iÅŸletim sistemi ilgili process Ã¶ldÃ¼ÄŸÃ¼nde kendisine ayrÄ±lmÄ±ÅŸ olan bellek alanÄ±nÄ± boÅŸ olarak iÅŸaretler(Ã¼zerinde iÅŸletim sistemi olmayan iÅŸlemcilerde Ã§alÄ±ÅŸan C programlarÄ±ndaki sÃ¼rece burada deÄŸinilmiyor, bu konuyu artÄ±k Sistem programlamaya baÅŸladÄ±ÄŸÄ±mda detaylÄ±ca Ã¶ÄŸreneceÄŸim).



Processlere ayrÄ±lan **Heap(C++ dÃ¼nyasÄ±nda Free Store)** bellek alanlarÄ±ndan bellek tahsisi yapÄ±ldÄ±ÄŸÄ±nda ne kadarlÄ±k bir bellek bloÄŸunun ayrÄ±ldÄ±ÄŸÄ± bilgisi yine **Heap(C++ dÃ¼nyasÄ±nda Free Store)** alanÄ±nda ama ayrÄ± bir veri yapÄ±sÄ±nda tutulmaktadÄ±r.</br>
Mesela `int* pd = malloc(100 * sizeof(int));` ile ayrÄ±lan bellek bloÄŸu o bellek bloÄŸuyla iÅŸlem bittikten sonra `free(pd);` fonksiyon Ã§aÄŸrÄ±sÄ± ile iade edildiÄŸinde bu fonksiyon Ã§aÄŸrÄ±sÄ±nda sadece bellek bloÄŸunun adresi fonksiyona geÃ§iliyor ama ne kadarlÄ±k bellek bloÄŸunun iade edileceÄŸi o ayrÄ±lan bellek bloÄŸuyla ilgili bilgilerin tutulduÄŸu veriyapÄ±sÄ±ndan anlaÅŸÄ±lmaktadÄ±r. </br>
**Heap(C++ dÃ¼nyasÄ±nda Free Store)** bellek alanÄ±nda sadece ayrÄ±lan bellek alanlarÄ± bulunmaz, ayrÄ±ca hangi adreste ne kadarlÄ±k bellek bloÄŸu ayrÄ±lmÄ±ÅŸ olduÄŸu bilgisi de ayrÄ± bir veri yapÄ±sÄ±nda tutulmaktadÄ±r, buradan **Heap(C++ dÃ¼nyasÄ±nda Free Store)** alanÄ±ndan bellek ayrÄ±ldÄ±ÄŸÄ±nda talep edilen bellek alanÄ±ndan biraz daha fazla bellek alanÄ± ayrÄ±lacaÄŸÄ± gÃ¶rÃ¼lmelidir. </br>
KÄ±saca daha Ã§ok `malloc` Ã§aÄŸrÄ±sÄ± Ã¶dÃ¼nÃ§ alÄ±nan bellek alanÄ±ndan Ã§ok daha fazla bellek alanÄ± harcanmasÄ±na neden olacaktÄ±r, bunu anlamak Ã§ok Ã¶enmlidir(burada daha fazla detaya girilmedi, detaylara girmek iÃ§in Sistem programlama konusuna bakmak gerekiyor).


## Dynamic Arrays(Dinamik diziler) 

Bir programÄ±n kullanacaÄŸÄ± verilerin bellekte hangi veri yapÄ±sÄ±yla tutulduÄŸu o programda kullanÄ±lacak olan algoritmayÄ± etkilemektedir.

ğŸ§­ BazÄ± veri yapÄ±larÄ± aÅŸaÄŸÄ±daki gibidir;
- Trees
    - Binary Tree
    - Binary Heap
- Linked List
    - Single linked list
    - Single  linked list
    - Doubly linked list
- Static Array
- Dynamic Arrac
- Graph



â—â—â— Bir programcÄ±nÄ±n ilk Ã¶nce Ã¶ÄŸrenmesi gereken en Ã§ok kullanÄ±lan(%80 oranÄ±nda kullanÄ±lÄ±yor denilebilir) veri yapÄ±sÄ± olan **dynamic array(dinamik dizi)** veri yapÄ±sÄ±dÄ±r.

C dilinin standart kÃ¼tÃ¼phanesinde **static array** dÄ±ÅŸÄ±nda bir veri yapÄ±sÄ± desteÄŸi yoktur, C++ dilinin standart kÃ¼tÃ¼phenesinde bilinen tÃ¼m veri yapÄ±larÄ± olmasa da bir Ã§oÄŸu bulunmkatadÄ±r(`vector` sÄ±nÄ±fÄ±nda dinamik dizi veri yapÄ±sÄ± bulunmaktadÄ±r).



Bir veriyapÄ±sÄ±ndan en Ã§ok beklenen api'ler eleman ekleme ve silme iÅŸlemleridir.


Ders sonu ...
