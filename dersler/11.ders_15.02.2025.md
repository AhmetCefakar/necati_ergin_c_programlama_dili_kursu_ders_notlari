# 11.Ders 15.02.2025 ğŸ•˜

Derse 22(09:01)-31(09:16)-33(10:08)-32(11:51)-32(12:17)-32(12:45) kiÅŸi katÄ±ldÄ±.

## OperatÃ¶rlerin DetaylÄ± Ä°ncelenmesi Devam

â— OperatÃ¶rler iÅŸlem yapÄ±lmasÄ±nÄ± saÄŸlayan token'lardÄ±r.


### Comparison Operators(KarÅŸÄ±laÅŸtÄ±rma OperatÃ¶rleri)

Toplamda altÄ± tane karÅŸÄ±laÅŸtÄ±rma operatÃ¶rÃ¼ vardÄ±r.
Bu operatÃ¶rler **Binary Infix** Ã¶zelliÄŸindedir yani iki operand alÄ±r ve operand'larÄ±n arasÄ±nda yer alÄ±r.
Bu operatÃ¶rler "**side effect(yan etki)**" oluÅŸturmaz.

ğŸ§­ Comparison Operators
    - Relational Operators
        - `<` `<=` `>` `>=` 
    - Equality Operators
      - `==` `!=`

ğŸ§­ Bu tÃ¼rdeki operatÃ¶rlerin adlarÄ± aÅŸaÄŸÄ±daki gibidir;
- `<` Less than
- `<=` Less or equal

- `>` Greater than
- `>=` Greater or equal 

- `==` Equal (to)
- `!=` Not Equal



â—â—â— **[Dersin en Ã¶nemli bilgilerinden biri]**
C dilinde "**Comparison Operators(KarÅŸÄ±laÅŸtÄ±rma OperatÃ¶rleri)**" ve lojik operatÃ¶rler(`!` `&&` `||`) "**int**" tÃ¼rÃ¼nden deÄŸer Ã¼retirler. 
Yani bu operatÃ¶rler ile oluÅŸturulan bir ifadenin(expression) tÃ¼rÃ¼ "**int**" tÃ¼rÃ¼dÃ¼r.

C dilinin standardÄ±na gÃ¶re doÄŸru/yanlÄ±ÅŸ deÄŸer Ã¼reten operatÃ¶rlerin "**int**" tÃ¼rÃ¼nden deÄŸerleri aÅŸaÄŸÄ±daki gibi yorumlanmaktadÄ±r;
- Ã–nerme doÄŸru ise "1" deÄŸeri kullanÄ±lÄ±r.
- Ã–nerme yanlÄ±ÅŸ ise "0" deÄŸeri kullanÄ±lÄ±r.

C dilinde Ã¼retilen "**int**" deÄŸer(1 ya da 0) bazÄ± idiyomatik yapÄ±larda kullanÄ±lÄ±yor.

C++ dilinde karÅŸÄ±laÅŸtÄ±rma operatÃ¶rlerinin Ã¼rettikleri deÄŸer "**bool**" tÃ¼rÃ¼ndendir bu konuda C dilinden ayrÄ±lmaktadÄ±r.


ğŸ§  IDE ya da editÃ¶r programlarÄ±nÄ±n saÄŸladÄ±ÄŸÄ± hazÄ±r kod parÃ§alarÄ±na verilen ad "**Code Snipped**", "**Code Snipped**" kullanarak hÄ±zlÄ±ca kodlama yapÄ±labiliyor. 



ğŸ‘‡ AÅŸaÄŸÄ±daki program ile "**Comparison Operators(KarÅŸÄ±laÅŸtÄ±rma OperatÃ¶rleri)**" kullanÄ±lan ifadelerin(expression) deÄŸerlerinin ne olacaÄŸÄ± incelenebilir;
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x, y;

    printf("iki tam sayi giriniz: ");
    scanf("%d%d", &x, &y);

    printf("%d < %d = %d", x, y, x < y);
    printf("%d <= %d = %d", x, y, x <= y);
    printf("%d > %d = %d", x, y, x > y);
    printf("%d >= %d = %d", x, y, x >= y);
    printf("%d == %d = %d", x, y, x == y);
    printf("%d != %d = %d", x, y, x != y);
}
```

AÅŸaÄŸÄ±daki karÅŸÄ±laÅŸtÄ±rma ifadelerini derleyicilerin nasÄ±l yorumladÄ±ÄŸÄ± incelenebilir;
- `a * b + c > 0` ifadesi operatÃ¶r Ã¶nceliÄŸinden dolayÄ± derleyici tarafÄ±ndan `((a * b) + c) > 0` ÅŸeklindeymiÅŸ gibi yorumlanacaktÄ±r.
- `x > y == z < t` ifadesi operatÃ¶r Ã¶nceliÄŸinden dolayÄ± derleyici tarafÄ±ndan `(x > y) == (z < t)` ÅŸeklindeymiÅŸ gibi yorumlanacaktÄ±r.


#### KarÅŸÄ±laÅŸtÄ±rma OperatÃ¶rlerinde Tipik hatalar ve Ä°diyomatik yapÄ±lar 

##### Matematiksel Ä°fadelerin Aynen KullanÄ±lmasÄ±ndan Kaynaklanan Hatalar

C dilini yeni Ã¶ÄŸrenmeye baÅŸlayanlarÄ±n tipik yaptÄ±ÄŸÄ± kodlama hatalarÄ±nÄ±n bir kÄ±smÄ± matematiksel notasyon ile benzerlik kurulmaya Ã§alÄ±ÅŸÄ±lmasÄ±dÄ±r. C dilindeki yapÄ±lar matematikteki notasyona bÃ¼yÃ¼k oranda benzer ama tÃ¼mden de benzer deÄŸil.

BazÄ± matematiksel notasyonlarÄ±n C dilinde nasÄ±l yorumlanacaÄŸÄ± incelenebilir;
- Matematikte kullanÄ±lan `ab / xy` ifadesi C dilinde `(((a * b) / x) * y)` ÅŸeklinde yorumlanacaktÄ±r.
- `-b / 2a` ifadesi C dilinde `(((-b) / 2) * a)` ifadesi(expression) olarak yorumlanacaktÄ±r.
- `10 < x < 20` ifadesi C dilinde `((10 < x) < 20)` ifadesi(expression) olarak yorumlanacaktÄ±r ve bu ifadenin sonucu her zaman "1" olarak doÄŸru(true) deÄŸeri olacaktÄ±r, bÃ¶yle bir kod yazÄ±ldÄ±ÄŸÄ±nda kaliteli derleyiciler uyarÄ± iletisi verecektir.



ğŸ§  Matematikteki iÅŸaret fonksiyonu bir sayÄ±nÄ±n iÅŸaretinin ne olduÄŸunu tanÄ±mlar ve "-1, 0, 1" olarak sadece Ã¼Ã§ farklÄ± deÄŸer alabilir, 

ğŸ‘‡ AÅŸaÄŸÄ±daki programda iÅŸaret fonksiyonunun C dilinde nasÄ±l yazÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x;
    
    printf("Bir tam sayi giriniz: ");
    scanf("%d", &x);

    printf("sign(%d) = %d\n", x, (x > 0) - (x < 0)); // Buradaki kullanÄ±m girilen sayÄ±nÄ±n iÅŸaretinin ne olduÄŸunun sonucunu Ã¼retmektedir, yani matematikteki iÅŸaret fonksiyonu denilebilir. 
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program iki farklÄ± ÅŸekilde girdi olarak alÄ±nan dÃ¶rt tam sayÄ±dan kaÃ§ tanesinin pozitif olduÄŸu bilgisini ekrana yazmaktadÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x, y, z, t;
    
    printf("dort tam sayi giriniz: ");
    scanf("%d%d%d%d", &x, &y, &z, &t);
    
    // 1. kullanÄ±m
    int post_count = 0;

    if(x > 0) ++post_count;
    if(y > 0) ++post_count;
    if(z > 0) ++post_count;
    if(t > 0) ++post_count;  


    // 2. kullanÄ±m
    int post_count = (x > 0) + (y > 0) + (z > 0) + (t > 0);

    printf("%d tane positif sayi girildi\n", post_count);
}
```

##### KarÅŸÄ±laÅŸtÄ±rma OperatÃ¶rÃ¼(`==`) Yerine Atama(`=`) OperatÃ¶rÃ¼nÃ¼n KullanÄ±lmasÄ±ndan Kaynaklanan Hatalar

C dilinde aÅŸaÄŸÄ±daki iki operatÃ¶r yanlÄ±ÅŸlÄ±kla birbiri yerine kullanÄ±ldÄ±ÄŸÄ±nda Ã§oÄŸu durumda **sÃ¶zdizim hatasÄ±(syntax error)** oluÅŸmuyor.
- `a = b` buradaki operatÃ¶r "**assignment**" operatÃ¶rÃ¼dÃ¼r.
- `a == b` buradaki operatÃ¶r "**equal to**" operatÃ¶rÃ¼dÃ¼r.


ğŸ‘‡ AÅŸaÄŸÄ±daki program 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x;
    
    printf("Bir tam sayi giriniz: ");
    scanf("%d", &x);

    if(x = 5) // Always true. Burada '==' yerine yanlÄ±ÅŸlÄ±kla '=' yazÄ±lmÄ±ÅŸtÄ±r.
        printf("Evet doÄŸru\n");
    else
        printf("Evet doÄŸru\n");
}
```


â— C dilinde tÃ¼rÃ¼ void olan ifadelerin dÄ±ÅŸÄ±nda tÃ¼m ifadelerin bir deÄŸeri vardÄ±r.

â— C ve C++ dillerinde atama operatÃ¶rleriyle oluÅŸturulan ifadelerin deÄŸeri nesneye atanan deÄŸerdir, `x = 7` bu ifadenin(expression) deÄŸeri "7" olmaktadÄ±r.


â— C dilinde kodlama yapan Ã§oÄŸu programcÄ± `==` operatÃ¶rÃ¼ kullanÄ±lÄ±rken `x == 5` yerine `5 == x` ifadesini tercih ediyor Ã§Ã¼nkÃ¼ `==` operatÃ¶rÃ¼ yerine `=` operatÃ¶rÃ¼nÃ¼ kullanmaktan kaynaklÄ± bir hatayÄ± Ã¶nlemek iÃ§in. Bu C dilinde "**idiomatic**" bir kullanÄ±mdÄ±r.

â—C dilinde "**x = y == z**" ÅŸeklindeki expression idiomatic bir yapÄ±dÄ±r ve "x = (x == z)" expression ile aynÄ± anlama gelmektedir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda kullanÄ±lan `x = y == z` ifadesi(expression) C dilinde bir idiom olarak kullanÄ±lmaktadÄ±r, tek satÄ±rsa dÃ¶rt satÄ±rda yazÄ±lacak "if-else statement" yerine kullanÄ±labiliyor. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x, y, z;
    
    // 1. kullanÄ±m
    x = y == z; // Bu ifade 'x = (y == z);' ile aynÄ± yorumlanacaktÄ±r ve buradaki kullanÄ±m bir idiomatic kullanÄ±mdÄ±r ve aÅŸaÄŸÄ±daki 'if statement' ile aynÄ± anlama gelmektedir.

    // 2. kullanÄ±m
    if(y == z) 
        x = 1;
    else
        x = 0;
}
```

##### OndalÄ±klÄ± SayÄ±larÄ±n KarÅŸÄ±laÅŸtÄ±rÄ±lmasÄ± Ä°ÅŸlemlerinde EÅŸittir OperatÃ¶rÃ¼ Ä°le KarÅŸÄ±laÅŸtÄ±rÄ±lmasÄ±ndan Kaynaklanan Hatalar 


C dilinde kodlama yaparken karÅŸÄ±laÅŸtÄ±rma operatÃ¶rlerini **kayan noktalÄ± sayÄ±larla** birlikte oluÅŸturulan ifadelerde oluÅŸabilecek veri kayÄ±plarÄ±na dikkat edilmesi gerekiyor. 

**Kayan noktalÄ± sayÄ±lar** `==` operatÃ¶rÃ¼ ile karÅŸÄ±laÅŸtÄ±rÄ±lÄ±rsa bu karÅŸÄ±laÅŸtÄ±rma sayÄ±larÄ±n tÃ¼m bitlerinin eÅŸit olmasÄ± durumunda doÄŸru olacaktÄ±r ama **kayan noktalÄ± sayÄ±larlar** virgÃ¼lden sÄ±nraki kÄ±sÄ±mlarÄ± herhangi bir deÄŸerde olabilir ve derleyici karÅŸÄ±laÅŸtÄ±rmayÄ± bit bit yapacaÄŸÄ± iÃ§in bÃ¶yle bir karÅŸÄ±laÅŸtÄ±rma istenilen bir karÅŸÄ±laÅŸtÄ±rma olmayacaktÄ±r.

AÅŸaÄŸÄ±daki ufak programlarda yukarÄ±daki durum gÃ¶rÃ¼lebilir, **kayan noktalÄ± sayÄ±larda** virgÃ¼lden sonraki kÄ±sma **mantissa** adÄ± verilmektedir.



C mÃ¼lakatlarÄ±nda sÄ±kÃ§a sorulan bir soru: On tane "0.1" sayÄ±sÄ± toplanÄ±rsa sonucun nasÄ±l olacaÄŸÄ± sorulmaktadÄ±r. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki **kayan noktalÄ± sayÄ±lar** ile yapÄ±lan toplama iÅŸleminin sonucunu yazÄ±lÄ±mda kullanÄ±lan **kayan noktalÄ± sayÄ±** gÃ¶steriminin hangi standarda gÃ¶re yapÄ±ldÄ±ÄŸÄ± etkilemektedir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    double d = 0.;

    for(int i = 0; i < 10; ++i){
        d += 0.1;
        printf("%d. step, d = %f\n", i, d);
    }    
    
    if(d == 1.)
        printf("evet tabi ki dogru\n");
    else
        printf("hayÄ±r tabi ki yanlis\n");

    return 0;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **kayan noktalÄ± sayÄ±** karÅŸÄ±laÅŸtÄ±rmasÄ±nÄ±n nasÄ±l gÃ¼venliksiz ÅŸekilde yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    double d = 0.5;

    if(d == .5)
        printf("evet tabi ki dogru\n");
    else
        printf("hayÄ±r tabi ki yanlis\n");

    return 0;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **kayan noktalÄ± sayÄ±** karÅŸÄ±laÅŸtÄ±rmasÄ±nÄ±n nasÄ±l gÃ¼venliksiz ÅŸekilde yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    double d = 1.; 	

    d /= 2;

    if(d == .5)
        printf("evet tabi ki dogr\n");
    else
        printf("hayÄ±r tabi ki yanlis\n");

    return 0;
}
```


â—â—â— Peki o zaman **kayan noktalÄ± sayÄ±larda** karÅŸÄ±laÅŸtÄ±rma iÅŸlemlerinin nasÄ±l yapÄ±lacaÄŸÄ± sorulacaktÄ±r, bu sayÄ±larda karÅŸÄ±laÅŸtÄ±rma yerine bir **epsilon** deÄŸer belirlenmesi ve sayÄ± ile eÅŸitlik karÅŸÄ±laÅŸtÄ±rmasÄ± yapÄ±lacak deÄŸerin farkÄ±nÄ±n mutlak deÄŸer deÄŸerinin belirlenen **epsilon** deÄŸeriden bÃ¼yÃ¼klÃ¼k ve kÃ¼Ã§Ã¼klÃ¼k durumuna bakÄ±lmalÄ±dÄ±r.


## Maximal Munch(En BÃ¼yÃ¼k Lokma) 

"**Maximal Munch(En BÃ¼yÃ¼k Lokma)**" kuralÄ±, derleyicilerin tokenizing aÅŸamasÄ±nda token'larÄ± belirlerken kullandÄ±ÄŸÄ± yÃ¶nteme verilen addÄ±r.
**Maximal Munch** kuralÄ±na C, C++, C#, Java vb. bir Ã§ok dilde aynÄ±dÄ±r.
**Maximal Munch** kuralÄ±na gÃ¶re tokenizing aÅŸamasÄ±nda token'lar belirlenirken soldan baÅŸlayarak en Ã§ok karakterden oluÅŸan token'lar belirlenecek ÅŸekilde Ã§alÄ±ÅŸÄ±r.
Tokenizing aÅŸamasÄ±nda koddaki token'lar belirlenirken boÅŸluk karakterleri doÄŸal bir ayÄ±rÄ±cÄ± olarak iÅŸlem gÃ¶rÃ¼r.
Tokenizing iÅŸlemi **sÃ¶zdizim(syntax)** kontrolÃ¼ iÅŸleminden Ã¶nce yapÄ±lÄ±yor ve bu iki iÅŸlem birbirinden farklÄ±dÄ±r.

`int z = x+++y;` bu kod satÄ±rÄ±ndaki statement bÃ¼nyesindeki `int z = x+++y` ifadesi(expression) **maximal munch** kuralÄ±na gÃ¶re aÅŸaÄŸÄ±daki gibi token'larÄ±na ayrÄ±lacaktÄ±r;</br>
`int`</br>
`z`</br>
`=`</br>
`x`</br>
`++`</br>
`+`</br>
`y`<br>
`;`<br>

ğŸ‘† YukarÄ±da gÃ¶rÃ¼ndÃ¼ÄŸÃ¼ gibi toplamda sekiz farklÄ± token tespit edilecektir. `int z = x+++y` ifadesi(expression) ve `int z = x++ + y` expression birbirine denktir.

`sum>>=++x` ifadesi(expression) aÅŸaÄŸÄ±daki gibi tokenize edilecektir.</br>
`sum`</br>
`>>=`</br>
`++`</br>
`x`</br>


âš¡ IDE programlarÄ± ya da Code Editor programlarÄ± herhangi bir programlama diliyle kod yazarken "**Maximal Munch(En BÃ¼yÃ¼k Lokma)**" kuralÄ±na gÃ¶re kodlarÄ± dÃ¼zenlediÄŸi farkedilecektir.


ğŸ‘‡ AÅŸaÄŸÄ±daki program Ã¼zerinden `int z = x+++y` ifadesinin Ã§alÄ±ÅŸmasÄ± sonucunda oluÅŸacak Ã§Ä±ktÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 5;
    int y = 8;

    int z = x+++y; // Buradaki kullanÄ±m 'ub' deÄŸildir ama ilk baÅŸta aÅŸaÄŸÄ±daki gibi iki farklÄ± ÅŸekilde yorumlanacaÄŸÄ± dÃ¼ÅŸÃ¼nÃ¼lebilir fakat 'Maximal Munch' kuralÄ±na gÃ¶re '1. ihtimal' Ã§alÄ±ÅŸacaktÄ±r.
    // int z = x++ + y; // 1. ihtimal
    // int z = x + ++y; // 2. ihtimal

    printf("x = %d\n", x); // 6 yazar
    printf("y = %d\n", y); // 8 yazar
    printf("z = %d\n", z); // 13 yazar
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki program arada boÅŸluk bÄ±rakÄ±lmasÄ± gereken bir yerde boÅŸluk kullanÄ±lmadÄ±ÄŸÄ±nda nasÄ±l **sÃ¶zdizim hatasÄ±(syntax error)** oluÅŸabiliyor bununla ilgilidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 10;
    int y = 20;
    int *ptr =  &x; 
    
    int z = y / *ptr; // Buradaki kod satÄ±rÄ± sÃ¶zdizim(syntax) kurallarÄ±na uygundur.
    int z = y /*ptr; // Burada sÃ¶zdizim hatasÄ±(syntax error) vardÄ±r. '/*' bir token'dÄ±r ve '/*ptr' ile '/ *ptr' birbirinden farklÄ±dÄ±r, IDE kullanÄ±lÄ±yorsa ide altÄ±nÄ± Ã§izecektir.
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.35-10.56 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***

## OperatÃ¶rlerin DetaylÄ± Ä°ncelenmesi Devam

### Logical Operators(MantÄ±ksal OperatÃ¶rler)

Lojik operatÃ¶rleri anlamak iÃ§in ilk Ã¶nce lojik ifadeleri anlamak gerekiyor.

AÅŸaÄŸÄ±daki gibi Ã¼Ã§ farklÄ± Lojik operatÃ¶r vardÄ±r;
- **`!`(unary)** Logical not(Lojik deÄŸil)
- **`&&`(binary)** Logical and(Lojik ve)
- **`||`(binary)** Logical or(Lojik veya)


C dilinin standardÄ±nda **logic exor** operatÃ¶rÃ¼ yoktur.


ğŸ§­ Matematiksel olarak mantÄ±ksal durumlar aÅŸaÄŸÄ±daki ÅŸekilde gÃ¶sterilmektedir;

| Ã–nerme(p) |         |        |
|:---------:|:-------:|:------:|
| Ã–nerme(p) |  doÄŸru  | yanlÄ±ÅŸ |
| DeÄŸil p   |  YanlÄ±ÅŸ | DoÄŸru  |


|p          |q        |p ve q  |
|:---------:|:-------:|:------:|
|D          |D        |D       |
|D          |Y        |Y       |
|Y          |D        |Y       |
|Y          |Y        |Y       |


| p         | q        |p veya q  |
|:---------:|:--------:|:--------:|
| D         | D        | D        |
| D         | Y        | D        |
| Y         | D        | D        |
| Y         | Y        | Y        |


| p         | q       | p Ã¶zel veya(exclusive or - exor) q |
|:---------:|:-------:|:----------------------------------:|
| D         | D       | Y                                  |
| D         | Y       | D                                  |
| Y         | D       | D                                  |
| Y         | Y       | Y                                  |


âš ï¸ C dilinde lojik operatÃ¶rlerin operandlarÄ± herhangi bir tÃ¼rden olabilir(hatta pointer tÃ¼rÃ¼nden bile olabiliyor).

â—â—â— C dilinde sadece Ã¼Ã§ tane lojik operatÃ¶r(`!`, `&&`, `||`) iÃ§in deÄŸil aÅŸaÄŸÄ±daki listedeki bÃ¼tÃ¼n yerlerde aslÄ±nda lojik bir deÄŸer beklenir fakat dilin kurallarÄ±na gÃ¶re bu yerlerde herhangi bir tÃ¼rden ifade kullanÄ±labilir. 
BÃ¶yle durumlarda lojik yorumlama(ya da lojik dÃ¶nÃ¼ÅŸÃ¼m) yapÄ±lÄ±r. 
- SÄ±fÄ±rdan farklÄ± tÃ¼m deÄŸerler **doÄŸru(true)** olarak yorumlanÄ±r. "**All non-zero values true**" cÃ¼mlesini iyi bilinmesi Ã¶nemlidir.
- Sadece "0" deÄŸeri "**yanlÄ±ÅŸ(false)**" olarak yorumlanÄ±r. **Only 0 value false** cÃ¼mlesini iyi bilinmesi Ã¶nemlidir.

1. All non-zero values true(0 harici tÃ¼m deÄŸerler doÄŸru olarak deÄŸerlendirilir)
2. 0 value false(0 deÄŸeri yanlÄ±ÅŸ olarak deÄŸerlendirilir)

AÅŸaÄŸÄ±daki listede "exp" yazan her yerde logic yorumlama yapÄ±lmaktadÄ±r yani **Zero/Non-zero** mantÄ±ksal durumlarÄ± mevcuttur;
- `!exp`
- `exp1 && exp2 `
- `exp1 || exp2`
- `exp ? opt1 : opt2;`
- `if(exp)`
- `while(exp)`
- `do {...} while(exp);`
- `for(;exp;)`


â— C dilinde **Comparison Operators(KarÅŸÄ±laÅŸtÄ±rma OperatÃ¶rleri)** ve lojik operatÃ¶rler(`!` `&&` `||`) "int" tÃ¼rÃ¼nden deÄŸer Ã¼retirler.

â— Bir C mÃ¼lakatÄ±nda `x && y`, `!expr` ÅŸeklindeki **ifadelerin(expression)** deÄŸerleri sorulursa cevabÄ±n "int" tÃ¼rÃ¼ olacaÄŸÄ± bilinmelidir, cÃ¼nkÃ¼ C dilinin tarihsel geliÅŸiminden dolayÄ± locig ifadelerin tÃ¼rleri "int" tÃ¼rÃ¼dÃ¼r ve "zero/non-zero" olarak "true/false" deÄŸerleri iÅŸlenir.


#### `!` Operator 

Bu operatÃ¶r "**unary**", "**unary prefix**", "**has no side effect**" Ã¶zelliktedir. 

OperatÃ¶r Ã¶ncelik tablosunun 2. Ã¶ncelik seviyesindeki tÃ¼m operatÃ¶rler "**unary**" yani tek operand alan operatÃ¶rlerdir ve `!` operatÃ¶rÃ¼ bu seviyededir.

`!exp` ÅŸeklinde kullanÄ±lÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki program bir tam sayÄ± deÄŸiÅŸkenin "logical not" operatÃ¶rÃ¼nÃ¼ almasÄ± durumunda nasÄ±l bir deÄŸer alacaÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 10;
    
    prindf("bir tam sayÄ± giriniz: ");
    scanf("%d", &x);
    
    prindf("!%d = %d\n", x, !x);
}
```



â— Bir ifadenin(expression) deÄŸilinin deÄŸili(`!!expr` ÅŸeklinde bir ifade) ya "0" ya da "1" deÄŸer alÄ±r.

â— `int y = 2343; int value = !!y;` bu kÄ±sa kod parÃ§asÄ± Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda "value" deÄŸiÅŸkenine "1" deÄŸeri atanacaktÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki program bir int deÄŸiÅŸkenin deÄŸilinin deÄŸili alÄ±ndÄ±ÄŸÄ±nda nasÄ±l bir deÄŸer Ã¼retildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 10;
    
    prindf("bir tam sayÄ± giriniz: ");
    scanf("%d", &x);
    
    prindf("!!%d = %d\n", x, !!x);
}
```

C dilinde logic **xor** operatÃ¶rÃ¼ yoktur ama aÅŸaÄŸÄ±daki programda olduÄŸu gibi kendimiz de bu operatÃ¶rÃ¼n gÃ¶revini Ã¼stlenecek kodlama yapabiliriz. 



ğŸ‘‡ AÅŸaÄŸÄ±daki program C dilinde olmayan **xor** operatÃ¶rÃ¼nÃ¼n en kolay ÅŸekilde nasÄ±l yazÄ±labileceÄŸini gÃ¶stermektedir, C mÃ¼lakatlarÄ±nda **xor** operatÃ¶rÃ¼nÃ¼n yaptÄ±ÄŸÄ± iÃ§i yapan bir ifadenin nasÄ±l yazÄ±labileceÄŸi soruluyormuÅŸ.
```C
#include <stdio.h>

int main(void)
{
    int x, y;

    printf("Ä°ki tam sayÄ± giriniz:");
    scanf("%d%d", &x, &y);
    
    printf("%d xor %d = %d", x, y, !!x != !!y); // Bu kullanÄ±m ile C dilinde olmayan 'xor' operatÃ¶rÃ¼ gibi Ã§alÄ±ÅŸacak mantÄ±ksal yapÄ± kurgulanmÄ±ÅŸ olur.
}
```

ğŸ§  `!!x != !!y` ÅŸeklinde bir ifade, **xor** operatÃ¶rÃ¼nÃ¼n yaptÄ±ÄŸÄ± iÅŸi yapacaktÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki program incelenerek `!` operatÃ¶rÃ¼nÃ¼n kullanÄ±mÄ±yla ilgili bilgi edinilebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = -1;
    int y = 0;

    // !(++x) olarak yorumlanÄ±r ve buradaki ifadenin deÄŸeri en son '1' olur.
    if(!++x) 
        print("doÄŸru-1");

    if(!x++)
        print("doÄŸru-2");

    if(!++x && !y--) 
        print("doÄŸru-3");
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki program incelenerek `!` operatÃ¶rÃ¼nÃ¼n **side-effect** Ã¶zelliÄŸinin olmadÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 0;

    int y = !x;

    print("x = %d\n", x); // Konsola 'x = 0' yazacaktÄ±r.
}
```


#### `&&` `||` Operands 

Bu operatÃ¶r "**binary**", "**binary infix**", "**has no side effect**" Ã¶zelliktedir.

`exp1 && exp2` ÅŸeklinde kullanÄ±lÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki program ile **mantÄ±ksal ve(logical and)** operatÃ¶rÃ¼nÃ¼n girilen deÄŸerlere gÃ¶re hangi sonucu Ã¼retiÄŸi incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x, y;

    printf("iki tam sayÄ± giriniz:");
    scanf("%d%d", &x, &y);
    
    printf("%d && %d = %d", x, y, x && y);
}
```


âš ï¸ C dilinde yazÄ±lan porgramlarda **&&(logical and)** operatÃ¶rÃ¼nÃ¼n yerine **&(bitwise and)** operatÃ¶rÃ¼nÃ¼n kullanÄ±ldÄ±ÄŸÄ± hatalÄ± durumlarla karÅŸÄ±laÅŸÄ±lmaktadÄ±r, bu tÃ¼r hatalara dikkat edilmelidir.



ğŸ‘‡ AÅŸaÄŸÄ±daki program ile **&&(logical and)** ve **&(bitwise and)** operatÃ¶rlerinin girilen deÄŸerlere gÃ¶re hangi sonucu Ã¼retiÄŸi incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x, y;

    printf("Ä°ki tam sayÄ± giriniz:");
    scanf("%d%d", &x, &y);

    if(x && y)
        printf("doÄŸru-1\n");  
    else
        printf("yanlis-1\n");

    if(x & y)
        printf("doÄŸru-2\n");  
    else
        printf("yanlis-2\n");
}
```


ğŸ§­ AÅŸaÄŸÄ±daki bilgiler Ã¶nemlidir;
- C dilinde **&&(logical and)** ve **&(bitwise and)** operatÃ¶rleri vardÄ±r ve bu operatÃ¶rler birbirinden farklÄ±dÄ±r. 
- C dilinde yapÄ±lan kodlamalarda `&&` yerine `&` kullanÄ±lmasÄ±ndan dolayÄ± oluÅŸan hatalarÄ±n tespiti Ã§ok zordur bu nedenle kodlamada dikkat edilmelidir.
- C dilinde **||(logical or)** ve **|(bitwise or)** operatÃ¶rleri vardÄ±r ve bu operatÃ¶rler birbirinden farklÄ±dÄ±r. 
- C dilinde yapÄ±lan kodlamalarda `||` yerine `|` kullanÄ±lmasÄ±ndan dolayÄ± oluÅŸan hatalarÄ±n tespiti Ã§ok zordur bu nedenle kodlamada dikkat edilmelidir.

ğŸ§­ Bitwise operatÃ¶rlerinin Ã§alÄ±ÅŸma mantÄ±ÄŸÄ± aÅŸaÄŸÄ±daki gibidir;
- **&(bitwise and)** operatÃ¶rÃ¼ karÅŸÄ±laÅŸtÄ±rÄ±lan deÄŸerlerin bitlerinin tamamÄ±nÄ± **ve(and)** iÅŸlemine tabi tutar.
- **|(bitwise or)** operatÃ¶rÃ¼ karÅŸÄ±laÅŸtÄ±rÄ±lan deÄŸerlerin bitlerinin tamamÄ±nÄ± **veya(or)** iÅŸlemine tabi tutar.
- **&(bitwise and)** ve **|(bitwise or)** operatÃ¶rleri kursun son Ã§eyreÄŸinde iÅŸlenecek konulardÄ±r. 

ğŸ§  C++ dilinde `&&` iÃ§in `and` ve `||` iÃ§in `or`, `&` iÃ§in `bitand` ve `|` iÃ§in `bitor` operatÃ¶rleri vardÄ±r, bu metinsel operatÃ¶rler yanlÄ±ÅŸ kodlama yapÄ±lmamasÄ± iÃ§in dile eklenmiÅŸtir.



ğŸ‘‡ AÅŸaÄŸÄ±daki program ile **mantÄ±ksal ve(logical or)** operatÃ¶rÃ¼nÃ¼n girilen deÄŸerlere gÃ¶re hangi sonucu Ã¼retildiÄŸi incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x, y;

    printf("iki tam sayÄ± giriniz:");
    scanf("%d%d", &x, &y);
    
    printf("%d || %d = %d", x, y, x || y);
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki program ile **||(logical or)** ve **|(bitwise or)** operatÃ¶rlerinin girilen deÄŸerlere gÃ¶re hangi sonucu Ã¼retildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x, y;

    printf("Ä°ki tam sayÄ± giriniz:");
    scanf("%d%d", &x, &y);

    if(x || y)
        printf("doÄŸru-1\n");  
    else
        printf("yanlis-1\n");

    if(x | y)
        printf("doÄŸru-2\n");  
    else
        printf("yanlis-2\n");
}
```



âš ï¸ Lojik ve operatÃ¶rÃ¼nÃ¼n kullanÄ±lmasÄ± gereken yerde bazen yanlÄ±ÅŸlÄ±kla lojik veya kullanÄ±ldÄ±ÄŸÄ± olmaktadÄ±r, bu hataya dikkat etmek gerekiyor, bunun nedeni muhtemelen konuÅŸma diliyle programlama dilindeki farklÄ±lÄ±ktÄ±r.
- ProgramlamayÄ± yeni Ã¶ÄŸrenmeye baÅŸlayanlar `if(x != 3 || x != 17)` bu **if statement(if deyimi)**'Ä± metinsel olarak "**x Ã¼Ã§e ya da on yediye eÅŸit deÄŸilse**" ÅŸeklinde yorumlama eÄŸilimindedir.
- Bu `if(x != 3 || x != 17)` **if statement(if deyimi)** detaylÄ± incelendiÄŸine her zaman "**doÄŸru(1)**" olacaÄŸÄ± gÃ¶rÃ¼lecektir, buradaki kod aslÄ±nda `if(x != 3 && x != 17)` ÅŸeklinde kullanÄ±lmak istendiÄŸi gÃ¶rÃ¼lmelidir.


â— Matematikte Bool Cebri konusunda yer alan **de morgan** kurallarÄ± programlamaya da uygulanabilir ve sonucu **true(non-zero)** olan bir ifadeyi(expression) false(0) olarak yorumlanabilecek ÅŸekilde deÄŸiÅŸtirilebilir, tam tersi de geÃ§erlidir.
- `!(x && y)` ifadesi(expression) `!x || !y` ifadesine(expression) denktir.
- `!(x || y)` ifadesi(expression) `!x && !y` ifadesine(expression) denktir.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.06-12.15 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


**De morgan** kuralÄ± uygulaan bazÄ± ifadeler aÅŸaÄŸÄ±daki gibidir;
- `if(x != 3 || x != 17)` **if statement(if deyimi)** her zaman doÄŸrudur(always true), burada **de morgan** uygularsak sÄ±rasÄ±yla aÅŸaÄŸÄ±daki adÄ±mlarÄ± izleyince her zaman yanlÄ±ÅŸ(always false) elde ederiz;
- `if(!(x != 3 || x != 17))` **if statement** iÃ§indeki ifadenin(expression) deÄŸili alÄ±nmÄ±ÅŸ hali, aÅŸaÄŸÄ±da bu deÄŸil iÅŸleminin uygulandÄ±ÄŸÄ±nda nasÄ±l bir ifade elde edildiÄŸi gÃ¶rÃ¼lebilir
- Bu `if(x == 3 && x == 17)` **if statement** ÅŸu `if(x != 3 || x != 17)` **if statement(if deyimi)**'Ä±n deÄŸil uygulanmÄ±ÅŸ halidir.
- `a > b` ifadesinin(expression) deÄŸili `a <= b` ve `a < b` ifadesinin(expression) deÄŸili `a >= b` ÅŸeklinde olacaktÄ±r, bu dÃ¶nÃ¼ÅŸÃ¼mlerde de sÄ±k hata yapÄ±lÄ±yormuÅŸ.



**Equality(EÅŸitlik) ve Equivalence(EÅŸdeÄŸerlik)**: Buradaki **Equivalence(EÅŸdeÄŸerlik)** terimi Ã¶nemli bu terim eÅŸitlik karÅŸÄ±laÅŸtÄ±rmasÄ±nÄ±n `==` operatÃ¶rÃ¼ kullanÄ±lmadan baÅŸka operatÃ¶rler kullanÄ±larak yapÄ±ldÄ±ÄŸÄ± durumu ifade etmek iÃ§in kullanÄ±lÄ±yor.



ğŸ‘‡ AÅŸaÄŸÄ±daki program ile sadece `<` operatÃ¶rÃ¼ ve **logical operators** kullanarak diÄŸer **Comparison Operators(`>` `>=` `<` `<=` `==` `!=`)** nasÄ±l yazÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x, y;

    printf("Ä°ki tam sayÄ± giriniz:");
    scanf("%d%d", &x, &y);

    // De-morgan kuralÄ±yla 
    printf("%d < %d = %d\n", x, y, x < y);
    printf("%d > %d = %d\n", x, y, y < x);
    printf("%d >= %d = %d\n", x, y, !(x < y));
    printf("%d <= %d = %d\n", x, y, !(y < x));
    printf("%d == %d = %d\n", x, y, !(x < y) && !(y < x)); // Buradaki iÅŸlem 'equivalence(eÅŸdeÄŸerlik)' olarak adlandÄ±rÄ±lÄ±r.
    printf("%d != %d = %d\n", x, y, (x < y) || (y < x));
}
```


## Short Circuit Behavior(KÄ±sa devre davranÄ±ÅŸÄ±)  


â— C ve C++ dillerinde "**Short circuit behavior(KÄ±sa devre davranÄ±ÅŸÄ±)**" davranÄ±ÅŸÄ± sÄ±kÃ§a kullanÄ±lmaktadÄ±r ve iyi anlaÅŸÄ±lmÄ±ÅŸ olmasÄ± gerekiyor.

â— AyrÄ±ca C dilinde bir Ã§ok **idiomatic** kullanÄ±mda **Short circuit behavior** kullanÄ±ldÄ±ÄŸÄ± iÃ§in Ã§ok iyi bilinmek zorundadÄ±r. Bu Ã¶zellik C#/Java gibi dillerde de mevcuttur.


â— `&&` ve `||` operatÃ¶rlerinin diÄŸer operatÃ¶rlerden Ã¶nemli bir farkÄ± olan "**Short circuit behavior(KÄ±sa devre davranÄ±ÅŸÄ±)**" davranÄ±ÅŸÄ± vardÄ±r, bu davranÄ±ÅŸta iÅŸleme giren operandlardan ilk Ã¶nce sol tarafta kalanÄ± yapÄ±lÄ±r ve oluÅŸan sonuca gÃ¶re saÄŸ tarafta baÅŸka kodlar varsa bu kodlarÄ±n Ã§alÄ±ÅŸtÄ±rÄ±lÄ±p Ã§alÄ±ÅŸtÄ±rÄ±lmayacaÄŸÄ±na kara verilir. 

â— "**Short circuit behavior(KÄ±sa devre davranÄ±ÅŸÄ±)**" Ã¶zelliÄŸi C dilinin standardÄ±nÄ±n bir kuralÄ±dÄ±r, yani tÃ¼m C derleyicileri bu kuralÄ± uygulamaktadÄ±r.

â— `&&` ve `||` operatÃ¶rlerinin "**Short circuit behavior(KÄ±sa devre davranÄ±ÅŸÄ±)**" davranÄ±ÅŸÄ± vardÄ±r fakat `&` ve `|` operatÃ¶rlerinin "**Short circuit behavior(KÄ±sa devre kuralÄ±)**" davranÄ±ÅŸÄ± yoktur!


ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**Short circuit behavior(KÄ±sa devre kuralÄ±)**" davranÄ±ÅŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 0;
    int y = 5;
    int z;
    
    z = x && ++y; // Bu satÄ±rda 'Short circuit behavior' vardÄ±r, '++y' kodu Ã§alÄ±ÅŸmayacaktÄ±r.

    printf("z = %d", z); // 'z = 0' yazar
    printf("y = %d", y); // 'y = 5' yazar
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki 1. ve 2. durumdaki kodlarÄ±n davranÄ±ÅŸlarÄ± aynÄ±dÄ±r ve 2. durumdaki kodda "**Short circuit behavior(KÄ±sa devre kuralÄ±)**" davranÄ±ÅŸÄ± vardÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    // 1. kullanÄ±m
    if(x > 5)
        if(y < 3)
        ++a;
    
    // 2. kullanÄ±m
    if(x > 5 && y < 3)
        ++a;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda fonksiyon Ã§aÄŸrÄ±larÄ±nda "**Short circuit behavior(KÄ±sa devre kuralÄ±)**" nasÄ±l Ã§alÄ±ÅŸÄ±yor incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdio.h>

int foo(void)
{
    printf("foo called!\n");
    return 1;
}

int bar(void)
{
    printf("bar called!\n");
    return 1;
}

int main(void)
{
    printf("foo() && bar(); = %d\n", foo() && bar());

    printf("\n~~~~~~~~~~~~~~~~\n");

    printf("!foo() && bar(); = %d\n", !foo() && bar());

    printf("\n~~~~~~~~~~~~~~~~\n");

    printf("foo() || bar(); = %d\n", foo() || bar());

    printf("\n~~~~~~~~~~~~~~~~\n");

    printf("!foo() || bar(); = %d\n", !foo() || bar());

    return 0;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**Short circuit behavior(KÄ±sa devre kuralÄ±)**" davranÄ±ÅŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 0;
    int y = 9;
    
    x && (y = 674); // Bu satÄ±rda 'Short circuit behavior' vardÄ±r, '(y = 674)' kodu Ã§alÄ±ÅŸmayacaktÄ±r.

    printf("x = %d", x); // 'x = 0' yazar
    printf("y = %d", y); // 'y = 9' yazar
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda en basit idiomlardan birinin kullanÄ±mÄ± incelenebilir. Bu programda **linear search** algoritmasÄ±na gÃ¶re bir dizide bir elemanÄ±n olup olmadÄ±ÄŸÄ± durumu incelenmektedir.
- 1. ve 2. kullanÄ±mlar aynÄ± sonucu Ã¼retecektir fakar 2. kullanÄ±m C dilinde idiomatic yapÄ±dasÄ±r ve profestonel bir C programcÄ±sÄ± 2. kullanÄ±mÄ± terciheder.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int ary[100];
    int key = 7;
    
    // linear search
    int i;

    // 1. kullanÄ±m
    for(i = 0;i < 100; ++i)
        if(ary[i] == key)
        break;

    // 2. kullanÄ±m, burada 'Short circuit behavior' kuralÄ±ndan fayfalanÄ±lÄ±yor
    for(i = 0; i < 100 && ary[i] != key; ++i)
    ;

    if(i < 100)
        printf("evet bulundu, index = %d\n", i);
    else
        printf("hayir bulunamadi");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **short circuit behavior(kÄ±sa devre davranÄ±ÅŸÄ±)** incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int* ptr;

    // some code here...

    // AÅŸaÄŸÄ±daki if statement koÅŸuÅŸunda '&&' operatÃ¶rÃ¼ ile 'kÄ±sa devre davranÄ±ÅŸÄ±' uygulanmaktadÄ±r, burada 'ptr' gÃ¶stericisi 'NULL pointer' olduÄŸunda ikinci kaÅŸul Ã§alÄ±ÅŸmayacaktÄ±r.
    if(ptr != NULL && *ptr > 10){
        // some code here...
    }
}
```



â” AÅŸaÄŸÄ±daki program programlama dili ne olursa olsun mÃ¼lakatlarda sorulan Ã§ok temel bir soru olan "Girilen Ã¼Ã§ sayÄ±dan ortancasÄ±nÄ± bulan programÄ± yazÄ±nÄ±z." sorusudur;
- ğŸ‘‡ AÅŸaÄŸÄ±daki program girilen Ã¼Ã§ sayÄ±nÄ±n ortancasÄ±nÄ± bulmak zor olabileceÄŸi iÃ§in tek tek sayÄ±larÄ±n en bÃ¼yÃ¼k ya da en kÃ¼Ã§Ã¼k sayÄ± olma durumlarÄ± iÃ§in kural yazÄ±p bunun deÄŸilini(de morgan) aldÄ±ÄŸÄ±mÄ±zda o yazÄ±nÄ±n ortanca olma durumunu tespit ederiz. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

// Kendisine argÃ¼man olarak verilen sayÄ±lardan ortanca olan sayÄ±yÄ± dÃ¶nen foksiyon
int getmid(int x, int y, int z)
{
    // '(x > y && x > z)' ifadesi 'x' en bÃ¼yÃ¼k sayÄ± mÄ± sorgulamasÄ±
    // '(x < y && x < z)' ifadesi 'x' en kÃ¼Ã§Ã¼k sayÄ± mÄ± sorgulamasÄ±
    // YukarÄ±da aÃ§Ä±klanan iki ifadenin veya ile birleÅŸtirilmesinden oluÅŸan ifade de 'x'in ortanca olmama durumunun mantÄ±ksal gÃ¶sterimidir.
    // YukarÄ±da aÃ§Ä±klanan iki ifadenin deÄŸilinin alÄ±ndÄ±ÄŸÄ± durumdaki ifade ise 'x'in ortanca sayÄ± olma durumunu gÃ¶sterecektir.
    if( !((x > y && x > z) || (x < y && x < z)) )
        return x;

    if( !((y > x && y > z) || (y < x && y < z)) )
        return y;

    return z;
}

int main(void)
{
    int x, y, z;

    printf("ortanca sayiyi bulmak iÃ§in uc tane tam sayi giriniz:");
    scanf("%d%d%d", &x, &y, &z);

    printf("girilen sayilar: %d, %d %d ve ortaca sayi %d.\n", x, y, z, getmid(x, y, z));

    return 0;
}
```


Ders sonu ...
