# 52.Ders 18.07.2025 ğŸ•˜

Derse 5(19:31)-6(19:38)-7(19:54)-8(20:16)-9(20:41)-8(21:10)-7(21:48)-7(22:25) kiÅŸi katÄ±ldÄ±.
---


## Bitsel OperatÃ¶rler Devam(Bitwise Operations)


ğŸ‘‡ AÅŸaÄŸÄ±daki programda temel bit iÅŸlemlerinin makro olarak yasÄ±lÄ±ÅŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#define SETBIT(x, n)        ((x) |= (<1 << (n))
#define RESETBIT(x, n)      ((x) &= ~(<1 << (n))
#define FLIPBIT(x, n)       ((x) ^= (<1 << (n))
#define ISBITSET(x, n)      ((x) & (<1 << (n))
#define ISBITNOTSET(x, n)   (!ISBITSET(x, n)) // Burada bir makroda baÅŸka bir makronun kullanÄ±labildiÄŸi gÃ¶rÃ¼lecektir.
```




ğŸ‘‡ AÅŸaÄŸÄ±daki programda endianness farklÄ±lÄ±klarÄ±nda dÃ¶nÃ¼ÅŸÃ¼mÃ¼n nasÄ±l yapÄ±lmasÄ± gerektiÄŸini anlamak iÃ§in incelenebilir. </br>
AÅŸaÄŸÄ±daki bitsel iÅŸlemlerde kullanÄ±lan makrolar C mÃ¼lakatlarÄ±nda sorulmaktadÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdint.h>

// 16 bit endian dÃ¶nÃ¼ÅŸÃ¼mÃ¼nÃ¼n yapÄ±lmasÄ±nÄ± saÄŸlayan mokro.
#define BSWAP16(x) ( (((x) & 0x00FF) << 8)  |  (((x) & 0xFF00) >> 8) )

// 32 bit endian dÃ¶nÃ¼ÅŸÃ¼mÃ¼nÃ¼n yapÄ±lmasÄ±nÄ± saÄŸlayan mokro.
// Her bir byte kendisinin ayna karÅŸÄ±lÄ±ÄŸÄ± olan byte ile deÄŸiÅŸ tokuÅŸ edilmektedir, bu iÅŸlemi uzun uzadÄ±ya yazmayacaÄŸÄ±m bu nedenle zihninde canlandÄ±rman gerekiyor eÄŸer canlandÄ±ramÄ±yorsan kaÄŸÄ±t kalem alÄ±p gÃ¶rselleÅŸtirerek anlayabilirsin. 
#define BSWAP32(x) (  \
    (((x) & 0x000000FFU) << 24) | \
    (((x) & 0x0000FF00U) << 8)  | \
    (((x) & 0x00FF0000U) >> 8)  | \
    (((x) & 0xFF000000U) >> 24)   \
)

// 64 bit endian dÃ¶nÃ¼ÅŸÃ¼mÃ¼nÃ¼n yapÄ±lmasÄ±nÄ± saÄŸlayan mokro.
#define BSWAP64(x) (  \
    (((x) & 0x00000000000000FFULL) << 56)  | \
    (((x) & 0x000000000000FF00ULL) << 40)  | \
    (((x) & 0x0000000000FF0000ULL) << 24)  | \
    (((x) & 0x00000000FF000000ULL) << 8)   | \
    (((x) & 0x000000FF00000000ULL) >> 8)   | \
    (((x) & 0x0000FF0000000000ULL) >> 24)  | \
    (((x) & 0x00FF000000000000ULL) >> 40)  | \
    (((x) & 0xFF00000000000000ULL) >> 56)    \
)


int main(void)
{
    uint16_t val16 = 0x1234;
    uint32_t val32 = 0x1234578;
    uint64_t val64 = 0x12345789ABCDEFULL;

    primtf("BSWAP16: 0x%04X\n", BSWAP16(val16));
    primtf("BSWAP32: 0x%08X\n", BSWAP32(val32));
    primtf("BSWAP64: 0x%08X\n", BSWAP64(val64));
}
```


â—â—â— Endianness dÃ¶nÃ¼ÅŸÃ¼mleri her zaman byte byte yapÄ±lmaktadÄ±r.

ğŸ‘‡ AÅŸaÄŸÄ±da 2 byte bÃ¼yÃ¼klÃ¼ÄŸÃ¼ndeki bir tam sayÄ±nÄ±n endianness dÃ¶nÃ¼ÅŸÃ¼mÃ¼nÃ¼n nasÄ±l olacaÄŸÄ± gÃ¶sterilmiÅŸtir(byte byte deÄŸiÅŸim yapÄ±lÄ±yor).
| Hex Number    | Binary Number       |
| ------------- | ------------------- |
| FC34          | 1111 1100 0011 0100 |
| 34FC          | 0011 0100 1111 1100 |



MÃ¼lakatlarda sorulan soru: Bir tam sayÄ±nÄ±n ikinin kuvveti olup olmadÄ±ÄŸÄ±nÄ± sÄ±nayan fonksiyonel makro yazÄ±nÄ±z. Bu makro C diliyle Ã§alÄ±ÅŸÄ±lÄ±yorsa mutlaka bir yerde karÅŸÄ±mÄ±za Ã§Ä±kar. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda yukarÄ±da tanÄ±mÄ± belirtilen makronun gerÃ§ekleÅŸtirimi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdint.h>
#include <stdio.h>

#define POWER_OF_TWO(x)   ((x) && !((x) & ((x) - 1))) // Bir tam sayÄ±yÄ± kedisinin bir eksiÄŸiyle ve iÅŸlemine sokarsak sayÄ±nÄ±n en saÄŸ ilk bitini 0 yapmÄ±ÅŸ oluruz. 


int main(void)
{
    printf("bir tam sayi giriniz: ");
    unsigned x;
    scanf("%u", &x);

    if(POWER_OF_TWO){
        printf("evet dogru.\n");
    }
    else{
        printf("hayir yanlis.\n");
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda  bir tam sayÄ±nÄ±n ikinin katÄ± olma durumunu sÄ±nayan makronun 0-UINT_MAX arasÄ±ndaki tam sayÄ±lar iÃ§in nasÄ±l sonuÃ§ verdiÄŸini anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdint.h>
#include <stdio.h>
#include <limits.h>

#define POWER_OF_TWO(x)   ((x) && !((x) & ((x) - 1)))

int main(void)
{
    for(unsigned int i = 0; i != UINT_MAX; ++i){
        if(POWER_OF_TWO(i)){
            printf("%u", i);
        }
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir sayÄ±nÄ±n ikinin kuvveti oluÅŸ olmadÄ±ÄŸÄ±nÄ± tespit etmek iÃ§in `POWER_OF_TWO` makrosu dÄ±ÅŸÄ±nda kullanÄ±labilecek baÅŸka bir yÃ¶ntemi gÃ¶rebilirsiniz.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x;

    printf("enter an integer: ");
    (void)scanf("%d", &x);

    if(x && (x & -x) == x)
        printf("power of two\n");
    else
        printf("not power of two\n");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir iÅŸaretli tam sayÄ±nÄ±n kendisinin tesr iÅŸaretli sayÄ±sÄ±yla bitsel ve iÅŸlemine sokulmaÄ±s sonucunda elde edilecek deÄŸerin bitlerinn nasÄ±l dizileneceÄŸi gÃ¶rÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int x1 = 87234;

    bprint(x1);
    bprint(-x1);
    bprint(x1 & -x1);


    int x2 = 4096;

    bprint(x2);
    bprint(-x2);
    bprint(x2 & -x2);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda ilginÃ§ iÅŸlemlerden biri incelenebilir. </br>
Programdaki `x`in deÄŸeri `a` deÄŸiÅŸkenine eÅŸitse `x`in deÄŸeri `b`nin deÄŸeri yapÄ±lacak ya da `x`in deÄŸeri `b` deÄŸiÅŸkenine eÅŸitse `x`in deÄŸeri `a`nin deÄŸeri yapÄ±lacak. </br>
Buradaki mantÄ±ÄŸÄ± anlamayÄ± sana bÄ±rakÄ±yorum, neden bunun doÄŸru olduÄŸunu kaÄŸÄ±t ve kalem ile zaman sarfederek kendin anlamalÄ±sÄ±n.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a = 23, b = 37;
    int x = a;

    printf("x = %d\n", x);

    x = a ^ b ^ x;

    printf("x = %d\n", x);

    x = a ^ b ^ x;

    printf("x = %d\n", x);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki tam sayÄ±nÄ±n en bÃ¼yÃ¼k ve en kÃ¼Ã§Ã¼k deÄŸerinin ne olduÄŸunu dallanma(if else) kullanmadan bitsel iÅŸlemler ile nasÄ±l yapÄ±ldÄ±ÄŸÄ±nÄ± anlamak iÃ§in inceleyebilirsin.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x, y;

    printf("enter two integer: ");
    (void)scanf("%d%d", &x, &y);

    int min = (y ^ (x ^ y) & -(x < y));
    int max = (x ^ (x ^ y) & -(x < y));

    printf("min(%d, %d) => %d \n", x, y, min);
    printf("max(%d, %d) => %d \n", x, y, max);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"


int main(void)
{
    int x = 56;

    x = ~-x; // Burada 'x'in deÄŸeri bir azalacaktÄ±r.
    
    printf("x = %d\n", x);

    x = -~x; // Burada 'x'in deÄŸeri bir artacaktÄ±r.

    printf("x = %d\n", x);
}
```


### Neden Bitsel Ä°ÅŸlemleri KullanÄ±yoruz Devam 

Sistem programlama tarafÄ±nda en sÄ±k yapÄ±lan iÅŸlemlerden biri tam sayÄ±nÄ±n bitlerini adeta bit dizisi(boolean dizisi) gibi kullanmaktÄ±r. 


Bir dosyanÄ±n bazÄ± Ã¶zelliklere sahip olup olmadÄ±ÄŸÄ± bilgisini iÅŸaretsiz bir tam sayÄ± tÃ¼rÃ¼nÃ¼n bitlerinde saklayabiliriz. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir dosyanÄ±n durum bilgisini tutmak iÃ§in bir tam sayÄ±nÄ±n bitlerinin nasÄ±l kullanÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

// AÅŸaÄŸÄ±daki makro deÄŸerleri maske olarak kullanÄ±lmaktadÄ±r. 
// Object-like mokrolarÄ±n deÄŸerleri genllikle hex formatÄ±nda verilir ama burada okumasÄ± kolay olmasÄ± iÃ§in onluk tabanda verilmiÅŸti.
#define ARCHIVE         1
#define READONLY        2
#define HIDDEN          4
#define DIRECTORY       8
#define SYSTEM          16


int main(void)
{
    unsigned int file_flags; // DosyanÄ±n durum bilgileri tutacak iÅŸaretsiz tam sayÄ± tÃ¼rÃ¼nden deÄŸiÅŸken tanÄ±mÄ±.

    // AÅŸaÄŸÄ±daki koÅŸul ifadesinde 'file_flags' deÄŸiÅŸkeninin 2 indisli bitinin bir olup olmasÄ±ÄŸÄ± sorgulanmaktadÄ±r. 
    if(file_flags & HIDDEN){
        // Do something ...
    }


    file_flags |= DIRECTORY; // Burada 'file_flags' deÄŸiÅŸeninin bitlerinde tutulan dosyanÄ±n 'DIRECTORY' Ã¶zelliÄŸine sahip deÄŸilse sahip olmasÄ± saÄŸlanÄ±yor.


    file_flags &= ~HIDDEN; // Burada 'file_flags' deÄŸiÅŸeninin bitlerinde tutulan dosyanÄ±n 'HIDDEN' Ã¶zelliÄŸinin kapatÄ±lmasÄ± saÄŸlanÄ±yor, bunu yaparken ilgili bit 0 yapÄ±lÄ±yor.


    file_flags ^= HIDDEN; // Burada 'file_flags' deÄŸiÅŸeninin bitlerinde tutulan dosyanÄ±n 'HIDDEN' Ã¶zelliÄŸinin flipping(0 ise 1, 1 ise 0 yapÄ±lmasÄ± iÅŸlemi) yapÄ±lmaktadÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda makro yerine enum deÄŸiÅŸken kullanÄ±larak bir Ã¶nceki programda yapÄ±lan iÅŸlemlerin aynÄ±larÄ±nÄ±n yapÄ±labileceÄŸi gÃ¶rÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"


typedef enum 
{
    ARCHIVE = 1,
    READONLY = 2,
    HIDDEN = 4,
    DIRECTORY = 8,
    SYSTEM = 16
}


int main(void)
{
    unsigned int file_flags; // DosyanÄ±n durum bilgileri tutacak iÅŸaretsiz tam sayÄ± tÃ¼rÃ¼nden deÄŸiÅŸken tanÄ±mÄ±.

    // AÅŸaÄŸÄ±daki koÅŸul ifadesinde 'file_flags' deÄŸiÅŸkeninin 2 indisli bitinin bir olup olmasÄ±ÄŸÄ± sorgulanmaktadÄ±r. 
    if(file_flags & HIDDEN){
        // Do something ...
    }


    file_flags |= DIRECTORY; // Burada 'file_flags' deÄŸiÅŸeninin bitlerinde tutulan dosyanÄ±n 'DIRECTORY' Ã¶zelliÄŸine sahip deÄŸilse sahip olmasÄ± saÄŸlanÄ±yor.


    file_flags &= ~HIDDEN; // Burada 'file_flags' deÄŸiÅŸeninin bitlerinde tutulan dosyanÄ±n 'HIDDEN' Ã¶zelliÄŸinin kapatÄ±lmasÄ± saÄŸlanÄ±yor, bunu yaparken ilgili bit 0 yapÄ±lÄ±yor.


    file_flags ^= HIDDEN; // Burada 'file_flags' deÄŸiÅŸeninin bitlerinde tutulan dosyanÄ±n 'HIDDEN' Ã¶zelliÄŸinin flipping(0 ise 1, 1 ise 0 yapÄ±lmasÄ± iÅŸlemi) yapÄ±lmaktadÄ±r.
}
```



âœï¸ Burada `ctype.h` kÃ¼tÃ¼phanesinin basit bir benzerinin gerÃ§eleÅŸtirimini yapmak iÃ§in `myctype.h` baÅŸlÄ±k dosyasÄ±nÄ± yazÄ±yoruz.
```C
// YazÄ±lan 'myctype.h' dosyasÄ±na eklenenler.

#pragma once

#define UPPER       1
#define LOWER       2
#define DIGIT       4
#define HEXDIGIT    8
#define PUNCT       16
#define SPACE       32
#define PRINTABLE   64
#define CNTRL       128 // 'Control' sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n kÄ±saltmasÄ±ndan makro adÄ± tÃ¼retilmiÅŸtir.


extern uint8_t flags_[];

#define ISUPPER(c)      (flags_[c] & UPPER)
#define ISLOWER(c)      (flags_[c] & LOWER)
#define ISALPHA(c)      (flags_[c] & (UPPER | LOWER))
#define ISDIGIT(c)      (flags_[c] & DIGIT)
#define ISALNUM(c)      (flags_[c] & (UPPER | LOWER | DIGIT))
#define ISPUNCT(c)      (flags_[c] & PUNCT)
#define ISHEXDIGIT(c)   (flags_[c] & HEXDIGIT)
#define ISSPACE(c)      (flags_[c] & SPACE)
#define ISPRINTABLE(c)  (flags_[c] & PRINTABLE)
#define ISCNTRL(c)      (flags_[c] & CNTRL)

```


âœï¸ Burada `ctype.h` kÃ¼tÃ¼phanesinin basit bir benzerinin gerÃ§eleÅŸtirimini yapmak iÃ§in `myctype.c` kaynak dosyasÄ±nÄ± yazÄ±yoruz.
```C
// YazÄ±lan 'myctype.c' dosyasÄ±na eklenenler.

#include <stdint.h>

const uint8_t flags_[128] = {
    0X80, 0X80, 0X80, 0X80, 0X80, 0X80, 0X80, 0X80, 
    0X80, 0XA0, 0XA0, 0XA0, 0XA0, 0XA0, 0X80, 0X80, 
    0X80, 0X80, 0X80, 0X80, 0X80, 0X80, 0X80, 0X80, 
    0X80, 0X80, 0X80, 0X80, 0X80, 0X80, 0X80, 0X80, 
    0X60, 0X50, 0X50, 0X50, 0X50, 0X50, 0X50, 0X50, 
    0X50, 0X50, 0X50, 0X50, 0X50, 0X50, 0X50, 0X50, 
    0X4C, 0X4C, 0X4C, 0X4C, 0X4C, 0X4C, 0X4C, 0X4C, 
    0X4C, 0X4C, 0X50, 0X50, 0X50, 0X50, 0X50, 0X50, 
    0X50, 0X49, 0X49, 0X49, 0X49, 0X49, 0X49, 0X41, 
    0X41, 0X41, 0X41, 0X41, 0X41, 0X41, 0X41, 0X41, 
    0X41, 0X41, 0X41, 0X41, 0X41, 0X41, 0X41, 0X41, 
    0X41, 0X41, 0X41, 0X50, 0X50, 0X50, 0X50, 0X50, 
    0X50, 0X4A, 0X4A, 0X4A, 0X4A, 0X4A, 0X4A, 0X42, 
    0X42, 0X42, 0X42, 0X42, 0X42, 0X42, 0X42, 0X42, 
    0X42, 0X42, 0X42, 0X42, 0X42, 0X42, 0X42, 0X42, 
    0X42, 0X42, 0X42, 0X50, 0X50, 0X50, 0X50, 0X80,
};

```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda kendi yazdÄ±ÄŸÄ±mÄ±z `myctype` kÃ¼tÃ¼phane modÃ¼lÃ¼nÃ¼n `myctype.c` dosyasÄ±nda tanÄ±mÄ± bulunacak `flags_[128]` tÃ¼rÃ¼nÃ¼n elemanlarÄ±nÄ±n nasÄ±l elde edildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include "myctype.h"
#include <ctype.h>

int main(void)
{
    for(int i = 0; i < 128; ++i){
        unsigned int result  = 0;

        if(isupper(i)) result |= UPPER;
        if(islower(i)) result |= LOWER;
        if(isdigit(i)) result |= DIGIT;
        if(isxdigit(i)) result |= HEXDIGIT;
        if(ispunct(i)) result |= PUNCT;
        if(isspace(i)) result |= SPACE;
        if(isprint(i)) result |= PRINTABLE;
        if(iscntrl(i)) result |= CNTRL;

        if(i && i % 8 == 0)
            printf("\n");
        printf("0X%02X, ", result);
    }
}
```




ğŸ‘‡ AÅŸaÄŸÄ±daki programda makro iÃ§inde makro kullanÄ±labileceÄŸini gÃ¶stermek iÃ§in yasÄ±lmÄ±ÅŸtÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include <stdlib.h>

int main(void)
{
    int ar[] ? { 2, 4, 6, 9, 1, 3, 7, 21, 98, 34, 45 };
    
    randomize();

    for(int i = 0; i < 10; ++i){
        printf("%d ", RANDOM_ELEM(ar)); // Buradaki statement'taki makro sÄ±rasÄ±yla aÅŸaÄŸÄ±daki gibi aÃ§Ä±lacaktÄ±r.
        // printf("%d ", ar[rand() % ASIZE(ar)]);
        // printf("%d ", ar[rand() % sizeof(ar) / sizeof(ar[0])]);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda kendi yazdÄ±ÄŸÄ±mÄ±z `myctype.h` kÃ¼tÃ¼phenesinin `ISDIGIT` fonksiyonunun kullamÄ±n incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"
#include "myctype.h"
#include <stdlib.h>

int main(void)
{
    int ch;

    printf("bir karakter girin: ");
    ch = getchar();

    if(ISHEXDIGIT(ch))
        printf("evet hex karakter.\n");
    else
        printf("hayir hex karakter degil.\n");
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 20.49-21.10 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


Bir byte'lÄ±k bir alanda birden fazla deÄŸiÅŸken saklanabilir mi, mesela 1 byte(8 bit olsun) alanda `xxxyyzzz` biÃ§iminde Ã¼Ã§ farklÄ± deÄŸiÅŸken saklanabilir, bu 1 byte alandan veri okumak iÃ§in maskelar ve bitsel kaydÄ±rma iÅŸlemleri uygulanmaktadÄ±r? Bu bize ÅŸunkarÄ± saÄŸlar;
1. Daha az bellek kullanÄ±mÄ±.
2. Bitsel iÅŸlemler daha hÄ±zlÄ± olacaÄŸÄ± iÃ§in, iÅŸlem maliyeti dÃ¼ÅŸÃ¼rÃ¼lmÃ¼ÅŸ olur.
3. MantÄ±ksal iliÅŸki iÃ§inde olan deÄŸiÅŸkenleri aynÄ± bellek bloÄŸunda tutulmasÄ± yapÄ±lacak iÅŸlemlerin kolay olmasÄ±nÄ± saÄŸlar(fonksiyonel makrolar kullanÄ±lÄ±r genellikle).


## YapÄ±larÄ±n Bit AlanÄ± ElemanlarÄ±(Bitfield Members) 

Bu konunun aslÄ±nda yapÄ±lar konusunda anlatÄ±lamsÄ± gerekirdi ama o aÅŸamada henÃ¼z bitsel iÅŸlemler bilinmediÄŸi iÃ§in bu ana kadar beklenmiÅŸtir.


ğŸ‘‡ AÅŸaÄŸÄ±daki program parÃ§asÄ±nda yapÄ±larÄ±n Ã¼yelerinin bitfield yapÄ±ldÄ±ÄŸÄ± deÄŸiÅŸik durumlar incelenebilir.
```C
struct Nec {
    int x : 3; // Burada derleyiciye 'x' deÄŸiÅŸkeninin deÄŸerinin Ã¼Ã§ bitlik alanda tutulmasÄ± sÃ¶ylenmiÅŸ oluyor.
};

// AÅŸaÄŸÄ±daki yapÄ±da bitfield Ã¼yelerle bitfield olmayan Ã¼yeler birlikte bulunmaktadÄ±r.
struct Nec2 {
    int x;
    double dval;
    unsigned int b : 5;
};

// AÅŸaÄŸÄ±daki yapÄ± bildiriminde tek bir byte'lÄ±k alanda Ã¼Ã§ farklÄ± deÄŸiÅŸken tutulmaktadÄ±r.
struct Nec3 {
    unsigned int a : 3;
    unsigned int b : 4;
    unsigned int b : 5;
};
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program parÃ§asÄ±nda **bitfield** yapÄ± Ã¼yelerinin kaÃ§ bitlik bÃ¼yÃ¼klÃ¼ÄŸe sahip olacaklarÄ±nÄ± belirten ifadenin sabit ifadesi olmasÄ± gerektiÄŸi gÃ¶rÃ¼lebilir.
```C
// AÅŸaÄŸÄ±daki yapÄ± bildiriminde tek bir byte'lÄ±k alanda Ã¼Ã§ farklÄ± deÄŸiÅŸken tutulmaktadÄ±r.

int x = 3;

struct Nec3 {
    unsigned int a : x; // Burada sÃ¶zdizimi hatasÄ± oluÅŸur Ã§Ã¼nkÃ¼ bitfield Ã¼yenin bit deÄŸerini belirten ifade sabit(constant) ifadesi olmak zorundadÄ±r.
    unsigned int b : 4;
    unsigned int b : 5;
};
```



â—â—â— C dilinin sÃ¶zdiziminde sabit(constant) ifadesi kullanÄ±lmasÄ± gereken yerler;
1. `switch` bildirimlerinde `case` ifadeleri.
2. Dizilerin eleman sayÄ±sÄ±nÄ± belirten ifadeler(Derleyicilerin opsiyonel olarak verdiÄŸi VLA dersteÄŸi dÄ±ÅŸÄ±nda).
3. Global deÄŸiÅŸkenlerin ilk deÄŸer vermekte kullanÄ±lan ifadeler. 


Bitfield yapÄ± Ã¼yeleri Ã§oÄŸunlukla iÅŸaretsiz tam sayÄ±lar olur ama iÅŸaretli tam sayÄ± olarak ta bildirilebilirler.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **bitfield** yapÄ± Ã¼yelerinin kullanÄ±mÄ±nÄ±n diÄŸer yapÄ± Ã¼yeleri ile benzer olduÄŸu incelenebilir.
```C
typedef struct {
    unsigned int a : 3;
    unsigned int b : 4;
    unsigned int b : 5;
} Nec;

int main(void)
{
    Nec nec1;

    Nec* p = &nec1;
    p->a;

    Nec nec2 = { 2, 12, 3 };

    Nec nec2 = { .a = 6, .b = 4 }; // Designated Initializer ile ilk deÄŸer verilebilir, ilk deÄŸer verilmeyen yapÄ± Ã¼yeleri hayata 0 deÄŸeri ile gelirler. 
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda **bitfield** yapÄ± Ã¼yelerinin **anonymous structure** tÃ¼rÃ¼nden olabileceÄŸi incelenebilir.
```C
typedef struct {
    int x, y, z;
    struct { // 'Nec' tÃ¼rÃ¼nÃ¼n bÃ¼nyesinde bildirilen anonim yapÄ± Ã¼yesi.
        unsigned int a : 3;
        unsigned int b : 4;
        unsigned int b : 5;
    };
} Nec;

int main(void)
{
    Nec nec1;

    nec1.a;
}
```



â—â—â— C dilinin sÃ¶zdiziminde bit adreslenebilir bir varlÄ±k deÄŸildir, bu nedenden dolayÄ± **bitfield** yapÄ± Ã¼yeleri adres operatÃ¶rÃ¼nÃ¼n(`&` operator) operandÄ± olamaz. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda **bitfield** yapÄ± Ã¼yelerinin adres operatÃ¶rÃ¼nÃ¼n(`&` operator) operandÄ± olamadÄ±ÄŸÄ± gÃ¶rÃ¼lecektir.
```C
typedef struct {
    unsigned int a : 3;
    unsigned int b : 4;
    unsigned int b : 5;
} Nec;

int main(void)
{
    Nec nec1;

    &nec1.a; // Burada sÃ¶zdizim hatasÄ± alÄ±nacaktÄ±r.
}
```



â—â—â— Bir **bitfield members** yapÄ± Ã¼yelerinin bellek bÃ¼yÃ¼klÃ¼ÄŸÃ¼nÃ¼n en az ne olacaÄŸÄ± derleyiciye bÄ±rakÄ±lmÄ±ÅŸtÄ±r, derleyicilerdeki "**Storage Unit**" deÄŸerinin ne olduÄŸuna gÃ¶re bu deÄŸerin katlarÄ± biÃ§iminde artacaktÄ±r, mesela Microsoft derleyicisinde "**Storage Unit**" deÄŸeri 4 byte'tÄ±r. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki programda sadece iki tane **bitfield** Ã¼yeye sahip olan yapÄ±nÄ±n bellek bÃ¼yÃ¼klÃ¼ÄŸÃ¼nÃ¼n ne olacaÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

typedef struct {
    unsigned int a : 3;
    unsigned int b : 4;
} Nec;

int main(void)
{
    printf("sizeof(Nec) = %zu", sizeof(Nec));
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki program "**Storage Unit**" deÄŸerinin yapÄ± tÃ¼rlerinin bellek bÃ¼yÃ¼klÃ¼klerini nasÄ±l etkiledÄŸini analmak iÃ§in incelenebilir
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

// 'Nec1' yapÄ± nesnesi 4 byte'lÄ±k bellek ihtiyacÄ±na sahip olacaktÄ±r.
typedef struct {
    unsigned int x1 : 7;
    unsigned int x2 : 1;
} Nec1;

// 'Nec2' yapÄ± nesnesi 4 byte'lÄ±k bellek ihtiyacÄ±na sahip olacaktÄ±r, Ã§Ã¼nkÃ¼ toplamda 32 bit alana ihtiyaÃ§ mevcut.
typedef struct {
    unsigned int x1 : 7;
    unsigned int x2 : 7;
    unsigned int x3 : 7;
    unsigned int x4 : 7;
    unsigned int x5 : 4;
} Nec2;


// 'Nec3' yapÄ± nesnesi 8 byte'lÄ±k bellek ihtiyacÄ±na sahip olacaktÄ±r, Ã§Ã¼nkÃ¼ toplamda 33 bit alana ihtiyaÃ§ mevcut ve bellek ihtiyacÄ± 'Storage Unit' deÄŸerinin katlarÄ± biÃ§iminde gidiyor.
typedef struct {
    unsigned int x1 : 7;
    unsigned int x2 : 7;
    unsigned int x3 : 7;
    unsigned int x4 : 7;
    unsigned int x5 : 5;
} Nec3;

int main(void)
{
    printf("sizeof(Nec) = %zu", sizeof(Nec));
}
```



â—â—â— Bir yapÄ± tÃ¼rÃ¼nÃ¼n **bitfield** Ã¼yelere sahip olduÄŸunda bu Ã¼yelerin bitlerinin nesnenin hangi bitlerinde tutulacaÄŸÄ± derleyiciye baÄŸlÄ±dÄ±r(endianness'a da baÄŸlÄ±dÄ±r), bu nedenden dolayÄ± yapÄ±nÄ±n **bitfield** Ã¼yelerine bitsel iÅŸlemlerle eriÅŸilmeye Ã§alÄ±ÅŸÄ±lmamalÄ±dÄ±r. </br>
ğŸ‘‡ AÅŸaÄŸÄ±daki program parÃ§asÄ±nda `Nec` tÃ¼rÃ¼nÃ¼n(esasÄ±nda tÃ¼r eÅŸ adÄ±) **bitfield** Ã¼yelerinin bellekte nesnenin neresinde tutulacaÄŸÄ± bilinemeyeceÄŸ iÃ§in bu Ã¼yelere sadece `.` ya da `->` oparetÃ¶rÃ¼ ile eriÅŸmek gerekmektedir.
```C
#define _CRT_SECURE_NO_WARNINGS

typedef struct {
    unsigned int x : 2;
    unsigned int y : 4;
    unsigned int z : 2;
} Nec;

int main(void)
{
    
}
```




ğŸ‘‡ AÅŸaÄŸÄ±daki programda **bitfield** Ã¼yelere sahip olan yapÄ±larda **bitfield** Ã¼yelerin bellekte performanslÄ± iÅŸlem yapÄ±lmasÄ±nÄ± saÄŸlayabilecek biÃ§imde yerleÅŸtirilebilmesi iÃ§in "**Pedding Bits**" kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

// 'Nec1' tÃ¼rÃ¼ bellekte tek bir byte'lÄ±k alanda tutulabilir.
typedef struct {
    unsigned int x : 3;
    unsigned int y : 4;
    unsigned int z : 1;
} Nec1;

// 'Nec2' tÃ¼rÃ¼ bellekte 2 byte'lÄ±k alanda tutulacaktÄ±r, 'Pedding bits' alanÄ± ile 'x' ve 'y' deÄŸiÅŸkenlerinin bellekte ayrÄ± byte alanlarÄ±nda tutulmasÄ± saÄŸlanÄ±yor.
typedef struct {
    unsigned int x : 4;
    unsigned int   : 4; // 'Pedding bits' alanÄ± bildiriliyor.
    unsigned int y : 5;
} Nec2;

//  'storage unit' deÄŸeri 2 byte ise 'Nec3' tÃ¼rÃ¼nÃ¼n kullanÄ±lmayan bitlerini belirtmek iÃ§in 'reserved' ya da 'unused' ya da 'notused' yapÄ± Ã¼yesi eklenebilir.
typedef struct {
    unsigned int x : 4;
    unsigned int y : 5;
    unsigned int z : 3;
    unsigned int reserved : 4; // KullanÄ±lmayan bitleri belirtmek iÃ§in kullanÄ±lan bildirim, buranÄ±n 
    // unsigned int unused : 4; // KullanÄ±lmayan bitleri belirtmek iÃ§in kullanÄ±lan bildirim.
    // unsigned int notused : 4; // KullanÄ±lmayan bitleri belirtmek iÃ§in kullanÄ±lan bildirim.
} Nec3;


int main(void)
{
    
}
```




ğŸ‘‡ AÅŸaÄŸÄ±daki programda yapÄ± Ã¼yelerini hizalamak iÃ§in **bitfield** Ã¼yelerin bit boyutu 0 olarak bildirilmesiyle nasÄ±l ayarlanabildiÄŸi incelenebilir.
```C
typedef struct {
    unsigned int x : 4;
    unsigned int y : 5;
    unsigned int   : 0; // Bu Ã¼ye kullanÄ±mÄ± bir sonraki yapÄ± Ã¼yesinin bir sonraki 'storage unit'e yerleÅŸtirilsin demektir.
    unsigned int z : 3;
} Nec;

int main(void)
{
    printf("sizeof(Nec) = %zu", sizeof(Nec));
}
```

### Bit AlanÄ± ElemanlarÄ±n KullanÄ±lma Nedenleri 


#### Bellek alanÄ±ndan tasarruf saÄŸlanmasÄ±



ğŸ‘‡ AÅŸaÄŸÄ±daki programda DOS iÅŸletim sisteminde "Tarih-Zaman" bilgisinin tutulmasÄ±nda yerden tasarruf iÃ§in **bitfield** yapÄ± Ã¼yelerinin nasÄ±l kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C

struct Date {
    unsigned int mday : 5; // AyÄ±n gÃ¼nÃ¼ bilgisi en Ã§ok 31 olabildiÄŸi iÃ§in 5 bitte tutulabilir.
    unsigned int mmon : 4; // YÄ±lÄ±n ayÄ± bilgisi en Ã§ok 12 olabildiÄŸi iÃ§in 4 bitte tutulabilir.
    unsigned int myear : 7; // DOS-OS doÄŸum yÄ±lÄ± 1980 kabul edilir ve 7 bitte de [0, 127] arasÄ±nda sayÄ± tutulabiliyor, 1980 + 127 olarak yÄ±l bilgisi tutulmaktadÄ±r.
};


struct Time {
    unsigned int mhour : 5; // Saat bilgisi en fazla 23 olabidiÄŸi iÃ§in 5 bitte tutulabilir.
    unsigned int mmin : 6; // Dakika bilgisi en fazla 59 olabidiÄŸi iÃ§in 6 bitte tutulabilir.
    unsigned int msec : 5; // `struct Time` tÃ¼rÃ¼nÃ¼ 2 byte alanÄ± sÄ±ÄŸabilmesi iÃ§in saniye bilgisi 6 bitlik deÄŸil 5 bitlik alanda tutulmuÅŸtur, bunun sonucu olarak ta sadece Ã§ift saniyeler tutulmuÅŸtur tek saniyeler tutulmamÄ±ÅŸtÄ±r.
}

int main(void)
{

}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda DOS benzeri kendi "Tarih-Zaman" bilgisini tutan yapÄ± tÃ¼rÃ¼nÃ¼n nasÄ±l yazÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


typedef struct Date {
    unsigned int day : 5;
    unsigned int mon : 4;
    unsigned int year : 7;
    unsigned int hour : 5;
    unsigned int min : 6;
    unsigned int sec : 5;
} DateTime;


int main(void)
{
    printf("sizeof(DateTime) = %zu\n", sizeof(DateTime));

    DateTime dt = {
        .day = 18,
        .mon = 7,
        .year = 2025 - 1980,
        .hour = 22,
        .min = 2,
        .sec = 54 / 2
    };
}
```


#### Birlikler ile Bit AlanÄ± Ãœyelerine Sahip YapÄ±larÄ±n Birlikte KullanÄ±lmasÄ± 

Bir birlik tÃ¼rÃ¼nde bir veriyi iki farklÄ± biÃ§imde temsiledebiliriz.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **union(birlik)** tÃ¼rÃ¼nÃ¼ kullanarak DOS tipi tarih-saat bilgisinin nasÄ±l tutulabileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdint.h>
#include <stdio.h>

typedef union {
    uint32_t uval;
    struct {
        unsigned int day : 5;
        unsigned int mon : 4;
        unsigned int year : 7;
        unsigned int hour : 5;
        unsigned int min : 6;
        unsigned int sec : 5;
    };
} DateTime;


int main(void)
{
    printf("sizeof(DateTime) = %zu\n", sizeof(DateTime));

    DateTime dt = {
        .day = 18,
        .mon = 7,
        .year = 2025 - 1980,
        .hour = 22,
        .min = 11,
        .sec = 48 / 2
    };

    printf("%u\n", st.uval);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda kendi oluÅŸturduÄŸumuz DOS iÅŸletim sisteminin tarih-zaman yapÄ± tÃ¼rÃ¼nÃ¼n taklidi bir yapÄ± tÃ¼rÃ¼nÃ¼n nasÄ±l kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdint.h>
#include <stdio.h>

typedef union {
    uint32_t uval;
    struct {
        unsigned int day : 5;
        unsigned int mon : 4;
        unsigned int year : 7;
        unsigned int hour : 5;
        unsigned int min : 6;
        unsigned int sec : 5;
    };
} DateTime;


int main(void)
{
    printf("sizeof(DateTime) = %zu\n", sizeof(DateTime));

    DateTime dt = {
        .uval = 3245759218u
    };

    printf("%02u-%02u-%u %02u-%02u-%02u\n", 
        dt.day, dt.mon, dt.year + 1980, dt.hour, dt.min, dt.sec * 2);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir birlik tÃ¼rÃ¼nden deÄŸiÅŸken bildiriminde birlik tÃ¼rÃ¼nÃ¼n hem 4 byte'lÄ±k bir deÄŸiÅŸken hem de 32 faklÄ± bitten oluÅŸan 32 farklÄ± boolean Ã¶zellikte deÄŸiÅŸken gibi kullanÄ±labildiÄŸi incelenebilir.
```C
#include <stdio.h>
#include <stdint.h>

typedef struct{
    _Bool bit0: 1;
    _Bool bit1: 1;
    _Bool bit2: 1;
    _Bool bit3: 1;
    _Bool bit4: 1;
    _Bool bit5: 1;
    _Bool bit6: 1;
    _Bool bit7: 1;
    _Bool bit8: 1;
    _Bool bit9: 1;
    _Bool bit10: 1;
    _Bool bit11: 1;
    _Bool bit12: 1;
    _Bool bit13: 1;
    _Bool bit14: 1;
    _Bool bit15: 1;
    _Bool bit16: 1;
    _Bool bit17: 1;
    _Bool bit18: 1;
    _Bool bit19: 1;
    _Bool bit20: 1;
    _Bool bit21: 1;
    _Bool bit22: 1;
    _Bool bit23: 1;
    _Bool bit24: 1;
    _Bool bit25: 1;
    _Bool bit26: 1;
    _Bool bit27: 1;
    _Bool bit28: 1;
    _Bool bit29: 1;
    _Bool bit30: 1;
    _Bool bit31: 1;
} Bits1;


typedef union{
    struct{
        _Bool bit0: 1;
        _Bool bit1: 1;
        _Bool bit2: 1;
        _Bool bit3: 1;
        _Bool bit4: 1;
        _Bool bit5: 1;
        _Bool bit6: 1;
        _Bool bit7: 1;
        _Bool bit8: 1;
        _Bool bit9: 1;
        _Bool bit10: 1;
        _Bool bit11: 1;
        _Bool bit12: 1;
        _Bool bit13: 1;
        _Bool bit14: 1;
        _Bool bit15: 1;
        _Bool bit16: 1;
        _Bool bit17: 1;
        _Bool bit18: 1;
        _Bool bit19: 1;
        _Bool bit20: 1;
        _Bool bit21: 1;
        _Bool bit22: 1;
        _Bool bit23: 1;
        _Bool bit24: 1;
        _Bool bit25: 1;
        _Bool bit26: 1;
        _Bool bit27: 1;
        _Bool bit28: 1;
        _Bool bit29: 1;
        _Bool bit30: 1;
        _Bool bit31: 1;
    };
    uint32_t uval;
} Bits2;


int main(void)
{
    // for(int i = 0; i < 32; ++i){
    //     printf("_Bool bit%d: 1;", i);
    // }

    printf("sizeof(Bits1) = %zu\n", sizeof(Bits1));
    printf("sizeof(Bits2) = %zu\n", sizeof(Bits2));

    Bits2 x1 = { 
        .uval = 768214u
    };

    printf("%d\n", x.bit13);

    Bits2 x2 = { 
        .bit0 = 1,
        .bit4 = 1,
        .bit7 = 1,
    };

    printf("%d\n", x2.uval);
}
```


> â” 
> 
> Sorulan soru;
> 
> Åimdi C dilinde 1 byte hafizam var. bu int olarak tutarsam bir sayiyi ifade eder. bunun yaninda bitwise islemler yaparak 8 tane on off bilgiyi tutabilirim. onun disinda sadece bunlardan biri olacak sekilde de 2 Ã¼zeri 8 = 256 tane farkli bilgiyi de tutabilirim. C araclari ile bunu ifade etmemin yolu enum yapisi midir?
>
> ```C
> typedef enum {
>   STATE_IDLE = 0,
>   STATE_INIT = 1,
>   STATE_READY = 2,
>   // ...
>   STATE_MAX = 255
> } SystemState;
> 
> SystemState s = STATE_READY;
> ```
> 
> Benim sorum ÅŸuydu bir byte'Ä± 256 farkli bilgiyi gÃ¶sterecek biÃ§imde C de nasÄ±l kullanÄ±rÄ±m?
> 
> Cevap;
> 
> Burada sorulan soru tam analaÅŸÄ±lamadÄ± o nedenle tam bir cevap verilemedi ama 1 byte ile [0-255] aralÄ±ÄŸÄ±nda deÄŸer tutulabilir.


Ders sonu ...
