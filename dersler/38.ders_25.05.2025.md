# 38.Ders 25.05.2025 🕘

Derse 6(09:01)-8(09:02)-9(09:05)-10(09:08)-9(09:12)-11(09:34)-11(10:01)-12(10:15)-12(11:21)-13(12:16)-13(12:45) kişi katıldı.
---

## Function Pointers Array Devam

### Function Pointer İle Sık Kullanılan Yöntemler 

#### En Sık Kullanılan İlk Yöntem

C dilindeki kütüphenelerde çok sık kullanılan bir örüntü mevcut, bu örüntü şu şekilde: Bir C kütüphenesinin sağlamış olduğu bir fonksiyonun(burada `func` adındaki fonksiyon olsun) varsayılan davranışı kütüphanenin bünyesinde bulunan başka bir fonksiyonu(burada `foo` adındaki fonksiyon olsun) çağırmak olsun, fakat kütüphene ayrı bir fonksiyon ile bu çağırılan fonksiyonun çağırdığı diğer fonksiyonu değiştirmek için bir başka fonksiyon(burada `set_func` adındaki fonksiyon olsun) sunabilir ve bir değişiklik yapıldığında geriye alınabilir.

⚠️ Aşağıda kodlarda görülebilecek olan programlama yaklaşımı C++ standart kütüphanesinde de çok sık kullanılıyor, üçüncü taraf kütüphaneler de bu yaklaşımı çok sık kullanmaktadır.


✍️ Aşağıdaki üç farklı dosyaya(`main.c`, `neco.h`, `neco.c`) dağılmış şekilde üçüncü taraf kütüphenelerde sıklıkla kullanılan yukarıda açıklanan yaklaşımın basit şekilde nasıl uygulandığını anlamak için incelenebilir.

👇 Aşağıdaki kodlar `neco.h` dosyasındadır.
```C

typedef void (*fptr)(void);

// Varsayılan davramış 'foo' adlı fonksiyonun çağırılmasıdır. 
void func(void);

fptr set_func(fptr);
```


👇 Aşağıdaki kodlar `neco.c` dosyasındadır.
```C

// Aşağıdaki 'foo' fonksiyonu ve 'gf' fonksiyon göstericisinin 'static' bildirilmesinin nedeni bu varlıkların 'neco.c' dosyası dışından kullanılmasını engellemek içindir, bu konu üç-dört hafta sonra ayrıntılı olarak işlenecektir.
// Burada kullanılan 'static' anahtar sözcüğünün işlevi yerel değişkenelerin 'static' olarak bildirildiğindeki işlevinden farklıdır!
static void foo(void)
{
    printf("foo() called!\n");
}

static fptr gf = &foo;  // Buradaki 'gf' adındaki değişken 'static' olarak tanımlanarak dış kaynak dosyalardan kullanıma kapatılmıştır.

// C kütüphenesinden dışarıya açılan ve global fonksiyon pointer'ı üzerinden fonksiyon çağrısı yapan 'func' fonksiyonu
void func(void)
{
    // ...

    gf();
}

// C kütüphenesinden dışarıya açılan ve 'func' fonksiyonunun davranışını değiştirmek için kullanılan 'set_func' fonksiyonu, geriye dönüş değeri 'gf' değişkeninin değeri olan fonksiyon adresidir, bu geriye dönüş değeri 'func' fonksiyonunun davranışının ilk haline döndürülebilmesi için kullanılıyor.
fptr set_func(fptr f)
{
    fptr fp = gf;
    gf = f;
    return fp;
}
```


👇 Aşağıda `main.c` dosyasının içeriği görülebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "neco.h"

void bar(void)
{
    printf("bar() called!\n");
}

int main(void)
{
    func(); // 'foo()' çağrılır.
    fptr f = set_func(&bar);
    func(); // 'bar()' çağrılır.

    set_func(f);
    func(); // 'foo()' çağrılır.
}
```


#### En Sık Kullanılan İkinci Yöntem 

Kuyruk ya da **stack veri yapısı** ile tutulan fonksiyonların belirli bir sırayla çağrılması yaklaşımı yöntemi.


👇 Aşağıdaki kodlar `neco.h` dosyasındadır.
```C
typedef void (*fptr)(void);

// Varsayılan davramış 'foo' adlı fonksiyonun çağırılmasıdır. 
void func(void);

fptr set_func(fptr);
```


👇 Aşağıdaki kodlar `neco.c` dosyasındadır.
```C
#define _CRT_SECURE_NO_WARNINGS

#include "neco.h"
#include <stdio.h>

#define MAX_REG_NUMBER 10

static fptr ga[MAX_REG_NUMBER]; // 'ga' değişkeni bir 'fonksiyon pointer' dizisidir.
static int ga_idx = 0;

void reg_func(fptr f)
{
    if(ga_idx == MAX_REG_NUMBER){
        return;
    }

    ga[ga_idx++] = f;
}

void func(void)
{
    // Kuyruk yapısına göre 'ga' dizisindeki fonksiyonların çağırılması işlemi
    //for(int i = 0; i < ga_idx; ++i){
    //    ga[i]();
    //}

    // Stack yapısına göre 'ga' dizisindeki fonksiyonların çağırılması işlemi
    for(int i = ga_idx - 1; i >= 0; --i){
        ga[i]();    
    }
}
```


👇 Aşağıda `main.c` dosyasının içeriği görülebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include "neco.h"
#include <stdio.>

void f1(void) { printf("f1 called!\n"); }
void f2(void) { printf("f1 called!\n"); }
void f3(void) { printf("f1 called!\n"); }
void f4(void) { printf("f1 called!\n"); }

int main(void)
{
    reg_func(f1);
    reg_func(f2);
    reg_func(f3);
    reg_func(f4);

    func();
}
```


## Multi Dimensional Arrays(Çok Boyutlu Diziler) 

❗❗❗ Bu konuda en güzel cümle şudur "Başlık **Çok Boyutlu Diziler**, C dilinde çok boyutlu dizi yoktur". Elemanı dizi olan dizilere çok boyutlu diziler denilmektedir, her ne kadar çok boyutlu dizi dense de gerçekte donanım üzerinde tek boyutlu dizi olarak tutulmaktadır.

Bu konunun yanlış anlaşılma ihtimali yüksek, bu nedenden dolayı iyi çalışılmalıdır.</br>
Diğer programlama dillerinde **Matrix** ya da **Multi Dimensional Array** denilen diziler esasında elemanları dizi olan dizilerdir.


👇 Aşağıdaki programda bazı tek boyutlu dizilerin ve elemanlarının türlerinin ne olduğu incelenebilir, buradaki bilgilerin iyi bilinmesi gerekiyor ki konunun sonraki kısımları iyi anlaşılabilsin.
```C
int main(void)
{
    int ary1[10]; // 'ary1' dizisinin elemanlarının türü 'int', 'ary1' nesnesinin(değişkeninin) türü 'int[5]' türüdür.
    double ary2[20]; // 'ary2' dizisinin elemanlarının türü 'double', 'ary2' nesnesinin(değişkeninin) türü 'double[20]' türüdür.
    int* ary3[7]; // 'ary3' dizisinin elemanlarının türü 'int*'. 'ary3' nesnesinin(değişkeninin) türü 'int*[7]' türüdür.
    int (*ary4[6])(int); // 'ary4' dizisinin elemanlarının türü 'int (*)(int)'. 'ary4' nesnesinin(değişkeninin) türü 'int (*[6])(int)' türüdür.
}
```


👇 Aşağıdaki programda iki boyutlu bir dizinin nasıl tanımlandığı incelenebilir.
```C
int main(void)
{
    int a1[5];

    // Elamanları 'a1'in türünden olan yani elemanlarının türü 'int[5]' türü olan yani her elemanı 5 elemanlı bir 'int' dizi adı olan adı 'x' olan 20 elemanlı bir dizi tanımı aşağıdaki gibidir.
    int x[20][5];
}
```



👇 Aşağıdaki programda tek boyutlu, iki boyutlu ve üç boyutlu dizilerle ilgili durumlar incelenebilir.
```C
int main(void)
{
    int a[5];
    int b[20][5]; // Burada 'b' dizisi elemanları beş elemanlı dizi olan 20 elemanlı dizidir.

    a[2]; // Buradaki ifadenin türü 'int' türüdür.
    b[13]; // Buradaki ifadenin türü 'int[5]' türüdür.

    // Aşağıdaki işlemler anlayamayan bir programcı çok boyutlu diziler konusunun diğer kısımlarını zaten anlayamayacaktır!
    int* p = a; // Burada sözdizim hatası(syntax error) olmamasının nedeni 'array to pointer conversion' işleminden dolayı 'a' dizi adının '&a[0]' ifadesine dönüştürülmesidir.
    int* p = b[3]; // Burada sözdizim hatası(syntax error) olmamasının nedeni 'array to pointer conversion' işleminden dolayı 'b[3]' dizi adının '&b[3][0]' ifadesine dönüştürülmesidir.

    int c[10][20][5]; // Burada bildirilen 'c' dizisi, elemanları 'int[20][5]' olan 10 elemanlı dizidir.
}
```


❗❗❗ Bir dizinin türü ne olursa olsun(burada dizinin boyutunun ne olduğunun önemi olmadığı vurgulanıyor) o dizinin elemanları bellekte ardışık olarak sıralanacaktır.



👇 Aşağıdaki programdaki `int b[4][5];` bildirimindeki `b` nesnesi program çalıştığında bellekte sıralı olacak şekilde dizilecektir, bu kısmı anlamak için görsel olarak konuyu anlatan kaynaklar araştırılabilir.
```C
int main(void)
{
    int a[5];
    int b[4][5]; // Burada 'b' dizisi elemanları beş elemanlı dizi olan 4 elemanlı dizidir ve 32 bitlik mimaride bellekte sıralı olarak '4 * 5 * 4 byte' alan kaplayacaktır.
}
```



👇 Aşağıdaki programda bazı çok boyutlu dizilerin nasıl tanımlanabileceği incelenebilir.
```C
int main(void)
{
    // Elemanları 'double[4]' türünden olan 10 elemanlı bir dizi aşağıdaki gibi tanımlanabilir.
    double ary1[10][4];

    // Elemanları 'int* [5]' türünden olan 21 elemanlı bir dizi aşağıdaki gibi tanımlanabilir.
    int* ary2[21][5];
}
```



👇 Aşağıdaki programda çok boyutlu dizilerde bazı ifadelerin bellekte kaplayacağı byte değerinin ne olacağı incelenebilir(32 bitlik sistemde).
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int a[4][8] = { 0 };

    printf("sizeof(a) = %zu\n", sizeof(a)); // Burada standart çıktı akımına 'sizeof(a) = 128' değeri gönderilir. 128 değeri şu hesaplamadan geliyor => '4 * 8 * sizeof(int)'
    printf("sizeof(a[0]) = %zu\n", sizeof(a[0])); // Burada standart çıktı akımına 'sizeof(a[0]) = 32' değeri gönderilir. 32 değeri şu hesaplamadan geliyor => '8 * sizeof(int)'
    printf("sizeof(a[0][0]) = %zu\n", sizeof(a[0][0])); // Burada standart çıktı akımına 'sizeof(a[0][0]) = 4' değeri gönderilir. 4 değeri şu hesaplamadan geliyor => 'sizeof(int)'
}
```



👇 Aşağıdaki programda önceden yazılmış olan `randomize`, `set_array_random`, `print_array` adlı `nutility.h` başlık dosyasında bulunan fonksiyonların çok boyutlu bir dizide nasıl kullanılabileceği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[4][8] = { 0 };

    randomize();
    set_array_random(a[2], 8);
    print_array(a[2], 8);
}
```

### Multi Dimensional Arrays Initialization(Çok Boyutlu Dizilere İlk Değer Verilmesi) 



👇 Aşağıdaki programda iki boyutlu bir diziye nasıl ilk değer verildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[5][4] = { 
        {1, 2, 3, 1},
        {9, 0, 3, 2},
        {4, 9, 1, 0},
        {5, 6, 3, 7},
        {4, 2, 9, 4},
    };

    for(int i = 0; i < 5; ++i){
        for(int k = 0; k < 4; ++k){
            printf("%d ", a[i][k]);
        }
        printf("\n");
    }
}
```



👇 Aşağıdaki programda iki boyutlu bir diziye ilk değer verirken değer verilmeyen dizi elemanlarının ilk değerinin 0 olacağı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[5][4] = { 
        {1, 2, 3, 1},
        {9, 0, },
        {4, 9, 1, 0},
        {5,},
        {4, 9, 4},
    };

    for(int i = 0; i < 5; ++i){
        for(int k = 0; k < 4; ++k){
            printf("%d ", a[i][k]);
        }
        printf("\n");
    }
}
```



👇 Aşağıdaki programda iki boyutlu bir diziye ilk değer verirken değer verilmeyen dizi elemanlarının ilk değerinin 0 olacağı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
     int a[5][4] = { 
        {1, 2, 3, 1},
        {9, 0, 3, 2},
        {4, 9, 1, 0},
    };

    for(int i = 0; i < 5; ++i){
        for(int k = 0; k < 4; ++k){
            printf("%d ", a[i][k]);
        }
        printf("\n");
    }
}
```



👇 Aşağıdaki programda iki boyutlu bir diziye ilk değer verirken göze garip gelen bir yöntemle nasıl dizinin elemanlarına ilk değer verileceği incelenebilir. Buradaki ilk değer verme **sözdiziminin(syntax)** kullanılması kodun niyetini belirtmediği için çok tercih edilmemelidir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
    // Aşağıdaki kullanım legal'dir ama kullanımı açık değildir yani okunaklı değil(hangi değer dizinin hangi elemanı belli değil).
    int a[5][4] = { 
        1, 2, 3, 1, 9, 0, 3, 2, 4, 9, 1, 0,
    };

    for(int i = 0; i < 5; ++i){
        for(int k = 0; k < 4; ++k){
            printf("%d ", a[i][k]);
        }
        printf("\n");
    }
}
```



👇 Aşağıdaki programda C diline C99 standardı ile eklenen "**Designated Initializer**" sözdizimi(syntax) ile tek boyutlu bir diziye nasıl ilk değer verildiği incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a1[10]= { [3] = 5, [7] = 2, [1] = 6 };

    int a2[]= { [3] = 5, [7] = 2, [1] = 6 }; // Buradaki gibi dizinin eleman sayısı verilmeden de 'Designated Initializer' yöntemiyle dizi tanımlanabilir.
}
```



👇 Aşağıdaki programda çok boyutlu bir dizide "**Designated Initializer**" sözdizimiyle(syntax) nasıl ilk değer verildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
     int a[5][4] = { 
        [3] = {1, 2, 3, 1},
    };

    for(int i = 0; i < 5; ++i){
        for(int k = 0; k < 4; ++k){
            printf("%d ", a[i][k]);
        }
        printf("\n");
    }
}
```



👇 Aşağıdaki programda çok boyutlu bir dizide "**Designated Initializer**" sözdizimiyle(syntax) nasıl ilk değer verildiği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

int main(void)
{
     int a[5][4] = { 
        [3] = {1, 2, 3, 1},
        [1] = { [2] = 7 }
    };

    for(int i = 0; i < 5; ++i){
        for(int k = 0; k < 5; ++k){
            printf("%d ", a[i][k]);
        }
        printf("\n");
    }
}
```



👇 Aşağıdaki programda çok boyutlu bir dizide ilk değer verilmediğinde ne olacağı incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
     int ary1[5][4]; // Burada 'ary1' dizisi yaşamına 'indetermined value(garbage value)' ile başlayacaktır.
     static int ary2[5][4]; // Burada 'ary2' dizisi yaşamına tüm elemanları '0' değerinde başlar.
}
```



👇 Aşağıdaki programda C dilini yeni öğrenenlerin çok sık yaptığı çok boyutlu dizilerle ilgili hatalı bir durum incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[4][5] = { 0 };

    int* p = a; // Buradaki ilk değer verme sözdizimi hatası(syntax error), hatalı olmasının nedeni 'a' değişkeninin 'array decay' ile '&a[0]' ifadesine çevrilmesidir, bu ifade 'int(*)[5]' türündedir ve tür uyuşmazlığından dolayı buradaki atama işlemi doğru değildir. C++ dilinde sözdizim hatasıdır(syntax error), C dilinde derleyiciler uyarı verir.

    int* p1 = a[0]; // Buradaki ilk değer verme işlemi doğrudur, 'a[0]' ifadesi 'array decay' ile '&a[0][0]' ifadesine çevrilir.

    // ptr, a'nın elemanının gösterecek bir pointer olsun
    // a'nın ilk elemanını gösteriyor olsun.
    int(*ptr)[5] = a; // Buradaki atama işlemi doğrudur.
}
```



❗❗❗ 👇 Aşağıdaki programda tek boyutlu bir dizinin adı üzerinden oluşturulan ifadelerin türlerinin ne olacağı incelenebilir. Buradaki bilgilerin bilinmesi önemlidir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[5] = { 10, 20, 30, 40, 50 };

    int (*p)[5] = &a; // Buradaki 'p' göstericisinin türü 'int(*)[5]' türüdür.

    // 'a' değişkeninin türü 'int[5]' türüdür.
    // 'a' ifadesinin türü 'array decay'den dolayı 'a' ifadesi '&a[0]' ifadesine çevrileceğinden ve bu ifadenin de türünün 'int*' olmasından dolayı 'int*' türüdür.
    // '&a' ifadesinin türü 'int (*)[5]' türüdür.

    // '*p' ifadesi 'a' ifadesine eşittir ve '*p' ifadesi üzerinden 'a' dizisi gezilebilir. 
    for(int i = 0; i < 5; ++i){
        printf("%d ", (*p)[i]); // Burada '*p' ifadesinin paranteze alınmasının nedeni '[]' operatörünün 'dereferencing' operatötünden daha yüksek önceliğe sahip olmasıdır, '*p[i]' böyle yazarsak derleyici '*(p + i)' olarak yorumlayacaktır ama biz bunu istemiyoruz ve bu 'ub' durumuna neden olur.
    }
}
```



👇 Aşağıdaki programda `int` türünden elemanları olan tek boyutlu bir dizinin kendi adı ile oluşturulan ifadelerin türleri ve bellek boyutlarının ne olacağı incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[4] = { 10, 20, 30, 40 };

    printf("%p  %p  %p\n", a, a + 1, a + 2);

    printf("%p  %p  %p\n", &a, &a + 1, &a + 2);

    /*
    
    'a' ifadesi '&a[0]' ifadesine denktir ve bellek boyutu 'sizeof(int)'
    '&a' ifadesi 'int (*)[4]' ifadesine denktir ve bellek boyutu 'sizeof(a)'
    
    */
}
```



👇 Aşağıdaki programda iki boyutlu bir dizinin adresi üzerinden oluşturulan ifadelerde pointer aritmetiğinin nasıl olduğu incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[10][4];

    for(int i = 0; i < 10; ++i){
        printf("%p  %p\n", &a[0] + i, a + i); // İki ifade de aynı adrese karşılık gelmektedir.
    }
}
```



👇 Aşağıdaki programda iki boyutlu bir dizinin adresi üzerinden oluşturulan ifadelerde pointer aritmetiğinin nasıl olduğu incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[10][4];
    int (*ptr)[4] = a; // Buradaki 'a' ifadesi 'array to pointer conversion' nedeniyle 

    for(int i = 0; i < 10; ++i){
        printf("%p  %p  %p\n", &a[0] + i, a + i, ptr); // Üç ifade de aynı adrese karşılık gelmektedir.
        ++ptr;
    }
}
```



👇 Aşağıdaki programda iki boyutlu bir dizinin adı üzerinden pointer değişkenlere nasıl değer atanabileceği incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[10][4];
    int (*p1)[4] = a; // 'p1' adındaki göstericinin türü 'int(*)[4]' türüdür.
    int (*p2)[4] = &a[0]; // 

    // 'a' dizisini ilk elemanının ilk elemanının adresinin nasıl tutulacağı aşağıdan incelenebilir.
    int* ptr = a[0][0];
}
```



👇 Aşağıdaki programda iki boyutlu bir dizinin adı üzerinden oluşturulan ifadelerin nasıl kullanıldığı incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[10][4] = { { 2, 5, 7, 9 } };

    int* p1 = &a[0][0];
    printf("%d\n", *p1);

    int* p2 = a[0]; // Burada 'array decay' işleminden dolayı 'p2' değişkenine '&a[0][0]' değeri ilk değer olarak veriliyor ve buradaki ilklendirme işlemi doğrudur.
    printf("%d\n", *p2);

    int* p3 = a; // Buradaki ilk değer verme deyimi(statement) doğru bir kullanım değildir çünkü 'a' değişkeninin türü 'int (*)[4]' türüdür ve 'int*' türüne örtülü olarak tür dönüşümü yapılmak isteniyor. C++ dilinde burada sözdizim hatası(syntax error) oluşur.
}
```



> Derse katılanlardan biri şu şeklide yorum yaptı => "Yani sayisal degerler ve hafizadaki konumlanma ayni ama türler mi farkli sadece", bu cümleyle ifade edilen düşünce doğrudur.



👇 Aşağıdaki programda iki boyutlu bir dizinin adı üzerinden oluşturulan ifadelerin türlerinin ne olacağı incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[10][4] = { { 2, 5, 7, 9, } };

    printf("%p\n", &a); // '&a' ifadesinin türü 'int (*)[10][4]' türüdür.
    printf("%p\n", a); // 'a' ifadesi 'arrat decay' ile '&a[0]' ifadesine çevrilir ve türü 'int (*)[4]' türüdür.
    printf("%p\n", &a[0]); // '&a[0]' ifadesinin türü 'int (*)[4]' türüdür.
    printf("%p\n", &a[0][0]); // '&a[0][0]' ifadesinin türü 'int*' türüdür.
}
```



👇 Aşağıdaki programda iki boyutlu dizinin elemanlarına nasıl erişildiği ve işlem yapıldığı incelenebilir. Buradaki programı on kişiden dokuzu anlayamıyormuş.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[5][4] = { 
        {1, 1, 1, 1},
        {2, 2, 2, 2},
        {3, 3, 3, 3},
        {4, 4, 4, 4},
        {5, 5, 5, 5},
    };

    ++**a; // Bu ifade '++(*(*a))' bu ifadeye denktir ve bu ifade 'a' dizisinin ilk elemanının ilk elemanına erişir ve o nesnenin değerini bir arttırır.
    
    for(int i = 0; i < 5; ++i){
        for(int k = 0; k < 4; ++k)
            printf("%d", a[i][k]);

        printf("\n");
    }
}
```



👇 Aşağıdaki programda iki boyutlu dizinin elemanlarına nasıl erişildiği ve işlem yapıldığı incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[5][4] = { 
        {1, 1, 1, 1},
        {2, 2, 2, 2},
        {3, 3, 3, 3},
        {4, 4, 4, 4},
        {5, 5, 5, 5},
    };

    int (*p)[4] = a;
    
    ++**p;
    
    for(int i = 0; i < 5; ++i){
        for(int k = 0; k < 4; ++k)
            printf("%d", a[i][k]);

        printf("\n");
    }
}
```



👇 Aşağıdaki programda iki boyutlu dizinin elemanlarına nasıl erişildiği ve işlem yapıldığı incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[5][4] = { 
        {1, 1, 1, 1},
        {2, 2, 2, 2},
        {3, 3, 3, 3},
        {4, 4, 4, 4},
        {5, 5, 5, 5},
    };

    int (*p)[4] = a;
    
    ++p; // Bu pointer aritmetiği işlemiyle 'p' göstericisi 'a' dizisinin ikinci elemanının adresini işaret edecektir.
    ++**p; // Burada 'p'nin gösterdiği dizinin ilk elemanının değeri bir arttırılıyor.
    
    for(int i = 0; i < 5; ++i){
        for(int k = 0; k < 4; ++k)
            printf("%d", a[i][k]);

        printf("\n");
    }
}
```



👇 Aşağıdaki programda iki boyutlu dizinin elemanlarına nasıl erişildiği ve işlem yapıldığı incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[5][4] = { 
        {1, 1, 1, 1},
        {2, 2, 2, 2},
        {3, 3, 3, 3},
        {4, 4, 4, 4},
        {5, 5, 5, 5},
    };

    int (*p)[4] = a;
    
    ++p; // Bu pointer aritmetiği işlemiyle 'p' göstericisi 'a' dizisinin ikinci elemanının adresini işaret edecektir.
    ++(*p)[2]; 

    for(int i = 0; i < 5; ++i){
        for(int k = 0; k < 4; ++k)
            printf("%d", a[i][k]);

        printf("\n");
    }
}
```


>❔
> 
> Sorulan soru; 
> 
> *p yi ifadede kullandigimda errray decay olmasini bekliyorum sanki
> 
> Cevap;
> 
> Evet öyle oluyor zaten.



👇 Aşağıdaki programda iki boyutlu dizinin elemanlarına nasıl erişildiği ve işlem yapıldığı incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[5][4] = { 
        {1, 1, 1, 1},
        {2, 2, 2, 2},
        {3, 3, 3, 3},
        {4, 4, 4, 4},
        {5, 5, 5, 5},
    };

    // Aşağıdaki üç ilk değer verme işlemi de aynı anlama gelmektedir.  
    int* p1 = &a[0][0];
    int* p2 = a[0];
    int* p3 = (int*)a; // Burada açık şekilde 'int(*)[4]' türünden 'int*' türüne tür dönüşümü yapılıyor, buradaki işlem legal ve 'wellform'dur.
    
    // Aşağıdaki pointer işlemlerinin hepsi aynı işlemi yapmaktadır ve yapılan işlem ise 'a' dizisinin ilk elemanının ilk elemanının değerinin bir arttırılmasıdır.
    ++*p1;
    ++*p2;
    ++*p3;

    for(int i = 0; i < 5; ++i){
        for(int k = 0; k < 4; ++k)
            printf("%d", a[i][k]);

        printf("\n");
    }
}
```



👇 Aşağıdaki programda iki boyutlu bir dizinin tek boyutlu diziymiş gibi kullanılabileceği incelenebilir(bunun nedeni kaç boyutlu olursa olsun dizi elemanlarının hepsinin bellekte sıralı olarak bulunmasıdır).
```C
#include <stdio.h>
#include "nutility.h"

int main(void)
{
    int a[5][4] = { 
        {1, 1, 1, 1},
        {2, 2, 2, 2},
        {3, 3, 3, 3},
        {4, 4, 4, 4},
        {5, 5, 5, 5},
    };
    
    int* p = &a[0][0];
    int n = 5 * 4;

    while(n--){
        printf("%d", *p++);
        (void)getchar();
    }
}
```


***
==================================================

✦✦✦✦✦ 11.02-11.24 birinci ara verildi. ✦✦✦✦✦

==================================================
***


Neden bir diziyi bir fonksiyona geçiyoruz diye düşünülürse, bunun yapılmasının nedeni dizi üzerinde işlem yapmak içindir.


👇 Aşağıdaki programda çok boyutlu dizilerin kullanımı incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

// 'int (*p)[4]' bir türdür ve bu türdeki '[4]' kısmı eleman sayısı değildir, tür bilgisinin bir bileşenidir.
void print_m(const int (*p)[4], int size)
{
    for(int i = 0; i < size; ++i){
        for(int k = 0; k < size; ++k){
            printf("%d ", p[i][k]);
        }
        printf("\n");
    }
}

int main(void)
{
    int ary[5][4] = { 
        {1, 1, 1, 1},
        {2, 2, 2, 2},
        {3, 3, 3, 3},
        {4, 4, 4, 4},
        {1, 1, 1, 1},
    };

    // Aşağıdaki iki fonksiyon çağrısı da birbirine denktir.
    print_m(ary, 5); // 'ary' dizisinin ilk elemanının adresi 'print_m' fonksiyonuna geçiliyor.
    printf("~~~~~~~~~~~~~~~~~~~~/n");
    print_m(&ary[0], 5); // 'ary' dizisinin ilk elemanının adresi 'print_m' fonksiyonuna geçiliyor.
}
```



👇 Aşağıdaki programda çok boyutlu dizilerin kullanımı incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

// 'int (*p)[4]' bir türdür ve bu türdeki '[4]' kısmı eleman sayısı değildir, tür bilgisinin bir bileşenidir.
void print_m(const int (*p)[4], int size)
{
    ptintf("sizepf(p) = %zu\n", sizepf(p));
    ptintf("sizepf(*p) = %zu\n", sizepf(*p));

    for(int i = 0; i < size; ++i){
        for(int k = 0; k < size; ++k){
            printf("%d ", p[i][k]);
        }
        printf("\n");
    }
}

int main(void)
{
    int a[5][4] = { 
        {1, 1, 1, 1},
        {2, 2, 2, 2},
        {3, 3, 3, 3},
        {4, 4, 4, 4},
        {1, 1, 1, 1},
    };

    int (*p)[4] = a;

    ptintf("sizepf(p) = %zu\n", sizepf(p)); // Burada 32 bit sistemde standar çıktıya 'sizepf(p) = 4\n' gönderilir çünkü 'p' ifadesi 'int (*)[4]' türünden bir pointer değişlendir.
    ptintf("sizepf(*p) = %zu\n", sizepf(*p)); // Burada 32 bit sistemde standar çıktıya 'sizepf(p) = 16\n' gönderilir çünkü '*p' ifadesi 'int[4]' türünden bir dizidir.
    ptintf("sizepf(**p) = %zu\n", sizepf(**p)); // Burada 32 bit sistemde standar çıktıya 'sizepf(p) = 4\n' gönderilir çünkü '**p' ifadesi 'int' türünden bir dizidir.
}
```



👇 Aşağıdaki programda çok boyutlu dizilerin kullanımı incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

// 'int (*p)[4]' bir türdür ve bu türdeki '[4]' kısmı eleman sayısı değildir, tür bilgisinin bir bileşenidir.
void print_m(const int (*p)[4], int size)
{
    for(int i = 0; i < size; ++i){
        for(int k = 0; k < size; ++k){
            printf("%d ", p[i][k]);
        }
        printf("\n");
    }
    printf("~~~~~~~~~~~~~~~~~~~~/n");
}

int main(void)
{
    int a[5][4] = { 
        {1, 1, 1, 1},
        {2, 2, 2, 2},
        {3, 3, 3, 3},
        {4, 4, 4, 4},
        {1, 1, 1, 1},
    };

    int (*p)[4] = a;

    // Aşağıdaki üç fonksiyon çağrısı aynı anlama gelmektedir ve bu üç çağrıda herhengi bir hata yoktur.
    print_m(a, 5);
    print_m(&a[0], 5);
    print_m(p, 5);

    // Aşağıdaki iki fonksiyon çağrılarısında fonksiyona geçilen pointer adreslerinin türü fonksiyonun parametre türüyle uyuşmamaktadır.
    // Aşağıdaki iki fonksiyon çağrısı için C dilinde derleyici uyarı verecektir ama C++ dilinde sözdizim hatasıdır(syntax error), uyarıyı kaldırmak ya da sözdizim hatasını(syntax error) önlemek için açık şekilde tür dönüşümü yapılmalıdır.
    // Aşağıdaki iki fonksiyon çağrısında tür uyuşmazlığı olsa da fiziksel adresler aynı olduğu için C dilinde doğru şekilde çalışacaktır!
    print_m(&a[0][0], 5);
    print_m(&a, 5); // Bu kod C++ dilinde sözdizim hatasıdır(syntax error) ama C dilinde derleyici sadece uyarı verecektir.
}
```



👇 Aşağıdaki programda çok boyutlu dizilerin kullanımı incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

// 'int (*p)[4]' bir türdür ve bu türdeki '[4]' kısmı eleman sayısı değildir, tür bilgisinin bir bileşenidir.
void print_m(const int (*p)[4], int size)
{
    for(int i = 0; i < size; ++i){
        for(int k = 0; k < size; ++k){
            printf("%d ", p[i][k]);
        }
        printf("\n");
    }
    printf("~~~~~~~~~~~~~~~~~~~~/n");
}

int main(void)
{
    int a[5][4] = {
        {1, 1, 1, 1},
        {2, 2, 2, 2},
        {3, 3, 3, 3},
        {4, 4, 4, 4},
        {1, 1, 1, 1},
    };

    int* p = &a[0][0];

    print_m((int(*)[4])p, 5); // Burada 'p' object pointer değişkeni tür değiştirme operatörü ile fonksiyonun parametre türüne dönüştürülüyor, burada uyarı iletisi ya da sözdizim hatası(syntax error) oluşmayacaktır.
}
```



👇 Aşağıdaki programda çok boyutlu dizilerin kullanımı incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

// 'int (*p)[4]' bir türdür ve bu türdeki '[4]' kısmı eleman sayısı değildir, tür bilgisinin bir bileşenidir.
//void print_m(const int (*p)[4], int size)
//{
//    for(int i = 0; i < size; ++i){
//        for(int k = 0; k < size; ++k){
//            printf("%d ", p[i][k]);
//        }
//        printf("\n");
//    }
//    printf("~~~~~~~~~~~~~~~~~~~~/n");
//}

void print_m(const int (*p)[4], int size)
{
    // '*p' demek 'p[0]' demektir.
    //++p; // Burada 'a' dizisinin ikinci 'int[4]' türünden elemanının adresi işaret edilir duruma gelecektir.

    while(size--){
        for(int i = 0; i < 4; ++i){
            printf("%d ", (*p)[i]); // Buradaki '(*p)[i]' ifadesi ile 'p' pointer parametrenin işaret ettiği 'int(*)[4]' türünden nesnenin elemanlarına sırasıyla erişiliyor.
        }

        ++p;
        printf("\n");
    }

    printf("~~~~~~~~~~~~~~~~~~~\n");
}

int main(void)
{
    int a[5][4] = { 
        {1, 1, 1, 1},
        {2, 2, 2, 2},
        {3, 3, 3, 3},
        {4, 4, 4, 4},
        {1, 1, 1, 1},
    };

    print_m(a, 5);
}
```



👇 Aşağıdaki programda çok boyutlu dizilerin kullanıldığı `print_m` fonksiyonlarınının hepsi aynı işi yapmaktadır, bunun bu zamana kadar alınan derslerden dolayı kolayca anlaşılıyor olması gerekir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

// 'int (*p)[4]' bir türdür ve bu türdeki '[4]' kısmı eleman sayısı değildir, tür bilgisinin bir bileşenidir.
//void print_m(const int (*p)[4], int size)
//{
//    for(int i = 0; i < size; ++i){
//        for(int k = 0; k < size; ++k){
//            printf("%d ", p[i][k]);
//        }
//        printf("\n");
//    }
//    printf("~~~~~~~~~~~~~~~~~~~~/n");
//}

void print_m_v1(const int (*p)[4], int size)
{
    for(int i = 0; i < size; ++i){
        print_array(*p, 4);
        ++p;
        printf("\n");
    }

    printf("~~~~~~~~~~~~~~~~~~~\n");
}

void print_m_v2(const int (*p)[4], int size)
{
    while(size--)
        print_array(*p++, 4);
    
    printf("~~~~~~~~~~~~~~~~~~~\n");
}

int main(void)
{
    int a[5][4] = { 
        {1, 1, 1, 1},
        {2, 2, 2, 2},
        {3, 3, 3, 3},
        {4, 4, 4, 4},
        {1, 1, 1, 1},
    };

    print_m(a, 5);
}
```



👇 Aşağıdaki programda çok boyutlu dizileri yeni öğrenenlerin zorlandığı çok boyutlu dizilerin türlerinin anlaşılabilmesi için incelenebilir. </br>
Birbirine benzer işlemleri farklı dizi türleri için yapan kodları da birbirine benzer olan fonksiyonların tanımları ve bu fonksiyonlara yapılan çağrılar incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

// Aşağıdaki fonksiyonun adı "Print Ramdom Matrisks" sözcüklerinden gelmektedir.
// Aşağıdaki fonksiyon 'int(*)[8]' türünden pointer olarak aldığı parametredeki dizinin elemanlarını standar çıktı akımına göndermektedir.
void print_rm8(const int (*p)[8], int size)
{
    for(int i = 0; i < size; ++i){
        for(int k = 0; k < 8; ++k)
            printf("%d", p[i][k]);
        printf("\n");
    }
    printf("~~~~~~~~~~~~~~~~\n");
}

// Aşağıdaki fonksiyonun adı "Set Ramdom Matrisks" sözcüklerinden gelmektedir.
// Aşağıdaki fonksiyon 'int(*)[8]' türünden pointer olarak aldığı parametredeki dizinin elemanlarına rastgele değerler atamaktadır.
void set_rm8(int (*p)[8], int size)
{
    for(int i = 0; i < size; ++i){
        for(int k = 0; k < 8; ++k)
            p[i][k] = rand() % 10;
    }
}


// Aşağıdaki fonksiyonun adı "Print Ramdom Matrisks" sözcüklerinden gelmektedir.
// Aşağıdaki fonksiyon 'int(*)[5]' türünden pointer olarak aldığı parametredeki dizinin elemanlarını standar çıktı akımına göndermektedir.
void print_rm5(const int (*p)[5], int size)
{
    for(int i = 0; i < size; ++i){
        for(int k = 0; k < 5; ++k)
            printf("%d", p[i][k]);
        printf("\n");
    }
    printf("~~~~~~~~~~~~~~~~\n");
}

// Aşağıdaki fonksiyonun adı "Set Ramdom Matrisks" sözcüklerinden gelmektedir.
// Aşağıdaki fonksiyon 'int(*)[5]' türünden pointer olarak aldığı parametredeki dizinin elemanlarına rastgele değerler atamaktadır.
void set_rm5(int (*p)[5], int size)
{
    for(int i = 0; i < size; ++i){
        for(int k = 0; k < 5; ++k)
            p[i][k] = rand() % 10;
    }
}



// Aşağıdaki fonksiyonun adı "Print Ramdom Matrisks" sözcüklerinden gelmektedir.
// Aşağıdaki fonksiyon 'int(*)[10]' türünden pointer olarak aldığı parametredeki dizinin elemanlarını standar çıktı akımına göndermektedir.
void print_rm10(const int (*p)[10], int size)
{
    for(int i = 0; i < size; ++i){
        for(int k = 0; k < 10; ++k)
            printf("%d", p[i][k]);
        printf("\n");
    }
    printf("~~~~~~~~~~~~~~~~\n");
}

// Aşağıdaki fonksiyonun adı "Set Ramdom Matrisks" sözcüklerinden gelmektedir.
// Aşağıdaki fonksiyon 'int(*)[10]' türünden pointer olarak aldığı parametredeki dizinin elemanlarına rastgele değerler atamaktadır.
void set_rm10(int (*p)[10], int size)
{
    for(int i = 0; i < size; ++i){
        for(int k = 0; k < 10; ++k)
            p[i][k] = rand() % 10;
    }
}

int main(void)
{
    // Aşağıdaki dört dizi dizi bildirilmiştir ve üç farklı dizi türü vardır, 'a' ve 'd' dizilerinin elemanlarının türü('int[8]' türü) aynıdır. 
    int a[4][8]; // 'a' dizisi'int[4][8]' türündedir ve elemanları 'int[8]' türünden olan 4 elemanlı bir dizidir. Bu dizi 'int x[32]' dizisiymiş gibi kullanılabilir.
    int b[10][5]; // 'b' dizisi'int[10][5]' türündedir ve elemanları 'int[5]' türünden olan 10 elemanlı bir dizidir. Bu dizi 'int x[50]' dizisiymiş gibi kullanılabilir.
    int c[6][10]; // 'c' dizisi 'int[6][10]' türündedir ve elemanları 'int[10]' türünden olan 6 elemanlı bir dizidir. Bu dizi 'int x[60]' dizisiymiş gibi kullanılabilir.
    int d[5][8]; // 'd' dizisi 'int[5][8]' türündedir ve elemanları 'int[8]' türünden olan 5 elemanlı bir dizidir. Bu dizi 'int x[40]' dizisiymiş gibi kullanılabilir.

    randomize();
    
    set_rm8(a, 4);
    set_rm8(d, 4);
    print_rm8(a, 4);
    print_rm8(d, 4);


    set_rm5(b, 10);
    print_rm5(b, 10);


    set_rm10(c, 6);
    print_rm10(c, 6);
}
```



👇 Aşağıdaki programda bir önceki programda yazılmış olan fonksiyonları genel(generic) olarak nasıl yazılabileceği incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

// Temel elemanlarının türü 'int' türünden olan iki boyutlu bir dizinin elemanlarına rastgele değer atayan fonksiyon.
void set_matrix(int* p, int row, int col)
{
    for(int i = 0; i < row; ++i){
        for(int k = 0; k < col; ++k)
             p[i * col + k] = rand() % 10;
    }
}

// Temel elemanlarının türü 'int' türünden olan iki boyutlu bir dizinin elemanlarını 'standard output'a gönderen fonksiyon.
void print_matrix(const int* p, int row, int col)
{
    for(int i = 0; i < row; ++i){
        for(int k = 0; k < col; ++k)
            printf("%d", p[i * col + k]);
        printf("\n"); 
    }

    printf("~~~~~~~~~~~~~~~~\n");
}

int main(void)
{
    // Aşağıdaki dört dizi dizi bildirilmiştir ve üç farklı dizi türü vardır, 'a' ve 'd' dizilerinin elemanlarının türü('int[8]' türü) aynıdır. 
    int a[4][8]; // 'a' dizisi'int[4][8]' türündedir ve elemanları 'int[8]' türünden olan 4 elemanlı bir dizidir. Bu dizi 'int x[32]' dizisiymiş gibi kullanılabilir.
    int b[10][5]; // 'b' dizisi'int[10][5]' türündedir ve elemanları 'int[5]' türünden olan 10 elemanlı bir dizidir. Bu dizi 'int y[50]' dizisiymiş gibi kullanılabilir.
    int c[6][10]; // 'c' dizisi 'int[6][10]' türündedir ve elemanları 'int[10]' türünden olan 6 elemanlı bir dizidir. Bu dizi 'int z[60]' dizisiymiş gibi kullanılabilir.
    int d[5][8]; // 'd' dizisi 'int[5][8]' türündedir ve elemanları 'int[8]' türünden olan 5 elemanlı bir dizidir. Bu dizi 'int t[40]' dizisiymiş gibi kullanılabilir.

    randomize();
    
    // Aşağıdaki fonksiyon çağrılarında C++ dilinde senteks hatası ve C dilinde derleyici uyarı iletisi verecektir.
    set_matrix(a, 4, 8);
    set_matrix(b, 10, 5);
    set_matrix(c, 6, 10);
    set_matrix(d, 5, 8);

    print_matrix(a, 4, 8);
    print_matrix(b, 10, 5);
    print_matrix(c, 6, 10);
    print_matrix(d, 5, 8);


    // Aşağıdaki fonksiyon çağrılarında C derleyicisi uyarı iletisi vermeyecektir çünkü 'a[0]' ifadesi 'array decay' iel '&a[0][0]' ifadesine çevrilecektir ve '&a[0][0]' ifadesinin türü 'int*' türüdür.
    set_matrix(a[0], 4, 8);
    set_matrix(b[0], 10, 5);
    set_matrix(c[0], 6, 10);
    set_matrix(d[0], 5, 8);
    
    print_matrix(a[0], 4, 8);
    print_matrix(b[0], 10, 5);
    print_matrix(c[0], 6, 10);
    print_matrix(d[0], 5, 8);


    // Aşağıdaki fonksiyon çağrılarında C derleyicisi uyarı iletisi vermeyecektir çünkü '&a[0][0]' ifadesinin türü 'int*' türüdür.
    set_matrix(&a[0][0], 4, 8);
    set_matrix(&b[0][0], 10, 5);
    set_matrix(&c[0][0], 6, 10);
    set_matrix(&d[0][0], 5, 8);
    
    print_matrix(&a[0][0], 4, 8);
    print_matrix(&b[0][0], 10, 5);
    print_matrix(&c[0][0], 6, 10);
    print_matrix(&d[0][0], 5, 8);


    // Aşağıdaki fonksiyon çağrılarında C derleyicisi uyarı iletisi ve C++ dili sözdizim hatası(syntax error) vermeyecektir çünkü tür dönüşümü yapılıyor.
    set_matrix((int*)a, 4, 8);
    set_matrix((int*)b, 10, 5);
    set_matrix((int*)c, 6, 10);
    set_matrix((int*)d, 5, 8);

    print_matrix((int*)a, 4, 8);
    print_matrix((int*)b, 10, 5);
    print_matrix((int*)c, 6, 10);
    print_matrix((int*)d, 5, 8);
}
```



👇 Aşağıdaki programda bir önceki programda yazılmış olan fonksiyonları genel(generic) olarak nasıl yazılabileceği incelenebilir ama buradaki yöntemde tür bilgisi kaybedildiği için kullanımda **ub** durumları oluşabilmektedir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include "nutility.h"

// Aşağıdaki gibi 'void*' türünden parametre alan fonksiyon tanımlandığında tür bilgisi ortadan kaldırıldığı için sözdizim kontrolü(syntax control) zorlaşacaktır çünkü tür bilgisini ortadan kaldırmış olduk.
void set_matrix(void* vp, int row, int col)
{
    int* p = (int*)vp;

    for(int i = 0; i < row; ++i){
        for(int k = 0; k < col; ++k)
             p[i * col + k] = rand() % 10;
    }
}

// Aşağıdaki gibi 'void*' türünden parametre alan fonksiyon tanımlandığında tür bilgisi ortadan kaldırıldığı için sözdizim kontrolü(syntax control) zorlaşacaktır çünkü tür bilgisini ortadan kaldırmış olduk.
void print_matrix(const void* vp, int row, int col)
{
    const int* p = (const int*)vp;

    for(int i = 0; i < row; ++i){
        for(int k = 0; k < col; ++k)
            printf("%d", p[i * col + k]);
        printf("\n"); 
    }

    printf("~~~~~~~~~~~~~~~~\n");
}


int main(void)
{
    // Aşağıdaki dört dizi dizi bildirilmiştir ve üç farklı dizi türü vardır, 'a' ve 'd' dizilerinin elemanlarının türü('int[8]' türü) aynıdır. 
    int a[4][8]; // 'a' dizisi'int[4][8]' türündedir ve elemanları 'int[8]' türünden olan 4 elemanlı bir dizidir. Bu dizi 'int x[32]' dizisiymiş gibi kullanılabilir.
    int b[10][5]; // 'b' dizisi'int[10][5]' türündedir ve elemanları 'int[5]' türünden olan 10 elemanlı bir dizidir. Bu dizi 'int y[50]' dizisiymiş gibi kullanılabilir.
    int c[6][10]; // 'c' dizisi 'int[6][10]' türündedir ve elemanları 'int[10]' türünden olan 6 elemanlı bir dizidir. Bu dizi 'int z[60]' dizisiymiş gibi kullanılabilir.
    int d[5][8]; // 'd' dizisi 'int[5][8]' türündedir ve elemanları 'int[8]' türünden olan 5 elemanlı bir dizidir. Bu dizi 'int t[40]' dizisiymiş gibi kullanılabilir.

    randomize();
    
    // Aşağıdaki işlemlerde C++ senteks hatası C derleyicileri de uyarı iletisi verecektir.
    set_matrix(a, 4, 8);
    set_matrix(b, 10, 5);
    set_matrix(c, 6, 10);
    set_matrix(d, 5, 8);

    print_matrix(a, 4, 8);
    print_matrix(b, 10, 5);
    print_matrix(c, 6, 10);
    print_matrix(d, 5, 8);


    // 'set_matrix' fonksiyonuna aşağıdaki gibi 'int[10]' türünden dizinin adresi bilerek ya da bilmeyerek gönderilebilir ama bu 'ub' durumuna neden olacaktır.
    int ary_x[10];
    set_matrix(ary_x, 5, 2);
}
```


***
==================================================

✦✦✦✦✦ 12.16-12.25 ikinci ara verildi. ✦✦✦✦✦

==================================================
***


👇 Aşağıdaki programda yukarıdaki programlarda iki boyutlu diziler(matrix) ile ilgili kullanılan fonksiyonların nasıl önişlemci programa yazdırtılabileceği incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

#define gsmf(s) void set_rm##s(int (*p)[s], int size) \
{   \
    for(int i = 0; i < size; ++i){  \
        for(int k = 0; k < s; ++k)  \
            p[i][k] = rand() % 10;  \
    }   \
}

#define gpmf(s) void print_matrix##s(const int (*p)[s], int size) \
{   \
    for(int i = 0; i < size; ++i){   \
        for(int k = 0; k < s; ++k)   \
            printf("%d", p[i][k]);   \
        printf("\n");  \
    }  \
    printf("~~~~~~~~~~~~~~~~\n");  \
}

// Aşağıda 'function like macro' kullanımıyla önişlemci programa altı farklı fonksiyon yazdırılmaktadır.
gsmf(5)
gsmf(8)
gsmf(10)

gpmf(5);
gpmf(8);
gpmf(10);


int main(void)
{
    // Aşağıdaki dört dizi dizi bildirilmiştir ve üç farklı dizi türü vardır, 'a' ve 'd' dizilerinin elemanlarının türü('int[8]' türü) aynıdır. 
    int a[4][8]; // 'a' dizisi'int[4][8]' türündedir ve elemanları 'int[8]' türünden olan 4 elemanlı bir dizidir. Bu dizi 'int x[32]' dizisiymiş gibi kullanılabilir.
    int b[10][5]; // 'b' dizisi'int[10][5]' türündedir ve elemanları 'int[5]' türünden olan 10 elemanlı bir dizidir. Bu dizi 'int y[50]' dizisiymiş gibi kullanılabilir.
    int c[6][10]; // 'c' dizisi 'int[6][10]' türündedir ve elemanları 'int[10]' türünden olan 6 elemanlı bir dizidir. Bu dizi 'int z[60]' dizisiymiş gibi kullanılabilir.
    int d[5][8]; // 'd' dizisi 'int[5][8]' türündedir ve elemanları 'int[8]' türünden olan 5 elemanlı bir dizidir. Bu dizi 'int t[40]' dizisiymiş gibi kullanılabilir.

    randomize();

    set_matrix8(a, 4);
    set_matrix5(b, 10);
    set_matrix10(c, 6);
    set_matrix8(d, 5);

    print_matrix8(a, 4);
    print_matrix5(b, 10);
    print_matrix10(c, 6);
    print_matrix8(d, 5);
}
```


👇 Aşağıdaki iki fonksiyon bildirimi birbirine denktir.
- `void foo1(int* p, int size);`
- `void foo1(int p[], int size);`

👇 Aşağıdaki iki fonksiyon bildirimi birbirine denktir.
- `void foo2(int** p, int size);`
- `void foo2(int* p[], int size);`

👇 Aşağıdaki iki fonksiyon bildirimi birbirine denktir.
- `void foo3(int (*p)[10], int size);`
- `void foo3(int p[][10], int size);`


🧠 `int ary[5][10][20];` olarak `ary` adında bir üç boyutlu dizi tanımlanabilir, `ary` dizisi `int[5][10][20]` türündendir, `ary` dizisinin elemanları `int[10][20]` türündendir, `ary` dizisinin elemanlarının elemanları `int[20]` türündendir, `ary` dizisinin elemanlarının elemanlarının elemanları `int` türündendir.



👇 Aşağıdaki programda tanımlanan `print_array10` adlı fonksiyonun sadece `int (*)[10]` türleri için kullanılabileceği görülmelidir, bu bilgi C++ dilinde daha önemli olacaktır.
```C
#include <stdio.h>

// Aşağıdaki 'print_array10' fonksiyonu sadece 10 elemanlı, elemanları 'int' türünden olan diziler için kullanılabilir.
void print_array10(const int (*p)[10])
{
    for(int i = 0; i < 10; ++i){
        printf("%d  ", (*p)[i]);
        //printf("%d  ", p[0][i]); // Bu kullanım yukarıdaki kod ile aynıdır.
    }
}

int main(void)
{
    int a[10] = { 0 };

    print_array10(&a);
}
```



👇 Aşağıdaki programda tanımlanan `print_array10` adlı fonksiyonun sadece `int (*)[10]` türleri için kullanılabileceği görülmelidir, bu bilgi C++ dilinde daha önemli olacaktır.
```C
#include <stdio.h>

void print_array10(const int (*p)[10])
{
    const int* ptr = *p;

    for(int i = 0; i < 10; ++i){
        printf("%d  ", ptr[i]);
    }
}

int main(void)
{
    int a[10] = { 0 };

    print_array10(&a);
}
```



👇 Aşağıdaki programda tanımlanan `print_array10` adlı fonksiyonun sadece `int (*)[10]` türleri için kullanılabileceği görülmelidir, bu bilgi C++ dilinde daha önemli olacaktır.
```C
#include <stdio.h>
#include "nutility.h"

void print_array10(const int (*p)[10])
{
    // Aşağıdaki 'nutility.h' başlık dosyasında bulunan 'print_array' fonksiyonuna yapılan çağrılar birbirine denktir.
    print_array(*p, 10);

    print_array(&(*p)[0], 10);
}

int main(void)
{
    int a[10] = { 0 };

    print_array10(&a);
}
```


>❔
> 
> Sorulan soru; 
> 
> Aslında yeni bir kavram öğrendik eskiye yönelik, tek boyutlu a dizisini &a ile de kullanıp bir fonksiyona rahatça geçebiliriz.
> 
> Cevap;
> 
> Kesinlikle evet.



👇 Aşağıdaki programda C dilinde dizi yazdırabilecek ilginç bir **function-like makro** kullanımı incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

#define gpa(s) void print_array##s(const int (*pa)[s]){ \
    for(int i = 0; i < s; ++i) \
        printf("%d  ", (*pa)[i]); \
    primtf("\n"); \
}

gpa(5);
gpa(10);

int main(void)
{
    int ary1[] = { 1, 5, 7, 3, 9 };
    int ary2[10] = { 0 };

    print_array5(&ary1);
    print_array10(&ary2);
}
```


Ders sonu ...
