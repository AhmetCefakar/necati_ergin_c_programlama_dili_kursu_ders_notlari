# 57.Ek Ders
---

## C Dilinde Hatalar Tekrar

Hatalar **programming error** ve **run-time error** olarak ikiye ayrılır. Programlama hatalarıyla başa çıkmak için kullanılan temel araç seti **Assertion**'lardır. </br>
**Assertion**'lar **Static Assertions**(**Compile Time Assertions**) ve **Dynamic Assertions**(**Run Time Assertions**) olarak iki öbeğe ayrılmaktadır, **Static Assertions** C diline dilin C11 standardıyla birlikte eklenmiştir. </br>
**Dynamic Assertions**(**Run Time Assertions**) programın çalışma zamanında alınan hataların tespiti için kullanılmaktadır.


👇 Aşağıdaki programda `foo` fonksiyonunda kullanılan hata tespit kodunun yanlış bir kullanım olduğu görülmelidir. 
```C
#include <stdio.h>
#include <stdlib.h>

void foo(int* p, int size)
{
    // Aşağıdaki if deyimi hata tespiti için eklenmiştir ama böyle bir hata tespit kodu yazmak iyi bir kullanım değildir.
    // İlk olarak bu kodun hata tespit kodu olduğu ilk bakışta anlaşılmamaktadır.
    // İkinci olarak da bu kod 'Static error detection' hata tespit kodları olduğu için, programı derlemeden önce bu kodları programdan kaldırmak gerekecektir, böyle yazarsak böyle bir çok kod olduğunda bunu kolayca yapamayız.
    if(p == NULL){
        fprintf(stderr, "p != NULL ifadesi dogrulanmadi.\n");
        fprintf(stderr, "%s dosyasinin %d. satiri\n", __FILE__, __LINE__);
    }

    for(int i = 0; i < size; ++i){
        printf("%d ", p[i]);
    }
}

int main(void)
{
    int a[10] = { 0 };
    int* p;

    p = NULL;

    // some code here ...

    foo(p, 10);
}
```



👇 Aşağıda `assert` makrosunun gerçekleştirimini derleyiciler yapmaktadır, her derleyici kendine göre bir tane gerleştirim yapar, olabilecek en basit `assert` makrosu aşağıdaki gibi olabilir;
```C
//sample assert macro implementation

#include <stdio.h>

#ifndef NDEBUG
#define ASSERT (EXPR) (                           \
    (EXPR)? (void)0: (                            \
        printf("%s:%d: failed assertion '%s' \n", \
        __FILE__, __LINE__, #EXPR                 \
        ),                                        \
        abort()                                   \
    ))                                            \
#else                                             \
#define ASSERT(EXPR) ((void)0)                    \
#endif /* NDEBUG */                               \
```


👇 Aşağıdaki programda basit bir `ASSERT` makrosunun kullanımı incelenebilir.
```C
#include <stdlib.h>

#define NDEBUG // Buradaki 'NDEBUG' 'No Debug' sözcüklerinden gelmektedir.

#ifndef NDEBUG
#define ASSERT (EXPR) (                           \
    (EXPR)? (void)0: (                            \
        printf("%s:%d: failed assertion '%s' \n", \
        __FILE__, __LINE__, #EXPR                 \
        ),                                        \
        abort()                                   \
    ))                                            \
#else                                             \
    #define ASSERT(EXPR) ((void)0)                \
#endif /* NDEBUG */                               \

int main(void)
{
    int x = 5;

    ASSERT(x != 0); // 'NDEBUG' bildirildiği için buradaki kod '((void)0)' ile yerdeğiştirilir.
}
```



👇 Aşağıdaki kod parçasında `assert` makrosunun nasıl devredışı bırakılabileceği incelenebilir.
```C
#define NDEBUG // Buradaki 'NDEBUG' 'No Debug' sözcüklerinden gelmektedir. Bu kullanım tüm 'assert' makrolarını devredışı bırakır ve böylece programdaki tüm hata tespit kodları programdan çıkartılmış olur.

#include <assert.h>

#ifndef NDEBUG
#define ASSERT (EXPR) (                           \
    (EXPR)? (void)0: (                            \
        printf("%s:%d: failed assertion '%s' \n", \
        __FILE__, __LINE__, #EXPR                 \
        ),                                        \
        abort()                                   \
    ))                                            \
#else                                             \
    #define ASSERT(EXPR) ((void)0)                \
#endif /* NDEBUG */                               \
```



👇 Aşağıdaki programda `assert` makrosunun nasıl devredışı bırakılabileceği incelenebilir.
```C
#include <stdlib.h>
#include <math.h>
#include <stdio.h>

#ifndef NDEBUG
#define ASSERT (EXPR) (                           \
    (EXPR)? (void)0: (                            \
        printf("%s:%d: failed assertion '%s' \n", \
        __FILE__, __LINE__, #EXPR                 \
        ),                                        \
        abort()                                   \
    ))                                            \
#else                                             \
    #define ASSERT(EXPR) ((void)0)                \
#endif /* NDEBUG */                               \


double foo(double d)
{
    ASSERT(d >= 0.);

    // some code here ...

    return sqrt(d * 1.2);
}

int main(void)
{
    double dx = foo(4.7);
    printf("dx = %f\n", dx);
}
```



`ASSERT` makrosu C++ dilindede kullanılmaktadır. </br>
👇 Aşağıdaki programda standart `assert` makrosunun kullanımı incelenebilir.
```C
#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <assert.h>

double foo(double d)
{
    ASSERT(d >= 0.);

    // some code here ...

    return sqrt(d * 1.2);
}

int main(void)
{
    double dx = foo(-4.7); // 'ASSERT' makrosu çalıştığında bufonksiyon çağrısında hata alınacaktır.
    printf("dx = %f\n", dx);
}
```



👇 Aşağıdaki programda `assert` makrosunun nasıl devredışı bırakılabileceği incelenebilir.
```C
#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#define NDEBUG // Bu kullanımla 'assert' makrolarının kullanımı devredışı bırakılmış olur.
#include <assert.h>

double foo(double d)
{
    ASSERT(d >= 0.);

    // some code here ...

    return sqrt(d * 1.2);
}

int main(void)
{
    double dx = foo(-4.7); // 'ASSERT' makrosu çalıştığında bu fonksiyon çağrısında hata alınacaktır.
    printf("dx = %f\n", dx);
}
```



👇 Aşağıdaki `assert` makrolarının kullanımında nasıl ilave açıklama eklenebileceği incelenebilir. `ASSERT_MSG` makrosunun kullanımında yan etkisi olmayan ifadelerin kullanılmasına dikkat edilmesi gerekiyor.
```C
#include <stdlib.h>
#include <math.h>
#include <stdio.h>
//#define NDEBUG // Bu kullanımla 'assert' makrolarının kullanımı devredışı bırakılmış olur.
#include <assert.h>

#define ASSERT_MSG(MSG, EXP)    assert((MSG, (EXP))) // Buradaki 'ASSERT_MSG' makrosu 'assert' makrosunu sarmalıyor, burada iki tane yazının yan yana gelmesi sonucu üretilecek yeni yazının bu iki yazının birleşi olmasından faydalanılıyor.

int main(void)
{
    int x = 0;
    ASSERT_MSG("value out of range", x != 0);

    int count = 5;
    assert(-count > 0);
}
```



👇 Aşağıdaki programda `assert` kullanımının doğru ve yanlış yaklaşımı 
```C
#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <assert.h>

void foo(int x, double d)
{
    // assert(x > 0 && d < 4.5); // İki farklı koşul aynı anda sınanmamalıdır.

    // Yukarıdaki 'assert' kullanımı yerine aşağıdaki gibi kullanmak daha doğrudur.
    assert(x > 0);
    assert(d < 4.5);
}


int main(void)
{
    foo(3, 7.1);
}
```


### Hata Durumlarının Bildirilmesi 

Eğer bir fonksiyon üstlendiği vazifeyi yerine getiremeyeceğini anlarsa(anladığında) kendisini çağıran koda bu durumu bildirmelidir, ama nasıl bildirebilir. </br>
Hataların yönetimi konusuna **error handling** denilmektedir ve **error handling** için tek bir ortak yol ya da konvension yoktur. </br>

**Error handling** için aşağıdaki yollar kullanılabilir;
1. Fonksiyonun geri dönüş değerinin fonksiyonun başarılı ya da başarısız olma durumunun döndürdüğü durum.
2. Fonksiyona geçilen bir nesnenin değerine bakılarak hata durumunun tespit edilmesi.

    👇 Aşağıdaki gibi bazen bir fonksiyonun geri dönüş türü yapı türünden oluyor ve bir hata olması durumunda hata durumunu tutan yapı üyesinin değeri güncellenecektir.
    ```C
    struct Result{
        int mx; // Hesaplanan değer.
        int error_code;
    }
    ```
3. `errno.h` başlık dosyasında tanımlı olan `errno` nesnesinin değeri üzerinden hata olup olmadığı sınanabiliyor. `errno` nesnesini derleyiciler global bir değişken ya da global bir object-like makro olarak tanımlayabiliyor. 


#### `errno.h` Başlık Dosyasındaki Araçları Kullanarak Hata Kontrolü

`errno` nesnesinin değeri hata olmadığında "0" hata olduğunda sıfırdan başka bir tam sayı değeridir.

👇 Aşağıdaki programda `errno` kullanımı incelenebilir.
```C
#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <assert.h>
#include <errno.h>

int main(void)
{
    printf("errno = %d\n", errno); // Standart çıktı akımına 'errno = 0' gönderilir.

    FILE* f = fopen("uygarpinar.dat", "rb");

    printf("errno = %d\n", errno); // Standart çıktı akımına 'errno = 2' gönderilir, bunun nedeni bir önceki statement'ta açılmak istenilen dosyanın açılamamış olmasıdır.

    if(!f){
        perror("file not opened "); // Standart çıktı akımına 'file not opened : No such file or directory' gönderilir.
    }
}
```


👇 Aşağıdaki programda `strerror` fonksiyonu kullanılarak `errno` hata kodunun ne anlama geldiği öğrenilebilmektedir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <assert.h>
#include <errno.h>
#include <string.h>

int main(void)
{
    printf("errno = %d\n", errno); // Standart çıktı akımına 'errno = 0' gönderilir.

    FILE* f = fopen("uygarpinar.dat", "rb");

    if(!f){
        perror("hata olustu : %s\n", strerror(errno); // Standart çıktı akımına 'file not opened : No such file or directory' gönderilir.
    }
}
```


👇 Aşağıdaki programda `strerror` fonksiyonu kullanılarak [0, 19] arasındaki hata kodlarının açıklamalarının ne olduğu standart çıktı akımına yazdırılmaktadır.
```C
#include <errno.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    for(int i = 0; i < 20; ++i){
        printf("error value %d : %s \n", i, strerror(i);
    }
}
```


C dilinin standardında belirtilen `EDOM`, `ERANGE`, `` object-like makroları sabit bir değere 



👇 Aşağıdaki programda `EDOM` kullanımı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <assert.h>
#include <errno.h>
#include <string.h>


int main(void)
{
    double d = sqrt(-4.5);

    if(errno == EDOM){
        printf("errno değeri == EDOM");
    }
}
```



👇 Aşağıdaki programda `ERANGE` hatasının oluşması durumu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <assert.h>
#include <errno.h>
#include <string.h>


int main(void)
{
    long lval1 = strtol("0x1ac4", NULL, 0);
    printf("lval1 = %ld\n", lval1);

    long lval2 = strtol("0xFFFFFFF", NULL, 0);
    
    if(errno == ERANGE){
        printf("Evet 'errno' degeri 'ERANGE'e esit.\n");
    }
    
    printf("lval2 = %ld\n", lval2);

    perror("'lval2' degiskeni icin donusum hatasi: ");
}
```


### `setjmp.h` Başlık Dosyasındaki `setjmp` ve `longjmp` Fonksiyonları

C++, Java, C# gibi dillerde hataların yönetimi için **Exception Handing** aracı bulunmaktadır, C++ kursunda bu kunu 8-10 saatte anlatılmaktaymış.

`errno` değeri kullanılmadan önce bu değer sıfırlanmalıdır ardından işlem yapılmalıdır, **function call chain** yapısında iç içe fonksiyon çağırılma zincirinde iç fonksiyonlarda hata oluştuğunda ilk çağırılan fonksiyona hata bilgisinin geri dönülmesi kullanılan bir yaklaşımdır(böyle bir durumda **non-local jump** bir goto deyimi kullanılır). </br>
`setjmp.h` başlık dosyasında yukarıda belirtilen durumda iç fonksiyonda hata oluştuğunda ilk çağıran fonksiyona geri dönülmesini sağlayan araçlar mevcuttur.

C dilinde `setjmp.h` başlık dosyasında bulunan `setjmp` ve `longjmp` fonksiyonlarının kullanımı ile diğer dillerde olan **Exception Handing** mekanizmasının basit bir benzeri oluşturulabilir.


👇 Aşağıdaki programda `setjmp` ve `longjmp` fonksiyonlarının kullanımı incelenebilir.
```C
#include <setjmp.h>

jmp_buf buf;


void bom(void)
{
    printf("bom cagirildi.\n");
    longjmp(buf, 4);
}

void baz(void)
{
    printf("baz cagirildi.\n");
    bom();
}

void bar(void)
{
    printf("bar cagirildi.\n");
    baz();
}

void foo(void)
{
    printf("foo cagirildi.\n");
    bar();
}

int main(void)
{
    if(setjmp(buf)){
        printf("longjmp jump'i sonucunda akis buraya geldi.\n");
    }
    else{
        foo();
    }   
}
```



> Sorulan soru;
> 
> `setjmp` fonksiyonu illaki bir if statement içinde mi kullanılması gerekiyor?
> 
> Cevap;
> 
> Evet çünkü, programın akışının 


## Variadic Fonksiyonlar 🌟 

Bir fonksiyonun **variadic** olması durumunda bu fonksiyonu çağıran kod tarafında istenildiği kadar argümanla fonksiyon çağrısı yapılabilir. </br>
Farklı farklı programlama dillerinde farklı farklı kullanım yapısıyla **variadic function** yapısı mevcuttur. </br>
**Variadic function** programlama dünyasında kullanılan genel bir terimdir, farklı farklı argüman sayısıyla çağırılabilen fonksiyonlar için kullanılmaktadır. </br>
Neden değişken sayıda parametre alan fonksiyonlara ihtiyaç duyuluyor diye düşünüldüğünde, `printf`, `scanf` fonksiyonlarında olduğu gibi önceden kaç tane değer için işlem yapılacağı önceden belirsizdir olduğu için **variadic** özellikte belirsi sayıda argüman geçilebilir olması kullanışlıdır. </br>
Mesela kendisine geçilen belirsiz adetteki tam sayıların toplamını hesaplayan ya da ortalamasını hesaplayan ya da sayıların en büyüğünü tespiteden vb. fonksiyonlar yazılacağında bu fonksiyonların **variadic** tanımlanması tercihedilir.

**Variadic function** sözdizimi şöyledir: En az bir parametre alan bir fonksiyonun en son parametresinin elipsis(`...`) token'ı yapılması sonucunda **variadic** bir fonksiyon bildirimi ya da tanımı yapılmaktadır. </br>
Mesela `void func(int x, ...);`, `void func(int x, int y, ...);` biçiminde **variadic function** bildirilebilir. </br>
Mesela `void func(int x, ..., int y );`, `void func(int x, int y, ..., ...);` biçimindeki **variadic function** bildirimleri hatalı ve illegal'dir. </br>
`void func(...);` böyle bir **variadic function** bildirimi C23 standardından önce illegaldir ama C23 ile birlikte legal hale getirilmiştir. </br>
Bir **variadic function**'ı çağıran kod bu fonksiyonun **variadic** olan son parametresi dışındaki parametrelerine argüman geçmek zorundadır.


👇 Aşağıdaki programda **variadic function** çağrılarının nasıl olabileceği incelenebilir.
```C
void func(int x, int y, ...);

int main(void)
{
    // func(); // Illegal function call.
    // func(2); // Illegal function call.
    func(2, 3); // Legal function call.
    func(3, 5., 3); // Legal function call.
    func(3, 6, 3, 5); // Legal function call.
    func(3, 5, 3, 5, 7, 8); // Legal function call.
}
```


🧭 C dilindeki **variadic function** yapısının eksiklikleri;
1. **Variadic** parametre karşılığı çağıran kod dilediği kadar argüman geçebilir ancak kaç argüman gönderdiğini bir biçimde çağrı yapılan fonksiyona bildirmek zorundadır, bunu yapabilmek için kullanılabilecek bir mekanizma yok.
2. **variadic function**'lar **type safe** değildir, bu durum **run-time** hatalara neden olabilme potansiyeline sahiptir, en sorun çıkaracak durum budur denilebilir.


**Variadic function**'ları tanımlarken bir tür kullanıyoruz(`va_list` türü, bu tür derleyiciye bağlı) ve üç farklı **functional-makro(`va_start`, `va_end`, `va_arg`, `va_copy`)** kullanıyoruz, bu makrolar `stdarg.h` başlık dosyasında bulunmaktadır.

❗❗❗ 🧭 Bir **Variadic function** ilk olarak kendisine **variadic** olarak geçilen değişken sayıdaki argümanın sayısını anlamasını sağlayacak bir mekanizmaya sahip olmalıdır, aşağıda kullanılabilecek üç farklı mekanizma görülebilir;
1. Bildirimi `void foo(int x, ...);` biçiminde olan bir fonksiyona geçilen argüman sayısı fonksiyonun ilk parametresine geçilen argümandan anlaşılabilir, mesela `foo(3, 3, 4, 5);`, `foo(2, 1, 2);` biçimindeki fonksiyon çağrıları buradaki mekanizmayı kullanmaktadır.
2. Bildirimi `void foo(int x, ...);` biçiminde olan bir fonksiyonun dökümanında belirtilen bir değer(mesela "-1" değeri) **variadic** argümanların sonunu belirtebilir, mesela `foo(10, 20, 30, 40, -1);`, `foo(11, 22, 33, -1);` biçimindeki fonksiyon çağrıları buradaki mekanizmayı kullanmaktadır.
3. Bildirimi `void foo(const char* *p, ...);` biçiminde olan bir fonksiyonun ilk parametresinin yazı adresi isteyen bir gösterici yapmak ve gönderilen argüman sayısını bu pointer'ın gösterdiği yazıdan almka, `printf`, `scanf` fonksiyonları bu tekniği kullanmaktadır.


***
==================================================

✦✦✦✦✦ 21.10-21.32 birinci ara verildi. ✦✦✦✦✦

==================================================
***



👇 Aşağıdaki programda bir **variadic function** tanımlanışının ve kullanılışını nasıl olduğu incelenebilir.
```C
#include <stdarg.h> // Bu başlık dosyası variadic function bildirimi yapabilmek için 
#include <stdio.h>

// Aşağıdaki 'sum' fonksiyonu kendisine geçilen variadic argüman sayısını yukarıda listelenen ilk teknikle tespitetmektedir.
int sum(int n, ...)
{
    va_list args;       // 1.adım 'va_list' türünden bir değişken tanımla.
    va_start(args, n);  // 2.adım 'va_start' function-like makro'suna kullan. İlk argümanı 'va_list' türünden bir değişken ve ikinci argümanı variadic parametrelerden önceki ilk parametre değeri.

    int sum = 0;

    for(int i = 0; i < n;++i)
        sum += va_arg(args, int); // 3.adım 'va_arg' function-like makro'suna kullanılarak fonksiyona geçilen variadic parametreler elde edilir. 

    va_end(args);

    return sum;
}

int main(void)
{
    int x = 10, y = 20, z = 71;

    printf("%d\n", sum(2, x, y));
    printf("%d\n", sum(3, x, y, z));
    printf("%d\n", sum(4, x, y, z, 200));
}
```


C dilinde standardın **default arguman conversion** dediği bir tavram var, bu kayram iki yerde önem taşımaktadır, 


👇 Aşağıdaki programda **default arguman conversion**'ın nasıl uygulandığı incelenebilir.
```C
#include <stdarg.h> // Bu başlık dosyası variadic function bildirimi yapabilmek için 
#include <stdio.h>

void foo(int x, ...);

int main(void)
{
    char c = 3;
    short s = 13;
    float f = 23.54;
    int i = 234;
    long lval = 34L;
    double dval = 124.643;

    foo(6, c, s, f, i, lval, dval);

    // default arguman conversion
    // int'ten küçük tam sayı türleri için 'integral promotion' uygulanır.
    // float türü double.
    // Diğer türler kendi türlerine atanır.
}
```



👇 Aşağıdaki programda **default arguman conversion** uygulanışını anlamak için incelenebilir.
```C
#include <stdarg.h> // Bu başlık dosyası variadic function bildirimi yapabilmek için 
#include <stdio.h>

// Aşağıdaki 'sum' fonksiyonu kendisine geçilen variadic argüman sayısını yukarıda listelenen ilk teknikle tespitetmektedir.
int sum(int n, ...)
{
    va_list args;       // 1.adım 'va_list' türünden bir değişken tanımla.
    va_start(args, n);  // 2.adım 'va_start' function-like makro'suna kullan. İlk argümanı 'va_list' türünden bir değişken ve ikinci argümanı variadic parametrelerden önceki ilk parametre değeri.

    int sum = 0;

    for(int i = 0; i < n;++i)
        sum += va_arg(args, int); // 3.adım 'va_arg' function-like makro'suna kullanılarak fonksiyona geçilen variadic parametreler elde edilir. 

    va_end(args); // 4.adım 'va_end' function-like makro'sun kullanılır.

    return sum;
}

int main(void)
{
    int x = 10, y = 20, z = 71;
    char c = 13;
    short s = 42;

    printf("%d\n", sum(3, x, c, s)); // Buradaki gibi bir fonksiyon çağrısı yapılabilir, 'int' türünden küçük boyutlu tam sayı türleri 'int' türüne yükseltilir.
}
```



👇 Aşağıdaki programda **default arguman conversion** uygulanışını anlamak için incelenebilir.
```C
#include <stdarg.h> // Bu başlık dosyası variadic function bildirimi yapabilmek için 
#include <stdio.h>

// Aşağıdaki 'max' fonksiyonu kendisine geçilen variadic argüman sayısını yukarıda listelenen ilk teknikle tespitetmektedir.
int get_max(int n, ...)
{
    int max = INT_MAX;
    va_list args;       // 1.adım 'va_list' türünden bir değişken tanımla.
    va_start(args, n);  // 2.adım 'va_start' function-like makro'suna kullan. İlk argümanı 'va_list' türünden bir değişken ve ikinci argümanı variadic parametrelerden önceki ilk parametre değeri.

    for(int i = 0; i < n;++i){
        int val = va_arg(args, int); // 3.adım 'va_arg' function-like makro'suna kullanılarak fonksiyona geçilen variadic parametreler elde edilir. 

        if(val > max)
            max = val;
    }

    va_end(args); // 4.adım 'va_end' function-like makro'sun kullanılır.

    return max;
}

int main(void)
{
    int max = get_max(5, 5, 45, 76, 8, 9, 71);

    printf("max = %d\n", max);
}
```



👇 Aşağıdaki programda 2. yöntem ile bir **variadic** fonksiyonun tanımlanışı ve kullanımı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdarg.h> // Bu başlık dosyası variadic function bildirimi yapabilmek için 
#include <stdio.h>

// Aşağıdaki 'max' fonksiyonu kendisine geçilen variadic argüman sayısını yukarıda listelenen ilk teknikle tespitetmektedir.
int get_max(int x, ...)
{
    int max = x;

    va_list args;
    va_start(args, x);
    
    // Birinci yolla döngünün yazılışı
    // while(1){
    //     int val = va_arg(args, int);

    //     if(val == -1)
    //         break;

    //     if(val > max){
    //         max = val;
    //     }
    // }

    // İkinci yolla döngünün yazılışı
    while((val = va_arg(args, int) != 1){
        if(val > max){
            max = val;
        }
    }

    va_end(args);

    return max;
}

int main(void)
{
    int max = get_max(3, 45, 76, 8, 9, 71, -1);

    printf("max = %d\n", max);
}
```



👇 Aşağıdaki programda 3. yöntem ile bir **variadic** fonksiyonun tanımlanışı ve kullanımı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdarg.h> // Bu başlık dosyası variadic function bildirimi yapabilmek için 
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

int myprintf(const char* p, ...)
{
    va_list args;
    va_start(args, p);
    int chars_count = 0;

    while(*p){
        int ch = toupper(*p);
        if(ch == `I`){
            chars_count += printf("%d ", va_arg(args, int));
        }
        else if(ch == 'F' || ch == 'D'){
            chars_count += printf("%f ", va_arg(args, double));
        }
        else if(ch == 'L'){
            chars_count += printf("%ld ", va_arg(args, long));
        }
        else if(ch == 'C'){
            chars_count += printf("%c ", va_arg(args, int));
        }
        else if(ch == 's'){
            chars_count += printf("%s ", va_arg(args, const char*));
        }
        else if(ch == 'U'){
            chars_count += printf("%u ", va_arg(args, unsigned));
        }

        ++p;
    }

    return chars_count;
}

int main(void)
{
    int x = 45;
    double dval = 2. 3423;
    float f = 2.43f;
    char c = 'Z';
    char s[] = "bir kimse";

    // int ==> iI
    // float ==> fF
    // double ==> dD
    // char ==> cC
    // unsigned int ==> uU
    // string ==> sS

    myprintf("ScFdi", s, c, f, dval, x);
}
```



👇 Aşağıdaki programda 2. yöntem ile `concat` adında bir **variadic** fonksiyonun tanımlanışı ve kullanımı incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdarg.h> // Bu başlık dosyası variadic function bildirimi yapabilmek için 
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

char* concat(const char* ptr, ...)
{
    va_list arg1;
    va_list arg2;

    va_start(arg1, ptr);
    
    // Aşağıdaki iki fonksiyonda birbiriyle aynı işi yapmaktadır.
    va_copy(arg2, arg1); // 'va_copy' makrosu C99 ile dile eklenmiştir.
    // va_start(arg2, ptr);

    char* p;
    size_t len = strlen(ptr);
    while((p = va_arg(arg1, char*)) != NULL){
        len += strlen(p);
    }
    va_end(arg1);

    char* pd = malloc(len + 1);
    if(pd == NULL){
        return NULL;
    }

    strcpy(pd, ptr);

    while((p = va_arg(arg2, char*)) != NULL){
        strcat(pd, p);
    }

    va_end(arg2);

    return pd;
}

int main(void)
{
    char s1[] = "necati";
    char s2[] = "cengiz";
    char s3[] = "mete";

    char* p = concat(s1, s2, s3, "ece", "oguz", NULL); // 
    puts(p);
}
```



👇 Aşağıdaki programda `vsnprintf` fonksiyonunun kullanımı incelenebilir, bu program cppreference.com sitesinden esinlenilmiştir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdarg.h> // Bu başlık dosyası variadic function bildirimi yapabilmek için 
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

void print_error(const char* fm, ...)
{
    char buffer[100];
    va_list args;
    va_start(args, fm);
    vsnprintf(buffer, 100, fm, args); // Başında 'v' harfi olan printf grubu fonkisyonların yaptığı işler başında 'v' harfi olmayan fonksiyonlar ile aynı ama tek farkları son parametrelerinin 'va_list' türünden bir nesne almasıdır.
    perror(buffer);
    va_end(args);
}


int main(void)
{
    char filename[] = "file.txt";
    FILE* f = fopen(filename, "r");

    if(!f){
        print_error("file open error : %s", filename);
    }
}
```



👇 Aşağıdaki program cppreference.com sitesinden alınmıştır, `log_vals` fonksiyonu ile tarih ve zaman bilgisiyle log kaydı atılmaktadır.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <time.h>
#include <stdarg.h>

void log_vals(const char* fmt, ...)
{
    char msg[50];
    time_t cln_tm;
    time(&cln_tm);
    strftime(msg, sizeof msg, "%F %T", localtime(&cln_tm));
    printf("[%s] ", msg);
    va_list args;
    va_start(args, fmt);
    vprintf(fmt, args);
    va_end(args);
}

int main(void)
{
    int ival = 34;
    double dval = 4.6;
    char str[] = "necati ergin";

    log_vals("log %d %f %s\n", ival, dval, str);
}
```


👇 Aşağıdaki programda **v öbeği** `printf` fonksiyonlarını anlamak için incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <time.h>
#include <stdarg.h>

void func(const char* pf, ...)
{
    va_list args;
    va_start(args, pf);

    vprintf(pf, args);
    va_end(args);
}

int main(void)
{
    func("necatinin %d kitabı var toplam ederi %f TL\n", 12, 43234242.56);

    return 0;
}
```


📌 **Variadic** fonksiyonlar güvenilir değildir, bu tür fonksiyonlar yazılırken ve kullanırken dikkatli olunması gerekir.


Ders sonu ...
