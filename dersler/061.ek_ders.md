# 61.Ek Ders
---


## BaÄŸlÄ± Liste Veri YapÄ±sÄ± GerÃ§ekleÅŸtirimi(Liked List Data Structure Implementation) ğŸŒŸ

BaÄŸlÄ± liste veri yapÄ±sÄ±nda Ã¶ÄŸeler bellekte ardÄ±ÅŸÄ±k(consecutive) deÄŸildir. BaÄŸlÄ± listenin her bir Ã¶ÄŸesi dinamik olarak ayrÄ±lan(allocation) bellek alanÄ±nda pointer ya da pointerlarla birlikte tutulmaktadÄ±r. </br>
BaÄŸlÄ± liste veri yapÄ±sÄ±nda tutulan her bir Ã¶ÄŸe bir ya da iki tane pointer deÄŸiÅŸken barÄ±ndÄ±rÄ±r, baÄŸlÄ± liste veri yapÄ±sÄ±nÄ±n her bir "**veri + pointer(s)**" bÃ¼tÃ¼nÃ¼ne **dÃ¼ÄŸÃ¼m(node)** denilmektedir. </br>

BaÄŸlÄ± liste veri yapÄ±sÄ±nÄ±n farklÄ± tÃ¼rleri mevcuttur(bunlar dÄ±ÅŸÄ±nda baÅŸka tÃ¼rler de var ama onlar birz Ã¶zel olduÄŸu iÃ§in burada deÄŸinilmiyor);
- Singly linked list
- Doubly linked list
- Circular singly linked list
- Circular doubly linked list

KullanÄ±cÄ± kod aÃ§Ä±sÄ±ndan bakÄ±ldÄ±ÄŸÄ±nda dÃ¼ÄŸÃ¼mlerdeki veriler Ã¶nemlidir ama farklÄ± dÃ¼ÄŸÃ¼mlerin verilerine eriÅŸebilmek iÃ§in dÃ¼ÄŸÃ¼mlerdeki pointer'lardan faydalanmak gerekmektedir.

**Tekli baÄŸlÄ± listede(Singly linked list)** ileriye doÄŸru hataket edilebilir ama geriye doÄŸru haraket edilemez. </br>
**Tekli baÄŸlÄ± listede(Singly linked list)** belirli bir indekse yapÄ±lacak ekleme iÅŸleminde algoritmik zaman maliyeti $O(1)$ dir. </br>
**Tekli baÄŸlÄ± listede(Singly linked list)** silme iÅŸlemini yaparken bir dÃ¼ÄŸÃ¼mÃ¼n kendisini silemeyiz sadece o dÃ¼ÄŸÃ¼mden sonraki dÃ¼ÄŸÃ¼mleri silebiliriz, bunun nedeni dÃ¼ÄŸÃ¼mleri birbirine baÄŸlayan pointer'larÄ±n yeni adreslerini belirlerken silinecek dÃ¼ÄŸÃ¼mden bir Ã¶nceki dÃ¼ÄŸÃ¼me eriÅŸimin olmasÄ± gerekmesidir.

**Ã‡ifte baÄŸlÄ± listede(Doubly linked list)** silme iÅŸlemi silinecek dÃ¼ÄŸÃ¼mden sonraki ve Ã¶nceki dÃ¼ÄŸÃ¼mlere eriÅŸilebildiÄŸi iÃ§in **Tekli baÄŸlÄ± listede(Singly linked list)** daha kolaydÄ±r.

BaÄŸlÄ± liste veri yapÄ±sÄ±nda ilk ve son dÃ¼ÄŸÃ¼mÃ¼ tutacak gÃ¶stericilere **Ã§apa(anchor)** da denilmektedir. </br>
BaÄŸlÄ± liste veri yapÄ±sÄ±nda ilk dÃ¼ÄŸÃ¼m adresini tutan pointer **baÅŸ(head)**, son dÃ¼ÄŸÃ¼mÃ¼n adresini tutan pointer **kuyruk(tail)** denilmektedir. </br>
**Tekli baÄŸlÄ± liste(Singly linked list)** veri yapÄ±sÄ±nda Ã§oÄŸu zaman sadece sadece ilk dÃ¼ÄŸÃ¼mÃ¼n adresini tutan pointer bulundurulur, son dÃ¼ÄŸÃ¼mÃ¼n adresini tutan pointer bulundurulmaz. </br>
**Ã‡ifte baÄŸlÄ± listede(Doubly linked list)** veri yapÄ±sÄ±nda Ã§oÄŸu zaman hem **baÅŸ(head)** hem de **kuyruk(tail)** gÃ¶stericileri tutulmaktadÄ±r.



ğŸ§­ **BaÄŸlÄ± liste** veri yapÄ±sÄ±nÄ±n faydalarÄ± ve kayÄ±plarÄ±;
- Tek bir bellek bloÄŸu iÃ§in bellek ayrÄ±lmaktadÄ±r, bu nedenle **parÃ§alÄ±(fragmentation)** bir bellekte Ã§alÄ±ÅŸÄ±rken veri yapÄ±sÄ±na yeni dÃ¼ÄŸÃ¼m eklemek konusunda sÄ±kÄ±ntÄ± yaÅŸanmaz. Fakat bir **dinamik dizi** veri yapÄ±sÄ±yla **parÃ§alÄ±(fragmentation)** bir bellekte Ã§alÄ±ÅŸmak daha zordur.
- **Reallocation** gibi bir maliyet yoktur, fakat bir **dinamik dizi** kullanÄ±ldÄ±ÄŸÄ±nda veri yapÄ±sÄ±nÄ±n boyutu arttÄ±rÄ±lacaÄŸÄ± zaman yeni bellek bloÄŸuna **dinamik dizinin** taÅŸÄ±nmasÄ± gerekir, bu iÅŸlem bazen bÃ¼yÃ¼k maliyet getirmektedir.
- BaÄŸlÄ± listelerde her yeni dÃ¼ÄŸÃ¼m ekleme iÅŸleminde **allocation** iÅŸlem maliyeti vardÄ±r, her dÃ¼ÄŸÃ¼m silme iÅŸleminde **deallocation** iÅŸlem maliyeti vardÄ±r.
- BaÄŸlÄ± listelerde her dÃ¼ÄŸÃ¼m veri dÄ±ÅŸÄ±nda bir ya da daha fazla gÃ¶sterici bilgisi tutacaÄŸÄ± iÃ§in asÄ±l veriden daha Ã§ok bellek alanÄ± kullanÄ±lacaktÄ±r, bunun dÄ±ÅŸÄ±nda her bellekten yer ayÄ±rma iÅŸlemi ayrÄ±lan bellek alanÄ±ndan ayrÄ± olarak her bellekten yer ayÄ±rma iÅŸlemiyle ilgili bazÄ± bilgilerin tutulduÄŸu **header** kÄ±smÄ±ndan kaynaklÄ± daha fazla bellek kullanÄ±lacaktÄ±r.
- BaÄŸlÄ± listelerde belirli bir indekste bulunan dÃ¼ÄŸÃ¼me eriÅŸmek iÃ§in listenin baÅŸÄ±ndan itibaren tek tek dÃ¼ÄŸÃ¼mleri geÃ§erek ilgili dÃ¼ÄŸÃ¼me eriÅŸebiliriz, bu iÅŸlemin maliyeti ise $O(n)$ dir.


â—â—â— EÄŸer yapÄ±lan iÅŸin bÃ¼yÃ¼k Ã§oÄŸunluÄŸu indeks ile eriÅŸimse o zaman baÄŸlÄ± liste veri yapÄ±sÄ±nÄ±n kullanÄ±lmasÄ± yÃ¼ksek maliyete neden olacaktÄ±r.

â—â—â— Ãœzerinde Ã§alÄ±ÅŸÄ±lan veri yapÄ±sÄ±nÄ±n boyutunun belirli bir bÃ¼yÃ¼klÃ¼k sÄ±nÄ±rÄ±na kadar dinamik dizilerin **cache miss**/**cache hit** oranÄ± baÄŸlÄ± listeye gÃ¶re Ã§ok daha dÃ¼ÅŸÃ¼ktÃ¼r, Ã§Ã¼nkÃ¼ dinamik dizilerde veriler sÄ±ralÄ±dÄ±r ama baÄŸlÄ± listelerde Ã§oÄŸunlukla sÄ±ralÄ± olmayan bellek alanlarÄ±ndadÄ±r, gÃ¼nÃ¼mÃ¼z iÅŸlemcilerinin verimini en Ã§ok **cache miss**/**cache hit** oranÄ± etkilemektedir.

â—â—â— GÃ¼nÃ¼mÃ¼zÃ¼n iÅŸlemcilerinin Ã§oÄŸunda olan **SIMD(Simgle Istruction Multiple Data)** yapÄ±sÄ± iÅŸlemcinin tek bir makine komutuyla bir veri yerine birden Ã§ok veri Ã¼zerinde iÅŸlem yapabilme Ã¶zelliÄŸidir. **SIMD(Simgle Istruction Multiple Data)** Ã¶zelliÄŸinden yararlanmak iÃ§in Ã¼zerinde iÅŸlem yapÄ±lan veri yapÄ±sÄ±nÄ±n Ã¶ÄŸelerinin bellekte sÄ±ralÄ± olmasÄ± gerekiyor.

â—â—â— **Dinamik dizi** veri yapÄ±sÄ± Ã¼zerinde Ã§alÄ±ÅŸÄ±lan veri yapÄ±sÄ±nÄ±n boyutu belirli bir bÃ¼yÃ¼klÃ¼k sÄ±nÄ±rÄ±na gelene kadar veri yapÄ±sÄ±nÄ±n adresi bilinen belirli bir indeksine yeni Ã¶ÄŸe ekleme/silme iÅŸlemleri yoÄŸun yapÄ±ldÄ±ÄŸÄ± durumlarda bile **dinamik dizi** veri yapÄ±sÄ±nÄ±n kullanÄ±lmasÄ± **baÄŸlÄ± liste** veri yapÄ±sÄ±nÄ±n kullanÄ±lmasÄ±ndan daha iyidir. ÅÃ¼phede kalÄ±ndÄ±ÄŸÄ±nda **Profiling** araÃ§larÄ±yla ilgili iÅŸlemcide hangi veri yapÄ±sÄ±nÄ±n daha hÄ±zlÄ± Ã§alÄ±ÅŸtÄ±ÄŸÄ± incelenmelidir.


Bir veri yapÄ±sÄ±nÄ±n kullanÄ±lmasÄ±nÄ±n nedeni o veri yapÄ±sÄ± Ã¼zerindeki veriler Ã¼zerinde bazÄ± algoritmalarÄ±n Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±dÄ±r, bundan dolayÄ± veri yapÄ±larÄ± ve algoritmalar birbirinden ayrÄ± dÃ¼ÅŸÃ¼nÃ¼lememektedir. </br>
AlgoritmalarÄ±n Ã¶nemli bir kÄ±smÄ± gerÃ§ekleÅŸtirim tarafÄ±nda Ã§oÄŸunlukla **takas(swap)** iÅŸlemi yapmaktadÄ±r, mesela bir sÄ±ralama algoritmasÄ±nÄ± bir dinamik dizi Ã¼zerinde Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±zda her takas iÅŸleminde bellek bloklarÄ±nÄ± taÅŸÄ±mak gerekecektir ama bir baÄŸlÄ± listede aynÄ± **takas(swap)** iÅŸlemi yapmak iÃ§in sadece pointer'larÄ± deÄŸiÅŸ tokuÅŸ etmek yeterli olacaktÄ±r. </br>
**Takas(swap)** iÅŸlemi gerektiren bazÄ± algoritmeler: SÄ±ralama algoritmalarÄ±, ters Ã§evirme algoritmalarÄ±, partition algoritmalarÄ±, merge algoritmalarÄ±, unique algoritmasÄ± vb.


â—â—â— Bir baÄŸlÄ± listede bulunan bir dÃ¼ÄŸÃ¼m aynÄ± anda aynÄ± tÃ¼rden dÃ¼ÄŸÃ¼mlerden oluÅŸan farklÄ± baÄŸlÄ± listelerin bir dÃ¼ÄŸÃ¼mÃ¼ olabilir, ya da bir dÃ¼ÄŸÃ¼m bulunduÄŸu baÄŸlÄ± listeden Ã§Ä±kartÄ±lÄ±p bellekten dÃ¼ÅŸÃ¼rÃ¼lmeden baÅŸka bir baÄŸlÄ± listeye eklenebilir(bu iÅŸleme **splice** adÄ± verilmektedir, bu iÅŸlemler konum bilindiÄŸinde $O(1)$ zaman karmaÅŸÄ±klÄ±ÄŸÄ±nda yapÄ±lÄ±r). Ã‡ok fazla **splice** iÅŸlemi yapÄ±lÄ±yorsa baÄŸlÄ± liste veri yapÄ±sÄ±nÄ±n kullanÄ±mÄ± doÄŸru birtercih olabilir.

â—â—â— Ãœretim ortamÄ±nda **dinamik dizi** veri yapÄ±sÄ± %90 civarÄ±nda ve **baÄŸlÄ± liste** veri yapÄ±sÄ± %10 civarÄ±nda kullanÄ±lÄ±yor diye bir oran verebiliriz, **baÄŸlÄ± liste** veri yapÄ±sÄ±nÄ±n iyi bilinmesinin nedenlerinden biri de yazÄ±lÄ±m mÃ¼lakatlarÄ±dÄ±r ve mÃ¼lakatlarda algoritma yazdÄ±rma aÅŸamalarÄ± Ã§oÄŸunlukla **baÄŸlÄ± liste** veri yapÄ±sÄ± Ã¼zerinden yapÄ±lmtadÄ±r.


ğŸ§  BaÄŸlÄ± listelerde ekleme/silme iÅŸlemlerinde herhangi bir konuma yeni dÃ¼ÄŸÃ¼m ekleme/silme iÅŸlemi yapÄ±labildiÄŸinden ilk dÃ¼ÄŸÃ¼m yerine ve son dÃ¼ÄŸÃ¼m yerine de ekleme/silme yapÄ±labilir ve ekleme/silme baÄŸlÄ± liste gerÃ§ekleÅŸtirimi yaparken ekleme/silme iÅŸlemini yapacak fonksiyonun bu durumlarÄ± da gÃ¶z Ã¶nÃ¼nde bulundurarak yazmak gerekecektir. Ä°ÅŸte bu durumlarÄ±n dikkate alÄ±nmasÄ±nÄ±n dikkat gerektirmesinden dolayÄ± mÃ¼lakatlarda sÄ±k sorulmaktadÄ±r. </br>
ğŸ§  BaÄŸlÄ± listelerde ekleme/silme iÅŸlemleri **Ã§apa(anchor)** pointer'larÄ± deÄŸilse yapÄ±lacak iÅŸlemler ayrÄ± **Ã§apa(anchor)** pointer'lar ise yapÄ±lacak iÅŸlemler ayrÄ±dÄ±r. </br>
ğŸ§  BaÄŸlÄ± listelerde silme iÅŸlemleri yaparken eÄŸer listede tek bir dÃ¼ÄŸÃ¼m varsa bu durumda da **Ã§apa(anchor)** pointer'larÄ±n **NULL pointer** haline getirilmesi gerekir.


ğŸ§ ğŸ§ ğŸ§  YazÄ±lacak kÃ¼tÃ¼phene ve kÃ¼tÃ¼phane modÃ¼llerindeki varlÄ±klarÄ±n adlarÄ± ad Ã§akÄ±ÅŸmasÄ± olmamasÄ± iÃ§in ilgili kÃ¼tÃ¼pheneyi niteleyen Ã¶zen bir Ã¶n ek ile nitelendirilmelidir.



âœï¸ Burada `nlist.h` baÅŸlÄ±k dosyasÄ±nÄ± aÅŸaÄŸÄ±daki gibi ekliyoruz, **Ã§ifte baÄŸlÄ± listede(doubly linked list)** veri yapÄ±sÄ±nÄ±n gerÃ§ekleÅŸtiriminde kullanÄ±lacak olan baÅŸlÄ±k dosyasÄ±nÄ± aÅŸaÄŸÄ±daki gibi yazÄ±yoruz.
```C
#pragma once
// #ifndef NLIST_H
// #define NLIST_H

#include <stddef.h> // 'size_t' tÃ¼r eÅŸ adÄ±nÄ±n bildirimini iÃ§eren en hafif baÅŸlÄ±k dosyasÄ± eklendi.
#include <stdbool.h> // 'bool', 'true', 'false' gibi object-like makrolarÄ± kullanabilmek iÃ§in eklenmiÅŸtir.

typedef int DATATYPE; // BaÅŸlangÄ±Ã§ta sadece 'int' tÃ¼rÃ¼ tutan bir baÄŸlÄ± liste oluÅŸturacaÄŸÄ±z.

// 'typedef struct' bildiriminde aÅŸaÄŸÄ±daki gibi Ã¼Ã§ farklÄ± yaklaÅŸÄ±m(convension) kullanÄ±labilmektedir.
typedef struct Node {
    DATATYPE value;
    struct Node* pprev;
    struct Node* pnext;
} Node;

// 'typedef struct' bildiriminde, tÃ¼r eÅŸ adÄ±yla yapÄ±nÄ±n adÄ± farklÄ± verilmesi '_' karakteri ile saÄŸlanmÄ±ÅŸtÄ±r.
// typedef struct Node_ {
//     DATATYPE value;
//     struct Node* pprev;
//     struct Node* pnext;
// } Node;

// 'typedef struct' bildiriminde, tÃ¼r eÅŸ adÄ±yla yapÄ±nÄ±n adÄ± farklÄ± verilmesi 'tag' Ã¶n eki ile saÄŸlanmÄ±ÅŸtÄ±r Bunu daha Ã§ok Microsoft firmasÄ± tercih etmektedir.
// typedef struct tagNode {
//     DATATYPE value;
//     struct Node* pprev;
//     struct Node* pnext;
// } Node;


// List  : 'struct List' yapÄ± tÃ¼rÃ¼nÃ¼n eÅŸ adÄ±.
// *HList: 'struct List' yapÄ± tÃ¼rÃ¼nden nesnelerin adresi olan tÃ¼rÃ¼n eÅŸ adÄ±.
typedef struct List {
    Node* mphead;
    Node* mptail;
    size_t size; // Listenin dÃ¼ÄŸÃ¼m sayÄ±sÄ±nÄ± tutacak yapÄ± Ã¼yesi.
} List, *HList;


HList create_list(void);

// BaÄŸlÄ± listenin sonuna 'call by value' yÃ¶ntemiyle dÃ¼ÄŸÃ¼m eklemek iÃ§in kullanÄ±lan fonksiyon(kopyalama maliyeti dÃ¼ÅŸÃ¼k olan nesneler iÃ§in kullanÄ±ÅŸlÄ±).
Node* push_back(HList hList, DATATYPE value);

// BaÄŸlÄ± listenin sonuna 'call by reference' yÃ¶ntemiyle dÃ¼ÄŸÃ¼m eklemek iÃ§in kullanÄ±lan fonksiyon(kopyalama maliyeti yÃ¼ksek olan nesneler iÃ§in kullanÄ±ÅŸlÄ±).
Node* push_back_ptr(HList hList, const DATATYPE* pvalue);

// BaÄŸlÄ± listenin baÅŸÄ±na 'call by value' yÃ¶ntemiyle dÃ¼ÄŸÃ¼m eklemek iÃ§in kullanÄ±lan fonksiyon(kopyalama maliyeti dÃ¼ÅŸÃ¼k olan nesneler iÃ§in kullanÄ±ÅŸlÄ±).
Node* push_front(HList hList, DATATYPE value);

// BaÄŸlÄ± listenin baÅŸÄ±na 'call by reference' yÃ¶ntemiyle dÃ¼ÄŸÃ¼m eklemek iÃ§in kullanÄ±lan fonksiyon(kopyalama maliyeti yÃ¼ksek olan nesneler iÃ§in kullanÄ±ÅŸlÄ±).
Node* push_front_ptr(HList hList, const DATATYPE* pvalue);

// BaÄŸlÄ± listenin belirli bir konumundan bir Ã¶nceki konuma 'call by value' yÃ¶ntemiyle dÃ¼ÄŸÃ¼m eklemek iÃ§in kullanÄ±lan fonksiyon(kopyalama maliyeti dÃ¼ÅŸÃ¼k olan nesneler iÃ§in kullanÄ±ÅŸlÄ±).
Node* insert_prev(HList hList, Node* pnode, DATATYPE value);

// BaÄŸlÄ± listenin belirli bir konumundan bir Ã¶nceki konuma 'call by reference' yÃ¶ntemiyle dÃ¼ÄŸÃ¼m eklemek iÃ§in kullanÄ±lan fonksiyon(kopyalama maliyeti dÃ¼ÅŸÃ¼k olan nesneler iÃ§in kullanÄ±ÅŸlÄ±).
Node* insert_prev_ptr(HList hList, Node* pnode, const DATATYPE* pvalue);

// BaÄŸlÄ± listenin belirli bir konumundan bir sonraki konuma 'call by value' yÃ¶ntemiyle dÃ¼ÄŸÃ¼m eklemek iÃ§in kullanÄ±lan fonksiyon(kopyalama maliyeti dÃ¼ÅŸÃ¼k olan nesneler iÃ§in kullanÄ±ÅŸlÄ±).
Node* insert_next(HList hList, Node* pnode, DATATYPE value);

// BaÄŸlÄ± listenin belirli bir konumundan bir sonraki konuma 'call by reference' yÃ¶ntemiyle dÃ¼ÄŸÃ¼m eklemek iÃ§in kullanÄ±lan fonksiyon(kopyalama maliyeti dÃ¼ÅŸÃ¼k olan nesneler iÃ§in kullanÄ±ÅŸlÄ±).
Node* insert_next_ptr(HList hList, Node* pnode, const DATATYPE* pvalue);

// Bir dÃ¼ÄŸÃ¼mÃ¼ silmek iÃ§in kullanÄ±lan fonksiyon, bu fonksiyondan geriye Ã§oÄŸunlukla kullanÄ±lan bir konvensiyon olarak silinen dÃ¼ÄŸÃ¼mden sonraki dÃ¼ÄŸÃ¼mÃ¼n adresi dÃ¶ndÃ¼rÃ¼lÃ¼yor.
Node* erase(HList hList, Node* pnode);

// BaÄŸlÄ± listedeki belirli bir indeksteki dÃ¼ÄŸÃ¼mÃ¼ geriye dÃ¶nen fonksiyon.
DATATYPE* get_item_idx(HList hList, size_t idx);

// BaÄŸlÄ± listeyi dolaÅŸmak iÃ§in kullanÄ±lan fonksiyon.
bool traverse(HList hList, bool(*fp)(DATATYPE*));
// BaÄŸlÄ± listeyi tersten dolaÅŸmak iÃ§in kullanÄ±lan fonksiyon.
bool rtraverse(HList hList, bool(*fp)(DATATYPE*));

// TÃ¼m listeyi silmek iÃ§in kullanÄ±lan fonksyion.
void clear_list(HList hList);

void destroy_list(HList);

// 
void pop_front(HList hlist);


// BaÄŸlÄ± listenin dÃ¼ÄŸÃ¼m sayÄ±sÄ±nÄ± dÃ¶ndÃ¼ren fonksiyon. 
static inline size_t get_size(HList hList)
{
    return hList->msize;
}

static inline bool is_empty(HList)
{
    // return hList->mphead == NULL;
    return hList->msize == 0;
}


// #endif
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 20.50-21.11 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***



âœï¸ Burada `nlist.c` kaynak dosyasÄ±nÄ± aÅŸaÄŸÄ±daki gibi ekliyoruz, **Ã§ifte baÄŸlÄ± listede(doubly linked list)** veri yapÄ±sÄ±nÄ±n gerÃ§ekleÅŸtiriminde kullanÄ±lacak olan kaynak dosyayÄ± aÅŸaÄŸÄ±daki gibi yazÄ±yoruz.
```C
#include "nlist.h"
#include <stdlib.h> // Ä°lk olarak 'malloc' fonksiyonunu kullanabilmek iÃ§in eklendi.


// Yeni bir liste oluÅŸturmak iÃ§in kullanÄ±lan fonksiyon 
HList create_list(void)
{
    // HList hlist = (HList)malloc(sizeof(List));

    // Unix/Linux sistem programlamada aÅŸaÄŸÄ±daki gibi bir yazÄ±m yÃ¶ntemi tercih edilmektedir, bu yÃ¶ntemde atama operatÃ¶rÃ¼nÃ¼n Ã¼rettiÄŸi deÄŸerden faydalanÄ±lmaktadÄ±r.
    HList hlist;
    
    if((hlist = (HList)malloc(sizeof(List))) == NULL ) {
        return NULL;
    }

    hlist->mphead = hlist->mptail == NULL;
    hlist->msize = 0;

    return hlist;
}


// BaÄŸlÄ± listenin sonuna 'call by value' yÃ¶ntemiyle dÃ¼ÄŸÃ¼m eklemek iÃ§in kullanÄ±lan fonksiyon(kopyalama maliyeti dÃ¼ÅŸÃ¼k olan nesneler iÃ§in kullanÄ±ÅŸlÄ±). 
Node* push_back(HList hList, DATATYPE value)
{
    Node* newnode;

    if((newnode = (Node*)malloc(sizeof(Node))) == NULL)
        return NULL;

    newnode->value = value; // DÃ¼ÄŸÃ¼me verisi atanÄ±yor.

    if(hList->mphead != NULL) // Liste boÅŸ deÄŸil
        hList->mptail->pnext = newnode; // Son dÃ¼ÄŸÃ¼mÃ¼n bir sonraki dÃ¼ÄŸÃ¼mÃ¼ gÃ¶steren pointer'Ä± yeni dÃ¼ÄŸÃ¼mÃ¼ gÃ¶sterecek biÃ§imde ayarlanmasÄ±.
    else // Liste boÅŸ
        hList->mphead = newnode; // Liste boÅŸsa eklenen yeni dÃ¼ÄŸÃ¼m 'head' dÃ¼ÄŸÃ¼m olarak ayarlanÄ±yor.

    // Yeni eklenen dÃ¼ÄŸÃ¼m artÄ±k en son dÃ¼ÄŸÃ¼m olacaÄŸÄ± iÃ§in yeni eklenen dÃ¼ÄŸÃ¼mÃ¼n pointer Ã¼yeleri ayarlanÄ±yor.
    newnode->pprece = hlist->mptail;
    newnode->pnext = NULL;

    // Liste veriyapÄ±sÄ±nÄ±n 'mptail' ve 'msize' verileri dÃ¼zeltiliyor.
    hlist->mptail = newnode;
    ++hlist->msize;

    return newnode;
}


// BaÄŸlÄ± listenin sonuna 'call by reference' yÃ¶ntemiyle dÃ¼ÄŸÃ¼m eklemek iÃ§in kullanÄ±lan fonksiyon(kopyalama maliyeti yÃ¼ksek olan nesneler iÃ§in kullanÄ±ÅŸlÄ±). 
// Refactor this fuction later.
Node* push_back_ptr(HList hList, const DATATYPE* pvalue)
{
    Node* newnode;

    if((newnode = (Node*)malloc(sizeof(Node))) == NULL)
        return NULL;

    newnode->value = *pvalue; // DÃ¼ÄŸÃ¼me verisi atanÄ±yor.
    
    if(hList->mphead != NULL) // Liste boÅŸ deÄŸilse.
        hList->mptail->pnext = newnode; // Son dÃ¼ÄŸÃ¼mÃ¼n bir sonraki dÃ¼ÄŸÃ¼mÃ¼ gÃ¶steren pointer'Ä± yeni dÃ¼ÄŸÃ¼mÃ¼ gÃ¶sterecek biÃ§imde ayarlanmasÄ±.
    else // Liste boÅŸsa.
        hList->mphead = newnode; // Liste boÅŸsa eklenen yeni dÃ¼ÄŸÃ¼m 'head' dÃ¼ÄŸÃ¼m olarak ayarlanÄ±yor.

    // Yeni eklenen dÃ¼ÄŸÃ¼m artÄ±k en son dÃ¼ÄŸÃ¼m olacaÄŸÄ± iÃ§in yeni eklenen dÃ¼ÄŸÃ¼mÃ¼n pointer Ã¼yeleri ayarlanÄ±yor.
    newnode->pprece = hlist->mptail;
    newnode->pnext = NULL;

    // Liste veriyapÄ±sÄ±nÄ±n 'mptail' ve 'msize' verileri dÃ¼zeltiliyor.
    hlist->mptail = newnode;
    ++hlist->msize;

    return newnode;
}


// BaÄŸlÄ± listenin baÅŸÄ±na 'call by value' yÃ¶ntemiyle dÃ¼ÄŸÃ¼m eklemek iÃ§in kullanÄ±lan fonksiyon(kopyalama maliyeti dÃ¼ÅŸÃ¼k olan nesneler iÃ§in kullanÄ±ÅŸlÄ±). 
Node* push_front(HList hList, DATATYPE value)
{
    // Belki sonradan yeni dÃ¼ÄŸÃ¼m yaratma iÅŸlemini ayrÄ± bir fonksiyona alabiliriz.
    Node* newnode;
    if((newnode = (Node*)malloc(sizeof(Node))) == NULL)
        return NULL;

    newnode->value = value; // DÃ¼ÄŸÃ¼me verisi atanÄ±yor.

    // Liste nesnesindeki gÃ¶stericiler ayarlanÄ±yor.
    newnode->pnext = hList->mphead;
    newnode->pprev = NULL;

    if(hlist->mphead == NULL) // Liste boÅŸsa.
        hlist->mptail = newnode; // Yeni eklenen dÃ¼ÄŸÃ¼m listedeki tek dÃ¼ÄŸÃ¼m olduÄŸu iÃ§in ilgili listenin sonraki dÃ¼ÄŸÃ¼mÃ¼ yeni eklenen dÃ¼ÄŸÃ¼m olarak ayarlanÄ±yor.
    else // Liste boÅŸ deÄŸilse.
        hlist->mphead->pprev = newnode; // Liste boÅŸ olmadÄ±ÄŸÄ±nda listenin o andaki ilk dÃ¼ÄŸÃ¼mÃ¼ nesnesinin bir Ã¶nceki dÃ¼ÄŸÃ¼mÃ¼ gÃ¶steren gÃ¶stericisi yeni eklenen dÃ¼ÄŸÃ¼mÃ¼ gÃ¶sterecek biÃ§imde ayarlanÄ±yor.
    
    hlist->mphead = newnode; // Listenin ilk dÃ¼ÄŸÃ¼mÃ¼ yeni eklenen dÃ¼ÄŸÃ¼m olacak biÃ§imde dÃ¼zenleme yapÄ±lÄ±yor.
    ++hlist->msize; // Listede bulunan dÃ¼ÄŸÃ¼m sayÄ±sÄ± deÄŸeri bir arttÄ±rÄ±lÄ±yor.

    return newnode;
}


// BaÄŸlÄ± listenin baÅŸÄ±na 'call by reference' yÃ¶ntemiyle dÃ¼ÄŸÃ¼m eklemek iÃ§in kullanÄ±lan fonksiyon(kopyalama maliyeti yÃ¼ksek olan nesneler iÃ§in kullanÄ±ÅŸlÄ±). 
Node* push_front_ptr(HList hList, const DATATYPE* pvalue)
{
    // Belki sonradan yeni dÃ¼ÄŸÃ¼m yaratma iÅŸlemini ayrÄ± bir fonksiyona alabiliriz.
    Node* newnode;
    if((newnode = (Node*)malloc(sizeof(Node))) == NULL)
        return NULL;

    newnode->value = *pvalue; // DÃ¼ÄŸÃ¼me verisi atanÄ±yor.

    // Liste nesnesindeki gÃ¶stericiler ayarlanÄ±yor.
    newnode->pnext = hList->mphead;
    newnode->pprev = NULL;

    if(hlist->mphead == NULL) // Liste boÅŸsa.
        hlist->mptail = newnode; // Yeni eklenen dÃ¼ÄŸÃ¼m listedeki tek dÃ¼ÄŸÃ¼m olduÄŸu iÃ§in ilgili listenin sonraki dÃ¼ÄŸÃ¼mÃ¼ yeni eklenen dÃ¼ÄŸÃ¼m olarak ayarlanÄ±yor.
    else // Liste boÅŸ deÄŸilse.
        hlist->mphead->pprev = newnode; // Liste boÅŸ olmadÄ±ÄŸÄ±nda listenin o andaki ilk dÃ¼ÄŸÃ¼mÃ¼ nesnesinin bir Ã¶nceki dÃ¼ÄŸÃ¼mÃ¼ gÃ¶steren gÃ¶stericisi yeni eklenen dÃ¼ÄŸÃ¼mÃ¼ gÃ¶sterecek biÃ§imde ayarlanÄ±yor.
    
    hlist->mphead = newnode; // Listenin ilk dÃ¼ÄŸÃ¼mÃ¼ yeni eklenen dÃ¼ÄŸÃ¼m olacak biÃ§imde dÃ¼zenleme yapÄ±lÄ±yor.
    ++hlist->msize; // Listede bulunan dÃ¼ÄŸÃ¼m sayÄ±sÄ± deÄŸeri bir arttÄ±rÄ±lÄ±yor.

    return newnode;
}


// BaÄŸlÄ± listenin belirli bir konumundan bir sonraki konuma 'call by value' yÃ¶ntemiyle dÃ¼ÄŸÃ¼m eklemek iÃ§in kullanÄ±lan fonksiyon(kopyalama maliyeti dÃ¼ÅŸÃ¼k olan nesneler iÃ§in kullanÄ±ÅŸlÄ±). 
Node* insert_next(HList hList, Node* pnode, DATATYPE value)
{
    Node* newnode;
    if((newnode = (Node*)malloc(sizeof(Node))) == NULL)
        return NULL;

    newnode->value = value;

    // Ekleme sona yapÄ±lÄ±p yapÄ±lmadÄ±ÄŸÄ±na gÃ¶re yapÄ±lacak iÅŸlem deÄŸiÅŸecektir.
    if(pnode != hlist->mptail) // Eklenen dÃ¼ÄŸÃ¼m son dÃ¼ÄŸÃ¼m deÄŸilse
        pnode->pnext->pprev = newnode; // Yeni oluÅŸturulan dÃ¼ÄŸÃ¼m eklendiÄŸi yerdeki dÃ¼ÄŸÃ¼mÃ¼n bir sonraki konumuna eklendiÄŸi iÃ§in, bir sonraki konumdaki dÃ¼ÄŸÃ¼mÃ¼n bir Ã¶nceki dÃ¼ÄŸÃ¼mÃ¼nÃ¼ gÃ¶steren pointer'Ä±n yeni eklenen dÃ¼ÄŸÃ¼mÃ¼ gÃ¶stermesi saÄŸlanÄ±yor.
    else // Eklenen dÃ¼ÄŸÃ¼m son dÃ¼ÄŸÃ¼m ise
        hlist->mptail = newnode; // Son dÃ¼ÄŸÃ¼mden sonraki dÃ¼ÄŸÃ¼m olmadÄ±ÄŸÄ± iÃ§in listenin son dÃ¼ÄŸÃ¼mÃ¼ yeni eklenen dÃ¼ÄŸÃ¼m olarak ayarlanÄ±yor.


    newnode->pnext = pnode->pnext; // Yeni eklenen dÃ¼ÄŸÃ¼mÃ¼n kendinden sonraki dÃ¼ÄŸÃ¼mÃ¼ gÃ¶steren pointer'Ä± ekleme yapÄ±pan dÃ¼ÄŸÃ¼mÃ¼n kendinden bir sonraki dÃ¼ÄŸÃ¼mÃ¼nÃ¼ gÃ¶steren pointer'Ä± olacak biÃ§imde dÃ¼zenleme yapÄ±lÄ±yor.
    pnode->pnext = newnode; // Ekleme yapÄ±lan dÃ¼ÄŸÃ¼mÃ¼n kendinden sonraki dÃ¼ÄŸÃ¼mÃ¼ yeni eklenen dÃ¼ÄŸÃ¼m olacak biÃ§imde deÄŸiÅŸiklik yapÄ±lÄ±yor.

    ++hlist->msize; // Listede bulunan dÃ¼ÄŸÃ¼m sayÄ±sÄ± deÄŸeri bir arttÄ±rÄ±lÄ±yor.

    return newnode;
}


// BaÄŸlÄ± listenin belirli bir konumundan bir sonraki konuma 'call by reference' yÃ¶ntemiyle dÃ¼ÄŸÃ¼m eklemek iÃ§in kullanÄ±lan fonksiyon(kopyalama maliyeti dÃ¼ÅŸÃ¼k olan nesneler iÃ§in kullanÄ±ÅŸlÄ±). 
Node* insert_next_ptr(HList hList, Node* pnode, const DATATYPE* pvalue)
{
    Node* newnode;
    if((newnode = (Node*)malloc(sizeof(Node))) == NULL)
        return NULL;

    newnode->value = *pvalue;

    // Ekleme sona yapÄ±lÄ±p yapÄ±lmadÄ±ÄŸÄ±na gÃ¶re yapÄ±lacak iÅŸlem deÄŸiÅŸecektir.
    if(pnode != hlist->mptail) // Ekleme iÅŸlemi yapÄ±lÄ±rken referans noktasÄ± olarak kullanÄ±lacak dÃ¼ÄŸÃ¼m son dÃ¼ÄŸÃ¼m deÄŸilse.
        pnode->pnext->pprev = newnode; // Yeni oluÅŸturulan dÃ¼ÄŸÃ¼m eklendiÄŸi yerdeki dÃ¼ÄŸÃ¼mÃ¼n bir sonraki konumuna eklendiÄŸi iÃ§in, bir sonraki konumdaki dÃ¼ÄŸÃ¼mÃ¼n bir Ã¶nceki dÃ¼ÄŸÃ¼mÃ¼nÃ¼ gÃ¶steren pointer'Ä±nÄ±n yeni eklenen dÃ¼ÄŸÃ¼mÃ¼ gÃ¶stermesi saÄŸlanÄ±yor.
    else // Ekleme iÅŸlemi yapÄ±lÄ±rken referans noktasÄ± olarak kullanÄ±lacak dÃ¼ÄŸÃ¼m son dÃ¼ÄŸÃ¼m ise.
        hlist->mptail = newnode; // Son dÃ¼ÄŸÃ¼mden sonraki dÃ¼ÄŸÃ¼m olmadÄ±ÄŸÄ± iÃ§in listenin son dÃ¼ÄŸÃ¼mÃ¼ yeni eklenen dÃ¼ÄŸÃ¼m olarak ayarlanÄ±yor.


    newnode->pnext = pnode->pnext; // Yeni eklenen dÃ¼ÄŸÃ¼mÃ¼n kendinden sonraki dÃ¼ÄŸÃ¼mÃ¼ gÃ¶steren pointer'Ä± ekleme yapÄ±lan dÃ¼ÄŸÃ¼mÃ¼n kendinden bir sonraki dÃ¼ÄŸÃ¼mÃ¼nÃ¼ gÃ¶steren pointer'Ä± olacak biÃ§imde dÃ¼zenleme yapÄ±lÄ±yor.
    pnode->pnext = newnode; // Ekleme yapÄ±lan dÃ¼ÄŸÃ¼mÃ¼n kendinden sonraki dÃ¼ÄŸÃ¼mÃ¼ yeni eklenen dÃ¼ÄŸÃ¼m olacak biÃ§imde deÄŸiÅŸiklik yapÄ±lÄ±yor.

    ++hlist->msize; // Listede bulunan dÃ¼ÄŸÃ¼m sayÄ±sÄ± deÄŸeri bir arttÄ±rÄ±lÄ±yor.

    return newnode;
}


// BaÄŸlÄ± listenin belirli bir konumundan bir Ã¶nceki konuma 'call by value' yÃ¶ntemiyle dÃ¼ÄŸÃ¼m eklemek iÃ§in kullanÄ±lan fonksiyon(kopyalama maliyeti dÃ¼ÅŸÃ¼k olan nesneler iÃ§in kullanÄ±ÅŸlÄ±). 
Node* insert_prev(HList hList, Node* pnode, DATATYPE value)
{
    Node* newnode;
    if((newnode = (Node*)malloc(sizeof(Node))) == NULL)
        return NULL;

    newnode->value = value;

    if(pnode != hList->mphead) // Ekleme iÅŸlemi yapÄ±lÄ±rken referans noktasÄ± olarak kullanÄ±lacak dÃ¼ÄŸÃ¼m ilk dÃ¼ÄŸÃ¼m deÄŸilse.
        pnode->pprev->pnext = newnode; // Yeni oluÅŸturulan dÃ¼ÄŸÃ¼m eklendiÄŸi yerdeki dÃ¼ÄŸÃ¼mÃ¼n bir Ã¶nceki konumuna eklendiÄŸi iÃ§in, bir Ã¶nceki konumdaki dÃ¼ÄŸÃ¼mÃ¼n bir sonraki dÃ¼ÄŸÃ¼mÃ¼nÃ¼ gÃ¶steren pointer'Ä±nÄ±n yeni eklenen dÃ¼ÄŸÃ¼mÃ¼ gÃ¶stermesi saÄŸlanÄ±yor.
    else // Ekleme iÅŸlemi yapÄ±lÄ±rken referans noktasÄ± olarak kullanÄ±lacak dÃ¼ÄŸÃ¼m ilk dÃ¼ÄŸÃ¼m ise.
        hlist->mphead = newnode; // Ä°lk dÃ¼ÄŸÃ¼mden Ã¶nceki dÃ¼ÄŸÃ¼m olmadÄ±ÄŸÄ± iÃ§in listenin ilk dÃ¼ÄŸÃ¼mÃ¼ yeni eklenen dÃ¼ÄŸÃ¼m olarak ayarlanÄ±yor.

    newnode->pnext = pnode; // Yeni eklenen dÃ¼ÄŸÃ¼mÃ¼n kendinden sonraki dÃ¼ÄŸÃ¼mÃ¼ gÃ¶sterdiÄŸi pointer'Ä± ekleme yapÄ±lan dÃ¼ÄŸÃ¼mÃ¼n kendisini gÃ¶stercek biÃ§imde ayarlanÄ±yor.
    newnode->pprev = pnode->pprev; // Yeni eklenen dÃ¼ÄŸÃ¼mÃ¼n kendinden Ã¶nceki dÃ¼ÄŸÃ¼mÃ¼ gÃ¶steren pointer'Ä± ekleme iÅŸlemi yapÄ±lan dÃ¼ÄŸÃ¼mÃ¼n kendinden Ã¶nceki dÃ¼ÄŸÃ¼mÃ¼ gÃ¶steren pointer'Ä± olacak biÃ§imde deÄŸiÅŸiklik yapÄ±lÄ±yor.
    pnode->pprev = newnode; // Ekleme iÅŸlemi yapÄ±lan dÃ¼ÄŸÃ¼mÃ¼n kendinden Ã¶nceki dÃ¼ÄŸÃ¼mÃ¼ yeni eklenen dÃ¼ÄŸÃ¼m olacak biÃ§imde deÄŸiÅŸiklik yapÄ±lÄ±yor.
    
    ++hlist->msize; // Listede bulunan dÃ¼ÄŸÃ¼m sayÄ±sÄ± deÄŸeri bir arttÄ±rÄ±lÄ±yor.

    return newnode;
}

// BaÄŸlÄ± listenin belirli bir konumundan bir Ã¶nceki konuma 'call by reference' yÃ¶ntemiyle dÃ¼ÄŸÃ¼m eklemek iÃ§in kullanÄ±lan fonksiyon(kopyalama maliyeti dÃ¼ÅŸÃ¼k olan nesneler iÃ§in kullanÄ±ÅŸlÄ±). 
Node* insert_prev_ptr(HList hList, Node* pnode, const DATATYPE* pvalue)
{
    Node* newnode;
    if((newnode = (Node*)malloc(sizeof(Node))) == NULL)
        return NULL;

    newnode->value = *pvalue;

    if(pnode != hList->mphead) // Ekleme iÅŸlemi yapÄ±lÄ±rken referans noktasÄ± olarak kullanÄ±lacak dÃ¼ÄŸÃ¼m ilk dÃ¼ÄŸÃ¼m deÄŸilse.
        pnode->pprev->pnext = newnode; // Yeni oluÅŸturulan dÃ¼ÄŸÃ¼m eklendiÄŸi yerdeki dÃ¼ÄŸÃ¼mÃ¼n bir Ã¶nceki konumuna eklendiÄŸi iÃ§in, bir Ã¶nceki konumdaki dÃ¼ÄŸÃ¼mÃ¼n bir sonraki dÃ¼ÄŸÃ¼mÃ¼nÃ¼ gÃ¶steren pointer'Ä±nÄ±n yeni eklenen dÃ¼ÄŸÃ¼mÃ¼ gÃ¶stermesi saÄŸlanÄ±yor.
    else // Ekleme iÅŸlemi yapÄ±lÄ±rken referans noktasÄ± olarak kullanÄ±lacak dÃ¼ÄŸÃ¼m ilk dÃ¼ÄŸÃ¼m ise.
        hlist->mphead = newnode; // Ä°lk dÃ¼ÄŸÃ¼mden Ã¶nceki dÃ¼ÄŸÃ¼m olmadÄ±ÄŸÄ± iÃ§in listenin ilk dÃ¼ÄŸÃ¼mÃ¼ yeni eklenen dÃ¼ÄŸÃ¼m olarak ayarlanÄ±yor.

    newnode->pnext = pnode; // Yeni eklenen dÃ¼ÄŸÃ¼mÃ¼n kendinden sonraki dÃ¼ÄŸÃ¼mÃ¼ gÃ¶sterdiÄŸi pointer'Ä± ekleme yapÄ±lan dÃ¼ÄŸÃ¼mÃ¼n kendisini gÃ¶stercek biÃ§imde ayarlanÄ±yor.
    newnode->pprev = pnode->pprev; // Yeni eklenen dÃ¼ÄŸÃ¼mÃ¼n kendinden Ã¶nceki dÃ¼ÄŸÃ¼mÃ¼ gÃ¶steren pointer'Ä± ekleme iÅŸlemi yapÄ±lan dÃ¼ÄŸÃ¼mÃ¼n kendinden Ã¶nceki dÃ¼ÄŸÃ¼mÃ¼ gÃ¶steren pointer'Ä± olacak biÃ§imde deÄŸiÅŸiklik yapÄ±lÄ±yor.
    pnode->pprev = newnode; // Ekleme iÅŸlemi yapÄ±lan dÃ¼ÄŸÃ¼mÃ¼n kendinden Ã¶nceki dÃ¼ÄŸÃ¼mÃ¼ yeni eklenen dÃ¼ÄŸÃ¼m olacak biÃ§imde deÄŸiÅŸiklik yapÄ±lÄ±yor.
    
    ++hlist->msize; // Listede bulunan dÃ¼ÄŸÃ¼m sayÄ±sÄ± deÄŸeri bir arttÄ±rÄ±lÄ±yor.

    return newnode;
}


// Bir dÃ¼ÄŸÃ¼mÃ¼ silmek iÃ§in kullanÄ±lan fonksiyon, bu fonksiyondan geriye Ã§oÄŸunlukla kullanÄ±lan bir konvensiyon olarak silinen dÃ¼ÄŸÃ¼mden sonraki dÃ¼ÄŸÃ¼mÃ¼n adresi dÃ¶ndÃ¼rÃ¼lÃ¼yor. 
Node* erase(HList hList, Node* pnode)
{
    if(pnode == hlist->mphead) // Silinecek dÃ¼ÄŸÃ¼m ilk dÃ¼ÄŸÃ¼m ise.
        hlist->mphead = pnode->pnext; // Listenin ilk dÃ¼ÄŸÃ¼mÃ¼nÃ¼ gÃ¶steren pointer silinen dÃ¼ÄŸÃ¼mÃ¼n bir sonraki dÃ¼ÄŸÃ¼mÃ¼ olarak ayarlanÄ±yor, burada listede tek dÃ¼ÄŸÃ¼m olduÄŸunda 'hlist->mphead' deÄŸeri 'null' olacaktÄ±r.
    else // Silinecek dÃ¼ÄŸÃ¼m ilk dÃ¼ÄŸÃ¼m deÄŸil ise.
        pnode->pprev->pnext = pnode->pnext; // Silinecek dÃ¼ÄŸÃ¼mÃ¼n bir Ã¶nceki dÃ¼ÄŸÃ¼mÃ¼nÃ¼n bir sonraki dÃ¼ÄŸÃ¼mÃ¼nÃ¼ gÃ¶steren pointer silinecek dÃ¼ÄŸÃ¼mÃ¼n bir sonraki dÃ¼ÄŸÃ¼mÃ¼ olacak biÃ§imde deÄŸiÅŸtiriliyor.
    
    if(pnode == hlist->mptail) { // Silinecek dÃ¼ÄŸÃ¼m son dÃ¼ÄŸÃ¼m ise.
        hlist->mptail = pnode->pprev; // Listenin son dÃ¼ÄŸÃ¼mÃ¼nÃ¼ gÃ¶steren pointer silinen dÃ¼ÄŸÃ¼mÃ¼n bir Ã¶nceki dÃ¼ÄŸÃ¼mÃ¼ olarak ayarlanÄ±yor, burada listede tek dÃ¼ÄŸÃ¼m olduÄŸunda 'hlist->mptail' deÄŸeri 'null' olacaktÄ±r.
    }
    else { // Silinecek dÃ¼ÄŸÃ¼m son dÃ¼ÄŸÃ¼m deÄŸil ise.
        pnode->pnext->pprev = pnode->pprev; // Silinecek dÃ¼ÄŸÃ¼mÃ¼n bir sonraki dÃ¼ÄŸÃ¼mÃ¼nÃ¼n bir Ã¶nceki dÃ¼ÄŸÃ¼mÃ¼nÃ¼ gÃ¶steren pointer silinecek dÃ¼ÄŸÃ¼mÃ¼n bir Ã¶nceki dÃ¼ÄŸÃ¼mÃ¼ olacak biÃ§imde deÄŸiÅŸtiriliyor.
    }

    --hlist->msize; // Listede bulunan dÃ¼ÄŸÃ¼m sayÄ±sÄ± deÄŸeri bir azaltÄ±lÄ±yor.
}

// BaÄŸlÄ± listedeki belirli bir indeksteki dÃ¼ÄŸÃ¼mÃ¼ geriye dÃ¶nen fonksiyon. 
DATATYPE* get_item_idx(HList hList, size_t idx)
{
    // Fonksiyona geÃ§ilen indeks deÄŸeri geÃ§erli mi sÄ±namasÄ± yapÄ±lÄ±yor.
    if(idx >= hlist->msize)
        return NULL;

    Node* pnode = hlist->mphead; // listenin ilk dÃ¼ÄŸÃ¼mÃ¼nÃ¼n adres deÄŸeri 'pnode' nesnesine atanÄ±yor.

    // Girilen indekse kadar listede dolaÅŸÄ±lÄ±p ilgili indekse gelindiÄŸinde aradÄ±ÄŸÄ±mÄ±z dÃ¼ÄŸÃ¼mÃ¼ bulmuÅŸ oluyoruz.
    for(size_t i = 0; i < idx; ++i) {
        pnode = pnode->pnext;
    }

    return &pnode->value;
}


// BaÄŸlÄ± listeyi dolaÅŸmak iÃ§in kullanÄ±lan fonksiyon. 
// Bu fonkisyonu anlayabilmek iÃ§in 'funciton pointer' konusunun iyi bilinmesi gerekiyor.
bool traverse(HList hList, bool(*fp)(DATATYPE*))
{
    for(Node* pnode = hList->mphead; pnode != NULL; pnode = pnode->pnext)
        if(!fp(&pnode->value))
            return false;
    
    return true;
}


// BaÄŸlÄ± listeyi tersten dolaÅŸmak iÃ§in kullanÄ±lan fonksiyon. 
bool rtraverse(HList hList, bool(*fp)(DATATYPE*))
{
    for(Node* pnode = hList->mptail; pnode != NULL; pnode = pnode->pprev)
        if(!fp(&pnode->value))
            return false;
    
    return true;
}


// TÃ¼m listeyi silmek iÃ§in kullanÄ±lan fonksyion. 
void clear_list(HList hList)
{
    Node* pnode = hlist->mphead; // Listenin ilk dÃ¼ÄŸÃ¼mÃ¼n adresi 'pnode' adÄ±ndaki nesnesine atanÄ±yor. 

    // Bu dÃ¶ngÃ¼ ile listedeki tÃ¼m dÃ¼ÄŸÃ¼mler siliniyor.
    while(pnode != NULL) {
        Node* ptemp = pnode->pnext; // Bir sonraki dÃ¼ÄŸÃ¼mÃ¼n adresi 'ptemp' adÄ±ndaki nesneye atanÄ±yor.
        free(pnode); // Ä°lgili dÃ¼ÄŸÃ¼m bellekten dÃ¼ÅŸÃ¼rÃ¼lÃ¼p iade ediliyor.
        pnode = ptemp; // Yeni 'pnode' dÃ¼ÄŸÃ¼mÃ¼ 'ptemp' olarak ayarlanÄ±yor.
    }

    hlist->mphead = hlist->mptail = NULL; // Listenin pointer Ã¼yelerinin deÄŸerleri 'NULL pointer' olarak gÃ¼ncelleniyor.
    hlist->msize = 0; // Listedeki dÃ¼ÄŸÃ¼m sayÄ±sÄ± deÄŸeri '0' yapÄ±lÄ±yor.
}


// Listeyi bellekten dÃ¼ÅŸÃ¼rmek iÃ§in kullanÄ±lan fonksiyon. 
void destroy_list(HList hlist)
{
    clear_list(hlist); // Listeteki tÃ¼m dÃ¼ÄŸÃ¼mleri silmek(dÃ¼ÄŸÃ¼mlerin bellekleri iade edilir) iÃ§in yapÄ±lan fonksiyon Ã§aÄŸrÄ±sÄ±.

    free(hlist); // Listenin kendi belleÄŸi iade ediliyor.
}


// Listenin baÅŸÄ±ndaki ilk dÃ¼ÄŸÃ¼mÃ¼ listeden Ã§Ä±kartma iÅŸlemini yapan fonksiyon. 
void pop_front(HList hlist)
{
    erase_from_list(hlist, hlist->mphead);
}
```


ğŸ“Œ BazÄ± durumlarda kod tekrar edebilir, bunun yapÄ±lmasÄ±nÄ±n nedeni kodun tekilleÅŸtirilmesinin kodun kalitesini dÃ¼ÅŸÃ¼rÃ¼yor olmasÄ± olabilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda yazdÄ±ÄŸÄ±mÄ±z baÄŸlÄ± liste modÃ¼lÃ¼nÃ¼ sÄ±nama iÅŸlemleri iÃ§in yazÄ±lmÄ±ÅŸ olan ilk program incelenebilir.
```C
#include "nlist.h"
#include <stdio.h>
#include <stdlib.h> // Ä°lk olarak 'exit' fonksiyonunu kullanmak iÃ§in eklenmiÅŸtir.


bool print_item(int* p)
{
    int n;

    if((n = printf("%d ", *p)) == 0)
        return false;
    
    return true;
}


int main()
{
    HList hlist;

    if((hlist = create_list()) == NULL) {
        fprintf(stderr, "cannot create linked list!\n");
        // return 1;
        exit(EXIT_FAILURE);
    }

    printf("size = %zu\n", get_size(hlist));

    if(is_empty(hlist)) {
        printf("the list is empty!\n");
    }
    else {
        printf("the list is not empty!\n");
    }


    Node* p;

    for(int i = 0; i < 20; ++i) {
        if((p = push_back(hlist, i + 1)) == NULL) {
            fprintf(stderr, "cannot add item to the linked list!\n");
            exit(EXIT_FAILURE);
        }
    }

    printf("size = %zu\n", get_size(hlist));

    traverse(hlist, &print_item);
    clear_list(hlist);

    printf("size = %zu\n", get_size(hlist));
    if(is_empty(hlist)) {
        printf("the list is empty!\n");
    }
    else {
        printf("the list is not empty!\n");
    }

    destroy_list(hlist);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda yazdÄ±ÄŸÄ±mÄ±z baÄŸlÄ± liste modÃ¼lÃ¼nÃ¼ sÄ±nama iÅŸlemleri iÃ§in yazÄ±lmÄ±ÅŸ olan ikinci program incelenebilir.
```C
#include "nlist.h"
#include <stdio.h>
#include <stdlib.h> // Ä°lk olarak 'exit' fonksiyonunu kullanmak iÃ§in eklenmiÅŸtir.


bool print_item(int* p)
{
    int n;

    if((n = printf("%d ", *p)) == 0)
        return false;
    
    return true;
}


int main()
{
    HList hlist;

    if((hlist = create_list()) == NULL) {
        fprintf(stderr, "cannot create linked list!\n");
        // return 1;
        exit(EXIT_FAILURE);
    }

    printf("size = %zu\n", get_size(hlist));

    if(is_empty(hlist)) {
        printf("the list is empty!\n");
    }
    else {
        printf("the list is not empty!\n");
    }


    Node* p;

    for(int i = 0; i < 20; ++i) {
        if((p = push_front(hlist, i + 1)) == NULL) {
            fprintf(stderr, "cannot add item to the linked list!\n");
            exit(EXIT_FAILURE);
        }
    }

    printf("size = %zu\n", get_size(hlist));

    traverse(hlist, &print_item);
    
    while(!is_empty(hlist)) {
        printf("value = %d, size = %zu\n", *get_item_idx(hlist, 0), get_size(hlist));
        pop_front(hlist);
        (void)getchar(); // Standart giriÅŸ akÄ±mÄ±ndan bir karakter girilmesi beklenecek.
    }

    destroy_list(hlist);
}
```


Ders sonu ...
