# 55.Ders 26.07.2025 ğŸ•˜

---

## Dosya Konum GÃ¶stericisi(File Pointer) Ãœzerinde Ä°ÅŸlem Yapan Fonksiyonlar ğŸŒŸ 

Bir dosyanÄ±n istenilen herhangi bir byte'Ä±ndan itibaren okuma ya da yazma iÅŸleminin yapÄ±lmasÄ±nÄ± saÄŸlayan fonksiyonlar bu baÅŸlÄ±k altÄ±nda incelenecektir.

Bu iÅŸlemler iÃ§in standart C kÃ¼tÃ¼phenesi bize beÅŸ tane fonksiyon saÄŸlamaktadÄ±r;
- `fseek`
- `rewind`
- `ftell`
- `fsetpos`
- `fsetpos`


### `fseek`, `rewind` ve `ftell` FonksiyonlarÄ± 

`fseek` fonksiyonunun prototipi `int fseek(FILE* _Stream, long _Offset, int _Origin);` biÃ§imindedir, bu fonksiyon "dosyada aramak" anlamÄ±na gelen "**File Seek**" sÃ¶zcÃ¼klerinden kÄ±saltÄ±larak elde edimiÅŸtir ve **dosya konum gÃ¶stericisinin(file pointer)** deÄŸreini deÄŸiÅŸtirmek iÃ§in kullanÄ±lan bir fonksiyondur. </br>
`rewind` fonksiyonunun prototipi `void rewind(FILE*);` biÃ§imindedir, bu fonksiyon **dosya konum gÃ¶stericisinin(file pointer)** deÄŸerini dosyanÄ±n baÅŸÄ±na Ã§ekmek iÃ§in kullanÄ±lÄ±r. </br>
`ftell` fonksiyonunun prototipi `long ftell(FILE*);` biÃ§imindedir, bu fonksiyon **dosya konum gÃ¶stericisinin(file pointer)** deÄŸerini Ã¶ÄŸrenmek iÃ§in kullanÄ±lÄ±r.



âš ï¸ C standart kÃ¼tÃ¼phenesinin `stdio.h` baÅŸlÄ±k dosyasÄ±yla ilgili ÅŸu eleÅŸtiri yapÄ±labilir: `stdio.h` baÅŸlÄ±k dosyasÄ±ndaki fonksiyonlardan dosyalar Ã¼zerinde iÅŸlem yapan fonksiyonlarÄ±n bazÄ±larÄ±nda `FILE*` tÃ¼rÃ¼ ilk parametre bazÄ±sÄ±nda son parametre, neden hep ilk pametre ya da son parametre deÄŸil. Bunun nedeni muhtemelen dosyalar Ã¼zerinde iÅŸlem yapan fonksiyonlarÄ±n zamanla tek tek dile eklenmesi ve fonksiyonlarÄ± tasarlarken bir ortak yaklaÅŸÄ±ma uyulmamasÄ±dÄ±r.


`fseek` fonksiyonu **dosya konum gÃ¶stericisinin(file pointer)** deÄŸerini belirleyen fonksiyondur, **dosya konum gÃ¶stericisinin(file pointer)** deÄŸerini deÄŸiÅŸtirmek iÃ§in Ã§aÄŸrÄ±labilecek Ã¼Ã§ tane fonkisyondan(diÄŸer ikisi: `rewind` ve `fsetpos`) biridir. </br>
`fseek` fonksiyonu Ã¼Ã§Ã¼ncÃ¼ parametresi Ã§aÄŸroyÄ± yapan koddan Ã¼Ã§ farklÄ± deÄŸerden birini beklemektedir, bu seÃ§enekler **object like makro** olarak mevcuttur, bu makrolar `stdio.h` baÅŸlÄ±k dosyasÄ±nda bulunan `SEEK_SET`, `SEEK_CUR`, `SEEK_END` makrolarÄ±dÄ±r. </br>
`fseek` fonksiyonunun Ã¼Ã§Ã¼ncÃ¼ parametresine `SEEK_SET`, `SEEK_END`, `SEEK_CUR` deÄŸerlerinden hangisinin geÃ§ildiÄŸi konumlandÄ±rma iÅŸleminde hangi noktanÄ±n baÅŸlangÄ±Ã§(origin) olarak alÄ±nacaÄŸÄ±nÄ± belirlemektedir. </br>
`fseek` fonksiyonunun Ã¼Ã§Ã¼ncÃ¼ parametresine `SEEK_SET` deÄŸeri geÃ§ildiÄŸinde, **dosya konum gÃ¶stericisinin(file pointer)** deÄŸeri dosyanÄ±n baÅŸÄ±ndan itibaren fonksiyona geÃ§ilen ikinci parametredeki deÄŸerin indeksine konumlandÄ±rÄ±lacaktÄ±r. </br>
`fseek` fonksiyonunun Ã¼Ã§Ã¼ncÃ¼ parametresine `SEEK_END` deÄŸeri geÃ§ildiÄŸinde, **dosya konum gÃ¶stericisinin(file pointer)** deÄŸeri dosyanÄ±n sonundan itibaren fonksiyona geÃ§ilen ikinci parametredeki deÄŸerin indeksine konumlandÄ±rÄ±lacaktÄ±r, fakat bu durumda ikinci parametre negatif bir tam sayÄ± olmalÄ±dÄ±r. </br>
`fseek` fonksiyonunun Ã¼Ã§Ã¼ncÃ¼ parametresine `SEEK_CUR` deÄŸeri geÃ§ildiÄŸinde, **dosya konum gÃ¶stericisinin(file pointer)** deÄŸeri dosya Ã¼zerinden yapÄ±lan okuma/yazma iÅŸlemlerinde **dosya konum gÃ¶stericisinin(file pointer)** en son bulunduÄŸu konuma gÃ¶re fonksiyona geÃ§ilen ikinci parametredeki deÄŸerin indeksine konumlandÄ±rÄ±lacaktÄ±r, bu durumda ikinci parametre duruma gÃ¶re pozitif ya da negatif bir deÄŸer alabilir. </br>
`fseek` fonksiyonu baÅŸarÄ±lÄ± olmasÄ± durumunda "0" deÄŸerini dÃ¶ndÃ¼rÃ¼r, baÅŸarÄ±sÄ±z olmasÄ± durumunda ise "non-zero" deÄŸer dÃ¶ndÃ¼rÃ¼r.



`FILE *f; fseek(f, 0L, SEEK_SET);` gibi bir kullanÄ±m **dosya konum gÃ¶stericisinin(file pointer)** deÄŸerini dosyanÄ±n ilk byte'Ä±na Ã§ekmeyi saÄŸlar. Bu iÅŸlemi yapmak iÃ§in `rewind` fonksiyonu da kullanÄ±labiliyor. </br>
`FILE *f; fseek(f, 100, SEEK_SET);` gibi bir kullanÄ±m **dosya konum gÃ¶stericisinin(file pointer)** deÄŸerini dosyanÄ±n baÅŸÄ±ndan itibaren 100 indeksli konuma Ã§ekmeyi saÄŸlar. </br>

`FILE *f; fseek(f, 0L, SEEK_END);` gibi bir kullanÄ±m **dosya konum gÃ¶stericisinin(file pointer)** deÄŸerini dosyanÄ±n son byte'Ä±na Ã§ekmeyi saÄŸlar. Bu iÅŸlem iki farklÄ± durum iÃ§in kullanÄ±labilir, bir dosyanÄ±n sonuna yazma iÅŸlemi yapabilmek iÃ§in kullanÄ±labilir(mesela append iÅŸleminde bu yapÄ±lmaktadÄ±r) ya da bir dosyanÄ±n byte olarak bÃ¼yÃ¼klÃ¼ÄŸÃ¼nÃ¼ ne olduÄŸunu Ã¶ÄŸrenmek iÃ§in kullanÄ±labilir(bunun iÃ§in `ftell` fonksiyonu kullanÄ±lÄ±yor). </br>
`FILE *f; fseek(f, -30L, SEEK_END);` gibi bir kullanÄ±m **dosya konum gÃ¶stericisinin(file pointer)** deÄŸerini dosyanÄ±n sonundan 30 byte geri alÄ±nÄ±r.

`FILE *f; fseek(f, 102L, SEEK_CUR);` gibi bir kullanÄ±m **dosya konum gÃ¶stericisinin(file pointer)** deÄŸerini son bulunulan konumdan 102 byte ileriye alÄ±nmÄ±ÅŸ olur.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda en sade haliyle `ftell` kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    FILE* f = fopen("primes10000.dat", "rb");

    if(f == NULL){
        printf("dasya acilamadi.\n"); // Hata durumlarÄ±nda bÃ¶yle Ã§Ä±ktÄ± vermek yerine sorunlu durumun bir dosyaya yazdÄ±rÄ±lmasÄ± daha iyi bir yaklaÅŸÄ±mdÄ±r.
        // fprintf(stderr, "dasya acilamadi.\n", file_pointer); // Sorunlu durum bu kullanÄ±mla dosyaya yazdÄ±rÄ±labilir.
        return 1;
    }

    printf("%ld\n", ftell(f)); // Burada dosya yeni aÃ§Ä±ldÄ±ÄŸÄ± iÃ§in 'file pointer' deÄŸeri '0' olacaktÄ±r.

    fclose(f);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iÃ§eriÄŸinde sÄ±rasÄ±yla belirli bir sayÄ±da asal sayÄ±lar tutulan bir dosyadan `fseek` fonksiyonu ile n. bir asal sayÄ±nÄ±n nasÄ±l tespit edilebildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    FILE* f = fopen("primes10000.dat", "rb");

    if(f == NULL){
        printf("dasya acilamadi.\n"); // Hata durumlarÄ±nda bÃ¶yle Ã§Ä±ktÄ± vermek yerine sorunlu durumun bir dosyaya yazdÄ±rÄ±lmasÄ± daha iyi bir yaklaÅŸÄ±mdÄ±r.
        // fprintf(stderr, "dasya acilamadi.\n", file_pointer); // Sorunlu durum bu kullanÄ±mla dosyaya yazdÄ±rÄ±labilir.
        return 1;
    }

    int n;
    printf("kacinci asal sayi: ");
    scanf("%d", &n);
    fseek(f, (n - 1) * (long)sizeof(int), SEEK_SET);

    int x;
    fread(&x, sizeof(int), 1, f);
    printf("%d. asal sayi %d.\n", n, x);


    fclose(f);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iÃ§eriÄŸinde belirli bir sayÄ±da `Person` tÃ¼rÃ¼nden verinin tutulduÄŸu bir dosyadan `fseek` fonksiyonu ile n. bir `Person` verisinin nasÄ±l tespit edilebildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "person.h"

int main(void)
{
    FILE* f = fopen("people20000.dat", "rb");

    if(f == NULL){
        printf("dasya acilamadi.\n"); // Hata durumlarÄ±nda bÃ¶yle Ã§Ä±ktÄ± vermek yerine sorunlu durumun bir dosyaya yazdÄ±rÄ±lmasÄ± daha iyi bir yaklaÅŸÄ±mdÄ±r.
        // fprintf(stderr, "dasya acilamadi.\n", file_pointer); // Sorunlu durum bu kullanÄ±mla dosyaya yazdÄ±rÄ±labilir.
        return 1;
    }

    int n;
    printf("kacinci kullanici kaydi: ");
    scanf("%d", &n);

    fseek(f, (n - 1) * (long)sizeof(Person), SEEK_SET);
    Person per;

    fread(&per, sizeof per, 1, f);
    printf_person(&per);

    fclose(f);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iÃ§eriÄŸinde belirli bir sayÄ±da `Person` tÃ¼rÃ¼nden verinin tutulduÄŸu bir dosyadan `fseek` fonksiyonu ile n. bir `Person` verisinin nasÄ±l tespit edilebildiÄŸi ve ardÄ±ndan dosyanÄ±n baÅŸÄ±ndaki `Person` verisinin nasÄ±l tespit edilebildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "person.h"

int main(void)
{
    FILE* f = fopen("people20000.dat", "rb");

    if(f == NULL){
        printf("dasya acilamadi.\n"); // Hata durumlarÄ±nda bÃ¶yle Ã§Ä±ktÄ± vermek yerine sorunlu durumun bir dosyaya yazdÄ±rÄ±lmasÄ± daha iyi bir yaklaÅŸÄ±mdÄ±r.
        // fprintf(stderr, "dasya acilamadi.\n", file_pointer); // Sorunlu durum bu kullanÄ±mla dosyaya yazdÄ±rÄ±labilir.
        return 1;
    }

    int n;
    printf("kacinci kullanici kaydi: ");
    scanf("%d", &n);
    
    fseek(f, (n - 1) * (long)sizeof(Person), SEEK_SET);
    Person per;

    rewind(f); // 'fseek(f, 0L, SEEK_SET);' ile aynÄ± iÅŸi yapan dosyanÄ±n baÅŸÄ±nÄ±n gÃ¶sterilmesini saÄŸlayan fonksiyon Ã§aÄŸrÄ±sÄ±.
    
    fread(&per, sizeof per, 1, f);
    printf_person(&per);

    fclose(f);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `fseek` ve `ftell` fonksiyonlarÄ±nÄ± kullanrak bir dosyanÄ±n dÃ¼yÃ¼klÃ¼ÄŸÃ¼nÃ¼n nasÄ±l elde edildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "person.h"

int main(void)
{
    FILE* f = fopen("people1000000.dat", "rb");

    if(f == NULL){
        printf("dasya acilamadi.\n"); // Hata durumlarÄ±nda bÃ¶yle Ã§Ä±ktÄ± vermek yerine sorunlu durumun bir dosyaya yazdÄ±rÄ±lmasÄ± daha iyi bir yaklaÅŸÄ±mdÄ±r.
        // fprintf(stderr, "dasya acilamadi.\n", file_pointer); // Sorunlu durum bu kullanÄ±mla dosyaya yazdÄ±rÄ±labilir.
        return 1;
    }

    fseek(f, 0L, SEEK_END);
    printf("dosya buyuklugu %ld\n", ftell(f));

    fclose(f);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iÃ§inde `Person` tÃ¼rÃ¼nden verilerin olduÄŸu bir dosyanÄ±n bÃ¼yÃ¼klÃ¼ÄŸÃ¼nÃ¼n nasÄ±l tespit edildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "person.h"

int main(void)
{
    FILE* f = fopen("people10000.dat", "rb");

    if(f == NULL){
        printf("dasya acilamadi.\n"); // Hata durumlarÄ±nda bÃ¶yle Ã§Ä±ktÄ± vermek yerine sorunlu durumun bir dosyaya yazdÄ±rÄ±lmasÄ± daha iyi bir yaklaÅŸÄ±mdÄ±r.
        // fprintf(stderr, "dasya acilamadi.\n", file_pointer); // Sorunlu durum bu kullanÄ±mla dosyaya yazdÄ±rÄ±labilir.
        return 1;
    }

    printf("sizeof(Person) = %zu", sizeof(Person));
    fseek(f, 0L, SEEK_END);
    printf("dosya buyuklugu %ld\n", ftell(f));

    fclose(f);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iÃ§inde `Person` tÃ¼rÃ¼nden verilerin olduÄŸu bir dosyanÄ±n bÃ¼yÃ¼klÃ¼ÄŸÃ¼nÃ¼n nasÄ±l tespit edildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "person.h"
#include "nutility.h"

int main(void)
{
    FILE* f = fopen("people10000.dat", "wb+"); // DosyanÄ±n iÃ§eriÄŸini silmeden dosyada yazma iÅŸlemi yapabilmek iÃ§in dosynÄ±n 'write binary +' olarak aÃ§Ä±lmasÄ±.

    if(f == NULL){
        printf("dasya acilamadi.\n"); // Hata durumlarÄ±nda bÃ¶yle Ã§Ä±ktÄ± vermek yerine sorunlu durumun bir dosyaya yazdÄ±rÄ±lmasÄ± daha iyi bir yaklaÅŸÄ±mdÄ±r.
        // fprintf(stderr, "dasya acilamadi.\n", file_pointer); // Sorunlu durum bu kullanÄ±mla dosyaya yazdÄ±rÄ±labilir.
        return 1;
    }

    randomize();
    Person per;
    set_random_person(&per);
    printf_person(&per);

    fseek(f, 0L, SEEK_END); // 'file pointer' dosyanÄ±n sonunu gÃ¶sterecek biÃ§imde ayarlanÄ±yor.

    fwrite(&per, sizeof Per, 1, f); // Burada dosyanÄ±n sonuna yeni Ã¼retilen 'Person' kaydÄ± ekleniyor.

    fclose(f);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iÃ§inde `Person` tÃ¼rÃ¼nden verilerin olduÄŸu bir dosyanÄ±n bÃ¼yÃ¼klÃ¼ÄŸÃ¼nÃ¼n nasÄ±l tespit edildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "person.h"
#include "nutility.h"

int main(void)
{
    FILE* f = fopen("people10000.dat", "rb+"); // DosyanÄ±n iÃ§eriÄŸini silmeden dosyada yazma ve okuma iÅŸlemlerini yapabilmek iÃ§in dosynÄ±n 'read binary +' olarak aÃ§Ä±lmasÄ±.

    if(!f){
        printf("dasya acilamadi.\n"); // Hata durumlarÄ±nda bÃ¶yle Ã§Ä±ktÄ± vermek yerine sorunlu durumun bir dosyaya yazdÄ±rÄ±lmasÄ± daha iyi bir yaklaÅŸÄ±mdÄ±r.
        // fprintf(stderr, "dasya acilamadi.\n", file_pointer); // Sorunlu durum bu kullanÄ±mla dosyaya yazdÄ±rÄ±labilir.
        return 1;
    }

    fseek(f, 0L, SEEK_END); // 'file pointer' dosyanÄ±n sonunu gÃ¶sterecek biÃ§imde ayarlanÄ±yor.
    printf("%ld\n", ftell(f)); // DosyanÄ±n boyutu yazdÄ±rÄ±lÄ±yor.

    // Dosyaya yeni bir kaydÄ±n eklenmsi.
    randomize();
    Person per;
    set_random_person(&per);
    print_person(&per);
    fwrite(&per, sizeof per, 1, f);

    rewind(f); // 'file pointer' dosyanÄ±n sonunu gÃ¶sterecek biÃ§imde ayarlanÄ±yor.
    printf("%ld\n", ftell(f)); // DosyanÄ±n boyutu yazdÄ±rÄ±lÄ±yor.

    fclose(f); 
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda kullanÄ±cÄ± bilgilerinin kayÄ±tlÄ± olduÄŸu dosyanÄ±n verilerinin okunmasÄ± iÅŸleminin bir fonksiyona alÄ±nmasÄ± iÅŸleminin nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "person.h"
#include "nutility.h"
#include <stdlib.h> // 'exit' fonksiyonunu kullanmak iÃ§in eklendi.

void print_records(const char* filename)
{
    FILE* f = fopen(filename, "rb");
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    Person per;

    // Dosyadaki tÃ¼m 'Person' tÃ¼rÃ¼nden kayÄ±tlarÄ±n dosyanÄ±n sonuna kadar yazdÄ±rÄ±lmasÄ± iÅŸlemi.
    while(fread(&per, sizeof(Person), 1, f)){
        printf_person(&per);
    }

    fclose(f);
}

int main(void)
{
    print_records("people1000.dat");
    (void)getchar();
    print_records("people1000.dat");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda kullanÄ±cÄ± bilgilerinin kayÄ±tlÄ± olduÄŸu dosyaya yeni veri ekleme ve dosyadaki verilerinin okunmasÄ± iÅŸleminin birer fonksiyona alÄ±narak nasÄ±l kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "person.h"
#include "nutility.h"
#include <stdlib.h> // 'exit' fonksiyonunu kullanmak iÃ§in eklendi.

void print_records(const char* filename)
{
    FILE* f = fopen(filename, "rb");
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    Person per;

    // Dosyadaki tÃ¼m 'Person' tÃ¼rÃ¼nden kayÄ±tlarÄ±n dosyanÄ±n sonuna kadar yazdÄ±rÄ±lmasÄ± iÅŸlemi.
    while(fread(&per, sizeof(Person), 1, f)){
        printf_person(&per);
    }

    fclose(f);
}

void add_record(const char* filename, const Person* p)
{
    FILE* f = fopen(filename, "ab"); // 'ab' modunda sadece dosyanÄ±n sonuna yazma iÅŸlemi yapÄ±labilir biÃ§imde dosya aÃ§Ä±lÄ±yor.
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    fwrite(p, sizeof(Person), 1, f);

    fclose(f);
}

int main(void)
{
    randomize();

    Person per;
    set_random_person(&per);
    print_person(&per);
    add_record("people.dat", &per);

    print_records("people.dat");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda kullanÄ±cÄ± bilgilerinin kayÄ±tlÄ± olduÄŸu dosyaya dÃ¶ngÃ¼ ile yeni veriler eklenmesi ve dosyadaki verilerinin okunmasÄ± iÅŸleminin birer fonksiyona alÄ±narak nasÄ±l kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "person.h"
#include "nutility.h"
#include <stdlib.h> // 'exit' fonksiyonunu kullanmak iÃ§in eklendi.

void print_records(const char* filename)
{
    FILE* f = fopen(filename, "rb");
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    Person per;

    // Dosyadaki tÃ¼m 'Person' tÃ¼rÃ¼nden kayÄ±tlarÄ±n dosyanÄ±n sonuna kadar yazdÄ±rÄ±lmasÄ± iÅŸlemi.
    while(fread(&per, sizeof(Person), 1, f)){
        printf_person(&per);
    }

    fclose(f);
}

void add_record(const char* filename, const Person* p)
{
    FILE* f = fopen(filename, "ab"); // 'ab' modunda sadece dosyanÄ±n sonuna yazma iÅŸlemi yapÄ±labilir biÃ§imde dosya aÃ§Ä±lÄ±yor.
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    fwrite(p, sizeof(Person), 1, f);

    fclose(f);
}

int get_record_count(const char* filename)
{
    FILE* f = fopen(filename, "rb"); // 'rb' modunda sadece dosyanÄ±n binary olarak okunabilmesi iÅŸlemini yapÄ±labilir biÃ§imde dosya aÃ§Ä±lÄ±yor.
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    fseek(f, 0, SEEK_END); 

    int rec_cnt = (int)(ftell(f) / sizeof(Person));

    fclose(f);

    return rec_cnt;
}

int main(void)
{
    randomize();

    Person per;

    for(int i = 0; i < 1000; ++i){
        set_random_person(&per);
        add_record("people.dat", &per);
    }
    
    print_records("people.dat");

    printf("dosyadaki kayit sayisi: %d\n", get_record_count("people.dat"));
}
```



â—â—â— `fseek` fonksiyonunun kullanÄ±mÄ±yla ilgili Ã§ok sÄ±k yapÄ±lan ve **ub** ye neden olan durum ÅŸaÄŸÄ±da belirtilmiÅŸtir. </br>
EÄŸer okuma iÅŸleminden sonra yazma iÅŸlemi yapÄ±lacaksa ya da tma tersi yazma iÅŸleminden sonra okuma iÅŸlemi yapÄ±lacaksa mutlama **dosya konum gÃ¶stericisinin(file pointer)** konumlandÄ±rÄ±lmasÄ± gerekir(`fflush` fonksiyonua yapÄ±lan Ã§aÄŸrÄ± da bunu saÄŸlar). </br>
Okuma iÅŸleminden yazma iÅŸlemine geÃ§erken ya da yazma iÅŸleminden okuma iÅŸlemine geÃ§erken **Dosya konum gÃ¶stericisinin(file pointer)** bulunduÄŸu konumdan itibaren iÅŸlem yapÄ±lacak olsa bile mutlaka `rewind(f);` veya `fseek(f, 0L, SEEK_SET);` fonksiyon Ã§aÄŸrÄ±larÄ± yapÄ±lÄ±r.



***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.36-10.55 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***



ğŸ‘‡ AÅŸaÄŸÄ±daki programda dosyadan okunan belirli kayÄ±tlardaki bilgilerin deÄŸiÅŸtirilerek yeniden aynÄ± dosyaya nasÄ±l yazdÄ±rÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "person.h"
#include "nutility.h"
#include <stdlib.h> // 'exit' fonksiyonunu kullanmak iÃ§in eklendi.
#include <string.h> // 'strcmp' fonksiyonunu kullanmak iÃ§in eklendi.

void print_records(const char* filename)
{
    FILE* f = fopen(filename, "rb");
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    Person per;

    // Dosyadaki tÃ¼m 'Person' tÃ¼rÃ¼nden kayÄ±tlarÄ±n dosyanÄ±n sonuna kadar yazdÄ±rÄ±lmasÄ± iÅŸlemi.
    while(fread(&per, sizeof(Person), 1, f)){
        printf_person(&per);
    }

    fclose(f);
}

void add_record(const char* filename, const Person* p)
{
    FILE* f = fopen(filename, "ab"); // 'ab' modunda sadece dosyanÄ±n sonuna yazma iÅŸlemi yapÄ±labilir biÃ§imde dosya aÃ§Ä±lÄ±yor.
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    fwrite(p, sizeof(Person), 1, f);

    fclose(f);
}

int get_record_count(const char* filename)
{
    FILE* f = fopen(filename, "rb"); // 'rb' modunda sadece dosyanÄ±n binary olarak okunabilmesi iÅŸlemini yapÄ±labilir biÃ§imde dosya aÃ§Ä±lÄ±yor.
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    fseek(f, 0, SEEK_END); 

    int rec_cnt = (int)(ftell(f) / sizeof(Person));

    fclose(f);

    return rec_cnt;
}

// Dosyadaki kayÄ±t ya da kayÄ±tlarÄ± deÄŸiÅŸtirmeye yÃ¶nelik fonksiyon
int modify_records(const char* filename, const char* oldname, const char* newname)
{
    FILE* f = fopen(filename, "rb+"); // 'rb+' modunda dosyanÄ±n binary olarak hem okunabilir hem de yazÄ±labilir biÃ§imde dosya aÃ§Ä±lÄ±yor.
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    Person per; // Dosyada okuma ve yazma iÅŸlemlerini yaparken kullanÄ±lacak olan deÄŸiÅŸken bildirimi yapÄ±lÄ±yor.
    int count = 0;

    while(fread(&per, sizeof(Person), 1, f)){
        if(!strcmp(per.name, oldname)){
            strcpy(per.name, newname);
            fseek(f, -(long)sizeof(Person), SEEK_CUR); // Dosyaya yazma iÅŸlemi yapmadan Ã¶nce Ã¼zerine yazÄ±lacak kaydÄ±n ayarlanmasÄ± iÃ§in 'file pointer' deÄŸeri ayarlarnÄ±yor.
            fwrite(&per, sizeof(Person), 1, f); // Dosyada deÄŸiÅŸtirilecek kaydÄ±n Ã¼zerine yazma iÅŸlemi.
            fseek(f, 0L, SEEK_CUR); // Dosyaya yazma iÅŸleminden dosyadan okuma iÅŸlemine geÃ§iÅŸ yapÄ±lacaÄŸÄ± iÃ§in 'file pointer' en son kaldÄ±ÄŸÄ± yeri gÃ¶sterecek biÃ§imde ayarlanÄ±yor.

            ++count;
        }
    }

    fclose(f);
    return count;
}

int main(void)
{
    int n = modify_records("people.dat", "hasan", "mete");

    printf("toplamda %d kayit degistirildi.\n", n);

    print_records("people.dat");
}
```


â—â—â— Dosyalarla yapÄ±lan iÅŸlemlerde bir dosyadan veri silmek gibi bir iÅŸlem mevcut deÄŸil, bir dosya bÃ¼yÃ¼yÃ¼ bilir ama kÃ¼Ã§Ã¼lemez. Bir dosyadan bazÄ± veriler silinmek isteniyorsa yeni bir dosya oluÅŸturulur eski dosyadaki verilerden silinecekler haricindekiler yeni dosyaya kopyalanÄ±r iki dosya kapatÄ±ldÄ±ktan sonra eski dosya silinir ve yeni dosyanÄ±n adÄ± eski dosya ile aynÄ± yapÄ±lÄ±r, bÃ¶ylece dosyadan istenmeyen veriler silinmiÅŸ olur.



ğŸ‘‡ AÅŸaÄŸÄ±daki program dosyadaki belirli kayÄ±tlarÄ±n bilgilerinin nasÄ±l silindiÄŸini anlamak iÃ§in incelenebilir, burada belirli bir gÃ¼nde doÄŸmuÅŸ olan kiÅŸilerin kayÄ±tlarÄ±nÄ±n dosyadan siliniÅŸini inceleyeceÄŸiz.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "person.h"
#include "nutility.h"
#include <stdlib.h> // 'exit' fonksiyonunu kullanmak iÃ§in eklendi.
#include <string.h> // 'strcmp' fonksiyonunu kullanmak iÃ§in eklendi.

void print_records(const char* filename)
{
    FILE* f = fopen(filename, "rb");
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    Person per;

    // Dosyadaki tÃ¼m 'Person' tÃ¼rÃ¼nden kayÄ±tlarÄ±n dosyanÄ±n sonuna kadar yazdÄ±rÄ±lmasÄ± iÅŸlemi.
    while(fread(&per, sizeof(Person), 1, f)){
        printf_person(&per);
    }

    fclose(f);
}

void add_record(const char* filename, const Person* p)
{
    FILE* f = fopen(filename, "ab"); // 'ab' modunda sadece dosyanÄ±n sonuna yazma iÅŸlemi yapÄ±labilir biÃ§imde dosya aÃ§Ä±lÄ±yor.
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    fwrite(p, sizeof(Person), 1, f);

    fclose(f);
}

int get_record_count(const char* filename)
{
    FILE* f = fopen(filename, "rb"); // 'rb' modunda sadece dosyanÄ±n binary olarak okunabilmesi iÅŸlemini yapÄ±labilir biÃ§imde dosya aÃ§Ä±lÄ±yor.
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    fseek(f, 0, SEEK_END); 

    int rec_cnt = (int)(ftell(f) / sizeof(Person));

    fclose(f);

    return rec_cnt;
}

// Dosyadaki kayÄ±t ya da kayÄ±tlarÄ± deÄŸiÅŸtirmeye yÃ¶nelik fonksiyon
int modify_records(const char* filename, const char* oldname, const char* newname)
{
    FILE* f = fopen(filename, "rb+"); // 'rb+' modunda dosyanÄ±n binary olarak hem okunabilir hem de yazÄ±labilir biÃ§imde dosya aÃ§Ä±lÄ±yor.
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    Person per; // Dosyada okuma ve yazma iÅŸlemlerini yaparken kullanÄ±lacak olan deÄŸiÅŸken bildirimi yapÄ±lÄ±yor.
    int count = 0;

    while(fread(&per, sizeof(Person), 1, f)){
        if(!strcmp(per.name, oldname)){
            strcpy(per.name, newname);
            fseek(f, -(long)sizeof(Person), SEEK_CUR); // Dosyaya yazma iÅŸlemi yapmadan Ã¶nce Ã¼zerine yazÄ±lacak kaydÄ±n ayarlanmasÄ± iÃ§in 'file pointer' deÄŸeri ayarlarnÄ±yor.
            fwrite(&per, sizeof(Person), 1, f); // Dosyada deÄŸiÅŸtirilecek kaydÄ±n Ã¼zerine yazma iÅŸlemi.
            fseek(f, 0L, SEEK_CUR); // Dosyaya yazma iÅŸleminden dosyadan okuma iÅŸlemine geÃ§iÅŸ yapÄ±lacaÄŸÄ± iÃ§in 'file pointer' en son kaldÄ±ÄŸÄ± yeri gÃ¶sterecek biÃ§imde ayarlanÄ±yor.

            ++count;
        }
    }

    fclose(f);
    return count;
}

int delete_records(const char* filename, int mday)
{
    FILE* f = fopen(filename, "rb");
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    char tempname[L_tmpnam];
    tmpnam(tempname); // copya dosya adÄ±nÄ±n eÅŸsiz olmasÄ± iÃ§in dosya adÄ± 'tmpnam' fonksiyonuyla elde ediliyor.

    FILE* fd = fopen(tempname, "wb");

    if(!fd){
        fprintf(strerr, "%s gecisi dosya olusturulamadi.\n", filename);
        fclose(fd);
        exit(EXIT_FAILURE);
    }

    Person per;

    int read_count = 0;
    int write_count = 0;

    while(fread(&per, sizeof(Person), 1, fs)){
        ++read_count;
        if(per.bdate.d_ != mday){ // Silinecek kayit degilse bloÄŸa gir.
            fwrite(&per, sizeof(Person), 1, fd);
            ++write_count;
        }
    }

    // Dosyalar kapatÄ±lÄ±yor
    fclose(fs);
    fclose(fd);

    // Eski dosya siliniyor.
    if(remove(filename)){
        fprintf(strerr, "%s dosyasi silinemedi.\n", filename);
        exit(EXIT_FAILURE);
    }

    // Yeni dosyanÄ±n adÄ± deÄŸiÅŸtiriliyor.
    if(rename(tempname, filename)){
        fprintf(strerr, "%s dosya adi degistirilemedi.\n", filename);
        exit(EXIT_FAILURE);
    }

    return read_count - write_count;
}

int main(void)
{
    for(int i = 0; i <= 31; ++i){
        if(i % 10 != 0){ // 10 deÄŸerine bÃ¶lÃ¼nmeyen gÃ¼nlerde doÄŸan kiÅŸi kayÄ±tlarÄ± dosyadan silinecek. 
            int n = delete_records("people.dat", i);
            printf("ayin %d. gununde dogan %d kayit silinde\n", i, n);
            (void)getchar(); // KullanÄ±cÄ±dan bir tuÅŸa basmasÄ± iÃ§in bekleniyor.
        }
    }

    printf("%d\n", get_records_count("people.dat"));
    (void)getchar(); // KullanÄ±cÄ±dan bir tuÅŸa basmasÄ± iÃ§in bekleniyor.
    print_records("people.dat"); 
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program `Person` kayÄ±tlarÄ±nÄ±n tutulduÄŸu dosyadaki kayÄ±tlarÄ±n nasÄ±l sÄ±ralandÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "person.h"
#include "nutility.h"
#include <stdlib.h> // 'exit' fonksiyonunu kullanmak iÃ§in eklendi.
#include <string.h> // 'strcmp' fonksiyonunu kullanmak iÃ§in eklendi.

void print_records(const char* filename)
{
    FILE* f = fopen(filename, "rb");
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    Person per;

    // Dosyadaki tÃ¼m 'Person' tÃ¼rÃ¼nden kayÄ±tlarÄ±n dosyanÄ±n sonuna kadar yazdÄ±rÄ±lmasÄ± iÅŸlemi.
    while(fread(&per, sizeof(Person), 1, f)){
        printf_person(&per);
    }

    fclose(f);
}

void add_record(const char* filename, const Person* p)
{
    FILE* f = fopen(filename, "ab"); // 'ab' modunda sadece dosyanÄ±n sonuna yazma iÅŸlemi yapÄ±labilir biÃ§imde dosya aÃ§Ä±lÄ±yor.
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    fwrite(p, sizeof(Person), 1, f);

    fclose(f);
}

int get_record_count(const char* filename)
{
    FILE* f = fopen(filename, "rb"); // 'rb' modunda sadece dosyanÄ±n binary olarak okunabilmesi iÅŸlemini yapÄ±labilir biÃ§imde dosya aÃ§Ä±lÄ±yor.
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    fseek(f, 0, SEEK_END); 

    int rec_cnt = (int)(ftell(f) / sizeof(Person));

    fclose(f);

    return rec_cnt;
}

// Dosyadaki kayÄ±t ya da kayÄ±tlarÄ± deÄŸiÅŸtirmeye yÃ¶nelik fonksiyon
int modify_records(const char* filename, const char* oldname, const char* newname)
{
    FILE* f = fopen(filename, "rb+"); // 'rb+' modunda dosyanÄ±n binary olarak hem okunabilir hem de yazÄ±labilir biÃ§imde dosya aÃ§Ä±lÄ±yor.
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    Person per; // Dosyada okuma ve yazma iÅŸlemlerini yaparken kullanÄ±lacak olan deÄŸiÅŸken bildirimi yapÄ±lÄ±yor.
    int count = 0;

    while(fread(&per, sizeof(Person), 1, f)){
        if(!strcmp(per.name, oldname)){
            strcpy(per.name, newname);
            fseek(f, -(long)sizeof(Person), SEEK_CUR); // Dosyaya yazma iÅŸlemi yapmadan Ã¶nce Ã¼zerine yazÄ±lacak kaydÄ±n ayarlanmasÄ± iÃ§in 'file pointer' deÄŸeri ayarlarnÄ±yor.
            fwrite(&per, sizeof(Person), 1, f); // Dosyada deÄŸiÅŸtirilecek kaydÄ±n Ã¼zerine yazma iÅŸlemi.
            fseek(f, 0L, SEEK_CUR); // Dosyaya yazma iÅŸleminden dosyadan okuma iÅŸlemine geÃ§iÅŸ yapÄ±lacaÄŸÄ± iÃ§in 'file pointer' en son kaldÄ±ÄŸÄ± yeri gÃ¶sterecek biÃ§imde ayarlanÄ±yor.

            ++count;
        }
    }

    fclose(f);
    return count;
}

int delete_records(const char* filename, int mday)
{
    FILE* f = fopen(filename, "rb");
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        exit(EXIT_FAILURE);
    }

    char tempname[L_tmpnam];
    tmpnam(tempname); // copya dosya adÄ±nÄ±n eÅŸsiz olmasÄ± iÃ§in dosya adÄ± 'tmpnam' fonksiyonuyla elde ediliyor.

    FILE* fd = fopen(tempname, "wb");

    if(!fd){
        fprintf(strerr, "%s gecisi dosya olusturulamadi.\n", filename);
        fclose(fd);
        exit(EXIT_FAILURE);
    }

    Person per;

    int read_count = 0;
    int write_count = 0;

    while(fread(&per, sizeof(Person), 1, fs)){
        ++read_count;
        if(per.bdate.d_ != mday){ // Silinecek kayit degilse bloÄŸa gir.
            fwrite(&per, sizeof(Person), 1, fd);
            ++write_count;
        }
    }

    // Dosyalar kapatÄ±lÄ±yor
    fclose(fs);
    fclose(fd);

    // Eski dosya siliniyor.
    if(remove(filename)){
        fprintf(strerr, "%s dosyasi silinemedi.\n", filename);
        exit(EXIT_FAILURE);
    }

    // Yeni dosyanÄ±n adÄ± deÄŸiÅŸtiriliyor.
    if(rename(tempname, filename)){
        fprintf(strerr, "%s dosya adi degistirilemedi.\n", filename);
        exit(EXIT_FAILURE);
    }

    return read_count - write_count;
}


// 'qsort' fonksiyonuna geÃ§ilecek olan sÄ±ralama iÅŸlemini yapacak fonksiyon.
static int pcmp(const void* vp1, const void* vp2)
{
   return cmp_person((const Person*)vp1, (const Person*)vp2);
}

// 'qsort' fonksiyonuna istek yapÄ±lÄ±p 'Person' trÃ¼nden dizinin sÄ±ralanmasÄ±nÄ± saÄŸlayan sarmalayÄ±cÄ± fonksiyon. 
void sort_person_array(Person* p, size_t size)
{
    qsort(p, size, sizeof(*p), &pcmp);
}

void sort_records(const char* filename)
{
    FILE* f = fopen(filename, "rb+"); // 'rb+' modunda dosyanÄ±n binary olarak hem okunabilir hem de yazÄ±labilir biÃ§imde dosya aÃ§Ä±lÄ±yor.
    if(!f){
        fprintf(strerr, "%s dosyasi acilamadi.\n", filename);
        fclose(f);
        exit(EXIT_FAILURE);
    }

    fseek(f, 0L, SEEK_END);
    int record_count = (int) (ftell(f) / sizeof(Person));
    Person* pd = (Person*) malloc(record_count * sizeof(Person));
    if(!pd){
        fprintf(strderr, "bellek yetersiz.\n");
        exit(EXIT_FAILURE);
    }

    rewind(f); // 'file pointer' dosyanÄ±n baÅŸÄ±na Ã§ekildi.
    fread(pd, sizeof(Person), record_count, f);
    sort_person_array(pd, record_count);
    rewind(f);
    fwrite(pd, sizeof(Person), record_count, f);

    fclose();
    free(pd); // Dinamik bellek alanÄ± iade ediliyor.
}

int main(void)
{
    sort_records("people.dat"); 

    print_recodrs("people.dat");
}
```


âš ï¸âš ï¸âš ï¸ Programlamada en kÃ¶tÃ¼ alÄ±ÅŸkanlÄ±ÄŸÄ±n biri Ã§ok bÃ¼yÃ¼k(kaylaÅŸÄ±k 50 satÄ±rdan bÃ¼yÃ¼k fonksiyonlarÄ± bu Ã¶beÄŸe dahil edebiliriz) fonksiyonlarÄ±n yazÄ±lmasÄ±dÄ±r. </br>
BÃ¼yÃ¼k fonksiyonlar aÅŸaÄŸÄ±daki sorunlara neden olur;
1. Fonksiyonu incelemek ve debug etmek zorlaÅŸÄ±r.
2. OkunmasÄ± ve bakÄ±mÄ± zor olur.


### `fsetpos` ve `fgetpos` FonksiyonlarÄ± 

`fsetpos` fonksiyonunun prototipi `int fsetpos(FILE*, const fpos_t *);` biÃ§imindedir, **dosya konum gÃ¶stericisinin(file pointer)** deÄŸerini deÄŸiÅŸtiren(setting operation) fonksiyondur. `FILE*` tÃ¼rÃ¼nden argÃ¼mandaki dosyanÄ±n **dosya konum gÃ¶stericisinin(file pointer)** deÄŸerini `const fpos_t *` tÃ¼rÃ¼ndeki parametre nesnesinin deÄŸeriyle deÄŸiÅŸtirir. Geri dÃ¶nÃ¼ÅŸ deÄŸeri "0" olunca iÅŸlem baÅŸarÄ±lÄ± "non-zero" olursa iÅŸlem baÅŸarÄ±sÄ±z anlamÄ±na geliyor. </br>
`fgetpos` fonksiyonunun prototipi `int fgetpos(FILE*, fpos_t *);` biÃ§imindedir, **dosya konum gÃ¶stericisinin(file pointer)** deÄŸerini dÃ¶nen fonksiyondur. `FILE*` tÃ¼rÃ¼nden argÃ¼mandaki dosyanÄ±n **dosya konum gÃ¶stericisinin(file pointer)** deÄŸerini `fpos_t *` tÃ¼rÃ¼ndeki parametre nesnesine atar ve bu nesne **out-prameter** olduÄŸu iÃ§in Ã§aÄŸrÄ± yaan kod deÄŸeri almÄ±ÅŸ olur. Geri dÃ¶nÃ¼ÅŸ deÄŸeri "0" olunca iÅŸlem baÅŸarÄ±lÄ± "non-zero" olursa iÅŸlem baÅŸarÄ±sÄ±z anlamÄ±na geliyor.

`fsetpos` ve `fgetpos` fonksiyonlarÄ±yla iÅŸlem yaparken **dosya konum gÃ¶stericisinin(file pointer)** deÄŸeri `fpos_t` tÃ¼r eÅŸ adÄ±yla temsil edilmiÅŸ, bu tÃ¼r eÅŸ adÄ±yla sistemdeki en bÃ¼yÃ¼k dosya byte boyutu karÅŸÄ±lanmÄ±ÅŸ olur, bu nedenden dolayÄ± bÃ¼yÃ¼k dosyalarla Ã§alÄ±ÅŸÄ±rken bu fonksiyonlar kullanÄ±lmalÄ±dÄ±r. </br>
`fpos_t` bir tÃ¼r eÅŸ dÄ±dÄ±r ve hangi iÅŸaretli tam sayÄ±ya karÅŸÄ±lÄ±k geldiÄŸi derleyiciye bÄ±rakÄ±lmÄ±ÅŸtÄ±r.

`fseek` fonksiyonu ile `fsetpos` fonksiyonu temelde aynÄ± iÅŸlemi yapÄ±yor yani **dosya konum gÃ¶stericisinin(file pointer)** deÄŸerini deÄŸiÅŸtirmek iÃ§in kullanÄ±lÄ±rlar, aralarÄ±ndaki farklar;
1. `fseek` fonksiyonu ikinci parametre deÄŸiÅŸkeni `long` tÃ¼rÃ¼ndendir ama `fpos_t` tÃ¼r eÅŸ adÄ± en az `long` tÃ¼rÃ¼nÃ¼n boyutunda olacaÄŸÄ± kesindir, bu nedenden dolayÄ± bÃ¼yÃ¼k dosyalarda Ã§alÄ±ÅŸÄ±rken `fsetpos` fonksiyonu tercihedilir.
2. `fsetpos` ve `fgetpos` fonksiyonlarÄ± kullanÄ±ldÄ±ÄŸÄ±nda dosya Ã¼zerinde ilk iÅŸleme vaÅŸlandÄ±ÄŸÄ± andaki **dosya konum gÃ¶stericisinin(file pointer)** deÄŸerine dÃ¶nmek kolaydÄ±r ve gÃ¼venlidir,  



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `fsetpos` ve `fgetpos` fonksiyonlarÄ±nÄ±n kullanÄ±mÄ± incelenebilir. 
```C
#include <stdio.h>
#include "person.h"

int main()
{
    FILE* f = fopen("people.dat", "rb");
    Person p;

    for(int i = 0; i < 100; ++i){
        fread(&per, sizeof(&per), 1, f);
    }

    fpos_t pos;
    fgetpos(f, &pos); // 'pos' nesnesine 'f' fonksiyonunun bu andaki 'file pointer' deÄŸeri atanÄ±yor.

    // some code here.

    fsetpos(f, &pos); // Bu fonksiyon Ã§aÄŸrsÄ± ile 'f' fonksiyonunun 'file pointer' deÄŸeri yukarÄ±daki 'fgetpos' Ã§aÄŸrÄ±sÄ± yapÄ±ldÄ±ÄŸÄ± andaki 'file pointer' deÄŸerine geri alÄ±nmÄ±ÅŸ olacaktÄ±r.
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 11.58-12.11 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***

### Eof and Error Flag

Ã–ncelikle dosya iÅŸlemlerini yaparken artalanda yapÄ±lan bazÄ± iÅŸlemleri bilmek gerekiyor;
Bir dosyadan okuma iÅŸlemi yapan bir fonksiyon Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ±nda aslÄ±nda o fonksiyon okuma iÅŸlemini yapmadan Ã¶nce `FILE*` tÃ¼rÃ¼nden deÄŸiÅŸken vasÄ±tasÄ±yla bit seviyesinde tutulan bir bayraÄŸa bakÄ±yor, bu bayraÄŸa **Eof Flag** deniliyor.

MÃ¼lakatlarda dosya iÅŸlemleriyle ilgili olarak en Ã§ok sorulan sorulardan biri **Eof Flag** deÄŸerinin ne zaman 1 yapÄ±ldÄ±ÄŸÄ±dÄ±r(set status), **Eof Flag** dosyadan okunacak byte kalmadÄ± anda 1 yapÄ±lmaz, dosyayÄ± okumak iÃ§in istek yapÄ±ldÄ±ÄŸÄ±nda dosyada okunacak byte kalmadÄ±ÄŸÄ± ilk baÅŸarÄ±sÄ±z okuma iÅŸleminde 1 yapÄ±lÄ±r(set status), dosyadan okuma iÅŸlemlerinde **Eof Flag** deÄŸerine bakÄ±lÄ±r bu deÄŸer 1 ise dosyadan okuma yapÄ±lmaya Ã§alÄ±ÅŸÄ±lmaz.

**Error Flag** okuma ya da yazma iÅŸleminin baÅŸarÄ±sÄ±z olmasÄ±nÄ±n nedeni dosya sonuyla ilgili olmadÄ±ÄŸÄ±nda(mesela sistem seviyesinde olan bir hata, bellek yetersiz olmasÄ± durumu bu hataya neden olabilir ya da salt okuma amaÃ§lÄ± aÃ§Ä±lan dosyada yazma iÅŸlemi yapÄ±lÄ±nda bu hataya neden olabilir) 

Bir dosya Ã¼zerinde okuma ya da yazma iÅŸleminin yapÄ±labilmesi iÃ§in **eof** ve **error** bayraklarÄ±nÄ±n 0 olmasÄ± gerekiyor, yoksa dosya Ã¼zerinde iÅŸlem yapÄ±lamaz.


### `foef`, `ferror`, `clearerr` FonksiyonlarÄ± 

`foef` fonksiyonunun prototipi `int foef(FILE*);` biÃ§imindedir, bu fonksiyon geriye **Eof Flag** deÄŸerini dÃ¶ner.

`ferror` fonksiyonunun prototipi `int ferror(FILE*);` biÃ§imindedir, bu fonksiyon geriye **Error Flag** deÄŸerini dÃ¶ner.

`clearerr` fonksiyonunun prototipi `void clearerr(FILE*);` biÃ§imindedir, bu fonksiyon bir dosyanÄ±n hata bayraklarÄ±nÄ± sÄ±fÄ±rlamak iÃ§in kullanÄ±lÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `feof` fonksiyonunun kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>
#include "person.h"

int main()
{
    FILE* f = fopen("out.txt", "r");

    if(feod(f)){
        printf("eof bayragi set edilmis-1.\n");
    }
    else{
        printf("eof bayragi set edilmemis-1.\n");
    }

    fseek(f, 0L, SEEK_END);

    if(feod(f)){
        printf("eof bayragi set edilmis-2.\n");
    }
    else{
        printf("eof bayragi set edilmemis-2.\n");
    }

    int c = fgetc(f);
    printf("c = %d\n", c);

    if(feod(f)){
        printf("eof bayragi set edilmis-3.\n");
    }
    else{
        printf("eof bayragi set edilmemis-3.\n");
    }

    fclose(f);
}
```



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programda `feof` fonksiyonunun `while` dÃ¶ngÃ¼sÃ¼yle aÅŸaÄŸÄ±daki gibi kullanÄ±mÄ± hatalÄ±dÄ±r Ã§Ã¼nkÃ¼ `feof` fonksiyonu geriye dosya sonuna gelinip gelinmediÄŸi bilgisini dÃ¶nmez, bu  fonksiyon geriye dosya sonuna gelindikten sonra dosya Ã¼zerinde yapÄ±lan ilk iÅŸlemde dosyada iÅŸlem yapÄ±labilecek byte kalmadÄ±ÄŸÄ±ndanda geriye "1" deÄŸerini dÃ¶ndÃ¼recektir.
```C
#include <stdio.h>

int main()
{
    FILE* f = fopen("out.txt", "r");

    while(!feof(f)){
        int c = fgetc(f);
        printf("%d ", c);
    }
    
    fclose(f);
}
```



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki programda `feof` fonksiyonunun `while` dÃ¶ngÃ¼sÃ¼yle aÅŸaÄŸÄ±daki gibi kullanÄ±mÄ± doÄŸru kullanÄ±mdÄ±r.
```C
#include <stdio.h>

int main()
{
    FILE* f = fopen("out.txt", "r");

    int c;
    while((c = fgetc(f)) != EOF){
        int c = fgetc(f);
        printf("%d ", c);
    }
    
    fclose(f);
}
```


â—â—â— EÄŸer bir dosyada **eof** ya da **error** bayraklarÄ±nÄ±n deÄŸeri 1 ise bu dosyalar Ã¼zerinde okuma ya da yazma iÅŸlemlerinin yapÄ±labilmesi iÃ§in ya hata bayraklarÄ±nÄ± sÄ±fÄ±rlayan `clearerr` fonksiyonu Ã§aÄŸÄ±rÄ±lmalÄ± ya da dosyanÄ±n **dosya konum gÃ¶stericisinin(file pointer)** deÄŸerini deÄŸiÅŸtiren fonksiyonlardan birinin(`fseek`, `rewind`, `fsetpos`) Ã§aÄŸÄ±rÄ±lmasÄ± ya da `fflush` fonksiyonuna Ã§aÄŸrÄ± yapÄ±lmasÄ± gerekiyor, bu iÅŸlemler hata bayraklarÄ±nÄ± sÄ±fÄ±rlar. 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **eof** bayraÄŸÄ±nÄ±n nasÄ±l temizlendiÄŸi incelenebilir.
```C
#include <stdio.h>

int main()
{
    FILE* f = fopen("out.txt", "r");

    int c;
    while((c = fgetc(f)) != EOF){
        int c = fgetc(f);
        printf("%d ", c);
    }
    printf("\n");

    if(feof(f))
        printf("eof bayragi set edilmis.\n");
    else
        printf("eof bayragi set edilmemis.\n");

    // Dosya hata bayraklarÄ±nÄ± sÄ±fÄ±rlayan iÅŸlemler aÅŸaÄŸÄ±dan gÃ¶rÃ¼lebilir.
    // rewind(f);
    // fseek(f, 0, SEEK_SET);
    clearerr(f);


    fclose(f);
}
```


â—â—â— `feof` sadece bir dosyadan okuma yazma iÅŸlemi yapÄ±lmasÄ± sÄ±rasÄ±nda **dosya konum gÃ¶stericisinin(file pointer)** deÄŸerinin dosya sonunu gÃ¶stermesinden dolayÄ± hata alÄ±nÄ±p alÄ±nmadÄ±ÄŸÄ± bilgisini edinmek iÃ§in kullanÄ±lÄ±r, ilgili dosyada bu neden dÄ±ÅŸÄ±nda bir sorundan dolayÄ± okuma ya da yazma iÅŸleminde hata olmuÅŸsa bu bayrak 1 yapÄ±lmaz.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda okuma amaÃ§lÄ± aÃ§Ä±lan bir dosyaya yazma iÅŸlemi yapÄ±lmasÄ±ndan dolayÄ± **error** bayraÄŸÄ± 1 yapÄ±lacaktÄ±r ve bundan faydalanarak `ferror` fonksiyonunun kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>

int main()
{
    FILE* f = fopen("out.txt", "r");
    if(!f){
        printf("dosya acilamadi.\n");
        return 1;
    }

    // 'fputc' fonksiyonu baÅŸarÄ±sÄ±z olduÄŸunda geri dÃ¶nÃ¼ÅŸ deÄŸer 'EOF' deÄŸeridir, baÅŸarÄ±lÄ± olduÄŸunda ise dosyaya yazdÄ±rÄ±lan karakterin kod deÄŸeridir. 
    if(fputc('X', f) == EOF){
        if(ferror(f)){
            printf("yazma hatasi olustu.\n");
            return 1;
        }
    }
    
    fclose(f);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **error** bayraÄŸÄ±nÄ±n nasÄ±l temizlendiÄŸi incelenebilir.
```C
#include <stdio.h>

int main()
{
    FILE* f = fopen("out.txt", "r");
    if(!f){
        printf("dosya acilamadi.\n");
        return 1;
    }

    fputc('X', f);

    if(ferror(f)){
        printf("error bayragi set edilmis.\n");
    }
    else{
        printf("error bayragi set edilmemis.\n");
    }
    
    // Dosya hata bayraklarÄ±nÄ± sÄ±fÄ±rlayan iÅŸlemler aÅŸaÄŸÄ±dan gÃ¶rÃ¼lebilir.
    rewind(f);
    // fseek(f, 0, SEEK_SET);
    // clearerr(f);

    if(ferror(f)){
        printf("error bayragi set edilmis.\n");
    }
    else{
        printf("error bayragi set edilmemis.\n");
    }

    fclose(f);
}
```


### `fflush` Fonksiyonu 

`fflush` fonksiyonunun prototipi `void fflush(FILE*);` biÃ§imindedir, bu fonksiyon bir dosyanÄ±n hata bayraklarÄ±nÄ± sÄ±fÄ±rlamak iÃ§in kullanÄ±lÄ±r.

Dosya iÅŸlemlerinde mesela dosyaya bir byte yazmak iÃ§in dosyaya yazma iÅŸlemini yapan fonksiyon Ã§aÄŸÄ±rÄ±lsa dahi fiilen o dosyaya o byte yazÄ±lmÄ±yor(eÄŸer Ã¶yle olsaydÄ±, dosyaya yazma iÅŸlemleri Ã§ok yavaÅŸ olurdu), bir dosya aÃ§Ä±ldÄ±ÄŸÄ±nda o doyaya baÄŸlÄ± artalanda(background) bir **file buffer(bir bellek alanÄ±)** oluÅŸturulur, bir dosya aÃ§Ä±ldÄ±ÄŸÄ±nda o dosyada okuma ve yazma iÅŸlemlerinin yapÄ±labilmesi iÃ§in ihtiyaÃ§ duyulan programÄ±n Ã§alÄ±ÅŸma zamanÄ±nda kullanÄ±lan bir bellek alanÄ± var, o bellek alanÄ± o dosya iÃ§in kullanÄ±lacak, o bellek alanÄ± ayrÄ±lamazsa(allacate) da `fopen` fonksiyonu baÅŸarÄ±sÄ±z olabilir. </br>
Bir dosyaya yapÄ±lan yazma iÅŸlemi doÄŸrudan dosyaya yapÄ±lmÄ±yor, yazma iÅŸlemi o dosyanÄ±n **file buffer(bir bellek alanÄ±)** tarafÄ±na yapÄ±lÄ±yor. </br>
**File buffer(bir bellek alanÄ±)** deÄŸerinin kaÃ§ byte olduÄŸu bilgisi `stdio.h` baÅŸlÄ±k dosyasÄ±ndaki `BUFSIZE` makrosunda yer almaktadÄ±r. </br>
Dosyalar Ã¼zerinde yapÄ±lan yazma iÅŸlemlerde bazÄ± iÅŸlemler gerÃ§ekleÅŸtiÄŸinde **file buffer(bir bellek alanÄ±)** alanÄ±nda bulunan bÃ¼tÃ¼n byte'lar fiilen dosyaya yazÄ±lÄ±r, iÅŸte bu iÅŸleme **flushing** deniliyor. </br>
**Flush** iÅŸlemi dosyanÄ±n **file buffer(bir bellek alanÄ±)** alanÄ±nda yapÄ±lan deÄŸiÅŸiklerin dosyaya fiilen kaydedilmesi iÅŸlemidir.



**Flush** iÅŸlemi hangi durumlarda yapÄ±lÄ±r;
1. **File buffer(bir bellek alanÄ±)** alanÄ± dolduÄŸunda **flush** iÅŸlemi yapÄ±lÄ±r.
2. EÄŸer program `exit` fonksiyonu ile **normal termination** iÅŸlemiyle sonlanÄ±yorsa **flush** iÅŸlemi yapÄ±lÄ±r.
3. `fflush` fonksiyonu Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ±nda **flush** iÅŸlemi yapÄ±lÄ±r.
4. Yazma amaÃ§lÄ± bir dosya okuma amaÃ§lÄ± bir dosyaya baÄŸlanmÄ±ÅŸ(Ä°ngilizce olarak bu durum **tie** fiiliyle belirtilir) durumda olacak ve okuma amaÃ§lÄ± bir dosyadan okuma iÅŸlemi yapÄ±lacak. Bu duruma **Standat input**'un **Standat output**'a baÄŸlanmÄ±ÅŸ(tie) oluÅŸunu misal olarak verebiliriz


Sistemlerin hemen hepsinde **flush** iÅŸleminin yapÄ±lmasÄ±nÄ±n sÄ±k rastlanan kullanÄ±mÄ± da **standat output**'un , 

â—â—â— Åu ÅŸikyet sÄ±k duyulabilir: "`printf` fonksiyonunu Ã§aÄŸÄ±rdÄ±m ama programÄ±n akÄ±ÅŸÄ± o Ã§aÄŸrÄ±ya gelsiÄŸinde yazdÄ±rÄ±lan veriler standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderilmedi!", bunun nedeni **standat output**'un **buffer(bir bellek alanÄ±)**'Ä±nÄ±n dolmasÄ± olabilir, **standat output** ta bir dosya onun da bir **buffer(bir bellek alanÄ±)**'Ä± var, demek ki henÃ¼z **standat output**'un **buffer(bir bellek alanÄ±)**'Ä± **flush** edilmemiÅŸ.

â—â—â— **Standat input** **Standat output**'a baÄŸlanmÄ±ÅŸ(Ä°ngilizce olarak bu durum **tie** fiiliyle belirtilir) durumdadÄ±r. **File buffer(bir bellek alanÄ±)**'Ä±n **flush** edilmesi iÃ§in bir baÅŸka durum: EÄŸer yazma amaÃ§lÄ± bir dosyanÄ±n **buffer(bir bellek alanÄ±)**'Ä± okuma amaÃ§lÄ± bir dosyaya baÄŸlanmÄ±ÅŸ(tie) ise



ğŸ‘‡ AÅŸaÄŸÄ±daki programda 
```C
#include <stfio.h>

int main(void)
{
    // Dosyadan bir okuma iÅŸlemi yapÄ±ldÄ±ÄŸÄ±nda Ã¶nce onun baÄŸlandÄ±ÄŸÄ± Ã§Ä±kÄ±ÅŸ akÄ±mÄ± 'flush' edilmektedir.
    // Yani aÅŸaÄŸÄ±daki kodlar Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda 'bir tam sayi giriniz: ' yazÄ±sÄ±nÄ±n ekranda gÃ¶rÃ¼lmesinin kesin olmasÄ±nÄ±n nedeni 'scanf' fonksiyonuyla bir giriÅŸ alÄ±nmasÄ±dÄ±r, Ã§Ã¼nkÃ¼ 'scanf' fonksiyonu 'standart input'un 'buffer(bir bellek alanÄ±)'Ä±nÄ± kullanÄ±yor ve 'standart input' 'standart output'a baÄŸlanmÄ±ÅŸ durumdadÄ±r.
    printf("bir tam sayi giriniz: ");
    int x;
    scanf("%d", x);
}
```



â—â—â— **Buffer(bir bellek alanÄ±)** kullanÄ±mÄ± Ã¶zelleÅŸtirilebiliyor, `setvbuf` fonksiyonu kullanÄ±larak **buffer(bir bellek alanÄ±)** kullanÄ±mÄ± tamamen ortadan kaldÄ±rabilir. `setvbuf` fonksiyonuyla **buffer(bir bellek alanÄ±)** kullanÄ±mÄ± engellenirse bir dosyaya yapÄ±lacak yazma iÅŸlemi doÄŸrudan dosyaya yazÄ±lacak anlamÄ±na gelmektedir.



`fflush` fonksiyonuna okuma amaÃ§lÄ± kullanÄ±lan bir dosyanÄ±n adresi argÃ¼man olarak verilmemelidir(**ub** durumuna neden olur). `fflush` fonksiyonuna **NULL pointer** argÃ¼man olarak geÃ§ilirse bu aÃ§Ä±k olan tÃ¼m dosyalarÄ±n **buffer(bir bellek alanÄ±)**'larÄ±nÄ± **flush** edilmesini saÄŸlar.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `fflush(NULL)` kullanÄ±mÄ± incelenebilir.
```C
#include <stfio.h>

int main(void)
{
    FILE* f;

    // some code here ...

    fflush(NULL); // Burada programda aÃ§Ä±k olan bÃ¼tÃ¼n dosyalarÄ±n 'buffer(bir bellek alanÄ±)'larÄ±nÄ± 'flush' edilecektir.
}
```


â—â—â— Sistem tarafÄ±ndan **Standat output**, **Standat input** ve **Standat error** birer dosya olarak ele alÄ±nmaktadÄ±r, nasÄ±l ki bir dosya aÃ§Ä±ldÄ±ÄŸÄ±nda `FILE*` tÃ¼rÃ¼nden bir referans dÃ¶nÃ¼yor, bir C ya da C++ programÄ± Ã§alÄ±ÅŸmaya baÅŸladÄ±ÄŸÄ±nda **Standat input**, **Standat output** ve **Standat error** iÃ§in Ã¼Ã§ farklÄ± dosya sistem tarafÄ±ndan oluÅŸturulmaktadÄ±r, bu dosyalarÄ±n Ã¶zelliklerin mÃ¼dahale edilebilir ama bu dosyalar sistem tarafÄ±ndan oluÅŸturulmaktadÄ±r. </br>
**Standat output** programÄ±n varsayÄ±lan Ã§Ä±kÄ±ÅŸ akÄ±mÄ±nÄ± temsil etmektedir, varsayÄ±lan olarak monitÃ¶re baÄŸlÄ±dÄ±r. </br>
**Standat input** programÄ±n varsayÄ±lan giriÅŸ akÄ±mÄ±nÄ± temsil etmektedir, varsayÄ±lan olarak klavyeye baÄŸlÄ±dÄ±r. </br>
**Standat error** hata iletilerinin verildiÄŸi Ã§Ä±kÄ±ÅŸ akÄ±mÄ±dÄ±r yani programÄ±n oluÅŸturacaÄŸÄ± verilrin deÄŸil de hata iletilerinin verildiÄŸi Ã§Ä±kÄ±ÅŸ akÄ±mÄ±dÄ±r, varsayÄ±lan olarak monitÃ¶re baÄŸlÄ±dÄ±r.


**Standat output**, **Standat input** ve **Standat error** birer dosya olarak kullanÄ±ldÄ±ÄŸÄ± iÃ§in bunlarÄ±n da `FILE*` tÃ¼rÃ¼nden referanslarÄ±(handler) vardÄ±r, `stdio.h` programa dahil edildiÄŸinde ÅŸu Ã¼Ã§ **adÄ±n(identifier)** kullanÄ±m hakkÄ± elde edilmiÅŸ olmaktadÄ±r;
- `stdout` **Standat output**'un handle'Ä±.
- `stdin` **Standat input**'un handle'Ä±.
- `stderr` **Standat error**'un handle'Ä±.


EÄŸer bir dosyaya yazma amaÃ§lÄ± iÅŸlem yapan bir fonksiyonun handle isteyen parametresine **Standat output**'un handle'Ä± olan `stdout`u argÃ¼man olarak geÃ§ilirse yazma iÅŸlemi dosyaya yapÄ±lÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `stdout` kullanÄ±mÄ± incelenebilir.
```C
#include <stfio.h>

int main(void)
{
    fprintf(stdout, "necati ergin.\n"); // 'fprintf' foksiyonuna doÄŸrudan bir dosya referansÄ± yerine 'stdout' verildiÄŸi iÃ§in girilen yazÄ± 'Standat output'a yazÄ±lacaktÄ±r.
    fputc('a', stdout); // 'fputc' foksiyonuna doÄŸrudan bir dosya referansÄ± yerine 'stdout' verildiÄŸi iÃ§in girilen karakter 'Standat output'a yazÄ±lacaktÄ±r.
    fputs("cavit kara", stdout); // 'fputs' foksiyonuna doÄŸrudan bir dosya referansÄ± yerine 'stdout' verildiÄŸi iÃ§in girilen yazÄ± 'Standat output'a yazÄ±lacaktÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `stdin` kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stfio.h>

int main(void)
{
    int x;

    printf("bir tam sayi girin: ");
    fscanf(stdin, "%d", &x); // 'fscanf' foksiyonuna doÄŸrudan bir dosya referansÄ± yerine 'stdin' verildiÄŸi iÃ§in 'Standat input'tan okuma iÅŸlemi yapacaktÄ±r.
    
    printf("x = %d\n", x);
}
```


Ders sonu ...
