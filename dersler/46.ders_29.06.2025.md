# 46.Ders 29.06.2025 🕘

Derse 4(09:02)-7(09:04)-7(09:20)-8(09:33)-10(09:45)-10(10:01)-11(10:51)-12(11:15)-11(12:15)-10(12:28) kişi katıldı.
---


## Standart C Kütüphanesinin `time` Modülü(time Library)

`time` modülünde öğrenilecek kavramların her programlama dilinde karşılığı vardır, başka dillerde de C dilinnin standart kütüphanesindeki `time.h` modülündekine benzer işlemleri yapan o dilin standart kütüphenesinin bir bileşeni olacaktır.


**Epoch**: Bir bilgisayar sisteminde tarih-saat bilgisini sadece rakamsal olarak gösterbilmek için belirli bir tarih-saat anından itibaren geçen saniye ya da salise sayısı olarak tutmak istendiğinde o belirli tarih-saat anına **epoch** adı veriliyor.

**Time-point(Zaman noktası)**: Bir **zaman noktası** sadece zaman çizelgesindeki bir andır. C'de bu genellikle hesaplama kolaylığından dolayı `time_t` türünde tutulur. **Calendar time(takvim zamanı)** ile aynıdır, ancak insan tarafından okunabilir tarih yerine soyut bir nokta olarak düşünülür.

**Calendar Time(Takvim Zamanı)**: C'deki **calendar time** `time_t` türü ile temsil edilir. Kavramsal olarak, "**Unix Epoch**" dan bu yana geçen saniye sayısıdır (_1 Ocak 1970'te 00: 00: 00_). Basitçe, makine açısından verimli bir **time-point(zaman noktası)** ölçüsü olarak hizmet eder.

**Broken-down time**: Parçalanmış zaman, bir `time_t` türünün yıl, ay, gün, saat, dakika, saniye vb. olarak insan tarafından okunabilir bir şekilde ayrıştırılarak tanımlandığı tarih gösterim biçimidir. `struct tm` yapı türü tarafından temsil edilir.

**Timestamp(Zaman Damgası)**: **Zaman damgası** genellikle bir günlüğe veya veritabanına damgalanmış, kaydedilmiş bir zaman noktası anlamına gelir.


**Time-point(Zaman noktası)** değerini nasıl ifade edebiliriz? 
1. **Calendar Time(Takvim Zamanı)**: **Epoch** anından itibaren(çoğu zaman "_01:01:1970 00:00:00_" tarihinden itibaren) geçmiş olan saniye değeridir ve `time_t` tür eş adında tutulan bir değerdir, bu değer insanın okuyabileceği ve anlamlı bir değer değildir ama tarihler üzerinde hesaplama yapmak için kullanılabilecek şekilde tarihi tutmanın kolay bir yoludur.
2. **Broken-down time(Ayrıştırılmış zaman bilgisi)**: İnsanın bir bakışta bulunulan anın(time-point) ne olduğunu anlayabileceği zamanın ifade ediliş biçimidir ama bu tarih bilgisini bu şekilde tutmak daha fazla bellek gerektirmektedir ve üzerinde işlem yapmak zordur. Mesala "_01.01.1973 00:00:007_" zaman gösterimi **broken-down time(ayrıştırılmış zaman bilgisi)** olarak gösterimdir. Bu tarih formatını tutmak için yapı türü olan `struct tm` türü kullanılır.


❗❗❗Aşağıdaki bilgiler önemlidir
- `time_t` tür eş adının hangi türe karşılık geleceği derleyiciye bırakılmıştır, derleyiciye göre `long long` ya da `long` türüne karşılık geliyor olabilir.
- C standardı **epoch** değerinin ne olacağının kararını derleyiciye bırakılmıştır, Unix/Linux sistemlerinde **epoch** değeri olarak "_01:01:1970 00:00:00_" tarihi kullanılıyor ve sistemlerin çoğunda **epoch** değeri "_01:01:1970 00:00:00_" tarihidir.
- `time.h` modülündeki `struct tm` yapı türü **C tarzı kütüphane** yapı türüdür ve yapıdaki tüm üyelerin ne olduğunun programcı tarafından bilinmesi gerekmektedir.


👇 Aşağıdaki program parçasından `struct tm` yapısının bildirimi incelenebilir.
```C
struct tm {
    int tm_year; // Yıl değeri. 1900 değerinden sonraki değeri tutmaktadır, '213' değeri '2113' yılını ifade etmektedir.
    int tm_mon; // Yılın kaçıncı ayı olduğunu ifade eden sayı değeri. 0: Ocak, 1: Şubat, ... , 11: Aralık.
    int tm_mday; // Ayın kaçıncı günü olduğunu ifade eden sayı değeri. Bu değer '21' ise ayın 21. günü olduğu anlamına gelmektedir.
    int tm_wday; // Haftanın kaçıncı günü olduğunu ifade eden sayı değeri. 0: Pazar, 1: Pazartesi, 2: Salı, 3: Çarçamba, 4: Perşembe, 5: Cuma, 6: Cumartesi.
    int tm_yday; // Yılın kaçıncı günü olduğunu ifade eden sayı değeri. 0: 1 Ocak, 1: 2 Ocak, ..., 29: 30 Ocak, ... . 
    int tm_hour; // Saat değeri. [0-23] değer aralığında 24 saat üzerinden tutulan bilgi.
    int tm_min; // Dakika değeri. [0-59] değer aralığında.
    int tm_sec; // Saniye değeri. [0-59] değer aralığında.
    int tm_isdst; // 'daylight saving time(gün ışığı tasarruf modu)' değeri. Bu değer 'tm_isdst < 0' ise veri tutulmadığı anlamına geliyor, bu değer 'tm_isdst = 0' ise gün ışığı tasarrufunda olunmadığı anlamına geliyor, bu değer 'tm_isdst > 0' ise gün ışığı tasarrufunda olunduğu anlamına geliyor.
};
```


## Yapılar ve Tür Eş Adı(`typedef`) Bildirimleri 

🧭 C kursunda `typedef` bildirimleri üç kısıma ayrılmıştı;
1. `size_t`, `ptrdiff_t`, `int8_t` `int16_t`, `int_least8_t` `int_least16_t`, `int_fast8_t` `int_fast16_t` vb. tür eş adlarının kullanımının incelendiği ilk kısım.
2. **Function pointers** konusundaki karmaşık fonksiyon bildirimlerinin daha sade bişimde gösterilebilmesi için `typedef` anahtar sözcüğünden faydalanılmaktadır.
3. Şu anda da `typedef` bildiriminin üçüncü kısmı olan `typedef` bildiriminin **kullanıcı tanımlı türler(user defined types)** ile kullanımını göreceğiz.


👇 Aşağıdaki program **kullanıcı tanımlı türler(user defined types)** varlıklar için tü reş adı bildiriminin nasıl yapıldığı incelenebilir.
```C
#include <time.h>

// Yapı bildirimi.
// 'nec' adı 'structer tag' olarak adlandırılmaktadır.
struct nec {
    int x, y, z;
};

// Birlik bildirimi.
// 'erg' adı 'union tag' olarak adlandırılmaktadır.
union erg {
    int x, y, z;
};

// Numaralandırım bildirimi.
// 'pos' adı 'enum tag' olarak adlandırılmaktadır.
enum pos {off, on, hold, standby};


typedef struct nec nec_t;
typedef union erg erg_t;
typedef enum pos pos_t;
```


> ❔ 
> 
> Sorduğum soru;
> 
> "user defined type"ların adlandırılmalarındaki genel convension tüm harfler küçük olması biçiminde miydi?
> 
> Cevap;
> 
> Hayır. C dilinde en çok kullanılan convension ilk farfin büyük diğer harflerin küçük olmasıdır, C++ dilinde tüm farflerin küçük olması daha çok tercih edilen bir convension.


👇 Aşağıdaki program parçasında yapılarla `typedef` bildirimi kullanımı incelenebilir.
```C
struct Nec {
    int x, y, z;
};


typedef struct Nec Nec; // Burada 'struct Nec' türünden 'Nec' adında tür eş adı bildiirmi yapılıyor.
typedef struct Nec* NecPtr; // Burada 'struct Nec*' türünden 'NecPtr' adında tür eş adı bildiirmi yapılıyor.
```


👇 Aşağıdaki program parçasında yapılarla `typedef` bildirimi kullanımı incelenebilir.
```C
struct Nec {
    int x, y, z;
};

typedef struct Nec Nec; // Burada 'struct Nec' türünden 'Nec' adında tür eş adı bildiirmi yapılıyor.

typedef Nec* NecPtr; // Burada 'struct Nec*' türünden 'NecPtr' adında tür eş adı bildiirmi yapılıyor. 'Nec*' ifadesi 'struct Nec*' ifadesine denktir.
```



👇 Aşağıdaki program parçasında yapılarla `typedef` bildirimi kullanımı incelenebilir.
```C
struct Nec {
    int x, y, z;
};

typedef struct Nec Nec, *NecPtr; // Burada tek bir statement ile 'Nec' ve 'NecPtr' adında tür eş adı bildirimi yapılmıştır. 'struct Nec' türüne 'Nec' adı ve 'struct Nec*' türüne 'NecPtr' adı verildi.
```



👇 Aşağıdaki programda yapı bildirimini yaparken aynı zamanda `typedef` bildiriminin de nasıl yapıldığı incelenebilir.
```C
// Aşağıdaki gibi kullanım ile tek seferde hem yapının bildirimi hem de 'typedef' bildirimi yapılmış oluyor.
// En çok kullanılan yapı bildirimi yöntemi budur;
typedef struct Nec {
    int a, b, c;
}Nec; // Buradaki 'Nec' adı bir değişken değil bir tür eş adıdır.


int main(void)
{
    // Aşağıda iki tane 'struct Nec' türünden değişken bildirimi yapılmıştır, statement'lar farklı ama oluşturulan türlerin aynı olduğu görülmelidir.
    struct Nec mynec;
    Nec x;
}
```



👇 Aşağıdaki programda yapı bildirimini yaparken aynı zamanda `typedef` bildiriminin de nasıl yapıldığı incelenebilir. 
```C
#include <stdlib.h>
#include <stdio.h>

// Aşağıdaki gibi kullanım ile tek seferde hem yapının bildirimi hem de 'typedef' bildirimleri yapılmış oluyor.
// En çok kullanılan yapı bildirimi yöntemi budur;
typedef struct Nec {
    int a, b, c;
}Nec, * NecPtr; // Buradaki 'struct Nec' türüne 'Nec' tür eş adı verildi ve 'struct Nec*' türüne 'NecPtr' tür  eş adı verildi.


int main(void)
{
    Nec x = { 4, 5, 7 };
    NecPtr ptr = &x;
}
```


👇 Aşağıdaki programdan bir yapının kullanılabilmesinin nasıl sadece tür eş adı üzerinden kullanımına zorlanabileceği incelenebilir.
```C
#include <stdlib.h>
#include <stdio.h>

// Aşağıda yapının etiketi(tag) eklenmediği için 'anonymous' olarak bildirilmiş oluyor, 'Nec' adı da 'typedef' bildirimi oluyor, bu durumda bu yapının nesnesini oluşturmak için sadece 'Nec' tür eş adı kullanılabilir.
// En çok kullanılan yapı bildirimi yöntemi budur;
typedef struct {
    int a, b, c;
}Nec; // Burada 'Nec' adında tür eş adı bildiriliyor.


int main(void)
{
    Nec x = { 4, 5, 7 };
}
```



❗❗❗ 👇 Aşağıdaki programda **anonymous structure** bildiriminin **pointer** türünden yapılarak ilgili `struct` türünün sadece dinamik ömürlü bir nesne olarak tanımlanmaya zorlanması incelenebilir.
```C
#include <stdlib.h>
#include <stdio.h>

// Aşağıdaki yapı türünün bir adı yok, bir eş adı da yok, ancak bu yapı türüne pointer türünün eş adı var.
// Aşağıdaki gibi bir yapı bildirimi yapılırsa, bir adı olmayan bu yapı türünden, otomatik ömürlü ve static ömürlü değişken tanımlama şansımız yoktur sadece dinamik ömürlü bir nesne tanımlanabilir.
typedef struct {
    int a, b, c;
} *NecPtr;


int main(void)
{
    NecPtr p;

    printf("%zu\n", (sizeof(p)); // Burada standart çıktı akımına sistemdeki pointer türünün byte değeri gönderilecektir.
    printf("%zu\n", (sizeof(*p)); // Burada standart çıktı akımına sistemde 'int' türü 4 byte olduğunda en az '12\n' değeri gönderilecektir.
}
```


**Unevaluated context(İşlem kodu üretilmeyen bağlam)**: C++ dilinde işlem kodu üretilmeyen 8, 9 farklı durum vardır.

❗❗❗ İşlem kodu üretilmeyen durumlarda tanımsız davranış oluşturan ifadeler kullanıldığında işlem kodu üretilmediği için **ub** durumu oluşmamaktadır.


❗❗❗ 👇 Aşağıdaki programda işlem kodu üretilen ve üretilmeyen durumlarda **ub** olup olmayacağı incelenebilir.
```C
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
    int ary[12] = { 0 };

    int x = ary[21]; // Burada 'ary' dizisi taşırıldığı için 'ub' durumu oluşur.
    size_t sz = sizeof(ary[21]); // Burada işlem kodu üretilmediği için 'ub' de yoktur.

    int* p;
    int* ptr = NULL;

    // Aşağıdaki durumların hiçbirinde 'ub' yoktur.
    printf("%d\n", sizeof(ary[765]));
    printf("%zu\n", sizeof(p));
    printf("%zu\n", sizeof(*p));
    printf("%zu\n", sizeof(*ptr));
}
```



❗❗❗ 👇 Aşağıdaki programda **anonymous structure** bildiriminin **pointer** türünden yapılarak ilgili `struct` türünün sadece dinamik ömürlü bir nesne olarak tanımlanmaya zorlanması incelenebilir.
```C
#include <stdlib.h>
#include <stdio.h>

// Aşağıdaki yapı türünün bir adı yok, bir eş adı yok, ancak yapı türüne pointer türünün eş adı var.
// Aşağıdaki gibi bir yapı bildirimi yapılırsa, bir adı olmayan bu yapı türünden, otomatik ömürlü ve static ömürlü değişken tanımlama şansımız yoktur sadece dinamik ömürlü bir nesne tanımlanabilir.
typedef struct {
    int a, b, c;
} *NecPtr;

int main(void)
{
    // Kütüphenelerde kullanılan bir C idiyomu
    NecPtr p = (NecPtr)malloc(sizeof(*p)); // Buradaki 'p' değişkeninin türü sadece 'NecPtr' tür eş adıyla erişile bilen 'struct' türünden değerdir. 'p' değişkeni 'NecPtr p' ile tanımlanan değişkendir, aynı statement içinde aynı değişken kullanılıyor.
}
```


> ❔ 
> 
> Sorulan soru;
> 
> Doğrudan *Necptr de diyemez miyiz, sizeof icinde
> 
> Cevap;
> 
> Tabiki de hayır, çünkü içerip operatörünün operandı bir tür olamaz, yukarıdaki programda `NecPtr` bir türdür bir ifade değildir, içerip öperatörünün operandı sadece adres olan ifadeler olabilir. </br>
> `*NecPtr` demek `*(int*)` demek gibi bir kullanım olacağı için hatalıdır.



👇 Aşağıdaki programda **dereferencing(içerik)(`*`)** ve **subscript(index of)(`[]`)** operatörleri görülebilir.
```C
#include <stdlib.h>
#include <stdio.h>


typedef struct {
    int x, y, z;
} *NecPtr;


int main(void)
{
    int x = 5;
    int* ptr = &x;
    int a[5] = { 0 };

    // Aslında iki tane 'dereferencing(içerik)' operatörü vardır.
    // Aşağıdaki iki ifade de iki farklı içerik operatörü görülebilir, ikisini birbirinden ayırmak için farklı adlar veriliyor ama iki operatör de bir adresteki nesneye erişmek için kullanılıyor.
    *ptr;
    a[3];
}
```



Mülakatlarda çok sık sorulan bir soru aşağıdaki gibidir? </br>
👇 Aşağıdaki programda bildirimi yapılan `x` ve `y` yapı değişkenlerinin birbirine atanması işlemi yapılıp yapılamayacağı mülakatlarda sorulmaktadır.
```C
typedef struct {
    int a, b, c;
}x;

typedef struct {
    int a, b, c;
}y;

int main(void)
{
    x = y; // Buradaki atama işlemi hatalıdır, derleyici 'x' ve 'y' türlerini farklı türler olarak yorumladığı için bu atama sözdizim hatasıdır(syntax error).
}
```



👇 Aşağıdaki programda C ve C++ dillerinde `struct` türünden değişken bildirimlerinin legal/illegal olma durumları incelenebilir.
```C
#include <time.h>

int main(void)
{
    // tm x; // Buradaki gibi bir bildirim C dilinde illegal, C++ dilinde legal durumdadır.
    
    // struct tm tm; // Buradaki gibi bir bildirim C ve C++ dillerinde legal durumdadır.
}
```



👇 Aşağıdaki programda farklı **kapsamlarda(csope)** aynı ada sahip **adların(identifier)** kullanılabileceği incelenebilir.
```C
#include <time.h>

struct x{
    int x, y;
};


void x(void) // function
{
    struct x x; // decleration x is in block scope

x: // 
    x.x = 5; // local x( in block scope)
}
```


📌 Label varlıklarının `goto` ile kullanmanın dışında kullanıldığında derleyiciler uyarı iletisi verecektir. Bazen prograncılar  **çıplak label(goto ile bağlı olmayan etiket)** kullanımını debug amaçlı kullanmaktadırlar ama pek iyi bir fikir değildir.


## `time` Başlık Dosysındaki Fonksiyonlar 

`time.h` başlık dosyasındaki fonksiyonlar aşağıdaki gibidir;
- `time`
- `localtime`
- `gmtime`
- `asctime`
- `difftime`
- `strftime`
- `mktime`


### `time` Fonksiyonu

Prototipi `time_t time(time_t *);` olan fonksiyonunun özellikleri aşağıdaki gibidir;
- **output** parametre almaktadır. 
- **calendar time** değerini hesaplayan bir fonksiyondur.
- `time_t` türünden kendisine geçilen nesneye değer atama işlemi yapan bir fonksiyondur ve aynı nesneyi geriye döndürür.
- Bu fonksiyona `NULL pointer` geçilirse tanımsız davranış oluşmaz, fonksiyondan geriye istek yapılan andaki tarih değerine sahip `time_t` türünden yapı nesnesi dönülürdü.



👇 Aşağıdaki programda `time` fonksiyonunun kullanımı incelenebilir.
```C
#include <stdio.h>
#include <time.h>

int main(void)
{
    time_t sec;
    time(&sec);

    printf("calendar time: %lld\n", sec); // Burada Microsoft derleyicisi için '1970.01.01 00:00:00' tarihinden itibaren geçen saniye değeri yazdırılacaktır.
}
```


👇 Aşağıdaki programda `time` fonksiyonunun kullanımı incelenebilir.
```C
#include <stdio.h>
#include <time.h>

int main(void)
{
    time_t sec = time(NULL);

    printf("calendar time: %lld\n", sec);
}
```


👇 Aşağıdaki programda `time` fonksiyonuna **NULL pointer** geçildiğinde ne olacağı incelenebilir.
```C
#include <stdio.h>
#include <time.h>

int main(void)
{
    printf("calendar time: %lld\n", time(NULL));
    printf("calendar time: %lld\n", time(0)); // Burada pointer beklenen yerde '0' tam sayı değeri geçilirse derleyici 'NULL pointer'a dönüşüm yapacaktır.

    time_t s1, s2;
    s2 = time(&s1); // Buradaki atamanın bir anlamı yoktur ama yapılabildiği görülmelidir.
}
```


### `localtime` ve `gmtime` Fonksiyonları 

Birçok kodda `time_t` değerinden `struct tm` türüne dönüşüm gerekir. </br>
`localtime` ve `gmtime` fonksiyonları `time_t` değerini `struct tm` değerine dönüştürür. </br>
`gmtime` fonksiyonu ile `localtime` fonksiyonu arasındaki tek bir fark mevcut o fark ta `gmtime` fonksiyonunun İngilteredeki **greenwich** meridyeninin tarih bilgisi ile işlem yapmasıdır.


❗❗❗ Prototipi `struct tm* localtime(const time_t *);` olan fonksiyon dışarıdan `time_t*` türünden adres değeri alır ve `time_t` türünden `struct tm` türüne dönüşüm yapıp geriye **static storage duration** özellikteki `struct tm` türünden bir nesne adresini döndürmektedir.


***
==================================================

✦✦✦✦✦ 10.30-10.50 birinci ara verildi. ✦✦✦✦✦

==================================================
***



`time` kütüphenesiyle ilgili olarak mülakatlarda sorulabilecek olan çok basit bir soru. </br>
Mülakat sorusu: Bir C programı yazınız, çalıştırıldığında içinde bulunulan anın tarih bilgisini "_29 Haziran 2025 10:25:51_" gibi yazan programı yazınız. </br>
👇 Aşağıdaki programda buradaki mülakat sorusunun yazılmış hali incelenebilir.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

int main(void)
{
    time_t sec;
    time(&sec);

    struct tm* p = localtime(&sec);

    const char* const pmons[] = { "Ocak", "Subat", "Mart", "Nisan", "Mayis", "Haziran", "Temmuz", "Agustos", "Eylul", "Ekim", "Kasim", "Aralik", };
    const char* const pdays[] = { "Pazar", "Pazartesi", "Sali", "Carsamba", "Persembe", "Cuma", "Cumartesi", };

    printf("%02d-%02d-%d\n", p->tm_mday, p->tm_mon, p->tm_year); // Burada tarih hatalı görünecektir.

    printf("%02d-%02d-%d\n", p->tm_mday, p->tm_mon + 1, p->tm_year + 1900); // Burada yapılan düzenleme sonrasında tarih doğru görünecektir.

    printf("%02d-%02d-%d %02d:%02d:%02d\n", p->tm_mday, p->tm_mon + 1, p->tm_year + 1900, p->tm_hour, p->tm_min, p->tm_sec); // Tam tarihin yazdırılması. 
    
    printf("%02d %s %d %02d:%02d:%02d\n", p->tm_mday, pmons[p->tm_mon], p->tm_year + 1900, p->tm_hour, p->tm_min, p->tm_sec); // Ay bilgisi yazı olarak yazıldığında nasıl göründüğü incelenebilir.

    printf("%02d %s %d %s %02d:%02d:%02d\n", p->tm_mday, pmons[p->tm_mon], p->tm_year + 1900, pdays[p->tm_wday], p->tm_hour, p->tm_min, p->tm_sec); // Ay ve haftanın günü bilgisi yazı olarak yazıldığında nasıl göründüğü incelenebilir.
}
```



👇 Aşağıdaki programda `localtime` fonksiyonuna değeri dışarıdan tanımlanmış olan `time_t` türünden bir değişkenin argüman olarak geçilmesi sonucundaki tarihin yazdırılışı incelenebilir.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

int main(void)
{
    time_t sec = 1'500'000'000;
    struct tm* p = localtime(&sec);

    const char* const pmons[] = { "Ocak", "Subat", "Mart", "Nisan", "Mayis", "Haziran", "Temmuz", "Agustos", "Eylul", "Ekim", "Kasim", "Aralik", };
    const char* const pdays[] = { "Pazar", "Pazartesi", "Sali", "Carsamba", "Persembe", "Cuma", "Cumartesi", };

    printf("%02d %s %d %s %02d:%02d:%02d\n", p->tm_mday, pmons[p->tm_mon], p->tm_year + 1900, pdays[p->tm_wday], p->tm_hour, p->tm_min, p->tm_sec); // Ay ve haftanın günü bilgisi yazı olarak yazıldığında nasıl göründüğü incelenebilir.
}
```



👇 Aşağıdaki programda `localtime` fonksiyonu kullanılarak `struct tm` türünden bir değişkenin `tm_isdst` üyesinin durumunun ne olduğu incelenebilir.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

int main(void)
{
    time_t sec = 1'500'000'000;

    struct tm* p = localtime(&sec);

    const char* const pmons[] = { "Ocak", "Subat", "Mart", "Nisan", "Mayis", "Haziran", "Temmuz", "Agustos", "Eylul", "Ekim", "Kasim", "Aralik", };
    const char* const pdays[] = { "Pazar", "Pazartesi", "Sali", "Carsamba", "Persembe", "Cuma", "Cumartesi", };

    printf("%02d %s %d %s %02d:%02d:%02d\n", p->tm_mday, pmons[p->tm_mon], p->tm_year + 1900, pdays[p->tm_wday], p->tm_hour, p->tm_min, p->tm_sec); // Ay ve haftanın günü bilgisi yazı olarak yazıldığında nasıl göründüğü incelenebilir.

    if(p->tm_isdst < 0){
        printf("gun isigi tasarruf modu verisi tutulmuyor.\n");
    }
    else if(p->tm_isdst > 0){
        printf("gun isigi tasarrufu modunda.\n");
    }
    else{
        printf("gun isigi tasarrufu modunda degil.\n");
    }
}
```



👇 Aşağıdaki programda `gmtime` fonksiyonu kullanılarak `struct tm` türünden bir değişkenin `tm_isdst` üyesinin durumunun ne olduğu incelenebilir.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

int main(void)
{
    time_t sec = 1'500'000'000;

    struct tm* p = gmtime(&sec);

    const char* const pmons[] = { "Ocak", "Subat", "Mart", "Nisan", "Mayis", "Haziran", "Temmuz", "Agustos", "Eylul", "Ekim", "Kasim", "Aralik", };
    const char* const pdays[] = { "Pazar", "Pazartesi", "Sali", "Carsamba", "Persembe", "Cuma", "Cumartesi", };

    printf("%02d %s %d %s %02d:%02d:%02d\n", p->tm_mday, pmons[p->tm_mon], p->tm_year + 1900, pdays[p->tm_wday], p->tm_hour, p->tm_min, p->tm_sec); // Ay ve haftanın günü bilgisi yazı olarak yazıldığında nasıl göründüğü incelenebilir.

    if(p->tm_isdst < 0){
        printf("gun isigi tasarruf modu verisi tutulmuyor.\n");
    }
    else if(p->tm_isdst > 0){
        printf("gun isigi tasarrufu modunda.\n");
    }
    else{
        printf("gun isigi tasarrufu modunda degil.\n");
    }
}
```


### `ctime`, `asctime`, `strftime` Fonksiyonları 

Eğer bir **time point** değerini bir fonksiyon yardımıyla bir yazıya dönüştürmek istiyorsak `time` modülünde bulunan `ctime`, `asctime`, `strftime` fonksiyonlarını kullanabiliriz.


#### `ctime`, `asctime` Fonksiyonlarının Kullanımı

`ctime` fonksiyonunun adı "calendar time to string" sözcüklerinden gelmektedir, bu fonksiyon `time_t` türünden aldığı değişkeni insanların okuyabileceği `Www Mmm dd hh:mm:ss yyyy\n\0` formatında tarih yazısına çevirir, formatın sonundaki `\n` ve `\0` karakterlerine gör.

`asctime` fonksiyonunun adı "ASCII time" sözcüklerinden gelmektedir, bu fonksiyon `struct tm*` türünden aldığı gösterici değişkeni insanların okuyabileceği `Www Mmm dd hh:mm:ss yyyy\n\0` formatında tarih yazısına çevirir, formatın sonundaki `\n` ve `\0` karakterlerine gör.

Bu fonksiyonların **bildirimleri(Prototype)** aşağıdaki gibidir;
- `char* ctime(const time_t* timer);`
- `char* asctime(const struct tm* timeptr);`


❗❗❗ `ctime`, `asctime` fonksiyonlarıyla ilgili aşağıdaki bilgiler önemlidir;
- Bu fonksiyonlar 26 karakter uzunluğunda sonunda new-line(`\n`) karakteri olan yani **yeni satırla sonlanan yazı(new-line terminated byte stream)[bu adı be uydurdum dikkate almayabilirsin]** bir yazı adresi döndürür.
- Her iki fonksiyon da aynı static ömürlü dizinin adresini döndürür.
- Yazının formatı önceden belirlenmiştir, derleyiciye bağlı değildir, değiştirilemez.



👇 Aşağıdaki programda `ctime`, `asctime` fonksiyonlarının kullanımı incelenebilir.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

int main(void)
{
    time_t tx;
    time(&tx);

    const char* pstr = ctime(&tx);
    struct tm* tp = localtime(&tx);
    const char* tpstr = asctime(tp);

    printf("(%p) (%p)\n", pstr, tpstr); // Buradaki fonksiyon çağrısının yapılma nedeni 'ctime' ve 'asctime' fonksiyonlarının aynı static ömürlü dizinin adresini döndürdüğünü görebilmek içindir.

    // Aşağıdaki `printf` çağrılarından yazıların sonunda '\n' olduğunu anlayabilmek için köşeli parantez ile yazılar yazdırılmıştır.
    printf("[%s]", pstr);
    printf("[%s]", tpstr);
}
```


👆 Yukarıdaki program çalıştırıldığı anda(yazılardaki köşeli parantezler silinmişti) 👇 aşağıdaki gibi bir çıktı alındı ve buradan analitik prikolojinin kurucusu kabuledilen "**Carl Jung**"dan bahsedildi;
```bash

(01114DBO) (01114DBO)
Sun Jun 29 11:11:11 2025
Sun Jun 29 11:11:11 2025
```


#### `strftime` Fonksiyonunun Kullanımı 

Bu fonkisyonunun kullanılmasının öğrenilmesi biraz ilgi istemektedir. </br>
`strftime` fonksiyonunun adı "**string format time**" sözcüklerinden gelmektedir ve `struct tm*` türünden gösterici nesnesinin gösterdiği `struct tm` türünden nesneyi istenilen formatta bir yazıya dönüştürmek için kullanılmaktadır, bir çok formatlama yöntemi olduğu için ihtiyaca göre inceleme yapıp kullanmak gerekecektir, ezberlemeye çalışmadan sadece ihtiyaca göre kullanmak gerekir.

Bildirimi `size_t strftime(char* _Buffer, size_t _SizeInBytes, const char* _Format, const struct tm* _TM);` biçimindedir ve 
- `_Buffer`: İlk parametredir, `sprintf` fonksiyonundaki gibi yazının oluşturulacağı adres değeri.
- `_SizeInBytes`: İkinci parametredir, ilk parametrede geçilen yazıya değer yazarken taşma olmaması için yazının en fazla kaç karakter olabileceği bilgisini alan parametredir.
- `_Format`: Üçüncü parametredir, yazıya dönüştürme işleminin hangi formata göre yapılacağı bilgisi.
- `_TM`: Dördüncü parametredir, yazıya dönüştürülmek istenilen `struct tm*` gösterici türünden `struct tm` nesnesinin adres değeri.



Windows sistem programlama tarafıda "Windows Api"leri var yani Windows işletim sistemi için C dilinde yazılmış sistem fonksiyonları, pencereleri çıkartmak için bu "Windows Api" fonksiyonları çağırılıyor. "Windows Api" fonksiyonlarının arasında 10-15 arasında parametre alan fonksiyonlar var.


> ❔ 
> 
> Sorulan soru;
> 
> windows işletim sistemi bildiğim kadarıyla tamamen c++ ile yazılmış
> Cevap;
> 
> Hayır, Mindows işletim sistemi tamamen C diliyle yazıldı fakat işletim sistemi tarafında nesne yönelimli programlamanın sağlayacağı faydalar olduğu için sonradan C++'ın eski dönemlerinde C++'nin sınıflarıyla C fonksiyonlarını sarmalıyorlar(**function wraper**), esasen tüm fonksiyonlar C fonksiyonu ama C++ fonksiyonlarıyla C fonksiyonları sarmalanıyor.



**MFC**: "**Microsoft Fundation Classes**" sözcüklerinin kısaltmasıdır. C Api'lerini daha kolay kullanılabilsin diye C++ sınıflarıyla sarmalıyorlar(eski dönemlerde kullanılan kütü C++ sınıflarıyla sarmalıyorlar)



👇 Aşağıdaki programda `windows.h` başlık dosyası ile Windows sisten fonksiyonlarının kullanımı incelenebilir.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <windows.h> // Windows işletim sisteminin API fonksiyonlarının olduğu başlık dosyası.

int main(void)
{
    Sleep(); // Windows API fonksiyonuna çağrı yapılıyor.
}
```



👇 Aşağıdaki programda `strftime` fonksiyonunun kullanımı incelenebilir.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

#define SIZE 100

int main(void)
{
    char str[SIZE];
    time_t sec;
    time(&sec);

    struct tm* p = localtime(&sec);

    strftime(str, SIZE, "weekday: %A", p); // 'str' yazısına haftanın günü yazdırılıyor.
    printf("[%s]\n\n", str);


    strftime(str, SIZE, "mounth: %B weekday: %A", p); // 'str' yazısına ay ve haftanın günü yazdırılıyor.
    printf("[%s]\n", str);

    
    strftime(str, SIZE, "%B-%A %y", p);
    printf("[%s]\n", str);


    strftime(str, SIZE, "%F", p);
    printf("[%s]\n", str);

    strftime(str, SIZE, "%EX", p);
    printf("[%s]\n", str);
}
```



👇 Aşağıdaki programda `strftime` fonksiyonunun Türkiye local belirlendiği durumdaki kullanımı incelenebilir.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <locale.h>

#define SIZE 100

int main(void)
{
    char* lp;

    if((lp = setlocal(LC_ALL, "turkish")) == NULL){
        printf("local degistirilemedi.\n");
        return 1;
    }

    char str[SIZE];
    time_t sec;
    time(&sec);

    struct tm* p = localtime(&sec);

    strftime(str, SIZE, "%d %B %A %Y", p);
    printf("[%s]\n", str);
}
```


### `mktime` Fonksiyonu 

`mktime` fonksiyonunun adı "**Make Time**" sözcüklerinden gelmektedir ve adının aksine bir dönüşüm fonksiyonudur, `localtime` fonksiyonunun yaptığının tersini yapan fonksiyondur. `struct tm` türünü `time_t` türüne dönüştürmektedir. </br>
`mktime` fonksiyonunun bildirimi `stataic inline time_t mktime(struct tm* const _Tm);` biçimindedir, fonkisyondan geriye `-1` değeri döndürülmesi dönüşümün yapılamadığını hata oluştuğu anlamına gelir.


👇 Aşağıdaki programda `mktime` fonksiyonunun kullanımı incelenebilir.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <locale.h>

#define SIZE 100

int main(void)
{
    struct tm tx = {
        .tm_yday = 1987 - 1900, // 1987
        .tm_mon = 4, // Nisan
        .tm_mday = 1, // 1 Nsan 1987 
    };

    time_t sec = mktime(&tx);

    if(sec == -1){
        printf("donusum yapilamadi.\n");
        return 1;
    }

    printf("calendar time: %lld seconds\n", sec);
}
```



👇 Aşağıdaki programda `mktime` fonksiyonunun **olağanlaştırma(normalization)** özelliğinin olduğu incelenebilir.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <locale.h>

#define SIZE 100

int main(void)
{
    struct tm tx = {
        .tm_yday = 1987 - 1900, // 1987
        .tm_mon = 69, // Buradaki değer gerçek bir ay değeri değil.
        .tm_mday = 1, // 1 Nsan 1987 
    };

    time_t sec = mktime(&tx); // 'mktime' fonksiyonunun 'olağanlaştırma(normalization)' özelliği olduğu görülmelidir.

    if(sec == -1){
        printf("donusum yapilamadi.\n");
        return 1;
    }

    printf("calendar time: %lld seconds\n", sec);
}
```



👇 Aşağıdaki programda bu günün tarihinden n gün öncesinin ya da sonrasının nasıl hesaplanabileceği incelenebilir, programda `mktime` fonksiyonunun **olağanlaştırma(normalization)** özelliğinden yararlanılıyor.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <locale.h>

#define SIZE 100

int main(void)
{
    time_t sec;
    time(&sec);

    printf("today : %s", ctime(&sec);
    printf("kac gun : ");
    int n;
    scanf("%d", &n);

    struct tm tm = *localtime(&sec);
    tm.tm_mday += n;
    //tm.tm_mday -= n;

    time_t ft = mktime(&tm);
    printf("%d gun sonrasi : %s", n, ctime(&ft);
}
```



👇 Aşağıdaki program yıl değeri "1955" tarihi olduğunda MS derleyicisinde doğru çalışmadığını gördük, bu bana MS derleyicisinin güvenilmez olduğu izlenimi bıraktı!
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <locale.h>

#define SIZE 100

int main(void)
{
    int d, m, y;

    printf("bir tarih girin: ");
    scanf("%d%d%d", &d, &m, &y);

    struct tm tx = {
        .tm_yday = y - 1900, 
        .tm_mon = m -1,
        .tm_mday = d,
        .tm_isdst = -1
    };

    if(mktime(&tx) != (time_t)-1){
        const char* const weekdays[] = { 
            "Pazar", "Pazartesi", "Sali", "Carsamba", "Persembe", "Cuma", "Cumartesi",
        };

        printf("yilin gunu : %d\n", tx.tm_yday);
        printf("haftanin gunu : %s\n", weekdays[tx.tm_wday]);
    }
    else{
        printf("donusum yapilamadi.\n");
    }
}
```


> ❔ 
> 
> Sorduğum soru;
> 
> 1900 öncesi tarihler kullanılmak istense kullanılamıyor o zaman 'time' kütüphanesiyle, 1900 öncesi tarihlerle işlem yapılması gereken durumlar olduğunda ne yapılması gerekiyor
> 
> Cevap;
> 
> İşaretli tam sayı gürüyse kullanılmasında bir engel yok. Burada `struct tm` türünün `tm_yday` üye değişkeni `1900` tarihinden itibaren tam sayı değeri olarak tutulmasından dolayı yanlış düşünmüşüm, `tm_yday` üye değişkenine eksi tam sayı değerleri verildiğinde `1900` öncesinin yıl değerleri elde edilecektir.


### `difftime` Fonksiyonu 

`difftime` fonksiyonunun adı "**Different Time**" sözcüklerinden gelmektedir ve iki tane `time_t` türünden değişkenin arasındaki zaman farkının hesaplanması için kullanılan bir fonksiyonudur, fonksiyonun geri döndürdüğü tam sayı türü saniye(ya da salise) değeridir.



👇 Aşağıdaki program `difftime` fonksiyonu kullanılarak iki tane `time_t` türünden değişkenin arasındaki zaman farkının nasıl hesaplandığı incelenebilir.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <locale.h>

#define SIZE 100

int main(void)
{
    struct tm t1 = { 0 };
    struct tm t2 = { 0 };

    // Başlangıç tarihi: 1 Ocak 2020
    t1.tm_year = 2020 - 1900;
    t1.tm_mon = 0;
    t1.tm_mday = 1;

    // Bitiş tarihi: 28 Haziran 2025
    t1.tm_year = 2025 - 1900;
    t1.tm_mon = 5;
    t1.tm_mday = 28;

    time_t time1 = mkdir(&t1);
    time_t time2 = mkdir(&t2);

    if(time1 == (time_t)-1 || time2 == (time_t)-1){
        printf("Zaman donusum hatasi.\n");
        return 1;
    }

    double seconds = difftime(time2, time1);
    double weeks = floor(seconds / (7 * 24 * 60 * 60));

    printf("Tarihler arasında yaklaşık %.0f hafta geçmiştir.\n", weeks);
}
```



🧭 Şu ana kadar `time` modülünün incelediğimiz fonksiyonları aşağıdaki gibidir;
- `time`
- `localtime`
- `gmtime`
- `ctime`
- `asctime`
- `strftime`
- `difftime`


### `clock` Fonksiyonu 

`clock` fonksiyonu, süre hesaplamak için kullanılmaktadır, bu fonksiyonun geriye dönüş değeri `clock_t` türüdür, `clock_t` türünün neyin eş adı olduğu derleyiciden derleyiciye değişmektedir(işaretli işaretsiz bir tam sayı türü ya da ondalıklı sayı türü olabilir). </br>
`clock` fonksiyonunun bildirimi `clock_t clock(void);` biçimindedir ve programın çalışmaya başlamasından fonksiyonun çağırıldığı noktaya kadar çalışma zamanında geçen süreyi döndürmektedir. </br>
`clock` fonksiyonunun geri dönüş değeri "**tick count**" değeridir, "**tick count**" değeri yazılımsal ya da donanımsal bir birim olabilir, "**tick count**" değerinin ne olduğu derleyiciden derleyiciye değiştiği için standart bir birim değildir, `time.h` dosyasında bulunan `CLOCKS_PER_SEC` adındaki makro bir saniyenin ne kadarlık "**tick count**" değerine karşılık geldiği bilgisini içermektedir, `CLOCKS_PER_SEC` makrosu da `clock_t` türündendir. </br>



C mülakatlarında geçen zamanın hesaplanmasıyla ilgili sorulabilecek sorularda yararlanılabilecek olan bilgi aşağıdaki gibidir; </br> 
👇 Aşağıdaki program çalışma süresi ölçülmek istenilen kodun saniye türünden hesaplayan programın nasıl yazılabileceği incelenebilir, programdaki kullanım idiomatic bir kullanımdır.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <locale.h>

#define SIZE 100

int main(void)
{
    clock_t tpstart = clock();

    // some code here ...

    clock_t tpend = clock();

    double _passedtime = (double)(tpend - tpstart) / CLOCKS_PER_SEC;
}
```



👇 Aşağıdaki programdan 5 milyon elemanlı bir tam sayı dizisini standart `qsort` işleviyle küçükten büyüğe sıralayan ve sıralama işleminin kaç saniye sürdüğünü **standard output** tarafna gönderen program incelenebilir.
```C
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <locale.h>

#define SIZE 100

static icmp(const int* vp1, const int* vp2)
{
    int x = *(const int*)vp1;
    int y = *(const int*)vp2;

    return x > y ? 1 : x < y ? -1 : 0;
}

void mysort(int* p, size_t size)
{
    qsort(q, size, sizeof(*p), &icmp);
}

int main(void)
{
    // 5 milyon elemanlı bir tam sayı dizisini standart qsorth işleviyle küçükten büyüğe doşru sıralayınız ve bu sıralama işleminin kaç saniye sürdüğünü yazdırır.
    int* p = (int*)malloc(sizeof(int) * 5'000'000u);
    if(!p){
        printf("bellek yetersiz.\n");
        return 1;
    }
    
    set_array_random(p, SIZE);
    printf("siralama basladi.\n");
    
    // 'clock()' işlevini kullanarak yapılacak hesaplama ile aşağıdaki gibi bir kod parçasının ne kadar süre aldığı öğrenilebilir.
    clock_t start = clock();
    mtsort(p, SIZE);
    clock_t end = clock();

    printf("siralama bitti '%.2f' saniye.\n", (double)(end -start) / CLOCKS_PER_SEC);
}
```

 

Bu arada az önceki kodu denerken farkettim ki, Visual Studio 2022 ile derlendiğinde, 2 Ocak 1970'den önceki tarihlerde sonuç vermiyor(derse katılanlardan biri böyle bir yorum ekledi).


***
==================================================

✦✦✦✦✦ 12.20 -12.27 ikinci ara verildi. ✦✦✦✦✦

==================================================
***


`time` kütüphanesi bir **C tarzı kütüphane**, bazı kütüpheneler **OOP tarzı kütüphene** ve bu kütüphaneler kullanıcının kendilerinin üyelerini gerekmedikçe dışarıya açmıyorlar ve dışarıdan bilinmesini istemiyorlar. </br>
**OOP tarzı kütüphenelerde** bir yapının nın elemanları ya hiç dışarıdan erişilebilir olmuyor ya da elemanların belirli durumlar haricinde dışarıdan değiştirilmesi istenmiyor, böyle kütüphanelerde en ufak işleri yapmak için bile fonksiyon çağrıları kullanılması gerekmektedir.


> ❔ 
> 
> Sorulan soru;
> 
> OOP tarzinda da fonk ve nasil cagirildigini bilmek gerek sanirim. ikisi arasinda tercih krikteri nasil omali kendimiz kütüphane yazarken
> 
> Cevap;
> 
> Sistem programlama tarafında ağırlıklı olarak **C tarzı kütüphane** kullanılması tercih ediliyor, **OOP tarzı kütüphene** kullanılması daha çok uygulama programcılığı tarafında tercih ediliyor.


## Complete Types and Incomplate Types Kavramları 

Bu konu başlığı C++ kursuna katılacaklar açısında da çok önemli bir konu ve iyi bilinmesi gerekiyor.

❗❗❗ **Incomplate type** kavramı daha çok **kullanıcı tanımlı türler(user defined types)** ile ilgilidir. **Kullanıcı tanımlı türler(user defined types)** olmayan türlerden sadece **void pointer türü(`void*`)** türü **incomplate type** diğerleri **complete type**.

Derleyicisinin bakış açısından bir **kullanıcı tanımlı tür(user defined type)** ya **complete type** ya da **incomplate type**.

**Complete type**: Eğer derleyici bir türün bildiriminin tamamını görüyorsa(o tür yapı türüyse yapının tüm üyelerini görebiliyorsa) o türe **complete type** deniliyor.

**incomplate type**: Eğer derleyici bir türün bildiriminin tamamını göremiyorsa o türe **incomplate type** deniliyor.


👇 Aşağıdaki program parçasında **complete type** ve **incomplate type** kavramlarının ne olduklarını anlamak için incelenebilir.
```C
// Aşağıdaki 'struct Nec' türü 'complete type' durumundadır.
struct Nec {
    int x, y;
    double d;
};


// Aşağıdaki fonksiyon bildiriminde 'struct Nec2' türü 'incomplete type' durumundadır.
struct Nec2 foo(struct Nec2);

// Aşağıdaki bildiriminde 'struct Nec3' türü  'incomplete type' durumundadır. Burada derleyiciye 'struct Nec3' adındaki bir türün olduğu söyleniyor ama o türün ne olduğuna dair bir bilgi verilmiyor ve böyle olunca da ortada eksik bilgi oldğu için 'tamamlanmamış tür' anlamına gelen 'incomplate type' deniliyor.
struct Nec3;


int main(void)
{

}
```



❗❗❗ **incomplate type** ve **complate type** türlerle ilgili aşağıdaki tespitler önemlidir;
- Bazı bildirimler ya da bazı ifadeler, söz konusu türün **incomplate type** olması durumunda da geçerlidir.
- Bazı ifadelerin geçerli olması için kullanılan türün **complate type** olması zorunludur.


**Incomplate type** kullanabilen ifadelerde çoğu zaman türün **complate type** yapılması istenmez.

❗❗❗ Eğer bir modüldeki bir ya da bir kaç varlığın kullanılması gerekiyorsa, ilgili modülün kaynak dosyaya eklenmesi yerine sedece kaynak dosyadaki gerekli olan veri türleri **incomplate type** olarak eklenebilir ve fonksiyonların bildirimleri yazılabilir.

❗❗❗ Bir kaynak dosyasına bir çok başlık dosyasınının eklenmesi aşağıdaki sorunlara neden olabilir;
- Büyük projelerde derleme zamanı uzar(extended compile time).
- Gereksiz modüllerin eklenmesi gereksiz yere Bağımlılık oluşturmaktadır(kaynak dosyalarının başlık dosyalarına bağımlılığı). Bağımlılıklarda bir başlık dosyasında yapılan değişikliğin başka bir dosyada da değişiklil yapılmasına neden olabilir.



En çok yapılan hata, programcının **incomplate type** kavramının ne olduğunu bilmediği ve anlamadığı için bir başlık dosyasının eklenmesinin zorunlu olduğunu düşündüğü için o başlık dosyasını kaynak koda ekliyor(`#include` ile). </br>
Bir başlık dosyasındaki bir kaç türü kullanmak için `#include` işlemi ile o türlerin bildirimlerinin yer aldığı başlık dosyasını eklemek yerine o türlerin kullanılacağı dosyaya o türlerin bildirimlerinin **incomplate type** olarak eklenmesi yeterli olacaktır, bu işlem ile eklenen **incomplate type** türler bir bağımlılık oluşturmamaktadır.


**Incomplate type** aşağıdaki durumlarda kullanılabilir;
1. Fonksiyon bildirimlerindeki türlerin **complate type** olması gerekmemektedir.

    
    👇 Aşağıdaki program parçasında fonksiyon bildirimlerindeki parametre ve geri dönüş türleri **complate type** olması gerekmediği görülmelidir.
    ```C
    struct Nec; // Buradaki 'struct Nec' türü üyelerinin tamanı bilinmediği için 'incomplate type' durumundadır.

    // Aşağıdaki fonksiyon bildirimlerindeki parametre ve geri dönüş türleri 'incomplate type' durumundadır.
    struct Nec foo(struct Nec);
    struct Nec* bar(struct Nec*);
    ```


2. Tür eş adı bildirimlerinde bildirilen türler **incomplate type** olabilir. 

    👇 Aşağıdaki program parçasında **incomplate type** yapı türü üzerinden bildirimleri yapılan tür eş adları incelenebilir.
    ```C
    struct Nec; // Buradaki 'struct Nec' türü üyelerinin tamanı bilinmediği için 'incomplate type' durumundadır.

    // typedef declerations 
    typedef struct Nec Nec; // 'struct Nec' yapı türüne 'Nec' tür eş adı verilmiştir.
    typedef struct Nec* NecPtr; // 'struct Nec*' yapı türü göstericisi türüne 'NecPtr' tür eş adı verilmiştir.
    typedef Nec(*Fptr)(Nec); // Burada 'struct Nec(*)(struct Nec)' fonksiyon göstericisi için 'Fptr' adından bir 'function pointer' tür eş adı bildirimi yapılmıştır.
    ```

3. `extern` bildirimlerinde **incomplate type** kullanılabilir.

    
    👇 Aşağıdaki program parçasında `extern` ile bildirilen türlerin **incomplate type** olabileceği görülebilir.
    ```C
    struct Nec; // Buradaki 'struct Nec' türü üyelerinin tamanı bilinmediği için 'incomplate type' durumundadır.

    extern struct Nec x;
    extern struct Nec ar[20];
    ```

4. **Incomplate type** durumunda gösterici değişkenler oluşturulabilir.

    
    👇 Aşağıdaki program parçasında **incomplate type** durumundaki yapı türünün kullanılabildiği görülebilir, buradan da anlaşılacağı gibi tamamlanmamış bir tür ile fonksiyon bildirimleri yapılabilir ve kaynak dosya derlenebilir durumdadır fakat **bağlama(linker)** aşamasında bu **incomplate type** varlıkların **complate type** hallerinin bulunabilir olması gerekiyor diğer türlü bağlama işleminde hata oluşur.
    ```C
    struct Nec; // Buradaki 'struct Nec' türü üyelerinin tamanı bilinmediği için 'incomplate type' durumundadır.

    struct Nec* create_nec(int, int); 
    void foo(struct Nec*);
    void bar(struct Nec*);


    int main(void)
    {
        struct Nec* necptr = create_nec(3, 6);
        foo(necptr);
        bar(necptr);
    }
    ```


Ders sonu ...
