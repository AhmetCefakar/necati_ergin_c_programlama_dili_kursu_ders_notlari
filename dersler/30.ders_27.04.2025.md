# 30.Ders 27.04.2025 ğŸ•˜

Derse 13(09:01)-16(09:06)-17(09:20)-18(09:33)-19(09:59)-20(10:24)-21(11:01)-21(11:52)-20(12:03) kiÅŸi katÄ±ldÄ±.
---

## Pointers Devam

### FonksiyonlarÄ±n Geri DÃ¶nÃ¼ÅŸ DeÄŸeri Olarak Pointer'lar Devam 

â— Adres dÃ¶ndÃ¼ren fonksiyonlar **ub**'ye neden olmadan ne dÃ¶ndÃ¼rebilir?
1. **Static Ã¶mÃ¼rlÃ¼** nesne adresi dÃ¶ndÃ¼rebilir, bunlar aÅŸaÄŸÄ±daki gibi olabilir;
    1. Global deÄŸiÅŸken adresleri.
    2. Static yerel deÄŸiÅŸken adresleri.
    3. **String literal** ifadeleri(**String literal** ifadeleri **Static Ã¶mÃ¼rlÃ¼** dizi nesneleridir).
2. Ã‡aÄŸÄ±ran kodun gÃ¶nderdiÄŸi adres dÃ¶ndÃ¼rebilir.
3. Diziler Ã¼zerinde iÅŸlem yapan fonksiyonlarÄ±n dizinin bir elemanÄ±nÄ±n adresini dÃ¶ndÃ¼rmesi.


Const Casting Operation



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `print_array` fonksiyonu kullanÄ±larak dizinin en bÃ¼yÃ¼k elemanÄ±ndan baÅŸlayarak(ya da en bÃ¼yÃ¼k elemanÄ±na kadar) dizinin geriye kalan elemanlarÄ±yla birlikte nasÄ±l yazdÄ±rÄ±lacaÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 20

int* get_array_max(const int* ptr, int size)
{
    const int* pmax = ptr;

    for(int i = 0; i < size; ++i){
        if(ptr[i] > *pmax){
            // pmax = &ptr[0];
            pmax = ptr + i; // Pointer aritmetiÄŸi ile dizinin i. elemanÄ±nÄ±n adresi 'pmax' gÃ¶stericisine yeni deÄŸeri atanÄ±yor.
        }
    }

    return (int*)pmax; // Buradaki casting iÅŸlemi 'const cast' olarak adlandÄ±rÄ±lmaktadÄ±r.
}

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    int* pmax = get_array_max(ar, SIZE);

    print_array(pmax, SIZE - (pmax - ar)); // Dizinin en bÃ¼yÃ¼k elemanÄ± ve sonraki dizi elemanlarÄ±nÄ± yazdÄ±rmak iÃ§in yapÄ±lan fonksiyon Ã§aÄŸrÄ±sÄ±.
    //print_array(pmax, SIZE - pmax + ar); // Burada sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur Ã§Ã¼nkÃ¼ '-', '+' operatÃ¶rleri soldan saÄŸa iÅŸlem Ã¶nceliÄŸine sahiptir, 'Tam sayÄ± - Adres' iÅŸleminden dolayÄ± hata oluÅŸur.

    print_array(ar, pmax - ar + 1); // Burada dizinin ilk elemanÄ±ndan en bÃ¼yÃ¼k elemanÄ± dahil tÃ¼m elemanlarÄ± yazdÄ±rÄ±lacaktÄ±r.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir dizideki en bÃ¼yÃ¼k ve en kÃ¼Ã§Ã¼k elemanlarÄ±n nasÄ±l tespit edilip yazdÄ±rÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 20

int* get_array_max(const int* ptr, int size)
{
    const int* pmax = ptr;

    for(int i = 0; i < size; ++i){
        if(ptr[i] > *pmax){
            // pmax = &ptr[0];
            pmax = ptr + i; // Pointer aritmetiÄŸi ile dizinin i. elemanÄ±nÄ±n adresi 'pmax' gÃ¶stericisine yeni deÄŸeri atanÄ±yor.
        }
    }

    return (int*)pmax; // Buradaki casting iÅŸlemi 'const cast' olarak adlandÄ±rÄ±lmaktadÄ±r.
}

int* get_array_min(const int* ptr, int size)
{
    const int* pmin = ptr;

    for(int i = 0; i < size; ++i){
        if(ptr[i] < *pmin){
            pmin = ptr + i; // Pointer aritmetiÄŸi ile dizinin i. elemanÄ±nÄ±n adresi 'pmin' gÃ¶stericisine yeni deÄŸeri atanÄ±yor.
        }
    }

    return (int*)pmin; // Buradaki casting iÅŸlemi 'const cast' olarak adlandÄ±rÄ±lmaktadÄ±r.
}

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    int* pmax = get_array_max(ar, SIZE);
    int* pmin = get_array_min(ar, SIZE);

    printf("max = %d ve en buyuk elemanin indeksi = %d\n", *pmax, pmax - ar);
    printf("min = %d ve en kucuk elemanin indeksi = %d\n", *pmin, pmin - ar);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir dizideki en bÃ¼yÃ¼k ve en kÃ¼Ã§Ã¼k elemanlarÄ±n nasÄ±l tespit edilip ardÄ±ndan deÄŸerlerinin deÄŸiÅŸtirildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 20

int* get_array_max(const int* ptr, int size)
{
    const int* pmax = ptr;

    for(int i = 0; i < size; ++i){
        if(ptr[i] > *pmax){
            // pmax = &ptr[0];
            pmax = ptr + i; // Pointer aritmetiÄŸi ile dizinin i. elemanÄ±nÄ±n adresi 'pmax' gÃ¶stericisine yeni deÄŸeri atanÄ±yor.
        }
    }

    return (int*)pmax; // Buradaki casting iÅŸlemi 'const cast' olarak adlandÄ±rÄ±lmaktadÄ±r.
}

int* get_array_min(const int* ptr, int size)
{
    const int* pmin = ptr;

    for(int i = 0; i < size; ++i){
        if(ptr[i] < *pmin){
            pmin = ptr + i; // Pointer aritmetiÄŸi ile dizinin i. elemanÄ±nÄ±n adresi 'pmin' gÃ¶stericisine yeni deÄŸeri atanÄ±yor.
        }
    }

    return (int*)pmin; // Buradaki casting iÅŸlemi 'const cast' olarak adlandÄ±rÄ±lmaktadÄ±r.
}

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    int* pmax = get_array_max(ar, SIZE);
    int* pmin = get_array_min(ar, SIZE);

    swap(pmax, pmin); // Dizideki en bÃ¼yÃ¼k ve en kÃ¼Ã§Ã¼k deÄŸerleri yer deÄŸiÅŸtirilmektedir.
    print_array(ar, SIZE);

    swap(get_array_max(ar, SIZE), get_array_min(ar, SIZE)); // Buradaki gibi de fonksiyondan fonen pointer nesneler baÅŸka bir fonksiyona argÃ¼man olarak geÃ§ilebilir.
    print_array(ar, SIZE);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir dizideki en bÃ¼yÃ¼k ve en kÃ¼Ã§Ã¼k elemanlarÄ±n bir pointer deÄŸiÅŸkende tutulmadan nasÄ±l tespit edilip ardÄ±ndan takas iÅŸlemi yapacan bir fonksiyona argÃ¼man olarak gÃ¶nderilebileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 20

int* get_array_max(const int* ptr, int size)
{
    const int* pmax = ptr;

    for(int i = 0; i < size; ++i){
        if(ptr[i] > *pmax){
            // pmax = &ptr[0];
            pmax = ptr + i; // Pointer aritmetiÄŸi ile dizinin i. elemanÄ±nÄ±n adresi 'pmax' gÃ¶stericisine yeni deÄŸeri atanÄ±yor.
        }
    }

    return (int*)pmax; // Buradaki casting iÅŸlemi 'const cast' olarak adlandÄ±rÄ±lmaktadÄ±r.
}

int* get_array_min(const int* ptr, int size)
{
    const int* pmin = ptr;

    for(int i = 0; i < size; ++i){
        if(ptr[i] < *pmin){
            pmin = ptr + i; // Pointer aritmetiÄŸi ile dizinin i. elemanÄ±nÄ±n adresi 'pmin' gÃ¶stericisine yeni deÄŸeri atanÄ±yor.
        }
    }

    return (int*)pmin; // Buradaki casting iÅŸlemi 'const cast' olarak adlandÄ±rÄ±lmaktadÄ±r.
}

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    swap(get_array_max(ar, SIZE), get_array_min(ar, SIZE)); // Dizideki en bÃ¼yÃ¼k ve en kÃ¼Ã§Ã¼k deÄŸerler yer deÄŸiÅŸtirilmektedir.
    print_array(ar, SIZE);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda oluÅŸturulan dizideki en bÃ¼yÃ¼k ve en kÃ¼Ã§Ã¼k sayÄ±lar tespit edilip bu iki sayÄ± dahil aradaki sayÄ±larÄ±n yazdÄ±rÄ±lmasÄ± iÅŸleminin nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 20

int* get_array_max(const int* ptr, int size)
{
    const int* pmax = ptr;

    for(int i = 0; i < size; ++i){
        if(ptr[i] > *pmax){
            // pmax = &ptr[0];
            pmax = ptr + i; // Pointer aritmetiÄŸi ile dizinin i. elemanÄ±nÄ±n adresi 'pmax' gÃ¶stericisine yeni deÄŸeri atanÄ±yor.
        }
    }

    return (int*)pmax; // Buradaki casting iÅŸlemi 'const cast' olarak adlandÄ±rÄ±lmaktadÄ±r.
}

int* get_array_min(const int* ptr, int size)
{
    const int* pmin = ptr;

    for(int i = 0; i < size; ++i){
        if(ptr[i] < *pmin){
            // pmin = &ptr[0];
            pmin = ptr + i; // Pointer aritmetiÄŸi ile dizinin i. elemanÄ±nÄ±n adresi 'pmin' gÃ¶stericisine yeni deÄŸeri atanÄ±yor.
        }
    }

    return (int*)pmin; // Buradaki casting iÅŸlemi 'const cast' olarak adlandÄ±rÄ±lmaktadÄ±r.
}

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    int* pmax = get_array_max(ar, SIZE);
    int* pmin = get_array_min(ar, SIZE);

    printf("max = %d ve en buyuk elemanin indeksi = %d\n", *pmax, pmax - ar);
    printf("min = %d ve en kucuk elemanin indeksi = %d\n", *pmin, pmin - ar);

    // AÅŸaÄŸÄ±daki basit 'durum makinesi' hangi adresin daha Ã¶nce olmasÄ±na gÃ¶re farklÄ± deÄŸerleri ile 'print_array' fonksiyon Ã§aÄŸrÄ±sÄ±nÄ±n yapÄ±lmasÄ±nÄ± saÄŸlamaktadÄ±r.
    if(pmin < pmax){
        print_array(pmin, pmax - pmin + 1);
    }
    else{
        print_array(pmax, pmin - pmax + 1);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda oluÅŸturulan dizideki en bÃ¼yÃ¼k ve en kÃ¼Ã§Ã¼k sayÄ±lar tespit edilip eÄŸer bÃ¼yÃ¼k sayÄ±nÄ±n indisi kÃ¼Ã§Ã¼k sayÄ±dan kÃ¼Ã§Ã¼kse takas ediliyor ve sonrasÄ±nda kÃ¼Ã§Ã¼k indisten bÃ¼yÃ¼k indise kadarlÄ±k kapalÄ± aralÄ±ktaki tÃ¼m dizi elemanlarÄ± standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderiliyor.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 20

int* get_array_max(const int* ptr, int size)
{
    const int* pmax = ptr;

    for(int i = 0; i < size; ++i){
        if(ptr[i] > *pmax){
            // pmax = &ptr[0];
            pmax = ptr + i; // Pointer aritmetiÄŸi ile dizinin i. elemanÄ±nÄ±n adresi 'pmax' gÃ¶stericisine yeni deÄŸeri atanÄ±yor.
        }
    }

    return (int*)pmax; // Buradaki casting iÅŸlemi 'const cast' olarak adlandÄ±rÄ±lmaktadÄ±r.
}

int* get_array_min(const int* ptr, int size)
{
    const int* pmin = ptr;

    for(int i = 0; i < size; ++i){
        if(ptr[i] < *pmin){
            // pmin = &ptr[0];
            pmin = ptr + i; // Pointer aritmetiÄŸi ile dizinin i. elemanÄ±nÄ±n adresi 'pmin' gÃ¶stericisine yeni deÄŸeri atanÄ±yor.
        }
    }

    return (int*)pmin; // Buradaki casting iÅŸlemi 'const cast' olarak adlandÄ±rÄ±lmaktadÄ±r.
}

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    int* pmax = get_array_max(ar, SIZE);
    int* pmin = get_array_min(ar, SIZE);

    printf("max = %d ve en buyuk elemanin indeksi = %d\n", *pmax, pmax - ar);
    printf("min = %d ve en kucuk elemanin indeksi = %d\n", *pmin, pmin - ar);

    // En kÃ¼Ã§Ã¼k elemanÄ±n indeks deÄŸeri en bÃ¼yÃ¼k elemandan daha bÃ¼yÃ¼kse iki gÃ¶stericinin deÄŸeri takas ediliyor.
    if(pmin > pmax){
        int* temp = pmin;
        pmin = pmax;
        pmax = temp;
    }

    // En bÃ¼yÃ¼k ve ne kÃ¼Ã§Ã¼k elemanlar arasÄ±ndaki dizi elemanlarÄ± yazdÄ±rÄ±lÄ±yor.
    while(pmin <= pmax){
        printf("%3d ", *pmin++); // Buradaki '*pmin++' ifadesi C idiyomudur.
    }
}
```


ğŸ§  Veri yapÄ±larÄ± ve algoritmalar konusunda ilk Ã¶ÄŸrenilen sÄ±ralama algoritmalarÄ± basit oldukalrÄ± iÃ§in "**bubble sort**", "**selection sort**" ve "**insertion sort**" algoritmalarÄ±dÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programdan bir dizideki elemanlarÄ±n sÄ±ralanmasÄ±nÄ±n **selection sort** ile nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "nutility.h"

#define SIZE 20

int* get_array_min(const int* ptr, int size)
{
    // Buradaki 'pmin' nesnesi 'otomatik storage duration'dÄ±r ama tuttuÄŸu deÄŸer fonksiyona gÃ¶nderilen dizinin en kÃ¼Ã§Ã¼k deÄŸeri olacaÄŸÄ± iÃ§in 
    // ve ilgili dizi bu fonksiyon dÄ±ÅŸÄ±nda var olan bir nesne olduÄŸu iÃ§in bu pointer deÄŸiÅŸkenin deÄŸeri oln adresin bu fonksiyondan geriye dÃ¶ndÃ¼rÃ¼lmesi yanlÄ±ÅŸ bir iÅŸlem deÄŸildir.
    const int* pmin = ptr;

    for(int i = 0; i < size; ++i){
        if(ptr[i] < *pmin){
            // pmin = &ptr[0];
            pmin = ptr + i; // Pointer aritmetiÄŸi ile dizinin i. elemanÄ±nÄ±n adresi 'pmin' gÃ¶stericisine yeni deÄŸeri atanÄ±yor.
        }
    }

    return (int*)pmin; // Buradaki casting iÅŸlemi 'const cast' olarak adlandÄ±rÄ±lmaktadÄ±r.
}

void selection_sort_v1(int* p, int size)
{
    for(int i = 0; i < size; ++i){
        swap(p + i, get_array_min(p + i, size - i));
    }
}

// AÅŸaÄŸÄ±daki fonksiyon 'selection sort' algoritmasÄ±na gÃ¶re diziyi sÄ±ralar ve geriye parametre olarak aldÄ±ÄŸÄ± dizinin adresini dÃ¶ndÃ¼rÃ¼r, bu ÅŸekilde bu fonksiyonu Ã§aÄŸÄ±ran kod buradan dÃ¶nen adresi kullanabileceÄŸi statement'lar yazabilir.
int* selection_sort_v2(int* p, int size)
{
    for(int i = 0; i < size; ++i){
        swap(p + i, get_array_min(p + i, size - i));
    }

    return p;
}

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    // Dizinin geriye deÄŸer dÃ¶ndÃ¼rmeyen 'selection_sort_v1' fonksiyonu ile sÄ±ralanÄ±p ardÄ±ndan standart Ã§Ä±ktÄ± akÄ±mÄ±na verilmesi iÅŸlemi yapÄ±lÄ±yor.
    selection_sort_v1(ar, SIZE);
    print_array(ar, SIZE);

    // 'ar' dizisi yeniden rastgele deÄŸerler ile doldurulduktan sonra geriye dizinin ilk elemanÄ±nÄ±n adresini dÃ¶ndÃ¼ren 'selection_sort_v2' fonksiyonu ile sÄ±ralanÄ±p ardÄ±ndan standart Ã§Ä±ktÄ± akÄ±mÄ±na verilmesi iÅŸlemi yapÄ±lÄ±yor.    
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    print_array(selection_sort_v2(ar, SIZE), SIZE);
}
```



Bir dizi Ã¼zerinde aÅŸaÄŸÄ±daki iÅŸlemler yapÄ±ldÄ±ÄŸÄ±nda;
- O diziyi deÄŸiÅŸtirmeye yÃ¶nelik bir iÅŸlem yapan fonksiyon.
- O diziye deÄŸer yerleÅŸtirmeye yÃ¶nelik bir fonksiyon.
`void` fonksiyon olarak yazÄ±labildiÄŸi gibi adres dÃ¶ndÃ¼ren bir fonksiyon olarak da yazÄ±labilir, bunun iÃ§in fonksiyonun aldÄ±ÄŸÄ± adresi geriye dÃ¶ndÃ¼rmesi gerekir.


### NULL Pointer 

**Makro**: Ã–niÅŸlemci programa tanÄ±tÄ±lan adlardÄ±r, `#defined` Ã¶miÅŸlemci komutuyla Ã¶niÅŸlemci programa tanÄ±tÄ±lan adlardÄ±r.

BÃ¼yÃ¼k harf ile yazÄ±lan `NULL` bir **object like makro**'dur, bir **anahtar sÃ¶zcÃ¼k(keyword)** deÄŸildir, derleyici aÃ§Ä±sÄ±ndan bir **identifier(ad)** da deÄŸildir.

Bu makro C dilinin standart kÃ¼tÃ¼phenesinin bir Ã§ok standart baÅŸlÄ±k dosyasÄ±nda(headre file) tanÄ±mlanmÄ±ÅŸtÄ±r(definition). 

ğŸ§­ `NULL` makrosu ÅŸu **.h** dosyalarnda yer almaktadÄ±r; 
- `stdio.h`
- `stdlib.h`
- `stddef.h`
- `string.h`
- `time.h`



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `NULL` makrosu `stdio.h` dosyasÄ±nda tanÄ±mlandÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h> // Bu baÅŸlÄ±k dosyasÄ±nda 'NULL' makrosunun tanÄ±mÄ± mevcuttur.

int main(void)
{
    int* p = NULL;
}
```



â—â—â— C hakkÄ±nda ya da kod hakkÄ±nda konuÅŸurken `NULL` demek yerine "**NULL pointer**" demek daha doÄŸru olacaktÄ±r Ã§Ã¼nkÃ¼ dilde **null character**, **null statement** gibi terimler de var ve karÄ±ÅŸÄ±klÄ±k olasÄ±lÄ±ÄŸÄ± vardÄ±r.

â—â—â— `NULL` bir adres deÄŸeridir ve bir sabit ifadesidir bu nedenden dolayÄ± da "**NULL pointer**" olarak adlandÄ±rÄ±lmasÄ± doÄŸru olacaktÄ±r.




ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**NULL pointer**" kullanÄ±mÄ± incelenebilir.
```C
#include <time.h> // Bu baÅŸlÄ±k dosyasÄ±nda 'NULL' makrosunun tanÄ±mÄ± mevcuttur.

int main(void)
{
    // 'ip' ve 'dp' deÄŸiÅŸkenlerinin bildirimleri ve deÄŸer atama iÅŸlemleri legal ve doÄŸru kullanÄ±mlardÄ±r.
    int* ip = NULL;
    double* dp = NULL;

    ip = NULL;
    dp = NULL;

    // AÅŸaÄŸÄ±dali ÅŸekilde 'int' tÃ¼rÃ¼nden 'ival' deÄŸiÅŸkene 'NULL' deÄŸerinin atanmasÄ± hatalÄ±dÄ±r.
    int ival;
    ival = NULL; // Bu atama yanlÄ±ÅŸtÄ±r, C dilinin kontrol zafiyetleri buna izin verse de bu atama yapÄ±lmamalÄ±dÄ±r, C++ dili bu kÄ±sÄ±mda sÃ¶zdizim hatasÄ±(syntax error) verecektir.
}
```


â—â—â— **NULL pointer** herhangi bir pointer deÄŸiÅŸkene atanabilir, pointer olmayan deÄŸiÅŸkenlere `NULL` atanmasÄ±(C derleyicisi izin verse dahi) yanlÄ±ÅŸtÄ±r.

â—â—â— C ve C++ dillerinde **NULL pointer** makrosunun anlamÄ± diÄŸer dillerdeki **null**, **nil** gibi terimlerden farklÄ±dÄ±r, diÄŸer dillerin bazÄ±larÄ±nda bir deÄŸiÅŸkenin bir deÄŸeri var ya da bir deÄŸeri yok durumunu tutmak iÃ§in kullanÄ±labilir ama C ve C++ dillerinde `NULL` sadece pointer tÃ¼rÃ¼nden deÄŸiÅŸkenlerin sahip olabileceÄŸi bir deÄŸerdir.


â—â—â— C ve C++ dillerinde deÄŸeri **NULL pointer** olan bir pointer deÄŸiÅŸken hiÃ§bir nesneyi gÃ¶stermeyen ama geÃ§erli bir pointer deÄŸiÅŸkendir.


â—â—â— Bir pointer deÄŸiÅŸkenin birbirinden faklÄ± iki **durumu(state)** sÃ¶z konusudur(bunlar: "**Uninitialized state**", "**Null state**", "**Valid state**", "**Dangling state**". bunlarÄ± ben ekledim, derste o anda hepsinden bahsedilmedi); </br>
AÅŸaÄŸÄ±da bir gÃ¶stericinin "**ub**" oluÅŸturmayan durumlarÄ±(state) listelenmiÅŸtir; 
1. Bir **nesnenin(object)** adresini gÃ¶sterebilir.
    - Bir **nesneyi(object)** gÃ¶sterebilir.
    - Bir dizinin sonunu gÃ¶sterebilir(dizinin son elemanÄ±dan ).
2. **NULL pointer** olabilir(bu o pointer deÄŸiÅŸkenin hiÃ§bir nesneyi gÃ¶stermediÄŸi anlamÄ±na gelir).


â—â—â— **NULL pointer** deÄŸere sahip bir pointer deÄŸiÅŸkenin hiÃ§bir **nesnenin(object)** adresi olmadÄ±ÄŸÄ± iÃ§in o gÃ¶stericinin **dereferancing** iÅŸlemine tabi tutulmasÄ± **ub** durumuna neden olacaktÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **NULL pointer** kullanÄ±mÄ±yla ilgili bazÄ± durumlar incelenebilir.
```C
#include <stdio.h> // Bu baÅŸlÄ±k dosyasÄ±nda 'NULL' makrosunun tanÄ±mÄ± mevcuttur.

int main(void)
{
    int x = 10;
    int* p = &x;

    printf("%d\n", *p);

    p = NULL;
    int i = *p; // Burada 'ub' vardÄ±r Ã§Ã¼nkÃ¼ 'p' gÃ¶stericisinin deÄŸerine eriÅŸilmektedir.
}
```



ğŸ§  Kursta ÅŸu ana kadar Ã¶ÄŸrenilen C dilinin standardÄ±nda belirtilen **ub** durumlar aÅŸaÄŸÄ±daki gibidir;
- Bir tam sayÄ±nÄ±n 0'a bÃ¶lÃ¼nmesi iÅŸlemi.
- **Otomatic Ã¶mÃ¼rlÃ¼(otomatic storage duration)** bir deÄŸiÅŸkene ilk deÄŸer atamadan o deÄŸikeni **indetermined value(garbage value)** deÄŸeriyle bir fadede kullanmak.
- **Yan etkiye(side effect)** maruz kalmÄ±ÅŸ bir deÄŸiÅŸkeni **sequence point** noktasÄ±ndan Ã¶nce aynÄ± **ifade(expression)** iÃ§inde kullanÄ±lmasÄ±. `x = ++x;` deyimi(statement) C dilinde **ub** ama C++ dilinde **ub** deÄŸildir.
- Ä°ÅŸaretli tam sayÄ±larda taÅŸma durumlarÄ±.
- Bir makronun **undefined** yapÄ±lmadan birden fazla kez tanÄ±mlanmasÄ±.
- Bir **NULL pointer**'Ä±n dereference edilmesi(bu iÅŸlem `*` ya da `[]` operatÃ¶rleriyle yapÄ±labilir).



â—â—â— Ä°ki pointer deÄŸiÅŸkenin ikisinin de deÄŸeri **NULL pointer** ise eÅŸitlik karÅŸÄ±laÅŸtÄ±rmasÄ± **1(doÄŸru, true)** olarak sonuÃ§lanacaktÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bulunan **NULL pointer** eÅŸitlikleri incelenebilir.
```C
#include <stdio.h> // Bu baÅŸlÄ±k dosyasÄ±nda 'NULL' makrosunun tanÄ±mÄ± mevcuttur.

int main(void)
{
    int x = 10;
    int* p12 = &x;
    int* p12 = NULL;

    if(p21 == p12){
        printf("evet esit.\n");
    }
    else{
        printf("hayir esit degil.\n");
    }

    int* p21 = &x;
    int* p22 = &x;

    if(p21 == p22){
        printf("evet esit.\n");
    }
    else{
        printf("hayir esit degil.\n");
    }

    int* p31 = NULL;
    int* p32 = NULL;

    if(p31 == p32){
        printf("evet esit.\n");
    }
    else{
        printf("hayir esit degil.\n");
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **zero-nonzero** durumlarÄ±nÄ±n **locig true/false** olarak kullanÄ±lmalarÄ± incelenebilir.
```C
#include <stdio.h> // Bu baÅŸlÄ±k dosyasÄ±nda 'NULL' makrosunun tanÄ±mÄ± mevcuttur.

int main(void)
{
    int ival = 5;

    // 'if statement'Ä±n expression deÄŸeri olan ifade 'zero-nonzero' durumuna gÃ¶re 'locig true/false' olarak yorumlanmaktadÄ±r.

    // AÅŸÄŸÄ±daki iki 'if statement' aynÄ± anlama gelmektedir.
    //if(ival)
    //if(ival != 0)

    // AÅŸÄŸÄ±daki iki 'if statement' aynÄ± anlama gelmektedir.
    //if(ival == 0)
    //if(!ival)
}
```



ğŸ§  C ve C++ dillerinde Logic ifade beklenilen yerler aÅŸaÄŸÄ±daki gibidir;
- `!exp`
- `exp1 && exp2`
- `exp1 || exp2`
- `exp ?`
- `if(exp)`
- `while(exp)`
- `do while(exp);`
- `for(;exp;)`


ğŸ§  C ve C++ dillerinde lojik ifade beklenilen yerlerde herhangi bir adres deÄŸeri kullanÄ±labilir. 
- `if(ptr != NULL)` statement'Ä± yerine `if(ptr)` kullanÄ±labilir ve ikinci kullanÄ±m daha Ã§ok tercih edilmektedir.
- `if(ptr == NULL)` statement'Ä± yerine `if(!ptr)` kullanÄ±labilir ve ikinci kullanÄ±m daha Ã§ok tercih edilmektedir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `ptr` pointer deÄŸiÅŸkeninin **NULL pointer** olma durunu `NULL` makrosu kullanÄ±lmadan nasÄ±l yazÄ±labileceÄŸi incelenebilir.
```C
int* foo(void);

int main(void)
{
    int* ptr = foo();

    // AÅŸaÄŸÄ±daki gibi 'if statement expression' yazmak iÃ§in 'NULL' makrosunun tanÄ±mÄ±nÄ±n bilinmesi iÃ§in bu tanÄ±mÄ±n yer aldÄ±ÄŸÄ± bir baÅŸlÄ±k dosyasÄ±nÄ±n eklenmesi gerekiyor.
    if(ptr != NULL){

    }

    // AÅŸaÄŸÄ±daki gibi 'if statement expression' yazmak iÃ§in herhangi bir baÅŸlÄ±k dosyasÄ±nÄ±n eklenmesi gerekmiyor.
    if(ptr){

    }
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda `ptr` pointer deÄŸiÅŸkeninin **NULL pointer** olma durunu `NULL` makrosu kullanÄ±lmadan sÄ±nanmaktadÄ±r.
```C
int* foo(void);

int main(void)
{
    int* ptr = foo();

    // AÅŸaÄŸÄ±daki gibi 'if statement expression' yazmak iÃ§in 'NULL' makrosunun tanÄ±mÄ±nÄ±n alÄ±nabilmesi iÃ§in bu tanÄ±mÄ±n yer aldÄ±ÄŸÄ± bir baÅŸlÄ±k dosyasÄ±nÄ±n eklenmesi gerekiyor.
    if(ptr == NULL){

    }

    // AÅŸaÄŸÄ±daki gibi 'if statement expression' yazmak iÃ§in herhangi bir baÅŸlÄ±k dosyasÄ±nÄ±n eklenmesi gerekmiyor.
    if(!ptr){

    }
}
```


â—â—â— **NULL pointer** mantÄ±ksal(logic) aÃ§Ä±dan zero(false) olarak yorumlanÄ±r, bu Ã¶nemli bir bilgidir.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.41-11.01 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


â—â—â— **Statik Ã¶mÃ¼rlÃ¼** pointer deÄŸiÅŸkenlere ilk deÄŸer verilmediÄŸinde pointer deÄŸiÅŸkenin alacaÄŸÄ± ilk deÄŸer **NULL pointer** olur.


ğŸ‘‡ AÅŸaÄŸÄ±daki programdan global alanta bildirilen ve **block scope** alanÄ±nda bildirilen static deÄŸiÅŸkenlerin baÅŸlangÄ±Ã§ deÄŸerlerinin **NULL pointer** olacaÄŸÄ± incelenebilir.
```C
#include <stdio.h>

int* gp;

void foo(void)
{
    static double* dp;

    if(dp == NULL)
        printf("dp has NULL pointer value.\n");
}

int main(void)
{
    if(gp == NULL)
        printf("gp has NULL pointer value.\n");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda nasÄ±l ki tam sayÄ± dizilerinde ilk deÄŸer verirken sadece bazÄ± elemanlara ilk deÄŸer verildiÄŸinde geriye kalar dizi elemanlarÄ±nÄ±n ilk deÄŸerlerinin "0" olmasÄ± gibi pointer deÄŸiÅŸkenlerin dizilerinde bu durumdaki dizi elemanlarÄ±nÄ±n ilk deÄŸerleri **NULL pointer** olacaktÄ±r.
```C
#include <stdio.h>

int main(void)
{
    int ar[10] = { 1, 2, 3, 4 }; // Bir diziye ilk deÄŸer verildiÄŸinde 'initializer' sayÄ±sÄ± dizi boyutundan daha kÃ¼Ã§Ã¼kse ilk deÄŸer verilmeyen dizi elemanlarÄ±nÄ±n ilk deÄŸerleri '0' olacaktÄ±r.
    
    for(int i = 0; i < 10; ++,){
        printf("%d " ar[i]);
    }

    // ElamanlarÄ± pointer olan diziler aÅŸaÄŸÄ±dakine benzer ÅŸekilde oluÅŸturulabilir
    int x = 10, y = 20, z = 30;
    int* arp[10] = { &x, &y, &z };

    for(int i = 0; i < 10; ++,){
        if(arp[i] == NULL)
            printf("%d. elaman NULL pointer'dÄ±r. " i);
        else
            printf("%d " arp[i]);
    }
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir tam sayÄ± deÄŸiÅŸkenin deÄŸerinin bir pointer deÄŸiÅŸkene atanmasÄ± iÅŸlemi incelenebilir, bu atama mantÄ±ken doÄŸru deÄŸildir ve yapÄ±lmamalÄ±dÄ±r.
```C
#include <stdio.h>

int main(void)
{
    int x = 8700;
    int* ptr;

    ptr = x; // Bu atama iÅŸlemi C dilinde legal ama semantic olarak doÄŸru deÄŸildir, C++ dilinde sÃ¶zdizim hatasÄ±(syntax error).
    ptr = 46; // Bu atama iÅŸlemi C dilinde legal ama semantic olarak doÄŸru deÄŸildir, C++ dilinde sÃ¶zdizim hatasÄ±(syntax error).
}
```


â—â—â— C dilinde `int* ptr = NULL;` ile `int* ptr = 0;` aynÄ± anlama gelmektedir ama bu "0" deÄŸeri(deÄŸeri "0" olan bir ifade deÄŸil doÄŸrudan "0" deÄŸeri) atanan pointer deÄŸiÅŸkenin "0" adresini gÃ¶sterdiÄŸi anlamÄ±na gelebilir ya da gelmeyebilir bu derleyiciye baÄŸlÄ±dÄ±r, eÄŸer derleyici bir gÃ¶stericiye "0" deÄŸerinin atanmasÄ± iÅŸlemini bu gÃ¶stericiye **NULL** atamasÄ± yapÄ±lacak ÅŸekilde yorumluyorsa bu **NULL pointer conversion** olarak adlandÄ±rÄ±lÄ±r.

â—â—â— C dilinde **NULL pointer** deÄŸer atanacak olan gÃ¶sterici deÄŸiÅŸkenlere bu iÅŸlemin aÃ§Ä±k ÅŸekilde `NULL` makrosuyla deÄŸer atanmasÄ± daha doÄŸrudur.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "0" sabitinin **NULL pointer** olarak kullanÄ±lmasÄ± incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int* ptr = 0; // Burada derleyicinin yaptÄ±ÄŸÄ± dÃ¶nÃ¼ÅŸÃ¼me 'NULL pointer conversion' denilmektedir.
    int* ptr2 = NULL;

    // AÅŸaÄŸÄ±daki iki atama iÅŸlemi de aynÄ± anlama gelmektedir.
    ptr = 0; // 'NULL pointer conversion'
    ptr = NULL;
}
```


> â” 
> 
> Sorulan soru;
> 
> Peki deÄŸer olarak ile adres olarak null pointer a eÅŸitlemek aynÄ±ysa bir deÄŸiÅŸkenin adresini NULL pointera eÅŸitledikten sonra o deÄŸiÅŸkene sonradan farklÄ± bir deÄŸer tanÄ±mlayabiliriz o zaman deÄŸil mi ?
> 
> Cevap;
> 
> "Bir deÄŸiÅŸkeni bir deÄŸere eÅŸitlemek" doÄŸru bir ifade ÅŸekli deÄŸildir, bunun yerine "bir deÄŸiÅŸkene bir deÄŸeri atamak" ÅŸeklinde ifade edilmelidir.
> 
> ğŸ‘‡ AÅŸaÄŸÄ±daki programda hayatÄ±na **NULL pointer** olarak baÅŸlayan bir pointer'Ä±n tuttuÄŸu deÄŸer sonradan deÄŸiÅŸtirilebildiÄŸi incelenebilir.
> ```C
> #include <stdio.h>
> 
> int main(void)
> {
>     int* ptr = NULL;
>     int i = 10;
> 
>     ptr = &i;
> }
> ```


#### NULL Pointer KullanÄ±lan Durumlar 


ğŸ§  **NULL Pointer Conversion**: Bir fonksiyon bir iÅŸi yaptÄ±ktan sonra geriye bir adres deÄŸeri dÃ¶nÃ¼yor ama bazÄ± durumlarda yapmasÄ± gereken iÅŸi yapamÄ±yorsa bu durumda **NULL pointer** dÃ¶nÃ¼yorsa bu kullanÄ±mÄ± ifade etmek iÃ§in kullanÄ±lan terimdir.

`NULL` pointer kullanÄ±lan durumlar aÅŸaÄŸÄ±da listelenmiÅŸtir;
1. BazÄ± fonksiyonlar bir iÅŸ yapmayÄ± hedefler ve yaptÄ±klarÄ± iÅŸle ilgili olarak bir nesne adresi dÃ¶ndÃ¼rÃ¼rler ancak bÃ¶yle fonksiyonlarÄ±n yapmalarÄ± istenen iÅŸi yapamama ihtimalleri de olabilir(misalen dosya aÃ§an bir fonksiyon dosyayÄ± aÃ§amayabilir).

    
    ğŸ‘‡ AÅŸaÄŸÄ±daki programda kullanÄ±lan "fopen" fonksiyonu baÅŸarÄ±lÄ± olursa adres dÃ¶ndÃ¼rÃ¼yor baÅŸarÄ±sÄ±z olursa geriye **NULL Pointer** dÃ¶ndÃ¼rmektedir. 
    ```C
    #include <stdio.h>
    #include <stdlib.h>

    int main(void)
    {
        FILE* f = fopen("one_file.txt", "r");

        if(f != NULL)
            printf("dosya acildi.\n");
        else
            printf("dosya acilamadi.\n");
    }
    ```


    
    ğŸ‘‡ AÅŸaÄŸÄ±daki programda `malloc` fonksiyonu ile bellek ayrÄ±lÄ±yor eÄŸer iÅŸlem baÅŸarÄ±sÄ±z olursa bu fonksiyondan geriye **NULL pointer** deÄŸer dÃ¶necektir.
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include <stdlib.h>

    int main(void)
    {
        int n;

        printf("kac tam sayi: ");
        scanf("%d", &n);

        int* p = malloc(n * sizeof(int));

        if(!p){
            printf("bellek yetersiz");
            return 1;
        }
    }
    ```

2. C dilinde veri yapÄ±larÄ±nda **arama(search)** iÅŸlemi yapan fonksiyonlar genellikle adres dÃ¶ndÃ¼rÃ¼rler(geleneksel olarak ya da convernsiyonel olarak bu bÃ¶yledir). Aranan deÄŸer bulunursa o deÄŸere sahip olan deÄŸiÅŸkenin adresi dÃ¶ndÃ¼rÃ¼lÃ¼r, eÄŸer aranan eleman dizide yoksa **NULL Pointer** dÃ¶ndÃ¼rÃ¼lÃ¼r.

    C standardÄ±nÄ±n sahip olduÄŸu aÅŸaÄŸÄ±daki fonksiyonlar arama iÅŸlemi yapan fonksiyonlardÄ±r(bu fonksiyonlara Ã¶n bilgi edinilebilsin diye deÄŸinilmiÅŸtir);
    - `strchr`
    - `strrchr`
    - `strstr`
    - `strpbrk`
    - `memchr`


    
    ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir karakter dizisinde geÃ§en bir karakteri aramak iÃ§in kullanÄ±lan `strchr` fonksiyonunun kullanÄ±mÄ± incelenebilir.
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>

    int main(void)
    {
        char str[] = "bugun gunlerden pazar.";

        char* pchr = strchr(str, 'a');

        if(p){
            printf("bulundu idx = %d\n", pchr - str);
            *pchr = '!';
            puts(str);
        }
        else{
            printf("bulunamadi.\n");
        }
    }
    ```


    
    ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir karakter dizisinde geÃ§en bir karakteri aramak iÃ§in kullanÄ±lan kendi yazdÄ±ÄŸÄ±mÄ±z `search_in_array` fonksiyonunun gerÃ§ekleÅŸtirimi ve kullanÄ±mÄ± incelenebilir. `search_in_array` fonksiyonu kursta ilk yazdÄ±ÄŸÄ±mÄ±z **NULL Pointer Conversion** kullanÄ±mÄ± iÃ§eren fonksiyondur.
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include "nutility.h"

    #define SIZE 100

    // pa   : Arama yapÄ±lacan dizinin adresi(dizinin ilk elemanÄ±nÄ±n adresi)
    // size : Dizinin eleman sayÄ±sÄ±
    // key  : Dizine arama yapÄ±lacak olan deÄŸer
    int* search_in_array(const int* pa, int size, int key)
    {
        for(int i = 0; i < size; ++i){
            if(pa[i] == key)
                return (int*)(pa + i);
        }

        return NULL;
    }

    int main(void)
    {
        int a[SIZE];

        randomize();
        set_array_random(a, SIZE);
        print_array(a, SIZE);

        int val;

        printf("aranacak degeri giriniz: ");
        scanf("%d", &val);

        int* p = search_in_array(a, SIZE, val);

        if(p == NULL){
            printf("bulunamadi.\n");
        }
        else{
            printf("bulundu, dizinin %d indisli elemanidir.", p - a);
        }
    }
    ```

3. Ã–yle fonksiyonlar var ki, Ã§aÄŸÄ±ran koddan bir adres isterler ancak Ã§aÄŸÄ±ran kodun fonksiyona **NULL pointer** gÃ¶ndermesini bir seÃ§enek olarak verirler, bu tÃ¼r fonksiyonlar **NULL pointer** gÃ¶nderilince iÅŸlemi bir yÃ¶ntemle ama **NULL pointer** olmayan bir adres gÃ¶nderilirse baÅŸka bir yÃ¶ntemle iÅŸleyecek olabilir ya da o fonksiyona **NULL pointer** deÄŸer gÃ¶ndermek **ub** durumuna neden olabilir, bu durumun fonksiyonun dokÃ¼mantasyonunda aÃ§Ä±klanmasÄ± gerekiyor. 

    ğŸ‘‡ AÅŸaÄŸÄ±daki program pointer parametre alan bir fonksiyonun bu parametreyle ilgili olarak nasÄ±l dokÃ¼mante edilebileceÄŸiyle ilgili fikir edinilebilir.
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include "nutility.h"

    #define SIZE 100

    void foo(int* ptr, int size); // Buradaki gibi bir fonksiyon bildirildiÄŸinde fonksiyonun aldÄ±ÄŸÄ± pointer parametrelerin ne olmasÄ± gerektiÄŸi dokÃ¼mante edilmelidir.
    ```


Geri dÃ¶nÃ¼ÅŸ deÄŸeri bir adres olan bir fonksiyon oluÅŸturuluyorsa;
1. Fonksiyonun nasÄ±l bir ares dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼nÃ¼n belirtilmesi gerekir, bunun iÃ§in kodun dokÃ¼mante edilmesi gerekiyor, kodun dokÃ¼mante edileceÄŸi ilk yer kodun iÃ§erisinde bunu yapmaktÄ±r(bu konu bir derste daha kapsamlÄ± anlatÄ±lacakmÄ±ÅŸ).
    - static adres
    - Ã‡aÄŸÄ±ran koddan alÄ±nan adres
    - Dinamik Ã¶mÃ¼rlÃ¼ nesne adresi


ğŸ”­ Bir YZ aracÄ±na C dilinde yazÄ±lmÄ±ÅŸ bir kaynak dosya ile ÅŸu "AÅŸaÄŸÄ±daki kaynak dosyanÄ±n dokÃ¼mantasyonunu "**Doxygene**" adlÄ± programÄ±n formatÄ±nÄ± kullanarak oluÅŸturabilir misin?" girdi verilirse "**Doxygene**" formatÄ±nda dosyadaki fonksiyonlarÄ±n dokÃ¼mantasyonu hazÄ±rlanmÄ±ÅŸ olacaktÄ±r.


>â”
> 
> Sorulan soru; 
> 
> Dinamik Ã¶mÃ¼rlÃ¼ adres dÃ¶ndÃ¼rmesi anlamsal olarak mantÄ±klÄ± mÄ±?
> 
> Cevap;
> 
> Evet mantÄ±klÄ± ve bu tÃ¼rde adres gÃ¶nderen fonksiyonlar Ã§ok sÄ±k kullanÄ±lmaktadÄ±r. 


 BurayÄ± sonradan sil...
Dersi bÃ¶lmek istemedim. Arada cevap verirseniz sevinirim. Gelen "OCAK-2025 C KURSU Onay" mailinde 48 adet tarihte ders gÃ¶zÃ¼kÃ¼yor. Ramazan BayramÄ±ndan dolayÄ± 29-30 Mart'ta ders olmamÄ±ÅŸtÄ±. 7-8 Haziran'da Kurban BayramÄ± var. 22 Haziran'dan sonra gelen mail linki Ã¼zerinden giriÅŸ yapmaya devam edebilecekmiyiz? Yoksa yeni bir zoom eriÅŸim linklerimi gÃ¶nderilecek?


Ã–nemli bir durumdan dolayÄ± ikinci aradan sonra ders yapÄ±lmadÄ±, bir sonraki hafta telafi edileceÄŸi belirtildi.


## Typedef Declerations-1 (TÃ¼r EÅŸ AdÄ± Bildirimleri) Bu baÅŸlÄ±ÄŸa gelinemedi


Ders sonu ...
