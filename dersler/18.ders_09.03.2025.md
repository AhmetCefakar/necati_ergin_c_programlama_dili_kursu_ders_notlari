# 18.Ders 09.03.2025 ğŸ•˜

Derse 15(09:05)-21(09:17)-22(10:04)-24(10:28)-22(12:22)-23(12:43) kiÅŸi katÄ±ldÄ±.
---

## Preprocessor & Preprocessor Directives Continue(Ã–n-iÅŸlemci ve Ã–n-iÅŸlemci BuyruklarÄ± Devam)

MakrolarÄ±n adlarÄ± deÄŸiÅŸken adlandÄ±rma kurallarÄ±na uymak zorundadÄ±r.

### `#include` Komutu Devam

**Conditional Compiling(koÅŸullu derleme)**: BazÄ± koÅŸullara gÃ¶re Ã¶n-iÅŸlemci programa verilecek olan komutlarÄ±n dÃ¼zenlenmesi iÅŸlemleirne verilen addÄ±r, bu konuya sonradan detaylÄ± deÄŸinilecektir.


### `#define` Komutu 

C ve C++ dillerinde **#define** Ã¶n-iÅŸlemci komutu ile programa tanÄ±tÄ±lan varlÄ±klara **macro** denmektedir.</br>
**Makro**'lar C++ dilinde az kullanÄ±lmtadÄ±r ama C dilinde Ã§ok sÄ±k kullanÄ±lmaktadÄ±r.</br>
**Macro** terimi excel vb. baÅŸka yazÄ±lÄ±m ya da programlama dillerinde farklÄ± anlamda kullanÄ±labiliyor ama oralardaki **macro** terimi ile C ve C++ dillerindeki **macro** terimi tamamen farklÄ± anlama gelmektedir.</br>
C ve C++ dillerinde **#define** Ã¶n-iÅŸlemci komutu ile programa tanÄ±tÄ±lan **macro**'lar kodda kullanÄ±ldÄ±ÄŸÄ±nda **preprocessing** aÅŸamasÄ±nda iÅŸlenir ve bu tanÄ±mlamalarÄ± yer deÄŸiÅŸtirme iÅŸlemlerini yapÄ±p siler ve **translation unit** dosyasÄ±nÄ± oluÅŸturur.

â— Bir sÃ¶zcÃ¼ÄŸÃ¼n anahtar sÃ¶zcÃ¼k olabilmesi iÃ§in o sÃ¶zcÃ¼kleri derleyicinin gÃ¶rmesi gerekir, bu bilgiye gÃ¶re Ã¶n-iÅŸlemci programa veirlen komutlarÄ±n hiÃ§biri anahtar sÃ¶zcÃ¼k deÄŸildir.

â— **Preprocessing** programÄ± blok tanÄ±maz yani kaynak dosyadaki bloklarla ilgilenmez ve onlarÄ± gÃ¶rmezden gelir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã¶n-iÅŸlemci programÄ±n hangi durumlarda **object-like makro** token'larÄ± iÅŸleyeceÄŸi gÃ¶rÃ¼lebilir.
```C
#include <stdio.h>

#define MAX 100

void func()
{
    printf("MAX value."); // Buradaki 'string literal' varlÄ±k iÃ§inde geÃ§en 'MAX' yazÄ±sÄ±nÄ± Ã¶n-iÅŸlemci program dikkate almayacaktÄ±r!
}

int main(void)
{
    int x = MAKRO_1; // Buradaki 'MAKRO_1' adlÄ± varlÄ±ÄŸÄ±n ne olduÄŸu 'name lookup' aÅŸamsÄ±nda tespit edilemez Ã§Ã¼nkÃ¼ 'MAKRO_1' adlÄ± object-like makro bu satÄ±rdan sonra tanÄ±mlanÄ±yor.
}

#define MAKRO_1 200
```



ğŸ§  **#define** Ã¶n-iÅŸlemci komutlarÄ± hangi durumlarda **re-placement** iÅŸlemine tabi tutulmaz, bunun listesi aÅŸaÄŸÄ±daki gibidir; 
1. Makro tanÄ±mÄ±ndan Ã¶nceki kullanÄ±mlarda. 
2. BaÅŸka bir yazÄ±nÄ±n ya da identifier parÃ§asÄ±ysa.
3. BÃ¼tÃ¼k-kÃ¼Ã§Ã¼k harf uyumu yoksa.
4. Bir **string literal** iÃ§inde geÃ§en bir yazÄ±ysa.


â—C dilinde **indentifier(ad)**'lar kÃ¼Ã§Ã¼k harf yoÄŸun olarak adlandÄ±rÄ±lÄ±r. Macro adlarÄ± iÃ§in tÃ¼m harflerin bÃ¼yÃ¼k harf olarak kullanÄ±lmasÄ± genel bir kullanÄ±mdÄ±r. 

â—C dilinde kullanÄ±lan makro'lar gÃ¶rsel olarak programdaki diÄŸer Ã¶ÄŸelerden ayrÄ±ÅŸtÄ±rÄ±labilmesi iÃ§in **all-caps(tÃ¼m harfler bÃ¼yÃ¼k)** olarak adlandÄ±rÄ±lÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki program makro tanÄ±mlarÄ±nÄ±n en sade haliyle birden fazla ifadeden oluÅŸtuÄŸunda nasÄ±l iÅŸleneceÄŸini anlamak iÃ§in incelenebilir. 
```C
#include <stdio.h>

#define MAX 1000
#define MAX2 100 + 200

int main(void)
{
    int x = 3 * MAX2; // Ã–n-iÅŸlemci program bu statement'Ä± 'int x = 3 * 100 + 200;' olarak deÄŸiÅŸtirecektir.

    printf("x = %d\n", x); // Burada konsola 'x = 500' yazacaktÄ±r.
    
    return 0;  
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program bir makro deÄŸeri olarak **string literal** kullanÄ±mÄ± incelenebilir.
```C
#include <stdio.h>

#define ERROR "insufficient memory"

int main(void)
{
    printf(ERROR); // Burada konsola 'insufficient memory' yazacaktÄ±r.
}
```


â— Makrolar Ã§oÄŸunlukla tek satÄ±rda yazÄ±lÄ±r fakat `\` karakteri kullanarak birden fazla satÄ±ra yayÄ±lan makro tanÄ±mÄ± yapÄ±labilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki program bir makro deÄŸerinin birden fazla satÄ±ra yayÄ±lacak ÅŸekilde nasÄ±l yazÄ±labileceÄŸini anlamak iÃ§in incelenebilir. 
```C
#include <stdio.h>

#define MAX 100 + 200 \
+ 300 + 400 \
+ 800

int main(void)
{
    int x = MAX;
  
    printf("x = %d", x); // Burada konsola '1800' yazacaktÄ±r.
}
```


[24:30:00]
ğŸ‘‡ AÅŸaÄŸÄ±daki program bir makro deÄŸerinin Ã¶ncelik paranteziyle nasÄ±l kullanÄ±ldÄ±ÄŸÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>

#define MAX (100 + 200)

int main(void)
{
    int x = 3 * MAX; // Ã–n-iÅŸlemci program bu statement'Ä± 'int x = 3 * (100 + 200);' olarak deÄŸiÅŸtirecektir.

    printf("x = %d\n", x); // Burada konsola 'x = 900' yazacaktÄ±r.
    
    return 0;  
}
```



âš ï¸ C dilini Ã¶ÄŸrenmeye yeni baÅŸlayanlarÄ±n sÄ±klÄ±kla yaptÄ±ÄŸÄ± yanlÄ±ÅŸ anlamalardan biri bir makroyu deÄŸiÅŸken zannetmesidir ama bu doÄŸru deÄŸil, makrolar bir deÄŸiÅŸken deÄŸildir ve Ã¶n-iÅŸlemci programÄ± tarafÄ±ndan deÄŸeriyle yer deÄŸiÅŸtirilir.


ğŸš€ **Symbolic constant** ya da **Manifest constant** terimleri makrolar ile kullanÄ±lan sabit deÄŸerlerin **re-plece(yer deÄŸiÅŸtirme)** iÅŸlemleriyle bir ÅŸeylerin yerine geÃ§melerine verilen terimlerdir ve bu makrolara **Object-like macro(Nesne benzeri makro)** denilebilir.

Makrolar temelde iki kategoriye ayrÄ±lÄ±r;
1. **Object-like macro(Nesne benzeri makro)**. Bu dersin konusu bu tÃ¼rden makro kullanÄ±mlarÄ±.
2. **Function-like macro(Fonksiyon benzeri makro)**. Bu kÄ±sÄ±m sonradan detaylÄ± iÅŸlenecek.

#### Object-like Macro(Nesne Benzeri Makro)



ğŸš€ MakrolarÄ±n en temel kullanÄ±m nedeni bir sabitle deÄŸiÅŸtirme iÅŸlemi yapmak iÃ§indir ve bu ÅŸekilde kullanÄ±lmaya **Symbolic constant** ya da **Manifest constant** denilmektedir.  

â— Programda Ã§ok kullanÄ±lan sabit bir deÄŸeri sÃ¼rekli kullanmaktansa ve o deÄŸerin neyi ifade ettiÄŸini kodu okuyana aÃ§Ä±k ÅŸekilde belirtebilmek iÃ§in o sabit deÄŸeri **Object-like macro** olarak kullanabiliriz ve bu Ã§oÄŸunlukla tercih edilmektedir.



ğŸ‘‡ AÅŸaÄŸÄ±daki program **object-like macro(nesne benzeri makro)** bir varlÄ±ÄŸÄ±n neden **L-value** operatÃ¶r alan bir operatÃ¶rÃ¼n operandÄ± olamayacaÄŸÄ± incelenebilir.
```C
#include <stdio.h>

#define ARRAY_SIZE 370

int main(void)
{
    ++ARRAY_SIZE; // Bu kod satÄ±rÄ±nÄ± Ã¶n-iÅŸlemci program '++370;' olarak deÄŸiÅŸtirecektir ve '++' operatÃ¶rÃ¼ operand olarak 'R-value' Ã¶zellikteki '370' varlÄ±ÄŸÄ±nÄ± alamayacaÄŸÄ± iÃ§in sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program **Symbolic constant** makro kullanÄ±mÄ±nÄ±n nasÄ±l olabileceÄŸiyle ilgilidir, pi sayÄ±sÄ±nÄ±n virgÃ¼lden sonraki beÅŸ basamaÄŸÄ±nÄ± kapsayan ondalÄ±klÄ± bir sayÄ±dÄ±r.
```C
#include <stdio.h>

#define PI (3.14159)

int main(void)
{
    double pi = PI;
    int y = 1;
    
    printf("x = %lf\n", x);
    
    return 0;  
}
```

â— Makro'lar Ã§oÄŸunlukla **.h** dosyalarÄ±nda tanÄ±mlanÄ±r ve programda **#include** komutu ile ilgili dosyaya dahil edilir.

â— Ã–zellikle **floating point number(bÃ¶lÃ¼mlÃ¼ yazÄ±lan sayÄ±lar)** deÄŸerlerini tutarken makrolarÄ±n kullanÄ±lmasÄ± sÄ±k baÅŸvurulan bir yÃ¶ntemdir.

ğŸ§  **Object-like macro** kullanÄ±mÄ±nÄ±n aÅŸaÄŸÄ±daki faydalarÄ± vardÄ±r;
1. Sabitleri kodu okuyanÄ± bilgilendirebilecek ÅŸekilde tanÄ±mlamÄ±ÅŸ oluyoruz.
2. Sabitlerin doÄŸrudan kendisini defalarca kullanmak hen yazÄ±mda bazÄ± yerlerde yanlÄ±ÅŸ yazma ihtimali vardÄ±r hem de aynÄ± sabit deÄŸer defalarca yazÄ±lmÄ±ÅŸ olacaktÄ±r bu da kodun bakÄ±mÄ±nÄ± zorlaÅŸtÄ±racaktÄ±r. 



C dilinin standardÄ±ndaki kÃ¼tÃ¼phaneler ya da Ã¼Ã§Ã¼ncÃ¼ taraf kÃ¼tÃ¼phaneler koda dahil edildiÄŸinde bazÄ± **Object-like macro** tanÄ±mlamalarÄ±nÄ±n geldiÄŸi gÃ¶rÃ¼lecektir, **Symbolic constant** kullanÄ±mÄ±nÄ±n tipik nedenleri aÅŸaÄŸÄ±daki gibidir;
1. **Enumeration** olarak kullanÄ±lmasÄ±. Mesela programda "0: On, 1: Off, 2: StandBy, 3: Hold" deÄŸerleri makro olarak tutulabilir. Bu kullanÄ±m gÃ¶mÃ¼lÃ¼ yazÄ±lÄ±mlarda ve sistem programlama tarafÄ±nda yoÄŸunlukla kullanÄ±lmaktadÄ±r.
2. Program genelinde kullanÄ±lacak olan sabit deÄŸerleri bir Ã§ok yerde kullanmadan makro olarak tek bir yerde tanÄ±mlayÄ±p deÄŸeri tek bir yerden yÃ¶netmek iÃ§in.


 
C diline yeni baÅŸlayanlar `int` tÃ¼rÃ¼nÃ¼ idrak etmekte zorlanÄ±rlar, bunun nedeni bu tÃ¼rÃ¼n dÃ¶rt farklÄ± ÅŸekilde yaygÄ±n olarak kullanÄ±lmasÄ±dÄ±r, bunlar;
1. Tam sayÄ±larÄ± tutmak iÃ§in doÄŸal tÃ¼rdÃ¼r.
2. **MantÄ±ksal(Logic)** tÃ¼rÃ¼ olarak **doÄŸru(true)/yanlÄ±ÅŸ(false)** ÅŸeklinde **zero(false)/non-zero(true)** olarak kullanÄ±lmasÄ±.
3. `int` tÃ¼rÃ¼nÃ¼n enumeration olarak kullanÄ±ldÄ±ÄŸÄ± durumlar iÃ§in **Object-like macro** olarak kullanÄ±ldÄ±ÄŸÄ± durumlar, mesela font deÄŸerini tutmak iÃ§in `#include FONT 13` ÅŸeklinde bir makro tanÄ±mlanabilir ve bu ÅŸekilde programda `FONT` adÄ± geÃ§en her yerde ne anlama geldiÄŸi kodu okuyunca anlaÅŸÄ±lacaktÄ±r. Bu kullanÄ±m gÃ¶mÃ¼lÃ¼ yazÄ±lÄ±mlarda ve sistem programlama tarafÄ±nda yoÄŸunlukla kullanÄ±lmaktadÄ±r.
4. **TaÅŸÄ±nabilirlik(portability)** saÄŸlamak iÃ§in kullanÄ±lÄ±r. Ã–yle sabitler var ki bizim kodda o sabitleri kullanmamÄ±z gerekiyor fakat o sabitler o programÄ±n Ã§alÄ±ÅŸacaÄŸÄ± iÅŸletim sistemine gÃ¶re ya da donanÄ±ma gÃ¶re ya da baÅŸka bir nedenden derleyicien derleyiciye farklÄ± olabiliyor, bu durumda standart kÃ¼tÃ¼phane ya da Ã¼Ã§Ã¼ncÃ¼ taraf kÃ¼tÃ¼phane sabitin kendisinin kullanÄ±lmasÄ± yerine bir sembolik sabit sunuyor. Mesela C dilinin standard kÃ¼tÃ¼phanesinin "stdlib.h" baÅŸlÄ±k dosyasÄ±nda bulunun `RAND_MAX` **object-like makro**'su rastgele sayÄ± Ã¼reten `rand()` fonksiyonunun Ã¼rete bileceÄŸi en bÃ¼yÃ¼k tam sayÄ± deÄŸerini belirlemektedir, bu deÄŸer farklÄ± derleyicilerde farklÄ± olabilir. Bu ÅŸekilde hem kodun okunmasÄ± kolaylaÅŸÄ±yor hem de kodun taÅŸÄ±nabilirliÄŸi saÄŸlanÄ±yor.


 
ğŸ‘‡ AÅŸaÄŸÄ±daki program `limits.h` baÅŸlÄ±k dosyasÄ±nda bulunan `INT_MAX`, `LONG_MAX`, `LONG_MIN`, `UINT_MAX` gibi deÄŸerlerin nasÄ±l kullanÄ±lacaÄŸÄ±nÄ± anlamak iÃ§in incelenebilir. `limits.h` baÅŸlÄ±k dosyasÄ±nda bulunan `CHAR_BIT` makrosu derleyici iÃ§in bir byte'ta kaÃ§ bit bulunacaÄŸÄ± bilgisi yeralmaktadÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h> // Bu head dosyasÄ±nda 'INT_MAX' vb. gibi makrolar yer alÄ±yor. 

int main(void)
{
    // Ä°ÅŸaretli int tÃ¼rÃ¼nÃ¼n alabileceÄŸi en bÃ¼yÃ¼k deÄŸer kullanÄ±lan derleyiciye ve programÄ±n Ã¼zerinde Ã§alÄ±ÅŸacaÄŸÄ± donanÄ±m sistemine gÃ¶re deÄŸiÅŸebilir, int bazen 4 byte bazen 2 beyte vb. olabilir.
    int max = 2147483647; 

    int max = INT_MAX; // Bu ÅŸekilde kullanmak programÄ±n taÅŸÄ±nabilirliÄŸini saÄŸlar.
}
```


 
MÃ¼lakatlarda sorulan bir soru: `limits.h` baÅŸlÄ±k dosyasÄ±ndaki `#define INT_MIN (-2147483647 -1)` makrosu neden bu ÅŸeklinde yazÄ±lÄ±yor? </br>
"-2147483648" sabitinin deÄŸeri "2147483648" ve bu deÄŸer int tÃ¼rÃ¼nÃ¼n sÄ±nÄ±rÄ±nÄ± aÅŸtÄ±ÄŸÄ± iÃ§in "(-2147483647 -1)" ÅŸeklinde kullanÄ±lmaktadÄ±r.



ğŸ§  **Object-like macro** kullanÄ±mÄ±nÄ±n nedenleri aÅŸaÄŸÄ±daki gibi gruplanabilir;
1. Sabitleri anlamlandÄ±rmak.
2. YazÄ±m hatalarÄ±nÄ± engellemek.
3. NumaralandÄ±rma deÄŸeri olarak kullanmak(Enumeration).
4. TaÅŸÄ±nabilirlik saÄŸlamak.
5. Kodda birden fazla yerde kullanÄ±lmasÄ± gereken sabit bir deÄŸerin deÄŸeri deÄŸiÅŸtirileceÄŸi zaman tek bir yerde deÄŸiÅŸtirilip her yerde deÄŸerinin deÄŸiÅŸtirilmesini saÄŸlamak iÃ§in kullanmak.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir **object-like makro**'nun nasÄ±l birden fazla yerde kullanÄ±lacak sabr bir deÄŸer iÃ§in kullanÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#define ARRAY_SIZE 150

int main(void)
{
    /*
    // Zahmetli kullanÄ±m.

    int ary[100];

    int i;

    for(i = 0; i < 100; ++i){
        // sme code here...
    }

    if(i == 100){
        // sme code here...
    }
    */

    // YukarÄ±daki kodlar aÅŸaÄŸÄ±daki gibi kullanÄ±lÄ±rsa dizi boyutu deÄŸeri tek bir yerden deÄŸiÅŸtirilebilir durumda olacaktÄ±r.
    int ary[ARRAY_SIZE];
    int i;

    for(i = 0; i < ARRAY_SIZE; ++i){
        // sme code here...
    }

    if(i == ARRAY_SIZE){
        // sme code here...
    }
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.30-10.51 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


ğŸ‘‡ AÅŸaÄŸÄ±daki programda "SIZE" makrosunun `#undef` kullanmadan iki defa tanÄ±mlanmasÄ±nÄ±n "**ub**" durumuna neden oluÅŸu incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>

#define SIZE 100

int main(void)
{
    #define SIZE 500

}
```

âš ï¸ Makrolar global alan ya da herhangi bir block scope iÃ§erisine yazÄ±labilir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda "SIZE" makrosu iki defa tanÄ±mlanmaktadÄ±r ve bu ÅŸekilde kullanÄ±m doÄŸrudur. Buradaki kodlama konuyu anlamak iÃ§in yazÄ±lmÄ±ÅŸtÄ±r, Ã¼retimde bÃ¶yle kodlama yapÄ±lmamalÄ±dÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>

#define SIZE 100

int main(void)
{
    #undef SIZE
    #define SIZE 500

}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda kullanÄ±lan `NULL` varlÄ±ÄŸÄ± `stdio.h` dosyasÄ±nda tanÄ±mlanmÄ±ÅŸ bir makro'dur.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int* ptr = NULL; // Burada 'NULL' makrosu kullanÄ±lmÄ±ÅŸtÄ±r.

}
```


 
ğŸ‘‡ AÅŸaÄŸÄ±daki program bir makro iÃ§inde baÅŸka makro tanÄ±mlamalarÄ±nÄ±n nasÄ±l kullanabileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <limits.h>

#define MIN 100
#define MAX 500
#define AVE ((MIN + MAX) / 2)

int main(void)
{
    int x = AVE; // Buradaki makro aÃ§Ä±lÄ±mÄ± '((100 + 500) / 2)' ÅŸeklinde olacaktÄ±r.
}
```

## Function-like Makro(Functional Makro) 

Bu ÅŸekilde oluÅŸturulan makrolar tipik olarak bir fonksiyona alternatif olarak kullanÄ±lÄ±yor.

â— **Function-like makro** olmasÄ± iÃ§in makro adÄ±ndan sonra boÅŸluk olmadan parantez kullanÄ±lmasÄ± gerekiyor diÄŸer tÃ¼rlÃ¼ makro **Object-like macro** olarak yorumlanacaktÄ±r. Mesela `#define SEQUARE (a) ((a) * (a))` tanÄ±mlamasÄ± her "SEQUARE" gÃ¶rÃ¼len yere `(a) ((a) * (a))` yazÄ±lmasÄ± anlamÄ±na geliyor.

ğŸ“Œ **#define _CRT_SECURE_NO_WARNINGS** makrosu VS-C derleyicisine Ã¶zeldir, bu makro **conditional compiling(koÅŸullu derlemeyle)** ilgilidir(bu konu henÃ¼z iÅŸlenmedi), bu makro ile uyarÄ± mesajlarÄ±nÄ±n alÄ±nmamasÄ± saÄŸlanÄ±yor. Makro'larÄ±n tek kullanÄ±m amacÄ± **replacement text** iÅŸlemi deÄŸildir ve bu makrolar **conditional compiling(koÅŸullu derlemeyle)** ile ilgilidir, bu kullanÄ±m sonradan iÅŸlenecektir.



ğŸ‘‡ AÅŸaÄŸÄ±daki program **function-like makro** kullanÄ±mÄ±nÄ± anlamak iÃ§in incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

# define MAX(a, b)   ((a) > (b)) ? (a) : (b))
# define SEQUARE(a)  ((a) * (a))
# define SEQUARE2 (a)  ((a) * (a)) // EÄŸer bu ÅŸekilde makro kullanÄ±lÄ±rsa sÃ¶zdizim hatasÄ±(syntax error) oluÅŸacaktÄ±r Ã§Ã¼nkÃ¼ 'SEQUARE2' geÃ§en yerler '(a) ((a) * (a))' olarak deÄŸiÅŸtirilecektir.

int main(void)
{
    int x1 = 6;
    int y1 = SEQUARE(x1); // Buradaki statement Ã¶n-iÅŸlemci program Ã§alÄ±ÅŸtÄ±ktan sonra 'int y1 = ((x1) * (x1));' haline gelecektir.

    int y2 = SEQUARE2(x1); // Buradaki statement Ã¶n-iÅŸlemci program Ã§alÄ±ÅŸtÄ±ktan sonra 'int y2 = (a)  ((a) * (a))(x1);' haline gelecektir.
    
    
    int x, y;
    
    print("iki sayi giriniz");
    scanf("%d%d", &x, &y);

    int max = MAX(x, y);  // Buradaki statement Ã¶n-iÅŸlemci program Ã§alÄ±ÅŸtÄ±ktan sonra 'int max = ((x) > (y)) ? (x) : (y));' haline gelecektir.
}
```



â—**Function-like makro** kullanÄ±mlarÄ± fonksiyon kullanÄ±mlarÄ±nÄ±n muadilleridir ve burada erken olarak ÅŸu soru akla gelecektir "Neden fonksiyon kullanmak yerine **Function-like makro** kullanalÄ±m?" ama bu konuya ileride deÄŸinilecek.



âš ï¸ **Function-like makro** kullanÄ±ldÄ±ÄŸÄ±nda makrodaki her **ifade(expression)** paranteze alÄ±narak kullanÄ±lmalÄ±dÄ±r, aÅŸaÄŸÄ±daki programdan bu durum incelenebilir, bu program Ã§alÄ±ÅŸtÄ±rÄ±larak incelenmelidir yoksa muhtemelen pek bir ÅŸey anlaÅŸÄ±lmayacaktÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

#define SEQUARE1(a)  a * a
#define SEQUARE2(a)  (a) * (a)
#define SEQUARE3(a)  ((a) * (a))

int main(void)
{
    int x = 5;
    
    int y11 = SEQUARE1(x);
    int y12 = SEQUARE1(x + 1);
    int y13 = 100 / SEQUARE1(x); 

    printf("y11 = %d\n y12 = %d\n y13 = %d", y11, y12, y13);
    printf("~~~~~~~~~~~~~~~~~~");

    
    int y21 = SEQUARE2(x);
    int y22 = SEQUARE2(x + 1);
    int y23 = 100 / SEQUARE2(x); 

    printf("y21 = %d\n y22 = %d\n y23 = %d", y21, y22, y23);
    printf("~~~~~~~~~~~~~~~~~~");

    
    int y31 = SEQUARE3(x);
    int y32 = SEQUARE3(x + 1);
    int y33 = 100 / SEQUARE3(x); 

    printf("y31 = %d\n y32 = %d\n y33 = %d", y31, y32, y33);
    printf("~~~~~~~~~~~~~~~~~~");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program **function-like makro** kullanÄ±mÄ±nda parametre almayan kullanÄ±mlarÄ±nÄ±n da yapÄ±labiliyor olduÄŸunu anlamak iÃ§in incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <time.h>

#define PRINT_NAME() printf("Name Surname")
#define PRINT_NAME printf("Name Surname") // Bu ÅŸekilde de makro tanÄ±mlanabilir ama bu durumda 'object-like makro' bildirimi yapÄ±lmÄ±ÅŸ oluyor, bÃ¶yle de olur ama kodu okuyana bir fonksiyonun yerine tercih edilen bir kullanÄ±m olduÄŸu bilgisi verilememiÅŸ olur.

#define RANDOMIZE() srand((unsigned)time(0))

int main(void)
{
    PRINT_NAME();

    PRINT_NAME;

    int x = RANDOMIZE();
    
    printf("x = %d", x);  
}
```



Bir makronun sonunda `;` karakterinin kullanÄ±lmasÄ± Ã¼Ã§ farklÄ± durum oluÅŸturabilir;
1. Null statement olarak Ã§ok Ã¶nemli olmayan bir durum oluÅŸturabilir.
2. **SÃ¶zdizim hatasÄ±(syntax error)** oluÅŸturabilir.
3. En kÃ¶tÃ¼ durum ise **sÃ¶zdizim hatasÄ±(syntax error)** oluÅŸmaz ve kodun anlamÄ± deÄŸiÅŸir, bu durumu tespit etmek projenin bÃ¼yÃ¼klÃ¼ÄŸÃ¼ne gÃ¶re zor olabilir.


ğŸ‘‡ AÅŸaÄŸÄ±daki program bir makronun sonunda ";" token'Ä± eklenince ne gibi durumlar oluÅŸuyor onu anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define SIZE 100;

int main(void)
{
    int x1 = SIZE; // Buradaki statement Ã¶n-iÅŸlemci program Ã§alÄ±ÅŸtÄ±ktan sonra 'int x1 = 100;;' haline gelecektir, burada Null statement vardÄ±r.
    int y1 = 100;

    printf("x1 = %d", x1);
    

    // Buradaki 'if statement Ã¶n-iÅŸlemci' program Ã§alÄ±ÅŸtÄ±ktan sonra   'if(y1 = 100;)' ÅŸeklinde yorumlanÄ±r, burada sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.
    if(y1 = SIZE){
        printf("x1 = %d", x1);
    }
    
    int x2 = 10;
    int y2 = 20;
    
    SWAP(x, y);
}
```


â”
MÃ¼lakatlarda sÄ±k sorulan bir soru;
- Ä°ki tam sayÄ±nÄ±n deÄŸerini **takas eden(swap)** bir makro oluÅŸturunuz?
- ğŸ‘‡ AÅŸaÄŸÄ±daki programda sorunun Ã§Ã¶zÃ¼mÃ¼ incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define SWAP1(a, b) {int temp = a; a = b; b = temp;}

#define SWAP1(a, b) do{int temp = a; a = b; b = temp;}while(0)

int main(void)
{
    int x = 10;
    int y = 20;
    
    if(x > y)
        SWAP1(x, y); // Burada sÃ¶zdizim hatasÄ±(syntax error) oluÅŸacaktÄ±r Ã§Ã¼nkÃ¼ kÄ±vÄ±rcÄ±k parantezden sonra ';' token'Ä± ekleniyor bu da 'else' bloÄŸunun sÃ¶zdizimini(syntax) bozuyor.
    else
        ++x;
        
    printf("x = %d, y = %d\n", x, y);


    if(x > y)
        SWAP2(x, y); // Burada sÃ¶zdizim hatasÄ±(syntax error) oluÅŸmayacaktÄ±r.
    else
        ++y;
        
    printf("x = %d, y = %d\n", x, y);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program **function-like makro** kullanÄ±mÄ±nÄ±n nasÄ±l doÄŸru yÃ¶ntemle yazÄ±labileceÄŸiyle ilgili incelenebilir, makrodaki her deÄŸiÅŸken paranteze alÄ±nmalÄ±dÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX(x, y)     ((a) > (b)) ? (a) : (b))
#define ISUPPER(c)    ((c) >= 'A' && (c) <= 'Z')

int main(void)
{
    printf("bir karakter giriniz: ");
    int ch = getchar();

    if(ISUPPER(ch))
        printf("evet buyuk harf\n");
    else
        printf("hayir buyuk harf deÄŸil\n");
}
```


â— C mÃ¼lakatlarÄ±nda fonksiyon kullanÄ±mÄ±yla makro kullanÄ±mÄ±nÄ±n karÅŸÄ±laÅŸtÄ±rÄ±lmasÄ±yla ilgili sorular eÄŸer mÃ¼lakatÄ± yapan kiÅŸi yetkin biriyse mutlaka sorulacaktÄ±r. Her iki yapÄ± da birbirine gÃ¶re artÄ± ve eksilere sahiptir.


â— 
ğŸ‘‡ AÅŸaÄŸÄ±daki programda makro kullanÄ±mÄ±nda "**ub**" durumu oluÅŸacaktÄ±r, bu oluÅŸabilecek hatalar iÃ§in bazÄ± Ã¶nlemler alÄ±nabilir bu Ã¶nlemlere dersim ilerleyen kÄ±sÄ±mlarÄ±nda deÄŸinilecektir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define SQUARE(x)   ((x) * (x))

int foo();

int main(void)
{
    int x = 7;
    
    // Burada 'SQUARE' makrosunda aynÄ± ifade iki defa geÃ§iyor ve bu ifade '++' operatÃ¶rÃ¼ gibi yan etkisi olan bir operatÃ¶rle kullanÄ±ldÄ±ÄŸÄ±nda 
    // function-like makro '((x++) * (x++))' ÅŸeklinde bir ifade oluÅŸturacaktÄ±r ve bu ifade de yan etkiye maruz kalmÄ±ÅŸ bir nesne(object) yeniden kullanÄ±ldÄ±ÄŸÄ± iÃ§in 'ub' durumu oluÅŸur.
    int y1 = SQUARE(x++);

    printf("y1 = %d", y1);
    
    
    // AÅŸaÄŸÄ±daki statement'taki 'function-like makro' ÅŸu ÅŸekilde '((foo()) * (foo()))' replace edilir ve bu da eÄŸer 'foo' fonksiyonu 'pure-function' deÄŸilse ciddi hatalara neden olabilir.
    int y2 = SQUARE(foo());
    
    printf("y2 = %d", y2);
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.00-12.10 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***



â—**Function-like makro** kullanÄ±mlarÄ±nda makro parametresi eÄŸer makro iÃ§inde birden fazla defa kullanÄ±lÄ±yorsa ve makro parametresi side-effect Ã¶zelliÄŸi olan bir ifade ise bu **ub** sorununa neden oluyordu, bu durum iÃ§in aÅŸaÄŸÄ±daki gibi Ã§Ã¶zÃ¼mler uygulanabilir;

1. Ä°lk Ã§Ã¶zÃ¼m **function-like makro** tanÄ±mÄ±nda bir Ã¶nlem almayÄ±p sorumluluÄŸu makroyu Ã§aÄŸÄ±ran koda bÄ±rakmaktÄ±r ama bu yÃ¶ntem proje bir ekip olarak geliÅŸtiriliyorsa Ã¶nerilmez.

2. **Gcc** ve **Clang** gibi derleyicilerde **compiler extension** olarak **statement expression** desteÄŸi ile **function-like makro** kullanÄ±mlarÄ±ndaki en Ã¶nemli sorun iÃ§in Ã§Ã¶zÃ¼m saÄŸlÄ±yor.

    `({ statements; })` ÅŸeklindeki kullanÄ±m **statement expression** kullanÄ±mÄ±dÄ±r ve aÅŸaÄŸÄ±daki sÃ¶zde kod gibi kullanÄ±labilir.</br>
    **statement expression** deÄŸeri en son statement deÄŸeridir, aÅŸaÄŸÄ±daki koddaki **statement expression** deÄŸeri `x * y;` deÄŸeridir yani "48" olacaktÄ±r.
    ```C
    (
        {
            int x = 5;
            int y = 7;

            ++x;
            ++y;
            x * y;
        }
    )
    ```

    `#define SQUARE(x) ({ int a = x; a * x; })` bu kullanÄ±m **compiler extension** olan **statement expression** ile Ã§Ã¶zÃ¼m Ã¼retmektir.

3. KullanÄ±cÄ± kodda iki farklÄ± seÃ§enek sunmak, bu Ã§Ã¶zÃ¼mde de sorumluluk kodu yazana bÄ±rakÄ±lÄ±yor.
    1. Fonksiyon kullanÄ±mÄ±.
    2. Fonksiyonel makro kullanÄ±mÄ±.

     
    ğŸ‘‡ AÅŸaÄŸÄ±daki programda aynÄ± iÅŸi yapan makro ve fonksiyonun aynÄ± adda olmaksÄ±zÄ±n nasÄ±l kullanÄ±labileceÄŸi gÃ¶rÃ¼lebilir. 
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include <stdlib.h>

    int square(int a)
    {
        return a * a;
    }

    #define SQUARE(x)   ((x) * (x))

    int main(void)
    {
        int x = 3;

        printf("Usage with 'square() function', square(x++): %d:\n", square(x++));
        
        printf("Usage with 'SQUARE() functional-makro', SQUARE(x): %d\n", SQUARE(x));
    }
    ```

    
    â— BazÄ± C kÃ¼tÃ¼phanelerinde tÃ¼m fonksiyon tanÄ±mlarÄ± aynÄ± adda tanÄ±mlanan makrolar varsa diye ad Ã§akÄ±ÅŸmasÄ± olmamasÄ± iÃ§in fonksiyonlar `int (square)(int a){ return a * a; }` ÅŸeklinde fonksiyon adlarÄ± paranteze alÄ±narak tanÄ±mlanÄ±yor, bu da ad Ã§akÄ±ÅŸmasÄ± oluÅŸma durumunu engellemektedir.


â”
MÃ¼lakatlarda ÅŸu ÅŸekilde bir soru sorulabilir;
- AynÄ± adda hem bir makro var hem de bir fonksiyon var bu ikisini aynÄ± kodda nasÄ±l bir arada kullanÄ±rÄ±m?
- ğŸ‘‡ AÅŸaÄŸÄ±daki programda aynÄ± adda olan makro ve fonksiyon nasÄ±l bir arada kullanÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

#define square(x)   ((x) * (x))

// AÅŸaÄŸÄ±daki fonksiyon tanÄ±mlamasÄ±nda 'int square(int a)' bu ÅŸekilde kullanÄ±lsaydÄ±, Ã¶n-iÅŸlemci programÄ± Ã¶nce Ã§alÄ±ÅŸtÄ±ÄŸÄ± iÃ§in 'square' adÄ±nÄ± 'object-like makro'nun bildirimindeki ifadeyle yer deÄŸiÅŸtirecektir.
int (square)(int a)
{
    return a * a;
}

int main(void)
{
    int x = 3;

    int y1 = square(6); // Burada makro kullanÄ±lmaktadÄ±r.

    int y2 = (square)(6); // Burada fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±lmaktadÄ±r.

    printf("y1: %d:\n", y1);
    printf("y2: %d:\n", y2);
}
```

â—**Function-like makro** kullanÄ±mlarÄ±nda iÃ§ iÃ§e aynÄ± makro adÄ± geÃ§iyorsa Ã¶n-iÅŸlemci program sadece bir seviye makroyu aÃ§ar yani tek sefer Ã§alÄ±ÅŸÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda makroda mokronun kendi adÄ±nÄ± iÃ§eren ifadelerde nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ± gÃ¶rÃ¼lebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// AÅŸaÄŸÄ±daki makro kendi adÄ±nÄ± iÃ§ermektedir, bu makro tek defa aÃ§Ä±lacaktÄ±r, birden fazla defa aÃ§Ä±lmamaktadÄ±r, bu yaklaÅŸÄ±mla bir makronun kendi kendisini defalarca yer deÄŸiÅŸtirmesi engellenmiÅŸ olur.
#define printf(a)   printf("%d\n", a)

int main(void)
{
    printf("some string");
}
```


ğŸ§  Makro fonksiyon olmadÄ±ÄŸÄ± iÃ§in derleyici fonksiyon Ã§aÄŸrÄ±larÄ± iÃ§in Ã¼rettiÄŸi kod Ã¼retilmeyecektir ve bu da kodun daha verimli Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlayabilir. 

ğŸš€ **Function-like makro** kullanÄ±mÄ±nÄ±n iyi bir muadili C99 standardÄ±ndan sonrasÄ± iÃ§in **inline function** kullanÄ±mÄ±dÄ±r ayrÄ±ca **inline** kelimesi bir key-word olmuÅŸtur.

ğŸ§­ **Function-like makro**'lar neden kullanÄ±lÄ±r;
- Daha az fonksiyon kullanÄ±larak kodun daha performanslÄ± Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlamak(ne kadar az fonksiyon Ã§aÄŸrÄ±sÄ± olursa kod daha hÄ±zlÄ± Ã§alÄ±ÅŸacaktÄ±r)
- KarmaÅŸÄ±k ifadelerin yazÄ±lmasÄ±nÄ± kolaylaÅŸtÄ±rmak iÃ§in kullanÄ±lÄ±r.
- HatalÄ± ifade yazma riskini ortadan kaldÄ±rmak iÃ§in kullanÄ±lÄ±r. 
- Ã–n-iÅŸlemci programa kod yazdÄ±rmak iÃ§in kullanÄ±lÄ±r. Bu **generic programing** yaklaÅŸÄ±mÄ±nÄ±n ilkel halidir(C++ dilinde derleyicinin kendisine kod yazdÄ±rmak iÃ§in kullanÄ±lan **Template** denilen daha iyi araÃ§lar mevcut) 


## Preprocessor Operators 

Preprocessor operatorleri Ã¼Ã§ tanedir, bunlar;
1. **`#`(**stringizing** ya da **stringification**) Operator**: Bu operatÃ¶r Unary operatÃ¶rdÃ¼r. Bu operatÃ¶rÃ¼n operandÄ± olan ifade Ã§ift tÄ±rnak iÃ§erisine alÄ±nÄ±r.
2. **`##`(**token-pasting**) Operator**: Token yapÄ±ÅŸtÄ±rma operatÃ¶rÃ¼dÃ¼r, bu operatÃ¶r binary operatÃ¶rdÃ¼r.  
3. **`defined` Operator**: Bu operatÃ¶r koÅŸullu derleme iÅŸlemlerinde kullanÄ±lÄ±r.

### `#` Operator 

ğŸ‘‡ AÅŸaÄŸÄ±daki programda `#` operatÃ¶rÃ¼nÃ¼n **Function-like makro** iÃ§erisinde nasÄ±l kullanÄ±ldÄ±ÄŸÄ±nÄ± anlamak iÃ§in incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define str(a)     #a

int main(void)
{
    printf(str(name)); // Bu statement Ã¶n-iÅŸlemci program tarafÄ±ndan 'printf("name");' olacak ÅŸekilde deÄŸiÅŸtirilir.
}
```

ğŸš€ `#` operatÃ¶rÃ¼nÃ¼n bir Ã§ok faydasÄ± vardÄ±r ama bunlar ileri konular olduÄŸu iÃ§in burada anlatÄ±lmÄ±yor, ÅŸimdilik sadece ÅŸunlar bilinmelidir: bÃ¶yle bir operatÃ¶rÃ¼n varlÄ±ÄŸÄ± bilinmeli, bu operatÃ¶rÃ¼n makro replacement-list iÅŸleminde kullanÄ±ldÄ±ÄŸÄ± ve bu operatÃ¶rÃ¼n operandÄ±nÄ±n Ã¶n-iÅŸlemci program taarfÄ±ndan Ã§ift tÄ±rnak iÃ§ine alÄ±narak kullanÄ±lmasÄ±.


### `##` Operator 


ğŸ‘‡ AÅŸaÄŸÄ±daki program `##` operatÃ¶rÃ¼nÃ¼n nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± analmak iÃ§in incelenebilir, `##` operatÃ¶rÃ¼ bu programdaki gibi kullanÄ±lmaz burada sadece iÅŸleyiÅŸi anlamak iÃ§in bu ÅŸekilde kullanÄ±lmÄ±ÅŸtÄ±r. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define str(x, y)       x ## y

int main(void)
{
    int counter = 0;
    str(cou, nter)++; // Ã–n-iÅŸlemci program buradaki kodu 'counter++;' olarak deÄŸiÅŸtirecektir.

    printf("counter = %d", counter);
}
```


#### `##` OperatÃ¶rÃ¼nÃ¼n Kod YazdÄ±rmayla Olan Ä°liÅŸkisi 

â— Buradaki kullanÄ±m Ã§ok Ã¶nemlidir ve anlaÅŸÄ±lmasÄ± Ã¶nemlidir.

ğŸ‘‡ AÅŸaÄŸÄ±daki program **##(token-pasting)** operatÃ¶rÃ¼ ile nasÄ±l kod yazÄ±labileceÄŸini anlaamk iÃ§in incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// 'Function-like makro' aÅŸaÄŸÄ±daki gibi 'gen_swap' adÄ±yla tanÄ±mlanmÄ±ÅŸtÄ±r, addaki 'gen'in anlamÄ± 'generate'tir.
#define gen_swap(type) void swap_##type(type* p1, type* p2) \
{ \
    type temp = *p1; \
    *p1 = *p2; \
    *p2 = temp; \
}

gen_swap(int)
gen_swap(long)
gen_swap(double)
gen_swap(unsigned)


void swap1(int* p1, int* p2)
{
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}

int main(void)
{
    int x1 = 5;
    int y1 = -10;
    
    printf("first --> x1 = %d, y1 = %d\n", x1, y1);
    swap_int(&x1, &y1);
    printf("last --> x1 = %d, y1 = %d\n", x1, y1);
    
    
    long x2 = 5L;
    long y2 = 10L;
    
    printf("first --> x2 = %ld, y2 = %ld\n", x2, y2);
    swap_long(&x2, &y2);
    printf("last --> x2 = %ld, y2 = %ld\n", x2, y2);
    
    
    double x3 = 5232343335;
    double y3 = 1555373234;
    
    printf("first --> x3 = %lf, y3 = %lf\n", x3, y3);
    swap_double(&x3, &y3);
    printf("last --> x3 = %lf, y3 = %lf\n", x3, y3);
    
    
    unsigned x4 = 52323;
    unsigned y4 = 155;
    
    printf("first --> x4 = %d, y4 = %d\n", x4, y4);
    swap_unsigned(&x4, &y4);
    printf("last --> x4 = %d, y4 = %d\n", x4, y4);
}
```


Ders sonu ...
