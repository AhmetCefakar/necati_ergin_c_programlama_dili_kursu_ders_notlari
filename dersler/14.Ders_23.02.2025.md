# 14.Ders 23.02.2025 ğŸ•˜

Derse 23(09:02)-23(09:14)-26(09:24)-29(10:06)-28(11:15)-27(12:57) kiÅŸi katÄ±ldÄ±.
---

## **getchar** Fonksiyonu


ğŸ‘‡ AÅŸaÄŸÄ±daki program **getchar** ve **_getch** fonksiyonlarÄ±nÄ±n nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± anlamak iÃ§in incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <conio.h> // Standart kÃ¼tÃ¼phane deÄŸil.

int main(void)
{
    printf("parolayi giriniz: ");
    int c1 = getchar(); // 'getchar' fonksiyonu standart giriÅŸ akÄ±mÄ±ndan her Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ±nda tek bir karakter okur ve ardÄ±ndan okuduÄŸu karakteri standart Ã§Ä±ktÄ± akÄ±mÄ±na gÃ¶nderir(echo verir)
    int c2 = getchar();
    int c3 = getchar();
    int c4 = getchar();


    printf("parolayi giriniz: ");
    int c1 = _getch();
    printf("*");
    int c2 = _getch();
    printf("*");
    int c3 = _getch();
    printf("*");
    int c4 = _getch();
    printf("*");

    printf("parolaniz:%c%c%c%c\n", c1, c2, c3, c4);
    
    return 0;
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki program standart olmayan **getche** fonksiyonunun nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± anlamak iÃ§in incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <conio.h> // Standart kÃ¼tÃ¼phane deÄŸil.

int main(void)
{
    printf("karakter giriniz: ");
    int c = _getche();
    
    printf("%d: %c\n", c);
    
    return 0;
}
```

ğŸ§­ Standart input'tan tek bir karakter okumak iÃ§in kullanÄ±lan standart olan ve olmayan fonksiyonlar aÅŸaÄŸÄ±daki gibidir;
- `int getchar(void)` fonksiyonu standart fonksiyondur, **new-line** ister, **echo** verir.
- `int _getch(void)` fonksiyonu standart fonksiyon deÄŸildir, **new-line** istemez, **echo** vermez.
- `int _getche(void)` fonksiyonu standart fonksiyon deÄŸildir, **new-line** istemez, **echo** verir.


## **putchar** Fonksiyonu 

`putchar` fonksiyonu "stdio.h" baÅŸlÄ±k dosyasÄ±nda yer almaktadÄ±r, 

`int putchar(int ch);` fonksiyonu bir karakterin kod numarasÄ±nÄ± alÄ±r ve o karakteri standart output'a gÃ¶nderir, bir hata olmazsa bu fonksiyondan geriye standart output'a gÃ¶nderilen karakter dÃ¶nÃ¼lÃ¼r.


ğŸ‘‡ AÅŸaÄŸÄ±daki program **putchar** fonksiyonunun Ä°ngiliz alfabesindeki 26 harf karakterinin nasÄ±l standart Ã§Ä±kÄ±ÅŸ akÄ±mÄ±na gÃ¶nderildiÄŸini anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <conio.h> // Standart kÃ¼tÃ¼phane deÄŸil.

int main(void)
{
    // for ascii upper-case latters.
    for(int i = 65; i < 65 + 26; ++i){
        putchar(i);
    }

    return 0;
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki program Ascii karakter kodlamasÄ±nda ilk 32 karakter ve son 127 nolu karakter gÃ¶rÃ¼ntÃ¼sÃ¼ olmayan kontrol karakterleri dÄ±ÅŸÄ±ndaki karakterleri standart output'a yazmaktadÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <conio.h> // Standart kÃ¼tÃ¼phane deÄŸil.

int main(void)
{
    // Glyph olan karakterleri yazdÄ±rma iÅŸlemi
    for(int i = 33; i < 127; ++i)
        putchar(i);
    
    return 0;
}
```

âš ï¸ Bu aÅŸamadan sonra kurs devamÄ±nda **getchar** ve **putchar** fonksiyonlarÄ±nÄ±n bilindiÄŸi varsayÄ±lacaktÄ±r.


## Test FonksiyonlarÄ±

Test Fonksiyonu demek bir soruya cevap olarak **doÄŸru/yanlÄ±ÅŸ(true/false)** ÅŸeklinde yanÄ±t verecek olan fonksiyon demektir.

â— C dilinde geleneksel olarak test fonksiyonlarÄ± **int** deÄŸer dÃ¶ndÃ¼rÃ¼r. 

â— C dilinde geleneksel olarak fonksiyon **non-zero** deÄŸer dÃ¶ndÃ¼rÃ¼rse **true**, **zero** deÄŸer dÃ¶ndÃ¼rÃ¼rse **false** olarak yorumlanÄ±r.

â— C99 standardÄ± ile **_Bool** tÃ¼rÃ¼ dile eklenmiÅŸ olsa da geleneksel olarak **_Bool** tÃ¼rÃ¼ yerine **int** tÃ¼rÃ¼ kullanÄ±lmaya devam ettirilmektedir.

C dilinde geleneksel olarak test fonksiyonlarÄ±nÄ±n adlarÄ± **is** Ã¶n ekiyle baÅŸlar.


BirÃ§ok test fonksiyonu 0 ya da 1 deÄŸerini dÃ¶ndÃ¼rÃ¼r ancak bir kÃ¼tÃ¼phaneden Ã§aÄŸÄ±racaÄŸÄ±nÄ±z test fonksiyonun **zero/non-zero(sÄ±fÄ±r/sÄ±fÄ±r olmayan)** deÄŸer dÃ¶ndÃ¼receÄŸini var sayarak kodlama yapÄ±lmalÄ±dÄ±r.


### One-liner Functions(TeksatÄ±rlÄ±k Fonksiyonlar)


ğŸ‘‡ AÅŸaÄŸÄ±daki program "Bir tam sayÄ±nÄ±n Ã§ift olup olmadÄ±ÄŸÄ±nÄ± sÄ±nayan **iseven** adlÄ± bir fonksiyon yazÄ±nÄ±z ?" sorusunun cevabÄ± olarak nasÄ±l bir fonksiyon yazÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int iseven_v1(int x)
{
    if(x % 2 == 0)
        return 1;
    else
        return 0;
}

int iseven_v2(int x)
{
    if(x % 2 == 0)
        return 1;
    
    return 0;
}

// Buradaki gibi tek satÄ±r olarak yazÄ±labilen fonksiyon 'one-liner' fonksiyon olarak adlandÄ±rÄ±lÄ±r.
int iseven(int x)
{
    return x % 2 == 0;
}

// AÅŸaÄŸÄ±daki fonksiyon bir sayÄ±nÄ±n tek olup olmadÄ±ÄŸÄ± bilgisini dÃ¶ndÃ¼rÃ¼r. 
// Buradaki fonksiyon 'one-liner' olarak adlandÄ±rÄ±lÄ±r.
int isodd(int x)
{
    //return x % 2 != 0;
    return x % 2;
}

int main(void)
{
    int x;
    printf("bir tam sayi girin: ");
    scanf("%d", &x);

    printf("girilen sayi: %d \n", x, );


    if(iseven(x)){
        printf("girilen sayi tektir\n");
    }
    else
        printf("girilen sayi cifttir\n");

    return 0;
}
```


â— C99 standardÄ± sonrasÄ±nda main fonksiyonu sonunda bir return statement yazÄ±lmazsa derleyiciler main fonksiyonunun sonuna **return 0;** eklemesini yapmaktadÄ±r, fakat bu iÅŸlem sadece **main** fonksiyonu iÃ§in geÃ§erlidir diÄŸer fonksiyonlar iÃ§in geÃ§erli deÄŸildir.

### isleap Function(ArtÄ±k yÄ±l Bulma Fonksiyonu)

â”
Herhangi bir programlama dili mÃ¼lakatlarÄ±nda aÅŸaÄŸÄ±daki soru Ã§ok soruluyormuÅŸ: Bir yÄ±lÄ±n(year) artÄ±k yÄ±l(leap year) olup olmadÄ±ÄŸÄ±nÄ± test eden bir fonksiyon yazÄ±nÄ±z?

**ArtÄ±k yÄ±l tanÄ±mÄ±**: DÃ¶rde tam bÃ¶lÃ¼nen ancak 100'e tam bÃ¶lÃ¼nmeyen ya da 400'e tam bÃ¶lÃ¼nen 
- 1987: 4'e tam bÃ¶lÃ¼nmÃ¼yor. HayÄ±r artÄ±k yÄ±l deÄŸil.
- 1984: Evet artÄ±k yÄ±l.
- 2000: Evet artÄ±k yÄ±l. 4'e tam bÃ¶lÃ¼nÃ¼r, 100'e bÃ¶lÃ¼nÃ¼r ama 400'e tam bÃ¶lÃ¼ndÃ¼ÄŸÃ¼ iÃ§in artÄ±k yÄ±ldÄ±r.
- 1900: HayÄ±r artÄ±k yÄ±l deÄŸildir. 4'e tam bÃ¶lÃ¼nÃ¼r 



ğŸ‘‡ AÅŸaÄŸÄ±daki program bir yÄ±lÄ±n artÄ±k yÄ±l olup olmadÄ±ÄŸÄ± cevabÄ±nÄ± dÃ¶nen 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

// AÅŸaÄŸÄ±daki kodda '&&' operatÃ¶rÃ¼nÃ¼n saÄŸ operandÄ± olan ifadede Ã¶ncelik parantezini kaldÄ±rÄ±rsak kod hayla doÄŸru olur mu?
// DoÄŸru olur.
int isleap(int y)
{
    return y % 4 == 0 && (y % 100 != 0 || y % 400 == 0);
}

// AÅŸaÄŸÄ±daki fonksiyon 'isleap' fonksiyonu ile aynÄ± sonucu Ã¼retir, parantezler kaldÄ±rÄ±lmasÄ±na raÄŸmen neden bir sorun olmadÄ±ÄŸÄ±nÄ± dÃ¼ÅŸÃ¼nmen gerekiyor!
int isleap_v2(int y)
{
    return y % 4 == 0 && y % 100 != 0 || y % 400 == 0;
}

int main(void)
{
    int year;

    printf("bir yil degeri giriniz:");
    scanf("%d", &year);  

    // AÅŸaÄŸÄ±daki bicinde yazmak daha yaygÄ±ndÄ±r.
    if(isleap(year)){
        printf("evet artÄ±k yil\n");
    }
    else{
        printf("hayÄ±r artÄ±k yil degil.\n");
    }

    return 0;
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki iki kod birbirinin aynÄ±sÄ±dÄ±r, burada birinci kullanÄ±m **redundant(gereksiz)** olarak adlandÄ±rÄ±lÄ±r Ã§Ã¼nkÃ¼ fazladan kod yazÄ±lmÄ±ÅŸtÄ±r. 
```C
// 1. kullanÄ±m 
if(x != 0)
    y = x;
else
    y = 0;

// 2. kullanÄ±m
y = x;
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program test fonksiyonlarÄ±ndan dÃ¶nÃ¼ÅŸ deÄŸerlerinin logic(mantÄ±ksal) ifadelerle birlikte nasÄ±l kullanÄ±lmasÄ± gerektiÄŸini anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int is_upper(int c);

int main(void)
{
    int x, y;
    scanf("%d%d", &x, &y);

    // AÅŸaÄŸÄ±daki kullanÄ±m C dilinde doÄŸru deÄŸildir Ã§Ã¼nkÃ¼ 'is_upper' fonksiyonu doÄŸru olarak '1' dÄ±ÅŸÄ±nda herhangi bir deÄŸer dÃ¶ndÃ¼rebilir.
    if(is_upper(x) == is_upper(y)){
        
    }

    // AÅŸaÄŸÄ±daki kullanÄ±m C dilinde doÄŸru kullanÄ±mdÄ±r. BÃ¶yle kullanÄ±lmasÄ±nÄ±n nedeni 'zero/non-zero' durumundan dolayÄ±.
    if(!!is_upper(x) == !!is_upper(y)){
        
    }

    return 0;
}
```



â— `!!expr` ifadesinin deÄŸeri ifade lojik doÄŸru ise "1", ifade lojik yanlÄ±ÅŸ ise "0" olacaktÄ±r.

### Armstrong Number

**Armstrong sayÄ±sÄ±**: Bir sayÄ± kaÃ§ basamaklÄ±ysa bu sayÄ±nÄ±n her bir basamaÄŸÄ±ndaki sayÄ±nÄ±n basamak sayÄ±sÄ± kadar Ã¼slerinin alÄ±ndÄ±ÄŸÄ± sayÄ±larÄ±n toplamÄ± o sayÄ±ya eÅŸit olan sayÄ±lara verilen addÄ±r.

Mesela: $xy = x^{2} + y^{2} $, $abc = a^{3} + b^{3} + c^{3}$, $xyzt = x^{4} + y^{4} + z^{4} + t^{4}$, $370 = 3^{3} + 7^{3} + 0^{3}$ ÅŸeklinde eÅŸitlik olan sayÄ±lar bu tanÄ±ma uyar.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda eÄŸer x **armstrong sayÄ±sÄ±** ise **non-zero**, eÄŸer x **armstrong sayÄ±sÄ±** deÄŸil ise **zero** deÄŸer dÃ¶ndÃ¼recek olan **is_armstrong** adlÄ± fonksiyonun kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

// AÅŸaÄŸÄ±daki fonksiyon kendisine gÃ¶nderilen bir tam sayÄ±nÄ±n **armstrong sayÄ±** olup olmadÄ±ÄŸÄ± bilgisini geriye dÃ¶nen bir test fonksiyonudur. Bu fonksiyonun gÃ¶vdesi yazÄ±lmadÄ± sonradan kendin yaz!
int is_armstrong(int x)
{
    
    
    return 0;
}

int main(void)
{
    int x;
    scanf("%d", &x);

    if(!!is_armstrong(x)){
        
    }

    return 0;
}
```

## Factoriyel Hesaplama

### Lookup Table KullanÄ±mÄ±


ğŸš€ Ãœretimde Ã¶zyinelemeli fonksiyonlarÄ±n bilinÃ§siz ÅŸekilde kullanÄ±lmasÄ± doÄŸru deÄŸildir Ã§Ã¼nkÃ¼ bu ÅŸekilde bir kullanÄ±m doÄŸasÄ± gereÄŸi Ã§ok fazla kaynak tÃ¼ketecektir(CPU ve Ram).



ğŸ‘‡ AÅŸaÄŸÄ±daki program faktÃ¶riyel hesabÄ± yapan bir fonksiyonun **lookup table** ile performanslÄ± olarak nasÄ±l yazÄ±labileceÄŸini anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

// Ã–zyinelemeli olarak faktÃ¶riyel hesabÄ± yapan fonksiyon
int factorial_v1(int x)
{
    if(x < 2)
        return 1;

    return x * factorial(x - 1);
}

// Lookup table ile faktÃ¶riyel hesabÄ± yapan fonksiyon
int factorial_v2(int x)
{
    // 'int' tÃ¼rÃ¼nde en fazla 12! deÄŸerine kadar bilgi tutulabildiÄŸi iÃ§in 
    static const int ary[] = { 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 362880, 39916800, 479001600 };

    if (x == 0) 
        return 1;
    
    if (x < 1 || x > 12) 
        return 0; // Out of valid factorial range
    
    return ary[x - 1]; // Get precomputed factorial from array
}

unsigned long long factorial_v3(int n) 
{
    // Static lookup table holding factorials from 0! to 20!
    static unsigned long long lookup[21];
    static int initialized = 0;

    if (!initialized) {
        // Initialize the lookup table on first call
        lookup[0] = 1; // 0! = 1

        for (int i = 1; i <= 20; i++) {
            lookup[i] = lookup[i - 1] * i;
        }

        initialized = 1; // Mark as initialized
    }

    // Handle invalid input (n < 0 or n > 20)
    if (n < 0 || n > 20) {
        return 0;
    }

    return lookup[n];
}


int main(void)
{
    int x;
    printf("faktoriyel degeri hesaplanacak olan sayiyi giriniz: ");
    scanf("%d", &x);

    printf("x sayÄ±sÄ±nÄ±n faktoriyeli: %d", factorial(x));
    
    return 0;
}
```



â— Algoritma sorularÄ±nda ilk sorgulanmasÄ± gereken ÅŸey kÄ±sÄ±t olup olmadÄ±ÄŸÄ±dÄ±r, kÄ±sÄ±t olup olmamasÄ±na gÃ¶re sorularÄ±n Ã§Ã¶zÃ¼mÃ¼ deÄŸiÅŸecektir.


## Standart **ctype.h** BaÅŸlÄ±k DosyasÄ± DetaylÄ± Ä°ncelenmesi 

Kurs baÅŸladÄ±ÄŸÄ±ndan beri C standart kÃ¼tÃ¼phenesinin ilk defa alt modÃ¼llerinden(Module) birini inceleyeceÄŸiz, bu alt modÃ¼l **ctype.h** modÃ¼lÃ¼dÃ¼r, 

**Module**: MantÄ±ksal olarak benzer domain'e ait iÅŸleri yapan yazÄ±lÄ±msal varlÄ±klarÄ±n bir araya getirilerek oluÅŸturulan dÄ±ÅŸarÄ±dan yalÄ±tÄ±lmÄ±ÅŸ birimlere verilen addÄ±r. "string.h" modÃ¼lÃ¼nde yazÄ±larla ilgili olarak kullanÄ±lan varlÄ±klar vardÄ±r, "stdio.h" modÃ¼lÃ¼nde standart girdi/Ã§Ä±ktÄ± iÅŸlemlerinin yapÄ±lmasÄ±nÄ± saÄŸlayan yazÄ±lÄ±msal varlÄ±klar vardÄ±r.

**Standart C library** ile saÄŸlanan modÃ¼llerden biri olan **ctype.h** dosyasÄ±nÄ± detaylÄ± inceleyelim.

**ctype.h** baÅŸlÄ±k dosyasÄ± en Ã§ok kullanÄ±lan standart C baÅŸlÄ±k dosyalarÄ±ndan biridir, bu baÅŸlÄ±k dosyasÄ±nda karakter test fonksiyonlarÄ± ve karakter dÃ¶nÃ¼ÅŸÃ¼k fonksiyonlarÄ± vardÄ±r.


ğŸ§­ "ctype.h" dosyasÄ±nda aÅŸaÄŸÄ±daki gibi iki gruba ayrÄ±lan fonksiyonlar vardÄ±r;
1. Karakter test fonksiyonlarÄ±;
    1. `int isupper();`  BÃ¼yÃ¼k harf mi?
    2. `int islower();`  KÃ¼Ã§Ã¼k harf mi?
    3. `int isalpha();`  Harf mi?
    4. `int isdigit();`  Rakam karakteri mi?
    5. `int isalnum();`  AlfanÃ¼merik(harf ya da rakam) karakter mi?
    6. `int xdigit();`   Hex basamak karakter mi(0, 1, ..., e, f, ..., E, F)?
    7. `int ispuct();`   Punctuation(Printable and not alphanumeric) karakter mi?

    8. `int isspace();`  whitespace('\t', '\v', ' ', '\n', '\r', '\f') karakter mi?
    9. `int isblank();`  Yatay tab ya da space karakter mi?
    10. `int isprint();` **Printable(non-control characters)** mi yani Ã§Ä±ktÄ± olarak bir gÃ¶rÃ¼ntÃ¼sÃ¼ olan karakter mi? BoÅŸluk ` ` karakteri iÃ§in de **non-zero(true)** deÄŸer dÃ¶ndÃ¼rÃ¼r?
    11. `int isgraph();` **Printable(non-control characters)** mi yani Ã§Ä±ktÄ± olarak bir gÃ¶rÃ¼ntÃ¼sÃ¼ olan karakter mi? BoÅŸluk ` ` karakteri iÃ§in de **zero(false)** deÄŸer dÃ¶ndÃ¼rÃ¼r?
    12. `int iscntrl();` Kontrol(control) karakter mi ?
2. Karakter dÃ¶nÃ¼ÅŸÃ¼m fonksiyonlarÄ±;
    1. `int toupper(int c);`
    2. `int tolower(int c);`


### Standart **ctype.h** BaÅŸlÄ±k DosyasÄ± Karakter test fonksiyonlarÄ± 



ğŸ‘‡ AÅŸaÄŸÄ±daki program **ctype.h** fonksiyonlarÄ±nÄ±n anlaÅŸÄ±lmasÄ± iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>

int main(void)
{
    int ch;

    printf("bir karakter giriniz:");
    ch = gatchar();
    
    if(isupper(ch)){
        printf("evet buyuk harf karakter.\n");
    }
    else{
        printf("hayÄ±r buyuk harf karakter degil.\n");
    }

    if(islower(ch)){
        printf("evet kÃ¼cÃ¼k harf karakter.\n");
    }
    else{
        printf("hayÄ±r kÃ¼cÃ¼k harf karakter degil.\n");
    }

    if(isalpha(ch)){
        printf("evet alfanumerik karakter.\n");
    }
    else{
        printf("hayÄ±r alfanumerik karakter degil.\n");
    }

    if(isdigit(ch)){
        printf("evet numerik karakter.\n");
    }
    else{
        printf("hayÄ±r numerik karakter degil.\n");
    }

    if(isalnum(ch)){
        printf("evet alfanÃ¼merik karakter.\n");
    }
    else{
        printf("hayÄ±r alfanÃ¼merik karakter degil.\n");
    }

    if(xdigit(ch)){
        printf("evet hex karakter.\n");
    }
    else{
        printf("hayÄ±r hex karakter degil.\n");
    }

    if(ispuct(ch)){
        printf("evet punctuation karakter.\n");
    }
    else{
        printf("hayÄ±r punctuation karakter degil.\n");
    }

    
    // AÅŸaÄŸÄ±daki gibi bir kod sadece ASCII karakter setine gÃ¶re doÄŸru Ã§alÄ±ÅŸacaktÄ±r.
    // Ama diÄŸer karakter setlerinde doÄŸru Ã§alÄ±ÅŸmayabilir ve bÃ¶yle kodlama yapÄ±lmamalÄ±, kodun taÅŸÄ±nabilirliÄŸi azalÄ±r bu kullanÄ±mda.
    if(ch > 'A' && ch < 'Z'){
        printf("evet buyuk harf karakter.\n");
    }
    else{
        printf("hayÄ±r buyuk harf karakter degil.\n");
    }

    return 0;
}
```


â—C standart kÃ¼tÃ¼phande olan bir Ã¶ÄŸe varsa onu kullanmak yerine kendimiz bir Ã¶ÄŸre yazarsak, aÅŸaÄŸÄ±daki sorunlar oluÅŸacaktÄ±r;
1. Kodun okunup anlaÅŸÄ±lmasÄ± kolay zorlaÅŸacaktÄ±r.
2. Test etmek gerekecektir ama standart kÃ¼tÃ¼phanesinin Ã§ÄŸelerinin testleri baÅŸkalarÄ± tarafÄ±ndan defalarca yapÄ±lmÄ±ÅŸtÄ±r.
3. Kodun taÅŸÄ±nÄ±rlÄ±ÄŸÄ± olmayacaktÄ±r. Dosya iÅŸlemleri, multi-threat programlama iÅŸletim sistemine baÄŸÄ±mlÄ±dÄ±r, bu iÅŸlemleri kullanan kodlar yazÄ±lÄ±rken standart kÃ¼tÃ¼phane fonksiyonlarÄ± kullanÄ±lmalÄ±dÄ±r.
4. **Efficiency(intrinsic)** olmayacaktÄ±r. 



ğŸ§  Bu kursun son Ã§eyreÄŸinde **Standart C library** fonksiyonlarÄ±ndan bazÄ±larÄ±nÄ±n nasÄ±l gerÃ§ekleÅŸtirildiÄŸi(implementation) anlatÄ±lacaktÄ±r, o zaman gÃ¶rÃ¼lecektir ki bu fonksiyonlarÄ±n tanÄ±mlarÄ±nda(definition) Ã§oÄŸunlukla **lookup table** kullanÄ±lÄ±yor.

ğŸ§­ Bu kurs boyunca 80-100 arasÄ±nda **Standart C library** fonksiyonu detaylÄ± ÅŸekilde inceleniyormuÅŸ, bu sayÄ± kurstan kursa deÄŸiÅŸiyormuÅŸ.

ğŸ”­ ğŸ” [Bu baÄŸlantÄ±dan](https://www.ascii-code.com/) **ASCII** karakter listesi gÃ¶rÃ¼lebilir.


[10:35:00-10:41:00]
ğŸ‘‡ AÅŸaÄŸÄ±daki program **ctype.h** fonksiyonlarÄ±nÄ±n anlaÅŸÄ±lmasÄ± iÃ§in incelenebilir, programda sadece 128 adet **ASCII** karakterleri listeleniyor, bunun dÄ±ÅŸÄ±nda **extended ASCII** karakterleri de vardÄ±r ama onlar programda kullanÄ±lmamÄ±ÅŸtÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

int main(void)
{
    printf("isupper characters;\n");
    for(int i = 0; i < 128; ++i){
        if(isupper(i))
            putchar(i);
    }
    putchar("\n");
    
    printf("islower\n");
    for(int i = 0; i < 128; ++i){
        if(islower(i))
            putchar(i);
    }
    putchar("\n");

    printf("isalpha\n");
    for(int i = 0; i < 128; ++i){
        if(isalpha(i))
            putchar(i);
    }
    putchar("\n");

    printf("isdigit\n");
    for(int i = 0; i < 128; ++i){
        if(isdigit(i))
            putchar(i);
    }
    putchar("\n");

    printf("isalnum\n");
    for(int i = 0; i < 128; ++i){
        if(isalnum(i))
            putchar(i);
    }
    putchar("\n");

    printf("xdigit\n");
    for(int i = 0; i < 128; ++i){
        if(xdigit(i))
            putchar(i);
    }
    putchar("\n");

    printf("ispuct\n");
    for(int i = 0; i < 128; ++i){
        if(ispuct(i))
            putchar(i);
    }
    putchar("\n");

    printf("isprint\n");
    for(int i = 0; i < 128; ++i){
        if(isprint(i))
            printf("%d", i);
    }
    putchar("\n");

    printf("isgraph\n");
    for(int i = 0; i < 128; ++i){
        if(isgraph(i))
            putchar(i);
    }
    putchar("\n");

    printf("isspace\n");
    for(int i = 0; i < 128; ++i){
        if(ispuct(i))
            printf("%d", i);
    }
    putchar("\n");

    printf("isblank\n");
    for(int i = 0; i < 128; ++i){
        if(isblank(i))
            printf("%d", i);
    }
    putchar("\n");

    printf("iscntrl\n");
    for(int i = 0; i < 128; ++i){
        if(iscntrl(i))
            printf("%d", i);
    }
    putchar("\n");

    return 0;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **ctype.h** fonksiyonlarÄ±nÄ±n rastgele sayÄ± ile Ã¼retilen 0-127 arasÄ±ndaki sayÄ±larÄ±n hangi karaktere karÅŸÄ±lÄ±k geldiÄŸini incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <Windows.h> // Standart bir baÅŸlÄ±k dosyasÄ± deÄŸil

int main(void)
{
    printf("isupper characters;\n");
    
    // AÅŸaÄŸÄ±daki 'while(1)' statement C dilinde 'infinity loop' olan idiomatic bir kullanÄ±mdÄ±r.
    while(1){
        int c = rand() % 127; // Burada 'c' deÄŸiÅŸkenine 0-127 arasÄ±nda rastgele tam sayÄ± atamasÄ± yapÄ±lmaktadÄ±r.
    
        if(isupper(c)){
            putchar(c);
            Sleep(100); // 'Windows.h' baÅŸlÄ±k dosyasÄ±nda olan programÄ± belirli bir sÃ¼re boÅŸ dÃ¶nmesini(beklemesini) saÄŸlamak iÃ§in kullanÄ±lÄ±yor.
        }
    }

    return 0;
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.45-11.05 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***



ğŸ‘‡ AÅŸaÄŸÄ±daki program **zero/non-zero** deÄŸer dÃ¶ndÃ¼ren test fonksiyonlarÄ±nÄ±n deÄŸerlerinin **kontrol deyimlerinde( control statement)** nasÄ±l kullanÄ±lacaÄŸÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stlib.h>
#include <ctype.h>

int main(void)
{
    int c1, c2;  
    
    // AÅŸaÄŸÄ±daki '!!' kullanÄ±mÄ± idiomatic yapÄ±dadÄ±r.
    if(!!isupper(c1) == !!isupper(c2)){
        
    }

    // AÅŸaÄŸÄ±daki kullanÄ±m da doÄŸrudur fakat idiomatic yapÄ± deÄŸildir.
    if(!isupper(c1) == !isupper(c2)){
        
    }
    
    return 0;
}
```

### Standart **ctype.h** BaÅŸlÄ±k DosyasÄ± Karakter dÃ¶nÃ¼ÅŸÃ¼m fonksiyonlarÄ± 


AÅŸaÄŸÄ±daki fonksiyonlar C standardÄ±nda bulunan **ctype.h** baÅŸlÄ±k dosyasÄ±ndaki karakter dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapan fonksiyonlardÄ±r;
1. `int toupper(int c);` fonksiyonu kÃ¼Ã§Ã¼k harf karakterden bÃ¼yÃ¼k harf karakterine dÃ¶nÃ¼ÅŸÃ¼m yapar. KÃ¼Ã§Ã¼k harf deÄŸer gÃ¶nderilmezse karakterin kendisini geriye dÃ¶ndÃ¼rÃ¼r.
2. `int tolower(int c);` fonksiyonu bÃ¼yÃ¼k harf karakterden kÃ¼Ã§Ã¼k harf karakterine dÃ¶nÃ¼ÅŸÃ¼m yapar. BÃ¼yÃ¼k harf deÄŸer gÃ¶nderilmezse karakterin kendisini geriye dÃ¶ndÃ¼rÃ¼r.


[11:13:00-11:15:15]
ğŸ‘‡ AÅŸaÄŸÄ±daki program toupper/tolower fonksiyonlarÄ±nÄ±n kullanÄ±mÄ±nÄ± anlamak iÃ§in incelenebilir. toupper/tolower fonksiyonlarÄ± harflerdeki karÅŸÄ±laÅŸtÄ±rmalarÄ± bÃ¼yÃ¼k kÃ¼Ã§Ã¼k harf ayrÄ±mÄ±na takÄ±lmadan yapabilmek iÃ§in kullanÄ±lÄ±yor.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stlib.h>
#include <ctype.h>

int main(void)
{
    printf("bir karakter giriniz: ");
    int c = getchar();

    printf("toupper %c ===> %c\n", ch, toupper(ch));
    printf("tolower %c ===> %c\n", ch, tolower(ch));

    return 0;
}
```


[11:16:00-11:19:55]
ğŸ‘‡ AÅŸaÄŸÄ±daki program toupper/tolower fonksiyonlarÄ±nÄ±n kullanÄ±mÄ±nÄ± anlayabilmek iÃ§in incelenebilir, toupper/tolower fonksiyonlar iÅŸlem yapsa da yapmasa da geriye deÄŸer dÃ¶ndÃ¼rÃ¼r ve bu Ã¶zellik ile bÃ¼yÃ¼k kÃ¼Ã§Ã¼k harf karakter karÅŸÄ±laÅŸtÄ±rmalarÄ± daha kolay yapÄ±labiliyor.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stlib.h>
#include <ctype.h>

int main(void)
{
    int c1, c2;  
    
    printf("iki karakter giriniz: ");
    c1 = getchar();
    c2 = getchar();

    if(c1 == c2){
        printf("%c ile %c ayni karakterler.\n", c1, c2);
    }
    else{
        printf("%c ile %c farkli karakterler.\n", c1, c2);
    }

    // 'a' ve 'A' girildiÄŸinde baÅŸarÄ±lÄ± cevap verilmesi isteniyorsa aÅŸaÄŸÄ±daki gibi kullanÄ±lmalÄ±dÄ±r.
    // 'toupper' fonksiyonunun kullanÄ±lmasÄ± C dilinde idiomatic yapÄ±dÄ±r ama 'tolower' fonksiyonu da kullanÄ±ldÄ±ÄŸÄ±nda da aynÄ± sonuÃ§ alÄ±nacaktÄ±r. 
    if(toupper(c1) == toupper(c2)){
        printf("%c ile %c ayni karakterler.\n", c1, c2);
    }
    else{
        printf("%c ile %c farkli karakterler.\n", c1, c2);
    }

    return 0;
}
```


## Ternary(Conditionla) Operator 

Bu operatÃ¶rÃ¼n yanlÄ±ÅŸ Ã¶ÄŸrenilmesi sÄ±k karÅŸÄ±laÅŸÄ±lan bir durumdur, genellikle "**ternary operator** iÃ§in **if** deyiminin farklÄ± bir kullanÄ±mÄ±dÄ±r." ÅŸeklinde dÃ¼ÅŸÃ¼nÃ¼lÃ¼yormuÅŸ ama bu dÃ¼ÅŸÃ¼nce yanlÄ±ÅŸtÄ±r Ã§Ã¼nkÃ¼ bir operatÃ¶r bir deÄŸer Ã¼retir ama bir **statement(deyim)** bir deÄŸer Ã¼retmez.

`if` bir statement(deyim) ve `exp1 ? exp2 : exp3` bir expression(ifade) yapÄ±dadÄ±r.

**The ternary operator** iÃ§in aÅŸaÄŸÄ±daki durumlar bilinmelidir;
- **Ternary operator** `?` ve `:` iki karaktere sahip olan Ã¼Ã§ operand alan tek operatÃ¶rdÃ¼r ve **The ternary operator** olarak ta adlandÄ±rÄ±lÄ±r, Ã¶ncelik yÃ¶nÃ¼ saÄŸdan soladÄ±r.
- **Ternary operator** ile oluÅŸturulan ifadelerin(expression) deÄŸeri ilk ifade sonucu "zero(0)" ise ikinci operant, ilk ifadenin deÄŸeri "non-zero" ise Ã¼Ã§Ã¼ncÃ¼ operanttÄ±r.
- **Ternary operator** bir ifadenin logic doÄŸru ya da yanlÄ±ÅŸ olmasÄ±na baÄŸlÄ± olarak iki deÄŸerden birini Ã¼retir.

AÅŸaÄŸÄ±daki durumlarÄ± bilmek Ã¶nemlidir;
- `x > y ? x : y * 5` ifadesi tokenizing aÅŸamasÄ±nda ÅŸu ÅŸekilde `(x > y) ? x : (y * 5)` yorumlanacaktÄ±r.
- `if((x > y) ? x : (y > 40))` ifadesi muhtemelen yanlÄ±ÅŸ yazÄ±lmÄ±ÅŸtÄ±r, olmasÄ± gereken ifade muhtemelen `if(x > y ? x : y) > 40)` ÅŸeklindedir.

â—C++ dilinde **ternary operator** ile oluÅŸturulan ifadeler(expression) ikinci ve Ã¼Ã§Ã¼ncÃ¼ operant L-value ise **L-value expression** ve R-value ise **R-value expression** olacaktÄ±r.

â—C dilinde **ternary operator** ile oluÅŸturulan ifadeler(expression) ikinci ve Ã¼Ã§Ã¼ncÃ¼ operatÃ¶rÃ¼n R-value ya da L-value olsun **R-value expression** olacaktÄ±r.  

### Ternary(Conditionla) Operator Ne Ä°Ã§in KullanÄ±lÄ±r 

âš ï¸ EÄŸer **ternary operator** ile Ã¼retilen deÄŸer kullanÄ±lmayacaksa **ternary operator** kullanmamak daha doÄŸru olacaktÄ±r.

**Ternary operator** ile Ã¼retilen deÄŸer en Ã§ok ÅŸu durumlarda kullanÄ±lÄ±r;
1. Ãœretilen deÄŸerin bir deÄŸiÅŸkene ilk deÄŸer olarak verilmesi ya da atanmasÄ±. `int max = x > y ? x : y;` bu kullanÄ±mda "x" deÄŸiÅŸkenine **ternary operator** ile Ã¼retilen deÄŸer ilk deÄŸer olarak veriliyor.
2. Ãœretilen deÄŸerin bir fonksiyona argÃ¼man yapÄ±lmasÄ±. `foo(x > y ? x : y);` bu kullanÄ±mda bu durum geÃ§erlidir.
3. **return** deyiminde bazÄ± durumlarda tek satÄ±rda deÄŸer dÃ¶ndÃ¼rmek iÃ§in kullanÄ±lÄ±r.

    
    ğŸ‘‡ AÅŸaÄŸÄ±daki program "factorial" hesabÄ± iÃ§in kullanÄ±lan fonksiyonun nasÄ±l **ternary operator** ile oluÅŸturulabileceÄŸini anlamak iÃ§in incelenebilir.
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include <stlib.h>
    #include <ctype.h>

    int factorial(int x)
    {
        if(x < 2 )
            return 1;

        return x * factorial(x - 1); 
    }

    int factorial(int x)
    {
        return x < 2 ? 1 : x * factorial(x - 1); 
    }

    int main(void)
    {

        return 0;
    }
    ```

    ğŸ‘‡ AÅŸaÄŸÄ±daki program iki sayÄ±dan bÃ¼yÃ¼k ve kÃ¼Ã§Ã¼k olanÄ±n hesaplanabilmesi iÃ§in kullanÄ±lan fonksiyonlarÄ±n nasÄ±l **ternary operator** ile oluÅŸturulabileceÄŸini anlamak iÃ§in incelenebilir.
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include <stlib.h>
    #include <ctype.h>

    int max2(int x, int y)
    {
        return x > y ? x : y; 
    }

    int min2(int x, int y)
    {
        return x > y ? y : x; 
    }

    int main(void)
    {

        return 0;
    }
    ```

4. **Ternary operator**'Ã¼n Ã¼rettiÄŸi deÄŸerin baÅŸka bir operatÃ¶rÃ¼n operandÄ± yapÄ±ldÄ±ÄŸÄ± durumlarda kullanÄ±lÄ±r. `if(ndays > (isleap(x) ? 29 : 28))` ÅŸeklinde kodlar yazmak iÃ§in kullanÄ±lÄ±r.

Burada **ternary operator**'Ã¼n kullanÄ±ldÄ±ÄŸÄ± yerlerin neler olduÄŸunun sonuna gelindi ve **ternary operator** ile ilgili birkaÃ§ konuya deÄŸinilip yeni baÅŸlÄ±ÄŸa geÃ§ilecek.


### Ternary(Conditionla) Operator Ä°le Ä°lgili BazÄ± Detaylar 


ğŸ§  Bazen programcÄ±lar else-if merdivenini es geÃ§erek **ternary operatÃ¶rÃ¼nÃ¼** kullanabiliyorlar. 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "a 5 ise b'ye 13, a 17 ise b'ye 19, a 29 ise b'ye 37 aksi halde b'ye 100 deÄŸeri atansÄ±n" buradaki iÅŸlem iki farklÄ± ÅŸekilde yapÄ±lmaktadÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stlib.h>
#include <ctype.h>

int main(void)
{
    int a, b;
    
    printf("bir sayi giriniz: ");
    scanf("%d", &a);
    
    // DÃ¼z if-else ile yazÄ±lmasÄ± durumu
    if(a == 5)
        b = 13;
    else if(a == 17)
        b = 19;
    else if(a == 29)
        b = 37;
    else
        b = 100;

    // YukarÄ±daki if-else merdiveninin 'ternary operator' ile aÅŸaÄŸÄ±daki gibi kullanÄ±mÄ± C dilinde idiomatic yapÄ±dÄ±r.
    b = a == 5 ? :
        a == 17 ? 19 :
        a == 29 ? 37 : 100;

    printf("b = %d\n", b);

    return 0;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "x'in deÄŸeri 5 ise a'ya aksi halde b'ye c'nin deÄŸerini ata" buradaki istenilen durumu gerÃ§ekleÅŸtirenleri yapan kodlar incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stlib.h>
#include <ctype.h>

int main(void)
{
    int x, a, b, c;

    // C dilinde 1. kullanÄ±m
    if(x == 5)
        a = c;
    else
        b == c;

    // x == 5 ? a : b = c; // Bu kod C++ dilinde legaldir fakat C dilinde saÄŸ operan deÄŸeri 'L-value' olmadÄ±ÄŸÄ± iÃ§in sÃ¶zdizim hatasÄ±(syntax error) oluÅŸacaktÄ±r.
    
    // C dilinde 2. kullanÄ±m
    *(x == 5 ? &a : &b) = c; // Bu kullanÄ±m C dilinde idiomatic kullanÄ±mdÄ±r ve bir Ã¼stteki yorum satÄ±rÄ±na alÄ±nmÄ±ÅŸ statement C dilinde sÃ¶zdizim hatasÄ±(syntax error) olduÄŸu iÃ§in o statement'Ä±n yaptÄ±ÄŸÄ± iÅŸi yapacak bir 'work-around' olarak kullanÄ±labiliyor yani aynÄ± iÅŸi farklÄ± ÅŸekilde dilin sÃ¶zdiziminin(syntax) etrafÄ±ndan dolaÅŸarak yapÄ±ldÄ±ÄŸÄ± kodlama yaklaÅŸÄ±mÄ±.

    return 0;
}
```



â—â—â— Bir C ya da C++ dilindeki ifadelerde tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ olup olmayacaÄŸÄ± **compile-time** da belirlenir, **ternary operator expression** kullanÄ±mlarÄ±nda ikinci ve Ã¼Ã§Ã¼ncÃ¼ operantlarÄ±n deÄŸerlerinden en kapsayÄ±cÄ± olanÄ± ifadenin tÃ¼rÃ¼nÃ¼ belirler, bununla ilgili detaylÄ± fikir sahibi olabilmek iÃ§in aÅŸaÄŸÄ±daki program incelenebilir.



â” AÅŸaÄŸÄ±daki soru mÃ¼lakatlarda sorulduÄŸunda 9/10 soruya yanlÄ±ÅŸ cevap veriyormuÅŸ.
- ğŸ‘‡ AÅŸaÄŸÄ±daki program "Program Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda process'in akÄ±ÅŸÄ± `double dval = 10 / (a == 5 ? x : d);` kodunun olduÄŸu yere geldiÄŸinde ekrana `dval` deÄŸeri ne olarak yazdÄ±rÄ±lÄ±r?" bu sorunun anlaÅŸÄ±lmasÄ± iÃ§in incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stlib.h>
#include <ctype.h>

int main(void)
{
    int x1 = 10, y1 = 3;
    double d1 = x1 / y1;

    printf("d1 = %d\n", d1); // Burada ekrana 'd1 = 3' yazacaktÄ±r.

    int a = 5;
    int x = 3;
    double dval = 3.;

    double dval = 10 / (a == 5 ? x : d); // Buradaki 'a == 5 ? x : d' ifadesinin tÃ¼rÃ¼ 'double' tÃ¼rÃ¼dÃ¼r, iÅŸte bu bilgi bu soru iÃ§in en Ã¶nemli bilgidir. Ternary operand'Ä±n tÃ¼rÃ¼ ikinci ve Ã¼Ã§Ã¼ncÃ¼ ifadelerinin tÃ¼rlerinden en kapsayÄ±cÄ± olanÄ±nÄ±n tÃ¼rÃ¼ olacaktÄ±r.

    printf("dval = %f\n", dval); // Burada konsola 'dval = 3.3333' yazacaktÄ±r

    return 0;
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.11-12.20 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


âš ï¸ Ternary operatÃ¶rÃ¼n Ã¼rettiÄŸi deÄŸer kullanÄ±lmÄ±yorsa bu operatÃ¶r makrolar iÃ§inde veya Ã¶zel durumlar haricinde kullanÄ±lmamalÄ±dÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda **ternary operatÃ¶r**'Ã¼n hangi durumlarda kullanÄ±lmamasÄ± gerektiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 10;
    int y = 5;
    int z = 12;

    x > 10 ? ++y : ++z; // Bu kullanÄ±m tercih edilmemelidir!

    x > 1 ? printf("dogru\n") : printf("yanlis\n"); // Bu kullanÄ±m tercih edilmemelidir!
    printf("%s\n", x > 1 ? "dogru" : "yanlis"); // Bu kullanÄ±m tercih edilebilir!

    return 0;
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda **ternary operatÃ¶r**'Ä±n hangi durumlarda kullanÄ±lmamasÄ± gerektiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

void for(void);
void bar(void);

int main(void)
{
    int x = 10;

    x > 4 ? foo() : bar(); // Bu ifadenin Ã¼reteceÄŸi deÄŸer kullanÄ±lÄ±rsa her iki fonksiyondan da geriye 'void' tÃ¼rÃ¼ dÃ¶neceÄŸi iÃ§in ve 'void' tÃ¼rÃ¼ hiÃ§ bir yerde kullanÄ±lamayacaÄŸÄ± iÃ§in yanlÄ±ÅŸ olacaktÄ±r.

    // x == 5 ? (a = c) : (b = c); // Buradaki sÃ¶zde kodda olduÄŸu gibi kullanÄ±mlar kÃ¶tÃ¼ durmaktadÄ±r ve bu kullanÄ±m yerine if-else kullanÄ±lmasÄ±nÄ±n tercih edilmesi daha doÄŸru olacaktÄ±r.

    // for(int i = a > b ? 0 : 5; i < size ; ++i) // Buradaki sÃ¶zde kodda olduÄŸu gibi bazÄ± yerlerde if deyimi kullanÄ±lamayacaÄŸÄ± iÃ§in buradaki gibi bir kullanÄ±m olabilir.

    // Ä°lk deÄŸer verme iÅŸlemleri bir koÅŸula baÄŸlÄ± olarak yapÄ±lmasÄ± gerekiyorsa bu gibi durumlarda 'ternary operatÃ¶r' kullanÄ±lmasÄ± yaygÄ±ndÄ±r.

    return 0;
}
```


## Loop Statements(DÃ¶ngÃ¼ Ä°fadeleri) 


DÃ¶ngÃ¼ deyimleri bir kodu ya da kodlarÄ± koÅŸula baÄŸlÄ± olarak belirli bir defa tekrar tekrar Ã§alÄ±ÅŸtÄ±rmak iÃ§in kullanÄ±lÄ±r.

ğŸ§­ ÃœÃ§ tane dÃ¶ngÃ¼ deyimi(statement) vardÄ±r, bunlar;
1. **for** statement
2. **while** statement
3. **do while** statement


ğŸ§  C dilinde sadece tek bir dÃ¶ngÃ¼ deyimi olsaydÄ± bile bu yeterli olurdu ama yerine gÃ¶re birini ya da diÄŸer bir baÅŸkasÄ±nÄ± kullanmak kodun okunurluÄŸunu kolaylaÅŸtÄ±rabilir.

ğŸ§  BazÄ± "**Code Generator**" programlarÄ± bir programlama dilinin kaynak kodu dosyalarÄ±nÄ± Ã¼retmektedir, bu programlarÄ±n Ã¼rettiÄŸi dÃ¶ngÃ¼ deyimlerine bakÄ±lsa hep sadece tek bir dÃ¶ngÃ¼nÃ¼n kullanÄ±ldÄ±ÄŸÄ± gÃ¶rÃ¼lmesi yÃ¼ksek ihtimaldir, sonuÅŸta o dosyalar bir insanÄ±n okumasÄ± iÃ§in kaynak dosya Ã¼retmiyor.


> â” 
> 
> Sorulan soru; 
> 
> Siz kod okumak Ã¶nemli demiÅŸtiniz hangi siteleri Ã¶nerirsiniz veya hangi ÅŸeyleri Ã¶nerirsiniz?
> 
> Cevap;
> 
> Åu anda kod okumanÄ±zÄ± Ã¶nermem Ã§Ã¼nkÃ¼ ÅŸu ana kadar anlatÄ±lanlar kursun iÃ§eriÄŸinin sadece %20'lik kÄ±smÄ±, zamanla ilerleme hÄ±zÄ± artmaktadÄ±r ve belirli bir seviyede dile hakim olunduktan sonra kod okunabilir.


> â” 
> 
> Sorulan soru;
> 
> Ben de ÅŸunu soracaktÄ±m algoritmamÄ±zÄ± geliÅŸtirmek iÃ§in kendimizce kod yazmamÄ±zÄ± Ã¶nerir misiniz fakat ÅŸu ÅŸekilde mesela dizileri kullanmaya zorunda kaldÄ±ÄŸÄ±mÄ±z durumlarÄ± ama ÅŸahsen mesela diziyi bir fonksiyonla kullanÄ±yordum fonksiyona * karakteri ile veriyormuÅŸuz bunu o esnada Ã¶ÄŸrendim bu durumda sizce ilerlemeye mi bekleyelim yoksa kendimizce bir ÅŸeyler yapmaya Ã§alÄ±ÅŸalÄ±m mÄ±
> 
> Cevap;
> 
> Yine ÅŸu aÅŸamada Ã¶nermem. Åu anda Leedcode sitesindeki algoritma sorularÄ±nÄ± Ã§Ã¶zmek bir Ã§ok konu bilinmediÄŸi iÃ§in doÄŸru olmayacaktÄ±r.


### while Loop Statement 

ğŸ§­ `while (expr);`, `while (expr){ ... }` statement aÅŸaÄŸÄ±daki kÄ±sÄ±mlardan oluÅŸur;
1. **while parantezi** : KoÅŸul ifadesinin yazÄ±ldÄ±ÄŸÄ± `(expr)` parantezlerinin kapsamÄ±na verilen addÄ±r.
2. **Control expression**: `expr` sadece bir **expression(ifade)** olabilir. BoÅŸ olamaz, null deÄŸer olamaz ve bir statement(deyim) olamaz.
3. **while statement(s)**: Bir dÃ¶ngÃ¼de iÅŸletilecek olan deyimler(statement) tek satÄ±r ya da bir blok iÃ§inde olabilir ya da hiÃ§ blok olmayabilir.

ğŸ§  **while statement** parantezi iÃ§indeki **deyim(expression)** deÄŸeri **non-zero** olduÄŸu sÃ¼rece dÃ¶ngÃ¼nÃ¼n gÃ¶vdesindeki deyimin yapÄ±lmasÄ±ndan ibarettir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **while statement** kullanÄ±mÄ±nÄ± farklÄ± durumlarda gÃ¶rmek iÃ§in incelenebilir. 
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int i = 0;
    
    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda konsola 0-9 arasÄ±ndaki sayÄ±larÄ± yazar.
    while(i < 10){
        printf("%d ", i);
        ++i;
    }
    
    
    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda konsola sÃ¼rekli '0' yazacaktÄ±r, burada sonsuz dÃ¶ngÃ¼ vardÄ±r.
    i = 0;
    while(i < 10)
        printf("%d ", i);
        ++i; // Buradaki statement dÃ¶ngÃ¼ye dahil deÄŸildir.
    
    
    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda konsola 1-10 arasÄ±ndaki sayÄ±larÄ± yazar.
    i = 0;
    while(i < 10)
        printf("%d ", ++i);
    

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda konsola 1-10 arasÄ±ndaki sayÄ±larÄ± yazar.
    i = 0;
    while(i++ < 10)
        printf("%d ", i);

    
    return 0;
}
```


â” 
AÅŸaÄŸÄ±daki soru mÃ¼lakatlarda Ã§ok sÄ±k sorulan sorularda biridir ve 9/10 kiÅŸi yanlÄ±ÅŸ cevap veriyormuÅŸ, burada dikkat Ã¶nemli.
- AÅŸaÄŸÄ±daki program Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda konsola ne yazar?
- ğŸ‘‡ AÅŸaÄŸÄ±daki program detaylÄ± incelendiÄŸinde `while(i++ < 10);` statement gÃ¶rÃ¼lecektir burada sonra ';' token'Ä± var ve bu da dÃ¶ngÃ¼nÃ¼n bir statement Ã§alÄ±ÅŸtÄ±rmadan on defa dÃ¶nmesine ve en son adÄ±mda `i++` ifadesinden dolayÄ± `i`nin deÄŸerinin 11 olmasÄ±na neden olur, bundan sonra `printf("%d ", i);` statement Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r ve ekrana "11" yazar.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int i = 0;
    
    while(i++ < 10);
        printf("%d ", i);
    
    return 0;
}
```


Ders sonu ...
