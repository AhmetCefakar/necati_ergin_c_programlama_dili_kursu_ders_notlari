# 8.Ders 02.02.2025 ğŸ•˜

Derse 21(09:01)-30(09:53)-28(11:46)-26(12:24)-24(12:50) kiÅŸi katÄ±ldÄ±.

## DÃ¼n Fonksiyonlar Konusuyla Ä°lgili Ä°ÅŸlenenlerin Ã–zeti

â—â—â— Bir nesnenin(object) kendisini fonksiyona gÃ¶ndermek ile nesnenin(object) deÄŸerini fonksiyona gÃ¶ndermek arasÄ±nda fark vardÄ±r.

â—â—â— Br programlama dilinin **sÃ¶zdizimi(syntax)** baÅŸka arkaplanda iÅŸlemcinin yÃ¼rÃ¼ttÃ¼ÄŸÃ¼ komutlar baÅŸkadÄ±r, 

â—â—â— DoÄŸrudan pointer kullanÄ±mÄ± olmayan dillerde(Jaca, Python vb.) "**Call by reference(Pass by reference)**" deÄŸer aktarÄ±mÄ± programlama dilini kullanan yazÄ±lÄ±mcÄ±lardan gizlenmiÅŸtir fakat ilgili kodun derlenmesi sonrasÄ±nda Ã¼retilen **assembly** kodlarÄ±nda bir ÅŸekilde "**Call by reference(Pass by reference)**" deÄŸer aktarÄ±mÄ± yapÄ±ldÄ±ÄŸÄ± gÃ¶rÃ¼lecektir.

â—â—â— C dilinde tÃ¼m fonksiyon Ã§aÄŸrÄ±larÄ±na geÃ§ilen argÃ¼manlarÄ±n deÄŸerleri varsayÄ±lan olarak "**Call by Value(Pass by Value)**" fonksiyona gitmektedir, fakat C++ dilinde bu durum geÃ§erli olmadÄ±ÄŸÄ± durumlar vardÄ±r. C dilinde bir fonksiyona geÃ§ilen argÃ¼manlarÄ±n "**Call by reference(Pass by reference)**" olarak aktarÄ±lmasÄ± iÃ§in pointer deÄŸerlerin fonksiyona aktarÄ±lmasÄ± gerekecektir.

â—â—â— C dilindeki **pointer**'lar konusu ve **Call by reference(Pass by reference)** kullanÄ±mÄ± kursun ikinci yarÄ±sÄ±nda(ilk yarÄ± C dilinin diÄŸer programlama dilleriyle Ã§oÄŸunlukla ortak kÄ±sÄ±mlarÄ±nÄ±n iÅŸlendiÄŸi kursun ilk 70/80 saatlik kÄ±smÄ±) iÅŸlenecektir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programdan iki "int" tÃ¼rÃ¼nden deÄŸiÅŸkenin deÄŸerinin takas edilmesi iÃ§in yazÄ±lan "swap" fonksiyonu incelenebilir, buradaki **pointer** deÄŸiÅŸkenlerine kursun ikinci yarÄ±sÄ±nda deÄŸinilecektir.
```C

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

// Buradaki kod kursun ikinci bÃ¶lÃ¼mÃ¼nde derinlemesine iÅŸlenecek olan iÅŸaretÃ§iler konusuyla ilgilidir.
void swap(int* a, int* b)
{
  int temp = *a; // Buradaki '*' operatÃ¶rÃ¼ 'dereferencing' ya da 'indirection' ÅŸeklinde adlandÄ±rÄ±lÄ±r ve ilgili adresteki nesneye(object) eriÅŸmek iÃ§in kullanÄ±lÄ±r
  
  *a = *b;
  
  *b = temp;
}

int main(void)
{
  int x = 78;
  int y = 32;
  
  printf("x = %d y = %d\n", x, y);
  
  swap(&x, &y); // Buradaki '&' operatÃ¶rÃ¼ deÄŸiÅŸkenin(variable) adres deÄŸerini fonksiyona argÃ¼man olarak vermek iÃ§in kullanÄ±lÄ±yor.
  
  printf("x = %d y = %d\n", x, y);
}
```


ğŸ§  C dilinde aÅŸaÄŸÄ±daki kullanÄ±mlar mevcut deÄŸildir yani C dili onlarÄ± desteklemez.
AÅŸaÄŸÄ±daki kullanÄ±mlara destek verilmemesinin asÄ±l nedeni C dilinin ufak bir dil olma amacÄ±dÄ±r;
- "**Nested Function**" kullanÄ±mÄ±. Bunu C++ dili de desteklemez ama orada "**Lambda Expressions**" kullanÄ±mÄ± bir tÃ¼r "**Nested Function**" denilebilir.
- "**Default Argument**" kullanÄ±mÄ±. `void foo(int x, int y = 20);` bu fonksiyon tanÄ±mÄ±ndaki **y** argÃ¼manÄ± **foo** fonksiyonunun Ã§aÄŸrÄ±ldÄ± yerde verilmezse **y** deÄŸeri **20** olacaktÄ±.
- "**Function Overloading**" kullanÄ±mÄ±, C++ dili destekler.



ğŸ§­ Bir token'Ä±n tÃ¼rÃ¼ aÅŸaÄŸÄ±dakilerden biri olabilir;
- Keyword
- Indentifier
- Operator
- Consttant
- String literal
- Delimeter


## Constants(Sabitler) 

âš ï¸ Bu konu Ã§ok fazla detay iÃ§ermektedir, bu konu kapsamÄ±nda C ve C++ arasÄ±ndaki farklÄ±lÄ±klardan da bahsedilecektir. Bu baÅŸlÄ±kta anlatÄ±lanlarÄ±n hemen anlaÅŸÄ±lmasÄ± beklenmemeli, ilerleyen derslerde ve kod okudukÃ§a konudaki detaylar anlaÅŸÄ±labilir hale gelecektir.

â—C dilinde sabitler tanÄ±mlanÄ±rken "**Constant**" terimini kullanÄ±rken, C++ dilinde sabitler tanÄ±mlanÄ±rken "**Literal**" terimini kullanÄ±lmaktadÄ±r.

NasÄ±l deÄŸiÅŸkenlerin ve **ifadelerin(expression)** tÃ¼rleri varsa **sabitlerin(Constants)** de tÃ¼rleri vardÄ±r, kodlama hatalarÄ±nÄ±n Ã¶nemli bir bÃ¶lÃ¼mÃ¼ **sabitlerin(Constants)** yanlÄ±ÅŸ kullanÄ±lmasÄ±ndna kaynaklanmaktadÄ±r.



â—â—â— C dilinde aÅŸaÄŸÄ±daki varlÄ±klarÄ±n tÃ¼rleri vardÄ±r(bu bilgi Ã¶nemlidir ve unutulmamalÄ±dÄ±r);
- **Expressions(Ä°fadeler)**
- **Variables(DeÄŸiÅŸkenler)**
- **Constants(Sabitler)**


ğŸ‘‡ AÅŸaÄŸÄ±daki programdan bazÄ± ifadelerin tÃ¼rleri(expression) incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
    int x = 23; // Burada 'x' deÄŸiÅŸkeninin 'decleration type' tÃ¼rÃ¼ 'int' tÃ¼rÃ¼ndedir.
    x; // Buradaki 'x' ifadesinin(expression) tÃ¼rÃ¼ 'int' 

    char c = 'e';
    +c; // Buradaki '+c' ifadesinin(expression) tÃ¼rÃ¼ 'int' 
    c;  // Buradaki 'c' ifadesinin(expression) tÃ¼rÃ¼ C dilinde 'int', C++ dilinde 'char' olmaktadÄ±r.

    short s1 = 6, s2 = 4;
    s1 + s2; // Buradaki 's1 + s2' ifadesinin(expression) tÃ¼rÃ¼ 'int' 

    s1 > s2; // Buradaki 's1 > s2' ifadesinin(expression) tÃ¼rÃ¼ C dilinde 'int' C++ dilinde 'bool' olacaktÄ±r.


    67;  // Buradaki ifadesinin(expression) tÃ¼rÃ¼ 'int'
    67.; // Buradaki ifadesinin(expression) tÃ¼rÃ¼ 'double'
    0;   // Buradaki ifadesinin(expression) tÃ¼rÃ¼ 'int'
    0.;  // Buradaki ifadesinin(expression) tÃ¼rÃ¼ 'double'
    45u; // Buradaki ifadesinin(expression) tÃ¼rÃ¼ 'unsigned int'


    int i = 20;
    i / 3;  //  Buradaki ifadesinin(expression) tÃ¼rÃ¼ 'int'. BÃ¶lme iÅŸleminde iki ifadenin de tÃ¼rÃ¼ 'int' olunca sonuÃ§ deÄŸer 'int' olmaktadÄ±r.
    i / 3.; //  Buradaki ifadesinin(expression) tÃ¼rÃ¼ 'double'


    int z = 12345671981;
    x * z; // Buradaki ifadesinin(expression) tÃ¼rÃ¼ 'int'. Fakat burada 'ub' durumu vardÄ±r Ã§Ã¼nkÃ¼ iÅŸaretli sayÄ±larda taÅŸma tanÄ±msÄ±z davranÄ±ÅŸa neden olacaÄŸÄ± C dilinin stanardÄ±nda belirtilir.

    x * 11LL; // Buradaki ifadesinin(expression) tÃ¼rÃ¼ 'long long'
}
```


âš ï¸ **Sabitlerin(Constants)** tÃ¼rlerinin bilinmesi static tÃ¼re sahip dillerde(C, C++, Java, C#, Golang vb.) Ã¶nemlidir.



**Expression(ifade)** tÃ¼rleriyle **constant(sabit)** tÃ¼rleri aynÄ± kurallara tabi deÄŸildir.


â—â—â— C dili **Sabitleri(Constants)** iki kategoriye ayÄ±rmaktadÄ±r;
1. **Integer Constants** Types;
    1. `int` type
    2. `unsigned int` type

    3. `long` type
    4. `unsigned long` type

    5. `long long` type
    6. `unsigned long long` type

2. **Floating Constants** Types;
    1. `float` type. Sonunda **.f**. 4.5f, 45.F, 456.0F vb. kullanÄ±mlarÄ±n tÃ¼rÃ¼ `double` olacaktÄ±r.
    2. `double` type. SayÄ±nÄ±n gÃ¶steriminde sadece **.** varsa. 4.5, 45., 456.0 vb. kullanÄ±mlarÄ±n tÃ¼rÃ¼ `double` olacaktÄ±r.
    3. `long double` type. 4.5L, 45.L, 456.0L vb. kullanÄ±mlarÄ±n tÃ¼rÃ¼ `double` olacaktÄ±r.



âš ï¸ Bir sabitin tÃ¼rÃ¼ **hex/octal/decimal** olamaz, bunlar sabitin yazÄ±mÄ±nda kullanÄ±labilecek sayÄ± sistemleridir. `0xA65C`, `0xA65CL`, `0xA65Cu` gibi **sabitlerin(constant)** tÃ¼rleri yazÄ±m ÅŸeklinden anlaÅŸÄ±labilir, buradaki tÃ¼rler sÄ±rasÄ±yla, `0xA65C`: `int`, `0xA65CL`: `long`, `0xA65Cu`: `unsigned int` olacaktÄ±r.

ğŸ‘‡ AÅŸaÄŸÄ±daki programda tam sayÄ±larÄ±n farklÄ± sayÄ± tabanlarÄ±nda gÃ¶sterimi incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    int x = 2131432;

    printf("x = %d\n", x);

    x = 0x41; // Hex gÃ¶sterim

    printf("x = %d\n", x);

    x = 0Xab; // Hex gÃ¶sterim

    printf("x = %d\n", x);

    x = 035;

    printf("x = %d\n", x);
}
```



ğŸš€ Neden Ã¼Ã§ farklÄ± sayÄ± sisteminde de(octal, decimal, hexadecimal) sayÄ± yazabilme olanaÄŸÄ± saÄŸlanmÄ±ÅŸtÄ±r? 
- Bunun nedeni Ã§alÄ±ÅŸÄ±lan domain'e gÃ¶re bu farklÄ± sayÄ± sistemlerinin kullanÄ±lmasÄ±nÄ±n tercih edilmesidir. 
- Mesela gÃ¶mÃ¼lÃ¼ sistem yazÄ±lÄ±mlarÄ±nda **hexadecimal** sayÄ± sistemi yoÄŸun olarak kullanÄ±lmaktadÄ±r. 
- C dilinin standardÄ±nda ikilik tabanda sabit yazÄ±mÄ± yoktur fakat derleyiciler **extension** olarak bunun desteÄŸini verebilir.



ğŸš€ **Digit Seperator**: BÃ¼yÃ¼k sayÄ±larÄ±n daha rahat okunabilmesi iÃ§in sÄ±yÄ±nÄ±n basamaklarÄ±nÄ± ayÄ±rarak gÃ¶sterilmesini saÄŸlayan bir **convension**'dÄ±r. `int x = 787'545'703;`ÅŸeklinde bir **declaration statement** tanÄ±mlamasÄ±ndaki **'** ayÄ±raÃ§ karakteri kullanÄ±mÄ± C dili standardÄ±nda yoktur, bu kullanÄ±ma derleyiciler extension olarak destek verir genellikle ama destek vermeyede bilir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda **digit Seperator** kullanÄ±mÄ± incelenebilir
```C
#include <stdio.h>

int main(void)
{
    int x = 0b1010'0101; // Binary gÃ¶sterim, bu 'compiler extension'dÄ±r.

    printf("x = %d\n", x);

    x = 0x41'e2'4f; // Hex gÃ¶sterim

    printf("x = %d\n", x);

    x = 0123'326; // Octal gÃ¶sterim

    printf("x = %d\n", x);

    x = 745'234'547;

    printf("x = %d\n", x);
}
```


EÄŸer sabitin yazÄ±mÄ±nda sayÄ± sisteminden baÄŸÄ±msÄ±z olarak sistemdeki `int` tÃ¼rÃ¼ sÄ±nÄ±rlarÄ± iÃ§erisinde kalÄ±yorsa sabitin tÃ¼rÃ¼ `int` tÃ¼rÃ¼nden olacaktÄ±r. 
`-763` ÅŸeklinde bir sabitin deÄŸeri **763** olacaktÄ±r, buradaki **-** bir operatÃ¶rdÃ¼r. `-763` ÅŸeklinde bir **expression(ifade)**'da "-" iÅŸaret operatÃ¶rÃ¼dÃ¼r ve bu operatÃ¶rÃ¼n operandÄ± ise "763" **sabitidir(constant)**.


ğŸ§  AÅŸaÄŸÄ±da bir sabitin tÃ¼rÃ¼nÃ¼ **Integer Constants** tÃ¼rlerinden biriyle yazmak iÃ§in nasÄ±l bir kullanÄ±m yapÄ±lmasÄ± gerektiÄŸi listelenmiÅŸtir.
- Sabitin tÃ¼rÃ¼nÃ¼ `int` yapmak iÃ§in sabitin sonuna hiÃ§bir karakter yazÄ±lmaz. **345**, **-3464**, **7** vb. sabitlerin tÃ¼rÃ¼ `int` olur.
- Sabitin tÃ¼rÃ¼nÃ¼ `unsigned int` yapmak iÃ§in sabitin sonuna **u** ya da **U** karakteri eklenir. **345U**, **3464U**, **7U** vb. sabitlerin tÃ¼rÃ¼ `unsigned int` olur.
- Sabitin tÃ¼rÃ¼nÃ¼ `long` yapmak iÃ§in sabitin sonuna **l** ya da **L** eklenir. âš ï¸ ProgramcÄ±lar **l** kullanmazlar Ã§Ã¼nkÃ¼ **l** **1** karakterine benzemektedir bunun yerine **L** kullanÄ±lmasÄ± doÄŸrudur.
- Sabitin tÃ¼rÃ¼nÃ¼ `unsigned long` yapmak iÃ§in sabitin sonuna **ul**, **lu**, **UL**, **Lu** eklenir.
- Sabitin tÃ¼rÃ¼nÃ¼ `long long` yapmak iÃ§in sabitin sonuna  **ll**, **Ll**, **lL**, **LL** eklenir. 
- Sabitin tÃ¼rÃ¼nÃ¼ `unsigned long long` yapmak iÃ§in sabitin sonuna  **ull**, **ULL**, **uLl**, **LLU** vb. eklenir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda yazÄ±lan for dÃ¶ngÃ¼lerinin nasÄ±l Ã§alÄ±ÅŸacaÄŸÄ± incelenebilir. </br>
ğŸ‰ğŸ¥³ Bazen C mÃ¼lakatlarÄ±nda bu programdaki gibi dÃ¶ngÃ¼ler verilip nasÄ±l Ã§alÄ±ÅŸacaÄŸÄ± soruluyormuÅŸ.
```C
#include <stdio.h>

int main(void)
{
    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼de dÃ¶ngÃ¼ ÅŸartÄ±ndaki 'i < 9l' ifadesi 'i < 9L' ÅŸeklinde yazÄ±lmasÄ± daha okunaklÄ± olacaktÄ±r.
    for(int i = 80; i < 9l; ++i){
        printf("%d", i);
    }

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼de dÃ¶ngÃ¼ ÅŸartÄ±ndaki 'i < 015' ifadesindeki gibi baÅŸÄ±nda '0' eklendiÄŸi iÃ§in sayÄ± octal sayÄ± tabanÄ±na gÃ¶re yorumlanacaktÄ±r. 
    for(int i = 12; i < 015; ++i){
        printf("%d", i);
    }
}
```



**Floating Constants** tÃ¼rleri sadece Ã¼Ã§ farklÄ± tÃ¼rden olabilir, bunlar;
- **float type const**: Sabit nokta iÃ§eriyor ve sonunda bÃ¼yÃ¼k ya da kÃ¼Ã§Ã¼k harf "F" karakteri varsa sabitin tÃ¼rÃ¼ `float` olacaktÄ±r(`3.4F`, `4.7F`, `675.F`, `2.0f` vb.)
- **double type const**: Sabit nokta iÃ§eriyor sabitin tÃ¼rÃ¼ `double` olacaktÄ±r(`4.`, `56.0` vb.)
- **long double type const**: Sabit nokta iÃ§eriyor ve sonunda bÃ¼yÃ¼k ya da kÃ¼Ã§Ã¼k harf "L" karakteri varsa sabitin tÃ¼rÃ¼ `long double` olacaktÄ±r(`34.L`, `34.5L`) 

â— `3.` ÅŸeklinde bir sayÄ± gÃ¶steriminde sabitin tÃ¼rÃ¼ 

â— `4F` ÅŸeklinde bir sayÄ± gÃ¶sterimi hatalÄ±dÄ±r doÄŸrusu `4.F` ÅŸeklindedir.


â— Sabitlerin tÃ¼rleri C++ dilinde daha Ã¶nemlidir bunun nedeni ise C++ dilinde **function overloading** desteÄŸinden dolayÄ±dÄ±r, adlarÄ± aynÄ± olan fonksiyon Ã§aÄŸrÄ±larÄ±nda hangi fonksiyona Ã§aÄŸrÄ± yapÄ±lacaÄŸÄ± fonksiyona geÃ§ilen argÃ¼manlarÄ±n tÃ¼rlerinden tespit edildiÄŸi iÃ§in C++ dilinde **sabitlerin(constant)** tÃ¼rleri Ã¶nemliir.


ğŸ§  **Floating Constants** gÃ¶steriminde aÅŸaÄŸÄ±daki gibi iki tÃ¼r gÃ¶sterim tÃ¼rÃ¼ vardÄ±r;
1. Fixed Natation. **3.234342**, **23.42**, **4534.65L** vb. ÅŸeklindeki gÃ¶sterimleri ifade eder.
2. Scientific Notation. **3.234342e2**, **7.234342E2**, **4.234342e-3**, vb. ÅŸeklindeki gÃ¶sterimleri ifade eder.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.26-10.45 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


## Character Literals(Karakter Sabitleri) 

C dilinde karakter **sabitleri(Constants)** int tÃ¼rÃ¼nden **sabitlerin(Constants)** Ã¶zel bir yazÄ±m biÃ§imidir. 'c', '\n', '\x12', `\023` vb. gÃ¶sterimler tek bir karakteri ifade eder.
C++ dilinde karakter **sabitleri(Constants)** `char` tÃ¼rÃ¼ndendir.


1. Bilgisayarlarda iÅŸletim sisteminin de destek verdiÄŸi birden fazla **Character Encoding(Karakter KodlamasÄ±)** seti vardÄ±r. Kurs boyunca **ASCII(128 karakter var)** karakter seti kullanÄ±lacaktÄ±r. Karakter setlerinde olan her bir karakter bir tam sayÄ± ile temsil edilir. 
2. Karakter setinde olan her bir karakter bir tam sayÄ± ile ifade edilir. Karakter setinde her bir karakterin temsil edildiÄŸi numaralara **Character Code(Coding Plane)** denilmektedir. Karakter kodlarÄ±nÄ±n gÃ¶steriminde daha Ã§ok hexedecimal gÃ¶sterim kullanÄ±lÄ±r.
3. KullanÄ±lan karakter tablosundaki karakterlerin nasÄ±l tutulacaÄŸÄ± sorusu mÃ¼hÃ¼mdir ve kullanÄ±lan **Character Encoding(Karakter KodlamasÄ±)** setinin ne olduÄŸuna gÃ¶re deÄŸiÅŸecektir. **Character Encoding(Karakter KodlamasÄ±)** setindeki her karakter ikilik sayÄ± sisteminde nasÄ±l tutulacaÄŸÄ±na karar vermek gerekecektir. Unicode 4 byte'ta kadar karakter iÃ§ermektedir fakat bu kodlamadaki kurallar ile **ASCII** karakter tablosundaki karakterler 1 byte alan kaplayacak ÅŸekilde tutulur ve baÅŸka karakterler ya 2 byte ya 3 byte ya da 4 byte alan kaplayabiliyor, kÄ±saca Unicode kodlamada her bir karakter 4 byte yer kaplamaz. Kurala gÃ¶re bir karakter 1 byte, 2 byte, 3 byte, 4 byte yer kaplayacak ÅŸekilde bir sistem kullanÄ±lmaktadÄ±r(bu yapÄ±yÄ± ayrÄ±ca araÅŸtÄ±rmak gerekiyor, bu kurta detaylarÄ±na deÄŸinilemeyecek kadar detaylÄ±dÄ±r).
4. Kurs boyunca kullanÄ±lacak olan **Character Code(Coding Plane)** **ASCII** olacak. **ASCII** kodlamada kÃ¼Ã§Ã¼k ve bÃ¼yÃ¼k harflerin kodlamasÄ±nda bÃ¼yÃ¼k/kÃ¼Ã§Ã¼k karakterler arasÄ±nda geÃ§iÅŸlerin kolay olabilmesi iÃ§in bÃ¼yÃ¼k alfabe karakterlerinin bitiminden sonra hemen kÃ¼Ã§Ã¼k alfabe karakterleri baÅŸlamaz arada 6 karakter fark bÄ±rakÄ±lmÄ±ÅŸtÄ±r, bunun nedeni tek bir bit deÄŸiÅŸtirilerek bÃ¼yÃ¼k/kÃ¼Ã§Ã¼k harfler arasÄ±nda geÃ§iÅŸin kolayca yapÄ±labilmesidir. Ä°ngiliz alfabesinde 26 tane harf vardÄ±r ve arada 6 tane fark bÄ±rakÄ±ldÄ±ÄŸÄ± iÃ§in "26 + 6 = 32" kadar fark oluÅŸmaktadÄ±r bu da mesela 'A' ile 'a' arasÄ±nda dÃ¶nÃ¼ÅŸÃ¼mÃ¼n sadece 5. bitin 0'dan 1'e Ã§evrilmesiyle kolayca yapÄ±labileceÄŸi anlamÄ±na gelir.

    ğŸ§­ **ASCII** karkter kodlamada rakam karakterleri aÅŸaÄŸÄ±daki bigi kodlanmÄ±ÅŸtÄ±r;
    - 48 0x30 0011'0000 --> '0'
    - 49 0x31 0011'0001 --> '1'
    - 50 0x32 0011'0010 --> '2'
    - 51 0x33 0011'0011 --> '3'
    - 52 0x34 0011'0100 --> '4'
    - 53 0x35 0011'0101 --> '5'
    - 54 0x36 0011'0110 --> '6'
    - 55 0x37 0011'0111 --> '7'
    - 56 0x38 0011'1000 --> '8'
    - 57 0x39 0011'1001 --> '9'

5. **ASCII** karakter kÃ¼mesindeki karakterler aÅŸaÄŸÄ±daki gibi gruplanÄ±r;
- **Alphabetic characters(Harf karakterleri)**
- **Numeric characters(Rakam karakterleri)**
- **Alphanumeric characters(Harf veya Rakam karakterleri)**
- **Control characters(GÃ¶rÃ¼ntÃ¼sÃ¼ olmayan karakterlerlerdir)**: Ä°lk 32 karakter([0-31] kapalÄ± aralÄ±ÄŸÄ±ndaki deÄŸere sahip karakterlerdir) ve 127. karakterler bu gruba girer
- **Printable/graphic characters(YazdÄ±rÄ±labilir/grafig karakterlerleri)**: Control karakteri olmayan ve bir gÃ¶rÃ¼ntÃ¼sÃ¼ olan karakterlerdir.
- **Punctuation characters**: GÃ¶rÃ¼ntÃ¼sÃ¼ olan ve Alphanumeric olmayan karakterlerdir. `.`, `=`, `!`, `-`, `;`, `?` vb. karakterler bu gruba girer.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **ASCII** karakter kodlamasÄ±ndaki tÃ¼m karakterler programÄ±n Ã§alÄ±ÅŸtÄ±rÄ±labilir dosyasÄ±nÄ±n Ã¼retildikten sonra Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ± dizine kaydedilecektir, bu dosyadan karakterleri ve kodlarÄ± incelenebilir.
```C
#include <stdio.h>
#include <ctype.h>

int main(void) 
{
    File* f = fopen("chars.txt", "w");

    for(int i = 0; i < 128; ++i){
        if(iscntrl(i))
            fprintf(f, "%3d     kontrol karakteri\n", i);
        else
            fprintf(f, "%3d     %c", i, i);
    }

    fclose(f);
}
```


ğŸ‘‡ AÅŸaÄŸÄ±daki programda **ASCII** karakterlerin bazÄ±larÄ±nÄ±n nasÄ±l int tÃ¼rÃ¼ne atandÄ±ÄŸÄ± ve bunlarÄ±n onluk tabandaki rakamsal karÅŸÄ±lÄ±klarÄ± incelenebilir.
```C
#include <stdio.h>
#include <ctype.h>

int main(void) 
{
    int c1 = '+';
    int c2 = '!';
    int c3 = '.';
    int c4 = '6';

    printf("c1 = %d\n", c1);
    printf("c2 = %d\n", c2);
    printf("c3 = %d\n", c3);
    printf("c4 = %d\n", c4);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki gibi bÃ¼yÃ¼k harf 'A' karakterini yazmak iÃ§in kullanÄ±lan doÄŸrudan `65` rakamÄ±nÄ±n kullanÄ±lmasÄ±yla `A` karakterinin kullanÄ±lmasÄ± arasÄ±nda ne gibi bir farklÄ±lÄ±k vardÄ±r diye C mÃ¼lakatlarÄ±nda sorulabiliyormuÅŸ, buradaki cevap Ã§ok aÃ§Ä±k eÄŸer karakterin sayÄ±sal kodu kullanÄ±lÄ±rsa C programÄ±nÄ±n Ã§alÄ±ÅŸacaÄŸÄ± karakter kodlamasÄ± deÄŸiÅŸtirildiÄŸinde sorun yaÅŸanÄ±r o nedenle doÄŸrudan kullanÄ±lan karakterin yazÄ±lmasÄ± doÄŸru olacaktÄ±r Ã§Ã¼nkÃ¼ **ASCII** dÄ±ÅŸÄ±ndaki bir karakter kodlamasÄ±nda 65 rakamÄ± 'A' karakterine karÅŸÄ±lÄ±k gelmeyebilir.
```C
#include <stdio.h>
#include <ctype.h>

int main(void) 
{
    int upper_a = 65; // Bu kullanÄ±m tercih edilmemelidir.
    int upper_a = 'A'; // Bu kullanÄ±m tercih edilmelidir.
}
```



â—â—â— TÃ¼m karakter kodlamalarÄ±nda rakam karakterleri sÄ±ralÄ± olacak ÅŸekilde seÃ§ilmektedir fakat harf karakterleri sÄ±ralÄ± olmayabilir.

`'0' + 5;` ifadesinin rakamsal sonucu '5' karakterine karÅŸÄ±lÄ±k gelecektir.



**Escape Sequence**: Genel olarak bir karakter kodlamada bir karaktere Ã¶zel bir anlam biÃ§ilmiÅŸse yani kendi olarak deÄŸil de onun dÄ±ÅŸÄ±nda bir mana ifade ediyorsa bÃ¶yle karakterler bu ÅŸekilde nitelenir.
- '\0' -> Null character
- '\a' -> Alert
- '\n' -> Newline
- '\r' -> Carriage return
- '\b' -> Back space(geri boÅŸluk)
- '\t' -> Horizontal tab
- '\f' -> Form feed, daha Ã§ok printer(yazÄ±cÄ±)'larÄ± ilgilendiren bir karaktermiÅŸ.
- '\v' -> Vertical tab
- '\\' -> Backslash
- '\'' -> Single quote
- '"'  -> Double quote
- '\"' -> Double quote
- '\?' -> Question mark
- '?'  -> Question mark


ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki **escape sequence** karakterleri incelenebilir.
```C
#include <stdio.h>
#include <ctype.h>

int main(void) 
{
    printf("%d\n", '\0'); // Null character
    printf("%d\n", '\n'); // Newline
    printf("%d\n", '\t'); // Horizontal tab
    printf("%d\n", '\v'); // Vertical tab
    printf("%d\n", '\a'); // Alert
    printf("%d\n", '\r'); // Carriage return
    printf("%d\n", '\b'); // Back space(geri boÅŸluk)
    printf("%d\n", '\f'); // Form feed
    printf("%d\n", '\\'); // Backslash
    printf("%d\n", '\''); // Single quote
    printf("%d\n", '"'); // Double quote
    printf("%d\n", '\"'); // Double quote
    printf("%d\n", '?'); // Question mark
    printf("%d\n", '\?'); // Question mark
}
```


C dilinin standardÄ±nda aÅŸaÄŸÄ±daki ÅŸekillerdeki gÃ¶sterimler sabit `int` tÃ¼rÃ¼nden kabul edilir, C dilinde karakter sabitleri aÅŸaÄŸÄ±daki ÅŸekillerde yazÄ±labilir;
- 'A', 'r' gibi ASCI code alfabetik karakterler.
- '\0', '\a', '\n' gibi "**escape sequence**" karakterler.
- '\x1ab3f6d', '\x2B1F' gibi hex sayÄ±lar(buradaki kullanÄ±mdaki 'x' kÃ¼Ã§Ã¼k farf olmak zorundadÄ±r yoksa santaksa uygun olmayacaktÄ±r).
- '\01734', '\0273' gibi octal sayÄ±lar.



ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki gibi karakter sabitler incelenebilir.
```C
#include <stdio.h>
#include <ctype.h>

int main(void) 
{
    int x = '\0x1b';
    x = '\n';
    x = '\xaa';
}
```


Bir sayÄ± farklÄ± sayÄ± tabanlarÄ±nda yazdÄ±rmak istendiÄŸinde bu iÅŸleme "**Formatting Output**" denilmektedir. </br>
Åu kullanÄ±mlar ile bir sayÄ±nÄ±n deÄŸeri farklÄ± sayÄ± tabanlarÄ±nda yazdÄ±rÄ±labilmektedir: 
- '\d'(ondalÄ±k)
- '\x'(hexadecimal) 
- '\X'(hexadecimal) 
- '\o'(octal)

âš ï¸ "**Formatting Output**" konusu en Ã¶nemli konulardan biridir.


ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki en ÅŸekilde sade "**formatting output**" nasÄ±l alÄ±nÄ±yor incelenebilir.
```C
#include <stdio.h>
#include <ctype.h>

int main(void) 
{
    int x = 983520;

    printf("decimal %d\n", x);
    printf("hex     %x\n", x);
    printf("HEX     %X\n", x);
    printf("octal   %o\n", x);
}
```


## C Standart Library 


â— C dilinin standart kÃ¼tÃ¼phanesi demek, C dili tarafÄ±ndan bize sunulmuÅŸ olan Ã¶ÄŸelerin oluÅŸturduÄŸu bir kÃ¼medir.

â— C dilinin standart kÃ¼tÃ¼phanesi sadece fonksiyonlardan oluÅŸmamaktadÄ±r, fonksiyonlar dÄ±ÅŸÄ±nda baÅŸka Ã¶ÄŸeler de vardÄ±r. 

â— C dilinin standart kÃ¼tÃ¼phane ile birlikte hazÄ±r gelen fonksiyonlara "**Standard C Functions**" denilmektedir. 

â— C dilinin standart kÃ¼tÃ¼phanesinin ne olduÄŸunu tanÄ±mlayan nedir diye dÃ¼ÅŸÃ¼nÃ¼lÃ¼rse bunun cevabÄ± "**C Dilinin Standart Belgesi(DokÃ¼manÄ±)**" olacaktÄ±r, bu belge iÃ§erisinde derleyicilerin tam olarak neyi yapmalarÄ±/saÄŸlamalarÄ± gerektiÄŸinin bilgileri yeralÄ±r.

â— "**C Dilinin Standart Belgesindeki(DokÃ¼manÄ±)**" "Library" baÅŸlÄ±ÄŸÄ± altÄ±nda C dilinin standart kÃ¼tÃ¼phanesinin ne olduÄŸu belirtilmektedir. 

â— C derleyicilerini yazanlar bu belgedeki gerekli olarak belirtilen her Ã¶ÄŸeyi oluÅŸturlar ki tam bir "**C Standart(Draft) Implementation**" yapmÄ±ÅŸ olsunlar.

â— C standardÄ±nÄ±n **Implementation**'larÄ±nÄ± **Compiler** geliÅŸtirenler yapmaktadÄ±r.


â—â—â— **C Standart Library** bÃ¼nyesinde yer alan Ã¶ÄŸeler ÅŸunlardÄ±r;
- **Standard C Functions** : C standard kÃ¼tÃ¼phanesinin Ã§oÄŸunluÄŸunu fonksiyonlardan oluÅŸmaktadÄ±r.
- **Marcos** : Ã–n iÅŸlemci programa(Preprocessing Program) tanÄ±tÄ±lan adlardÄ±r. Makro olan Ã¶ÄŸelerin simleri bir kural olarak deÄŸil ama "**conventional**" olarak tamamÄ± bÃ¼yÃ¼k harfle yazÄ±lÄ±r.
   - **Object like macro**
   - **Function like macro**
- **User-defined data types**
- **Type alias(TÃ¼r eÅŸ adlarÄ±)(int32_t, int16_t vb.)**


âš ï¸ C dilinin standardÄ±nda "iÅŸaret(mark, sign)" ÅŸeklinde bir tanÄ±m yoktur. '_' ÅŸeklinde bir varlÄ±ÄŸÄ± belirtmek iÃ§in **character** terimi kullanÄ±lmalÄ±dÄ±r.


> 
> â— Neden standart kÃ¼tÃ¼phane var?
> 
> **Standart Library**'in olmasÄ±nÄ±n saÄŸladÄ±ÄŸÄ± faydalar aÅŸaÄŸÄ±daki gibidir;
> 
> 1. **Portability(TaÅŸÄ±nabilirlik)**: YazÄ±lmÄ±ÅŸ bir kodun farklÄ± **Implementation(Derleyici gerÃ§ekleÅŸtirimi)**'lar arasÄ±nda geÃ§iÅŸ yapÄ±ldÄ±ÄŸÄ±nda kodlarÄ±n aynÄ± ÅŸekilde Ã§alÄ±ÅŸacaÄŸÄ±ndan emin olunmasÄ±nÄ± saÄŸlar. AyrÄ±ca derleyicileri geliÅŸtirenler aynÄ± kodun farklÄ± iÅŸletim sistemlerinde Ã§alÄ±ÅŸabilmesi iÃ§in yapÄ±lmasÄ± gereken iÅŸletim sistemi Ã§aÄŸrÄ±larÄ±nÄ± bizim yerimize oluÅŸturacak ÅŸekilde derleyicileri geliÅŸtirirler, bu da dilin standardÄ±na uyularak yazÄ±lacak kodlarÄ±n iÅŸletim sistemlerinden baÄŸÄ±msÄ±z olarak bir Ã§ok iÅŸletim sisteminde ve bir Ã§ok mikroiÅŸlemci Ã¼zerinde Ã§alÄ±ÅŸacak ÅŸekilde taÅŸÄ±nabilir olmasÄ±nÄ± saÄŸlayacaktÄ±r.
> 
> 2. **Common Interface(Ortak ArayÃ¼z)**: C standardÄ±nda ÅŸu varlÄ±klarÄ±n nasÄ±l olmasÄ± gerektiÄŸi belirtilmektedir: fonksiyonlar, mecro(makrolar), type alias, User-defined data types.
Bir yazÄ±lÄ±m dilindeki **Standart Library** kullanÄ±ldÄ±ÄŸÄ±nda herkes tarafÄ±ndan ne iÅŸ yaptÄ±ÄŸÄ± bilinen dilin Ã¶ÄŸeleri belirlenmiÅŸ olur ve bu ÅŸekilde **Common Interface** oluÅŸturulmuÅŸ olur ve bu oluÅŸabilecek karÄ±ÅŸÄ±klÄ±klarÄ± ortadan kaldÄ±rÄ±lmÄ±ÅŸ olur.
> 
> 3. HazÄ±r yazÄ±lmÄ±ÅŸ yapÄ±larÄ± kullanÄ±m kolaylÄ±ÄŸÄ±: **C Standart Library** bÃ¼nyesinde bulunan hazÄ±r yapÄ±lar bizi o yapÄ±larÄ± yazmak zahmetinden kurtarÄ±r, mesela **C Standart Library**'nin saÄŸladÄ±ÄŸÄ± matematiksel iÅŸlemlerin yapÄ±lmasÄ±nÄ± saÄŸlayan bir kÃ¼tÃ¼phanenin olmasÄ± bizi matematiksel iÅŸlemleri yapmak iÃ§in kullanÄ±lan varlÄ±klarÄ± yazma zahmetinden kurtarÄ±r.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.06-12.15 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


â—â—â— C dilini bilmek demek C dilinin **Standart Library**'sinin bilinmesi gerektiÄŸi anlamÄ±na geliyor.

ğŸ§­ **Standart Library**'deki her ÅŸey aynÄ± seviyede Ã¶nemli deÄŸildir;
1. Ä°lk kategori bilinmelidir(90/100 civarÄ±ndaki standard C fonksiyonu detaylÄ± bilinmelidir diyebiliriz, bunlar kurs geneline yayÄ±lacak ÅŸekilde anlatÄ±lmaktadÄ±r) 
2. Ä°kinci kategori bilinse iyi olur
3. ÃœÃ§Ã¼ncÃ¼ kategori bilinmesi gerekmeyen ama ihtiyaÃ§ olduÄŸunda dokÃ¼manlarÄ± araÅŸtÄ±rÄ±p kullanÄ±labilecek durumda olunmasÄ± gerekir.


## C Standart Library printf ve scanf FonksiyonlarÄ± 


**input/output** fonksiyonlarÄ± olan `printf` ve `scanf` fonksiyonlarÄ±nÄ±n sonundaki **f** harfi **formating** anlamÄ±na gelmektedir, bu fonksiyonlarÄ±n detaylarÄ±nÄ±n anlaÅŸÄ±lmasÄ± dÃ¼ÅŸÃ¼nÃ¼ldÃ¼ÄŸÃ¼nden daha zordur.

**Program**: YazÄ±lmÄ±ÅŸ olan bir kod Ã¶beÄŸinin diskte yer alan haline verilen addÄ±r.

**Process**: Ã–zellikle bir iÅŸletim sistemi altÄ±nda Ã§alÄ±ÅŸmakta olan bir programa verilen addÄ±r.

**Input Stream**: DÄ±ÅŸarÄ±dan bir **process**'e doÄŸru gelen(akan) byte'larÄ±(0, 1 dizileri) ifade etmek iÃ§in kullanÄ±lan terimdir. 

**Output Stream**: Bir **process**'ten dÄ±ÅŸarÄ±ya doÄŸru giden(akan) byte'larÄ±(0, 1 dizileri) ifade etmek iÃ§in kullanÄ±lan terimdir.


Bir program Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda Ã¼Ã§ tane **stream** varsayÄ±lan olarak oluÅŸturulur, buna **Standart Stream** denir ve tÃ¼rleri aÅŸaÄŸÄ±daki gibidir.
1. **Standart Input Stream(Standart Input)** DeÄŸiÅŸiklik yapÄ±lmadÄ±ysa varsayÄ±lan olarak klavye baÄŸlÄ±dÄ±r.
  AÅŸaÄŸÄ±daki C standart fonksiyonlarÄ±, **Standart Input Stream** fonksiyonlarÄ±nÄ±n bir kÄ±smÄ±dÄ±r;
  - scanf
  - fscanf
  - sscand
  - getchar
  - fgetc
  - fread
2. **Standart Output Stream(Standart Output)** deÄŸiÅŸiklik yapÄ±lmadÄ±ysa varsayÄ±lan olarak ekrana baÄŸlÄ±dÄ±r.
  AÅŸaÄŸÄ±daki C standart fonksiyonlarÄ±, **Standart Output Stream** fonksiyonlarÄ±nÄ±n bir kÄ±smÄ±dÄ±r;
  - printf
  - fprintf
  - sprintf
  - snprintf
  - putchar
  - puts
  - fwrite
3. **Standart Error Stream(Error Output)** 


ğŸš€ **stdio** kÃ¼tÃ¼phanesinin adÄ± "**Standart Input Output**" tanÄ±mÄ±nÄ±n kÄ±saltmasÄ±dÄ±r.


>â”
> 
> SorduÄŸum soru;
>   
> AÅŸaÄŸÄ±daki "Stream" tÃ¼rleri dÄ±ÅŸÄ±nda baÅŸka "Stream" tÃ¼rÃ¼ olabiliyor mu? 
> 1. Standart Input Stream(Standart Input)
> 2. Standart Output Stream(Standart Output)
> 3. Standart Error Stream(Error Output)
> 
> Cevap;
> 
> Olabilir ama bunlar standart olan stream'lerdir bunlar dÄ±ÅŸÄ±nda baÅŸka stream tÃ¼rleri de olabilir.



âš ï¸âš ï¸âš ï¸ C ve C++ Ã¶ÄŸrenmeye baÅŸlayanlar ilk baÅŸta `#include <stdio.h>` dosyasÄ± iÃ§erisinde `printf()` fonksiyonu gibi fonksiyonlarÄ±n **tanÄ±mÄ±nÄ±n(definition implementation)** olduÄŸunu dÃ¼ÅŸÃ¼nÃ¼r fakat bu **.h** dosyalarÄ±nda sadece fonksiyonlarÄ±n **bildirimleri(declaration, prototip)** bulunmaktadÄ±r. 
Peki fonksiyonlarÄ±n **tanÄ±mlarÄ±(gÃ¶vdeleri)** nerede diye sorulacaktÄ±r.
Bunun cevabÄ± ÅŸudur: **.h** dosyalarÄ±nda yer alan fonksiyonlarÄ±n kodlarÄ± Ã¶nceden yazÄ±lmÄ±ÅŸ ve derlenip object dosyalarÄ± Ã¼retilmiÅŸtir. 
Yani **.h** dosyalarÄ±nda aÃ§Ä±k ÅŸekilde fonksiyonlarÄ±n **tanÄ±mlarÄ±(gÃ¶vdeleri)** yazmaz.
**.h** dosyalarÄ±nda yer alan fonksiyonlarÄ±n Ã§aÄŸrÄ±larÄ± en son **linking** aÅŸamasÄ±nda **linker program** tarafÄ±ndan object dosyalarÄ± ile baÄŸlanmaktadÄ±r. 
Bu konu Ã¶nemli ve detaylÄ±dÄ±r, ilerleyen derslerde ayrÄ±ntÄ±larÄ±na deÄŸinilecektir.



â—â—â— **Output** tÃ¼rleri aÅŸaÄŸÄ±daki gibi iki tÃ¼re ayrÄ±lmaktadÄ±r;
1. **Formatted Output**: Ä°nsanlar tarafÄ±ndan okunabilir olan karakterlerin Ã§Ä±ktÄ± olarak oluÅŸturulmasÄ±na verilen addÄ±r. Bu iÅŸlem maliyetlidir. AyrÄ±ca hangi sisteme gÃ¶re formatlama iÅŸleminin yapÄ±lacaÄŸÄ± da formatlÄ± Ã§Ä±kÄ±ÅŸ iÅŸlemini yapmak iÃ§in yapÄ±lmasÄ± gereken iÅŸlemci seviyesindeki iÅŸlem adÄ±mlarÄ±nÄ±n sayÄ±sÄ±nÄ± etkilemektedir(kÄ±saca iÅŸlem maliyetini etkiler).
2. **Unformatted Output**: Bellekteki byte dizileri Ã¼zerinde herhangi bir iÅŸlem yapÄ±lmasÄ±na gerek olmadan bellekteki haliyle 0 ve 1 dizilerinin dÄ±ÅŸarÄ±ya gÃ¶nderilmesi iÅŸlemidir.

ğŸ§  FormatlÄ± Ã§Ä±ktÄ±nÄ±n maliyeti formatsÄ±z Ã§Ä±kÄ±ÅŸÄ±n maliyetinden daha yÃ¼ksektir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programdakine benzer iÅŸlemler "**formatted output**" olarak Ã§Ä±ktÄ± oluÅŸturma iÅŸlemlerinde kullanÄ±lmaktadÄ±r, buradan da neden "**formatted output**" maliyetli olduÄŸu anlaÅŸÄ±labilir.
```C
#include <stdio.h>

int main(void) 
{
    int x = 983520;

    int temp = x;

    // AÅŸaÄŸÄ±daki dÃ¶ngÃ¼ ile yazdÄ±rÄ±lan Ã§Ä±ktÄ±nÄ±n rakamsal karakterleri tersten elde edilebiliyor ama bunlarÄ±n Ã§Ä±ktÄ± olarak verilmeden Ã¶nce tere Ã§evrilmesi gerekmektedir, burada sadece temsili bir iÅŸlem yapÄ±lmÄ±ÅŸtÄ±r, 'formatted output' tam olarak bu deÄŸil ama buradakine benzer iÅŸlemler yapÄ±lÄ±yor.
    while(temp != 0){
        // Bir sayÄ±nÄ±n ona bÃ¶lÃ¼mÃ¼nden kalanÄ± tespit edince birler basamaÄŸÄ±nÄ±n deÄŸerini elde ederiz, bu deÄŸer ile '0' karakterinin kodunu toplarsak o sayÄ±nÄ±n karakter kod deÄŸerini elde ederiz(bunun nedeni tÃ¼m karakter kodlama sistemlerinde 0-9 arasÄ±ndaki sayÄ± karakterlerinin kodlarÄ±nÄ±n sÄ±ralÄ± olmasÄ±nÄ±n kesin olmasÄ±dÄ±r)
        putchar(temp % 10 + '0'); 

        temp /= 10; // Bu iÅŸlem ile 'temp' sayÄ±sÄ±nÄ±n birler basamaÄŸÄ± sayÄ±dan atÄ±lmaktadÄ±r.
    }
}
```



ğŸ§  Bir tam sayÄ± tÃ¼rÃ¼nÃ¼n **formatlÄ± Ã§Ä±ktÄ±(formatted output)** oluÅŸturma iÅŸleminde aÅŸaÄŸÄ±daki gibi ÅŸeylere karar vermek gerekebilmektedir;
- Hangi sayÄ± sistemi kullanÄ±lmalÄ±?
- Ã–nek olsun mu olmasÄ±n mÄ±(`0x1CAF` vb.)?
- 16 tabanÄ±nda gÃ¶sterilecekse basamak rakamlarÄ± bÃ¼yÃ¼k harf mi olmalÄ± yoksa kÃ¼Ã§Ã¼k harf mi olmalÄ±?
- Pozitif deÄŸerler iÃ§in '+' karakteri yazÄ±lsÄ±n mÄ±?
- **Output with**: Bu format iÅŸlemi "**Yazma alanÄ± geniÅŸliÄŸi**" olarak adlandÄ±rÄ±lÄ±r. YazdÄ±rÄ±lacak yazÄ±nÄ±n kaÃ§ karakterlik alanÄ± kaplayacaÄŸÄ±, saÄŸa mÄ± sola mÄ± dayalÄ± olarak yazdÄ±rma iÅŸleminin yapÄ±lacaÄŸÄ±. **fill character** olarak hangi karakter kullanÄ±lacaÄŸÄ± gibi bir Ã§ok formatlama iÅŸlemi mevcuttur.


AÅŸaÄŸÄ±da bazÄ± formatlÄ± Ã§Ä±ktÄ±lar gÃ¶sterilmiÅŸtir;

Sola dayalÄ± ÅŸekilde ve boÅŸluklu olarak aÅŸaÄŸÄ±daki gibi formatlÄ± olarak rakam ve yazÄ±larÄ± yazdÄ±rÄ±lmasÄ±
1. 35902     ad1 soyad1 
2. 32902     ad2 soyad2

Sola dayalÄ± ÅŸekilde ve boÅŸluk olan yerle `_` olacak ÅŸekilde aÅŸaÄŸÄ±daki gibi formatlÄ± olarak rakam ve yazÄ±larÄ±n yazdÄ±rÄ±lmasÄ±
1. 35902____ ad1 soyad1 
2. 25952____ ad2 soyad2

Sola dayalÄ± ÅŸekilde ve boÅŸluk olan yerle `$` olacak ÅŸekilde aÅŸaÄŸÄ±daki gibi formatlÄ± olarak rakam ve yazÄ±larÄ±n yazdÄ±rÄ±lmasÄ±
1. 62970$$$$ ad1 soyad1 
2. 20459$$$$ ad2 soyad2


SonuÃ§ olarak formatlÄ± Ã§Ä±ktÄ± Ã¼retme Ã§ok yÃ¶nlÃ¼ bir iÅŸlem, bir Ã§ok farklÄ± formatlama yÃ¶ntemi(yaklaÅŸÄ±mÄ±) mevcuttur, bu nedenle anlaÅŸÄ±lmasÄ± zamana yayÄ±lmalÄ±dÄ±r.


Ders sonu ...
