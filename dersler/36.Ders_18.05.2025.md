# 36.Ders 18.05.2025 ğŸ•˜

Derse 10(09:01)-11(09:04)-12(09:07)-13(09:08)-12(09:41)-13(09:49)-12(10:01)-11(10:19)-12(10:29)-13(10:40)-12(11:01)-12(12:03)-11(12:47) kiÅŸi katÄ±ldÄ±.
---

## void Pointers Devam


â—â—â— Primitive tÃ¼rden nesnelerin(pointer nesnelerde bu gruba dahildir) bellek bloklarÄ±nÄ±n byte byte o nesnenin bir yerden baÅŸka yere kopyalanmasÄ± iÅŸlemi her zaman doÄŸru Ã§alÄ±ÅŸacaktÄ±r ama **user defined type** varlÄ±klar ile Ã§alÄ±ÅŸÄ±rken bÃ¶yle bir kesinlik yoktur.

â—â—â— **Generic Function**'larÄ±n `void*` tÃ¼rÃ¼nden parametreleri tanÄ±msÄ±z davranÄ±ÅŸ riski olmadan `char*`, `signed char*`, `unsigned char*` tÃ¼rlerine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lerek kullanÄ±labilir.



ğŸ§­ BugÃ¼nkÃ¼ derste C standart kÃ¼tÃ¼phenesinda olan beÅŸ tane standart **generic fonksiyonlarÄ±nÄ±** inceleyeceÄŸiz, bu **generic fonksiyonlarÄ±** kendi yazacaÄŸÄ±mÄ±z **generic fonksiyonlarda** kullanacaÄŸÄ±z, bu nedenle iyi bilinmelidir, kendi yazacaÄŸÄ±mÄ±z **generic fonksiyonlarda** iÅŸlemlerin bir kÄ±smÄ±nÄ± bu fonksiyonlarla birlikte yapacaÄŸÄ±z.
- `memset`
- `memcpy`
- `memmove`
- `memchr`
- `memcmp`



ğŸ‘‡ AÅŸaÄŸÄ±daki programda herhangi bir tÃ¼rden diziyi ters Ã§eviren `greverse` adlÄ± **generic fonksiyonun** nasÄ±l yazÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

#define SIZE    20

// AÅŸaÄŸÄ±daki fonksiyon generic olarak bir diziyi ters Ã§evirme iÅŸini yapmaktadÄ±r.
// vpa  : Ters Ã§evrilecek olan dizinin adresi
// size : Dizinin uzunluÄŸu(dizinin eleman sayÄ±sÄ±)
// sz   : Dizinin bir elemanÄ±nÄ±n kaÃ§ byte olduÄŸu bilgisi
void greverse(void* vpa, size_t size, size_t sz)
{
    char* p = (char*)vpa;

    for(size_t i = 0; i < size /2; ++i){
        // Dizinin baÅŸtan ve sondan elemanlarÄ±nÄ± takas etmek iÃ§in ÅŸu ÅŸekilde dizi elemanlarÄ±nÄ± tespit etmek gerekirdi => p[i]   p[size - 1 - i]
        // AÅŸaÄŸÄ±da pointer aritmetiÄŸi ve ters Ã§evrilecek olan dizinin tek bir elemanÄ±nÄ±n byte bÃ¼yÃ¼klÃ¼ÄŸÃ¼ bilindiÄŸinde aÅŸaÄŸÄ±daki gibi diziyinin baÅŸtan ve sondan elemanlarÄ±nÄ± takas edebiliriz.
        gswap(p + i * sz, p + (size - 1 - i) * sz, sz);
    }
}

int main(void)
{
    int a[SIZE];
    
    randomize();
    set_array_random(a, SIZE);
    print_array(a, SIZE);
    greverse(a, SIZE, sizeof(int));
    print_array(a, SIZE);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda herhangi bir tÃ¼rden diziyi ters Ã§eviren `greverse` adlÄ± **generic fonksiyonun** nasÄ±l yazÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include "nutility.h"

#define SIZE    20

// AÅŸaÄŸÄ±daki fonksiyon generic olarak bir diziyi ters Ã§evirme iÅŸini yapmaktadÄ±r.
// vpa  : Ters Ã§evrilecek olan dizinin adresi
// size : Dizinin uzunluÄŸu(eleman sayÄ±sÄ±)
// sz   : Dizinin bir elemanÄ±nÄ±n kaÃ§ byte olduÄŸu bilgisi
void greverse(void* vpa, size_t size, size_t sz)
{
    char* p = (char*)vpa; // 

    for(size_t i = 0; i < size /2; ++i){
        // Dizinin baÅŸtan ve sondan elemanlarÄ±nÄ± takas etmek iÃ§in ÅŸu ÅŸekilde dizi elemanlarÄ±nÄ± tespit etmek gerekirdi => p[i]   p[size - 1 - i]
        // AÅŸaÄŸÄ±da pointer aritmetiÄŸi ve ters Ã§evrilecek olan dizinin tek bir elemanÄ±nÄ±n byte bÃ¼yÃ¼klÃ¼ÄŸÃ¼ bilindiÄŸinde aÅŸaÄŸÄ±daki gibi diziyinin baÅŸtan ve sondan elemanlarÄ±nÄ± takas edebiliriz.
        gswap(p + i * sz, p + (size -1 - i) * sz, sz);
    }
}

int main(void)
{
    double a[] = { 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8 };
    
    greverse(a, asize(a), sizeof(double));

    for(size_t i = 0; i < size; ++i){
        printf("%f \n", a[i]);
    }
}
```


### `string.h` BaÅŸlÄ±k dosyasÄ± Generic FonksiyonlarÄ± 


ğŸ§­ AÅŸaÄŸÄ±daki fonksiyonlarÄ±n baÅŸlÄ±k dosyasÄ± `string.h` ama bu baÅŸlÄ±k dosyasÄ±ndaki ÅŸu fonksiyonlar yazÄ±lar ya da baÅŸka tÃ¼rden nesneler ile kullanÄ±labilen fonksiyonlardÄ±r;
- `memset`: Fonksiyon adÄ± "**Memory Set**". Bir bellek bloÄŸunun her bir byte'Ä±nÄ± bir tam sayÄ± deÄŸeriyle doldurur(set ediyor).
- `memcpy`: Fonksiyon adÄ± "**Memory Copy**". Bir bellek bloÄŸunu bir yerden baÅŸka bir yere kopyalar.
- `memmove`: Fonksiyon adÄ± "**Memory Move**". Bir bellek bloÄŸunu bir yerden baÅŸka bir yere kopyalar. 
- `memchr`: Fonksiyon adÄ± "**Memory Chare**". Bir bellek bloÄŸunda bir byte'Ä±n deÄŸerini aramak iÃ§in kullanÄ±lÄ±yor.
- `memcmp`: Fonksiyon adÄ± "**Memory Compare**". Ä°ki bellek bloÄŸunu karÅŸÄ±laÅŸtÄ±rÄ±yor.


ğŸš€ `strcpy`, `strchr`, `strcmp` adlÄ± yazÄ±larla kullanÄ±lan fonksiyonlardÄ±r ile `memcpy`, `memchr`, `memcmp` byte'lar Ã¼zerinde iÅŸlem yapan **generic fonksiyonlardÄ±r**, bu fonksiyonlarÄ±n adlarÄ±nÄ±n sonlarÄ± aynÄ±dÄ±r ama bu fonkaiyonlardan hangilerinin kullanÄ±lacaÄŸÄ± kullanÄ±m yerine gÃ¶re deÄŸiÅŸiklik gÃ¶sterecektir. Mesela yazÄ±larla iÅŸlem yaparken **Null terminated byte stream** dizilerle Ã§alÄ±ÅŸÄ±rken `memcpy`, `memchr`, `memcmp` fonksiyonlarÄ±nÄ±n kullanÄ±mÄ±na dikkat edilmesi gerekecektir.


#### `memset` Generic Fonksiyonu 



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `memset` fonksiyonu kullanÄ±mÄ± hankkÄ±nda bilgi edinilebilir.
```C
#include <stdio.h>
#include <string.h> // 'memset' fonksiyonu bu baÅŸlÄ±k dosyasÄ±nda bulunuyor.
#include "nutility.h"

#define SIZE    20

// 'memset' fonksiyonu bir bellek bloÄŸunun her bir byte'Ä±nÄ± bir tam sayÄ± deÄŸeriyle doldurur.
// AÅŸaÄŸÄ±da 'memset' fonksiyonunun prototipi incelenebilir.
// vp  : Byte'larÄ± set edilecek bellek bloÄŸunun adresinin deÄŸeri.
// val : Her bir byte'ta yazÄ±lacak tam sayÄ± deÄŸeri.
// sz  : Bellek bloÄŸunun toplamda kaÃ§ byte olduÄŸu bilgisi.
// Return value: Bellek bloÄŸundaki her bir byte'Ä± set edilen nesnenin adres deÄŸeri.
// void* memset(void* vp, int val, size_t sz);

int main(void)
{
    int x = 246343;

    printf("x = %d\n", x);

    memset(&x, 0, sizeof x); // 'x' nesnesinin deÄŸeri 0 yapÄ±lÄ±yor Ã§Ã¼nkÃ¼ nesnenin tÃ¼m byte'larÄ±na 0 deÄŸeri yazÄ±lÄ±yor.

    printf("x = %d\n", x);
}
```


â—â—â— **To Clear a Memory Block**: Bir bellek bloÄŸunun tÃ¼m bitlerinin sÄ±fÄ±r yapÄ±lmasÄ±dÄ±r. Bu iÅŸlemi yapmak iÃ§in `memset` fonksiyonu kullanÄ±labilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `memset` fonksiyonu ile `int` tÃ¼rÃ¼nden bir nesnenin tÃ¼m byte'larÄ±na 255 deÄŸeri atandÄ±ÄŸÄ±nda ilgili nesnenin deÄŸerinin ne olacaÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    20

int main(void)
{
    int x = 246343;

    printf("x = %d\n", x);

    memset(&x, 255, sizeof x); // 'x' nesnesinin tÃ¼m bitleri "1" yapÄ±lÄ±yor. 'x' nesnesinin tÃ¼rÃ¼ 'int' olduÄŸu iÃ§in iÅŸaretli bir tam sayÄ± tÃ¼rÃ¼ ve bu durumda tÃ¼m bitler 1 olur ve bu da '-1' deÄŸerine karÅŸÄ±lÄ±k gelir.

    printf("x = %d\n", x);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `memset` fonksiyonu ile `int` tÃ¼rÃ¼nden bir nesnenin tÃ¼m byte'larÄ±na 1 deÄŸeri atandÄ±ÄŸÄ±nda ilgili nesnenin deÄŸerinin ne olacaÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    20

int main(void)
{
    int x = 246343;

    printf("x = %d\n", x);

    memset(&x, 1, sizeof x); // 'x' nesnesinin tÃ¼m byte deÄŸerlei "0000'0001" yapÄ±lÄ±yor.

    printf("x = %d\n", x);
}
```




ğŸ‘‡ AÅŸaÄŸÄ±daki programda `memset` generic fonksiyonunun **gerÃ§ekleÅŸtiriminin(implementation)** nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#include <stdio.h>
//#include <string.h>
#include "nutility.h"

#define SIZE    20

// Kendi yazdÄ±ÄŸÄ±mÄ±z 'my_memset' fonksiyonu 'memset' fonksiyonunun yaptÄ±ÄŸÄ± iÅŸin aynÄ±sÄ±nÄ± yapan bir gerÃ§ekleÅŸtirimdir. 
// vp  : Byte'larÄ± set edilecek bellek bloÄŸunun adresinin deÄŸeri.
// val : Her bir byte'ta yazÄ±lacak tam sayÄ± deÄŸeri.
// sz  : Bellek bloÄŸunun toplamda kaÃ§ byte olduÄŸu bilgisi.
void* my_memset(void* vp, int val, size_t sz)
{
    char* p = (char*)vp;

    while(sz--)
        *p++ =(char)val;

    return vp;
}

int main(void)
{
    int x = 246343;

    printf("x = %d\n", x);

    memset(&x, 1, sizeof x); // 'x' nesnesinin tÃ¼m byte deÄŸerleri "0000'0001" yapÄ±lÄ±yor.

    printf("x = %d\n", x);
}
```


>â”
> 
> Sorulan soru; 
> 
> byte duzeyinde nasil butun bitleri ayni anda set edebiliyor? Low-level bir dilin teker teker bitleri set etmesi/kopyalamasi gerekmez mi?
> 
> Cevap;
> 
> HayÄ±r, `memset` fonksiyonu bitler Ã¼zerinde iÅŸlem yapmÄ±yor, byte'lar Ã¼zerinde iÅŸlem yapmaktadÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki program `memset` fonksiyonu kullanÄ±larak `"aaaabbbbccccdddd"` karakter dizisinin ÅŸu yazÄ±ya `"aaaaXXXXccccdddd"` nasÄ±l Ã§evrildiÄŸini anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>
#include <string.h>
#include "nutility.h"

int main(void)
{
    char str[] = "aaaabbbbccccdddd";
    puts(str);
    memset(str + 4, 'X', 4);
    puts(str);
    
    // AÅŸaÄŸÄ±da yazÄ±nÄ±n son dÃ¶rt karakterinin '!' yapÄ±lmak istenmiÅŸtir, burada bir hata olursa dÃ¼zelt
    memset(str + asize(str) - 1 - 4, '!', 4);
    puts(str);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir `int` dizinin tÃ¼m elemanlarÄ±nÄ±n deÄŸerinin "0" yapmak iÃ§in `memset` fonksiyonunun nasÄ±l kullanÄ±lacaÄŸÄ± incelenebilir.
```C
#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    100

int main(void)
{
    int ar[SIZE];

    randomize();
    set_array_random(ar, SIZE);
    print_array(ar, SIZE);

    // memset(ar, 0, SIZE * sizeof(int)); // Buradaki 'memset' fonksiyon Ã§aÄŸrÄ±sÄ± aÅŸaÄŸÄ±daki fonksiyon Ã§aÄŸrÄ±sÄ±yla aynÄ±dÄ±r.
    memset(ar, 0, sizeof ar);

    print_array(ar, SIZE);
}
```


#### `memcpy` Generic Fonksiyonu 

`memcpy` fonksiyonu bir bellek bloÄŸunu baÅŸka bir bellek bloÄŸuna kopyamak iÃ§in kullanÄ±lÄ±r. </br>
`memcpy` fonksiyonu kopyaladÄ±ÄŸÄ± nesnenin tÃ¼rÃ¼nÃ¼ bilmez yani bu bilgiden habersizdir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `memcpy` generic fonksiyonunun prototipi incelenebilir ve en temel haliyle `memcpy` fonksiyonunun nasÄ±l kullanÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    20

// 'memcpy' fonksiyonu bir bellek bloÄŸunun tÃ¼m byte'larÄ±nÄ± birinci parametreye adresi gÃ¶nderilen bloÄŸa kopyalar.
// AÅŸaÄŸÄ±da 'memset' fonksiyonunun prototipi incelenebilir.
// vpdest       : Kopyalama yapÄ±lacak olan bellek bloÄŸunun adresi.
// vpsource     : Kopyalanacak kaynak verinin blunduÄŸu nesnenin adresi.
// sz           : KaÃ§ byte kopyalanacaÄŸÄ± bilgisi.
// Return value : DeÄŸer kopyalama yapÄ±lan nesnenin adres deÄŸeri('vpsource' adresi geriye dÃ¶nÃ¼lÃ¼r).
void* c_memcpy(void* vpdest, const void* vpsource, size_t sz);

int main(void)
{
    double d1 = 124.3534323;
    double d2;

    // AÅŸaÄŸÄ±daki iki kod satÄ±rÄ± da sonuÃ§ olarak aynÄ± iÅŸlemi yapmaktadÄ±r(yani 'd1' deÄŸiÅŸkeninin deÄŸerini 'd2' deÄŸiÅŸkenine atamaktadÄ±r)
    //d2 = d1;
    memcpy(&d2, &d1, sizeof(double));

    printf("d1 = %f\n", d1);
    printf("d2 = %f\n", d2);
}
```


âš ï¸ Standard C fonksiyonlarÄ± ile yapÄ±labilecek iÅŸlemler iÃ§in kod yazÄ±lmamalÄ±dÄ±r, hazÄ±r olan fonksiyonlar kullanÄ±lmalÄ±dÄ±r, bu ÅŸekilde programÄ±n daha kolay okunmasÄ±, programÄ±n daha kolay deÄŸiÅŸtirilebilir olmasÄ± saÄŸlanmÄ±ÅŸ olur.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `int` tÃ¼rÃ¼nden bir dizinin nasÄ±l baÅŸka bir diziye kopyalanabildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    100

void* c_memcpy(void* vpdest, const void* vpsource, size_t sz);

int main(void)
{
    int a[SIZE];
    int b[SIZE];

    randomize();
    set_array_random(a, SIZE);
    print_array(a, SIZE);

    memcpy(b, a, sizeof a);
    print_array(b, SIZE);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir diziden baÅŸka bir diziye dizilerin belirli indekslerinden baÅŸlayarak belirli sayÄ±da dizi elemanÄ±nÄ±n nasÄ±l kopyalanabileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    100

void* c_memcpy(void* vpdest, const void* vpsource, size_t sz);

int main(void)
{
    int a[SIZE];
    int b[SIZE] = { 0 };

    randomize();
    set_array_random(a, SIZE);
    print_array(a, SIZE);

    int idx_a, idx_b, n;

    printf("a disinde hangi indeksten baslayarak? : ");
    scanf("%d", &idx_a);

    printf("b disinde hangi indeksten baslayarak? : ");
    scanf("%d", &idx_b);

    printf("kac eleman kopyalansin: ");
    scanf("%d", &n);

    memcpy(b + idx_b, a + idx_a, n * sizeof(int));

    print_array(a, SIZE);
    print_array(b, SIZE);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `memcpy` generic fonksiyonunun **gerÃ§ekleÅŸtiriminin(implementation)** nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    100

// 'memcpy' fonksiyonu bir bellek bloÄŸunun tÃ¼m byte'larÄ±nÄ± birinci parametreye adresi gÃ¶nderilen bloÄŸa kopyalar.
// AÅŸaÄŸÄ±da 'memset' fonksiyonunun prototipi incelenebilir.
// vpdest       : Kopyalama yapÄ±lacak olan bellek bloÄŸunun adresi.
// vpsource     : Kopyalanacak kaynak verinin blunduÄŸu nesnenin adresi.
// sz           : KaÃ§ byte kopyalanacaÄŸÄ± bilgisi.
// Return value : DeÄŸer kopyalama yapÄ±lan nesnenin adres deÄŸeri('vpsource' adresi geriye dÃ¶nÃ¼lÃ¼r).
void* c_memcpy(void* vpdest, const void* vpsource, size_t sz)
{
    // 'void*' pointer tÃ¼rÃ¼ pointer aripmetiÄŸinde kullanÄ±lamayacaÄŸÄ±na gÃ¶re bu tÃ¼rleri 'byte' tÃ¼rÃ¼nÃ¼ tesil edebilecek olan bir tÃ¼r olan 'char' tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rÃ¼yoruz.
    char* pdest = (char*)vpdest;
    const void* psource = (const void*)vpsource;

    while(sz--)
        *pdest++ = *psource++;

    return vpdest;
}

int main(void)
{
    int a[SIZE];
    int b[SIZE];

    randomize();
    set_array_random(a, SIZE);
    print_array(a, SIZE);

    int idx_a, idx_b, n;

    printf("a disinde hangi indeksten baslayarak? : ");
    scanf("%d", &idx_a);

    printf("b disinde hangi indeksten baslayarak? : ");
    scanf("%d", &idx_b);

    printf("kac eleman kopyalansin: ");
    scanf("%d", &n);

    c_memcpy(b + idx_b, a + idx_a, n * sizeof(int));

    print_array(a, SIZE);
    print_array(b, SIZE);
}
```


âš ï¸âš ï¸âš ï¸ `const Type` tÃ¼rÃ¼nden `Type` tÃ¼rÃ¼ne yapÄ±lan aÃ§Ä±ktan(explicit) tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mleri doÄŸrudan **ub** deÄŸildir, **ub** olmasÄ± iÃ§in tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapÄ±lan `const` nesnenin deÄŸerinin deÄŸiÅŸtirilmesi gerekir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `memcpy` fonksiyonu ile karakter dizilerinin(yani yazÄ±larÄ±n) belirli kÄ±sÄ±mlarÄ±nÄ±n nasÄ±l kopyalanabileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    20

int main(void)
{
    char s1[] = "AAAABBBBCCCC";
    char s2[] = "XXXXYYYYWWWW";

    puts(s1);
    puts(s2);

    memcpy(s2 + 4, s1 + 4, 4);

    puts(s1);
    puts(s2);


    memcpy(s2 + 8, s1, 4);

    puts(s1);
    puts(s2);
}
```


âš ï¸ Bundan sonrasÄ±nÄ± anlayabilmek iÃ§in `string` fonkisyonlar konusunda anlatÄ±lanlarÄ±n hatÄ±rlanmasÄ± gerekecektir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda "**Overlapped**" durumundan dolayÄ±, `strcpy` fonksiyonunun nasÄ±l "**ub**" oluÅŸturacak ÅŸekilde kullanÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    100

int main(void)
{
    char str[SIZE] = "sevcan";

    strcpy(str + 3, str); // Burada yapÄ±lan iÅŸlem 'Overlapped' bloklar Ã¼zerinde iÅŸlem yapÄ±ldÄ±ÄŸÄ± iÃ§in burada 'ub' vardÄ±r.

    puts(str);
}
```


ğŸš€ **Overlapped bellek bloklarÄ±**: Ä°ÅŸlem yapÄ±lan iki farklÄ± gÃ¶stericinin adres deÄŸerleri aynÄ±ysa ya da dizilerle Ã§alÄ±ÅŸÄ±lÄ±rken dizilerin adresleri kesiÅŸiyorsa oluÅŸan bu duruma verilen isimdir.



ğŸš€ **restrict anahtar sÃ¶zcÃ¼ÄŸÃ¼**: Bu anahtar sÃ¶zcÃ¼k kullanÄ±larak aynÄ± fonksiyona gÃ¶nderilen pointer parametrelerin deÄŸerlerinin aynÄ± olmayacaÄŸÄ± ya da bellek bloklarÄ±nÄ±n Ã§akÄ±ÅŸmayacaÄŸÄ±na dair bir kesinlik olduÄŸu belirtilmiÅŸ olur, bu bilgiyi derleyici kullanÄ±r ve bu bilgiyi daha iyi ÅŸekilde makine kodunun Ã¼retilmesi saÄŸlanmÄ±ÅŸ olur.


`restrict` anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n kullanÄ±lmasÄ± sadece derleyiciye yardÄ±m eden bir bildirimdir, `restrict` paramentreleri olan fonksiyonlara **Overlapped bellek bloklarÄ±** olmayan adres deÄŸerine sahip argÃ¼manlarÄ±n geÃ§ilmesi sorumluluÄŸu o fonksiyonlara Ã§aÄŸrÄ± yapacak olan koddadÄ±r.


### `memmove` Generic Fonksiyonu 

`memcpy` ve `memmove` fonksiyonlarÄ± temelde aynÄ± iÅŸi yapmaktadÄ±r ve bildirimleri Ã§ok benzerdir, aradaki fark `memcpy` fonksiyonunun **Overlapped bellek bloklarÄ±** Ã¼zerindeki davranÄ±ÅŸÄ±nÄ±n tanÄ±msÄ±z olmasÄ±, `memmove` fonksiyonunun **Overlapped bellek bloklarÄ±** Ã¼zerindeki davranÄ±ÅŸÄ±nÄ±n tanÄ±mlÄ± olmasÄ±dÄ±r.

`memcpy` ve `memmove` fonksiyonlarÄ±nÄ±n prototype'larÄ± C99 standardÄ±nda aÅŸaÄŸÄ±daki gibidir;
- `void* memcpy(void* restrict vpdest, const void* restrict vpsource, size_t sz);`
- `void* memmove(void* vpdest, const void* vpsource, size_t sz);`



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `memmove` fonksiyonu ile **Overlapped bellek bloklarÄ±** Ã¼zerindeki kopyalama iÅŸleminin "**ub**" olmaksÄ±zÄ±n nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    100

int main(void)
{
    char str[SIZE] = "sevcan";
    memmove(str + 3, str, strlen(str) + 1); // Bu fonksiyon Ã§aÄŸrÄ±sÄ±ndaki son argÃ¼manÄ±n 'strlen(str) + 1' sonundaki '+ 1'in nedeni yazÄ±nÄ±n '\0' karakterini de kopyalayabilmek iÃ§indir.

    puts(str);
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `memcpy` ve `memmove` fonksiyonlarÄ±nÄ±n kullanÄ±mÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    100

int main(void)
{
    int a[SIZE];

    randomize();
    set_array_random(a, SIZE);
    print_array(a, SIZE);

    memcpy(a + 20, a, 40 * sizeof(int)); // Bu fonksiyon Ã§aÄŸrÄ±sÄ± 'ub'ye neden olur.

    memmove(a + 20, a, 40 * sizeof(int)); // Bu fonksiyon Ã§aÄŸrÄ±sÄ±nda 'ub' yoktur.
}
```


âš ï¸ `memmove` fonksiyonunun **gerÃ§ekleÅŸtirimi(implementation)** bu derste yazÄ±lmayacak, baÅŸka bir derste gÃ¶sterilecekmiÅŸ.


ğŸ§  `memmove` fonksiyonu genellikle ÅŸu ÅŸekilde tanÄ±mlanmaktadÄ±r;
- Adresler bÃ¼yÃ¼klÃ¼k kÃ¼Ã§Ã¼klÃ¼k karÅŸÄ±laÅŸtÄ±rmasÄ±na sokuluyor, bÃ¶ylece kopyalamanÄ±n yÃ¶nÃ¼ belirleniyor(**Overlapped bellek bloklarÄ±** olduÄŸunda kopyalama baÅŸtan sona doÄŸru mu yoksa sondan baÅŸa doÄŸru mu olmalÄ± o belirleniyor).


### memchr Generic Fonksiyonu 

`strchr` fonksiyonu bir yazÄ±da bir karakter arÄ±yor, `memchr` fonksiyonu bir bellek bloÄŸunda bir byte arÄ±yor yani yazÄ± aramak zorunlu deÄŸil. </br>
`memchr` fonksiyonunun adÄ± "**Memory Character**" sÃ¶zcÃ¼klerinin kÄ±saltmasÄ±ndan geliyor.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `memchr` fonksiyonunun bildirimi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    100

// 'memchr' fonksiyonu bir bellek bloÄŸunun iÃ§inde bir byte'Ä± aramak iÃ§in kullanÄ±lÄ±yor, bu fonksiyon bir yazÄ±da bir karakter aramak iÃ§in de kullanÄ±labilir.
// AÅŸaÄŸÄ±da 'memchr' fonksiyonunun prototipi incelenebilir.
// vp              : Ä°Ã§inde arama yapÄ±lacak bellek bloÄŸunun adresi(baÅŸlangÄ±Ã§ adresi).
// val             : Aranacak deÄŸer.
// sz              : Ä°Ã§inde arama yapÄ±lacak bellek bloÄŸunun bÃ¼yÃ¼klÃ¼ÄŸÃ¼(byte olarak).
// Return value    : AranÄ±lan deÄŸer bulunursa ilk bulunan deÄŸerin dizideki adresi, eÄŸer bulunamazsa NULL pointer deÄŸer geriye dÃ¶necektir.
// void* memchr(const void* vp, int val, size_t sz);

int main(void)
{
    unsigned char buf[] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 1, 1, 1};

    unsigned char* p = (unsigned char*) memchr(buf, 9, sizeof buf);

    if(p)
        printf("bulundu idx = %d\n", p - buf);
    else
        printf("bulunamadÄ±\n");
}
```


>â”
> 
> Sorulan soru; 
> 
> YukarÄ±daki soruyla ilgili bir soru.
> byte byte ariyor dediniz, char gibi 1 bytetan degil de int ten olussaydi peki
> 
> Cevap;
> 
> `int` tÃ¼rÃ¼ 4 byte'lÄ±k bloklarda tutulan ayrÄ± bir formatta veri olduÄŸu iÃ§in `memchr` fonksiyonu ile `int` tÃ¼rÃ¼ aranamaz, `memchr` fonksiyonu ile sadece bir byte'lÄ±k bir deÄŸer aranabilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir yazÄ±nÄ±n ortasÄ±ndan baÅŸlayÄ±p `memchr` fonksiyonu ile nasÄ±l bir karakterin aranabileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    100

// void* memchr(const void* vp, int val, size_t sz);

int main(void)
{
    char str[] = "necati cavit selin ayhan";

    char* p = (char*)memchr(str + 6, 'a', 10);

    if(p){
        printf("bulundu idx = %d\n", p - str);
        puts(p);
    }
}
```


>â”
> 
> Sorulan soru; 
> 
> Demek istedigim int veya baska bir boyutta olsa byte byte bakip birsey donebilir miydi?
> 
> Cevap;
> 
> DÃ¶nmeye dÃ¶nersiniz ama onun bir anlamÄ± olmaz, mesela `int` tÃ¼rÃ¼nde 0 deÄŸerini `memchr` ile aratÄ±lsa `int` tÃ¼rÃ¼nden nesnenin byte'larÄ±ndan biri 0 ise onun adresini dÃ¶necektir ama bu adres deÄŸeri bir iÅŸe yaramayacaktÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `memchr` generic fonksiyonunun **gerÃ§ekleÅŸtiriminin(implementation)** nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    100

// 'memchr' fonksiyonu bir bellek bloÄŸunun iÃ§inde bir byte'Ä± aramak iÃ§in kullanÄ±lÄ±yor, bu fonksiyon bir yazÄ±da bir karakter aramak iÃ§in de kullanÄ±labilir.
// AÅŸaÄŸÄ±da 'memchr' fonksiyonunun prototipi incelenebilir.
// vp              : Ä°Ã§inde arama yapÄ±lacak bellek bloÄŸunun adresi(baÅŸlangÄ±Ã§ adresi).
// val             : Aranacak deÄŸer.
// sz              : Ä°Ã§inde arama yapÄ±lacak bellek bloÄŸunun bÃ¼yÃ¼klÃ¼ÄŸÃ¼(byte olarak).
// Return value    : AranÄ±lan deÄŸer bulunursa ilk bulunan deÄŸerin dizideki adresi, eÄŸer bulunamazsa NULL pointer deÄŸer geriye dÃ¶necektir.
void* c_memchr(const void* vp, int val, size_t sz)
{
    const char* p = (const char*) vp;

    while(sz--){
        if(*p == val)
            return (Char*) p;
        ++p;
    }

    return NULL;
}

int main(void)
{
    char str[] = "necati cavit selin ayhan";

    char* p = (char*)c_memchr(str + 6, 'a', 10);

    if(p){
        printf("bulundu idx = %d\n", p - str);
        puts(p);
    }
}
```


### `memcmp` Generic Fonksiyonu 

Bizi zorlayacak bir fonksiyon. </br>
`strcmp` fonksiyonu "**lexicographical compare**" yÃ¶ntemine gÃ¶re iki yazÄ±yÄ± karÅŸÄ±laÅŸtÄ±rÄ±p birinci parametre bÃ¼yÃ¼kse pozitif deÄŸer, ikinci parametre bÃ¼yÃ¼kse negatif deÄŸer ve iki yazÄ± eÅŸitse "0" deÄŸerini dÃ¶ndÃ¼rmektedir. </br>
`strcmp` fonksiyonundaki karÅŸÄ±laÅŸtÄ±rma yaklaÅŸÄ±mÄ± bir Ã§ok yerde karÅŸÄ±mÄ±za Ã§Ä±kacaÄŸÄ± iÃ§in iyi bilinmesi Ã¶nemlidir. </br>
`memcmp` fonksiyonu kendisine gÃ¶nderilen iki pointer deÄŸiÅŸkeni byte byte karÅŸÄ±laÅŸtÄ±rmaktadÄ±r, bu karÅŸÄ±laÅŸtÄ±rma "**lexicographical compare**" yÃ¶ntemine gÃ¶re yapÄ±lmaktadÄ±r. </br>

`strcmp` ve `memcmp` fonksiyonlarÄ±nÄ±n bildirimleri aÅŸaÄŸÄ±daki gibidir;
- `strcmp(const char* p1, const char *p2);`
- `memcmp(const void* p1, const void *p2, size_t sz);`


`memcmp` fonksiyonu ile aÅŸaÄŸÄ±daki gibi iki bellek bloÄŸunun karÅŸÄ±laÅŸtÄ±rmasÄ± yapÄ±ldÄ±ÄŸÄ±nda ilk bellek bloÄŸundaki Ã¼Ã§Ã¼ncÃ¼ byte deÄŸeri daha bÃ¼yÃ¼k olduÄŸu tespit edileceÄŸi iÃ§in geriye pozitif bir deÄŸer dÃ¶ndÃ¼rÃ¼lecektir.

| Ä°lk parametre deÄŸeri | Ä°kinci parametre deÄŸeri |
|:--------------------:|:-----------------------:|
|1001'0001             |   1001'0001             |
|0001'0000             |   0001'0000             |
|1111'0001             |   1000'0000             |
|1001'0001             |   1001'0001             |


**Endianness(Big-Endian & Little-Endian)**: TanÄ±mÄ± ya buraya



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `memcpy` fonksiyonu ile iki `int` tÃ¼rÃ¼nden deÄŸiÅŸkenin byte byte karÅŸÄ±laÅŸtÄ±rmasÄ±nÄ±n nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir, buradaki karÅŸÄ±laÅŸtÄ±rma iÅŸaretli tam sayÄ± olarak karÅŸÄ±laÅŸtÄ±rma iÅŸlemi deÄŸildir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    100

int main(void)
{
    int x = 134658;
    int y = -524658;

    int ret = memcpy(&x, &y, sizeof(int));

    if(ret > 0){
        printf("%d > %d\n", x, y);
    }
    else if(ret < 0){
        printf("%d < %d\n", x, y);
    }
    else{
        printf("%d = %d\n", x, y);
    }
}
```


> â”
> Sorulan soru
> Ä°kisi float olsa tolerans mevzusu gundeme gelir mi, yoksa esitligi tespit edebilir mi?
>
> Cevap;
>
> Sadece iki float sayÄ±nÄ±n tÃ¼m bitleri aynÄ±ysa eÅŸitlik karÅŸÄ±laÅŸtÄ±rmasÄ±nda kullanÄ±labilir ama tek bitte bile veri kaybÄ± olmuÅŸsa eÅŸitlik bozulacaktÄ±r. </br>
> OnladÄ±klÄ± sayÄ±larda **not a number** bir deÄŸer var bunun iÃ§in baÅŸka bir karÅŸÄ±laÅŸtÄ±rma yapÄ±lmasÄ± gerekiyor, baÅŸka bir derste buna deÄŸinilebilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `memcpy` fonksiyonu ile iki int tÃ¼rÃ¼nden deÄŸiÅŸkenin byte byte karÅŸÄ±laÅŸtÄ±rmasÄ±nÄ±n nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir, buradaki karÅŸÄ±laÅŸtÄ±rma iÅŸaretli tam sayÄ± olarak karÅŸÄ±laÅŸtÄ±rma iÅŸlemi deÄŸildir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    100

int main(void)
{
    int x = -1;
    int y = 1;

    int ret = memcpy(&x, &y, sizeof(int));

    if(ret > 0){
        printf("%d > %d\n", x, y);
    }
    else if(ret < 0){
        printf("%d < %d\n", x, y);
    }
    else{
        printf("%d = %d\n", x, y);
    }
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki farklÄ± dizinin elemanlarÄ±nÄ±n eÅŸitlik karÅŸÄ±laÅŸtÄ±rmasÄ±nÄ±n `memcmp` fonksiyonuyla nasÄ±l yapÄ±ldÄ±ÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    10

int main(void)
{
    int a[SIZE];
    int b[SIZE];

    randomize();
    set_array_random(a, SIZE);
    memcmp(b, a, sizeof a);

    if(!memcmp(a, b, sizeof a))
        printf("evet esit");
    else 
        printf("hayi esit degil");

    a[3]++;
    
    if(!memcmp(a, b, sizeof a))
        printf("evet esit");
    else 
        printf("hayi esit degil");
}
```


â—â—â— `memcmp` fonksiyonu ile tek byte'a sÄ±ÄŸan karakter kodlamalarÄ±nda yapÄ±lan karÅŸÄ±laÅŸtÄ±rmalar "**lexicographical compare**" yÃ¶ntemine gÃ¶re yapÄ±lacaktÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda yazÄ±larÄ±n `memcmp` fonksiyonuyla belirli bir kÄ±sÄ±mlarÄ±nÄ±n nasÄ±l karÅŸÄ±laÅŸtÄ±rÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    10

int main(void)
{
    char s1[] = "ahmet ergin aksoy";
    char s2[] = "cettin ersoy turhan";

    if(memcmp(s1 + 6, s2 + 7, 5) < 0)
        printf("dogru\n");    
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 11.01-11.21 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `memcmp` generic fonksiyonunun **gerÃ§ekleÅŸtiriminin(implementation)** nasÄ±l yapÄ±ldÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include "nutility.h"

#define SIZE    100

// 'memcmp' fonksiyonu kendisine gÃ¶nderilen iki pointer deÄŸiÅŸkeni byte byte karÅŸÄ±laÅŸtÄ±rmaktadÄ±r, bu karÅŸÄ±laÅŸtÄ±rma 'lexicographical compare' yÃ¶ntemine gÃ¶re yapÄ±lmaktadÄ±r.
// AÅŸaÄŸÄ±da 'memcmp' fonksiyonunun prototipi incelenebilir.
// vp1             : KarÅŸÄ±laÅŸtÄ±rma yapÄ±lacak birinci bellek bloÄŸunun adresi.
// vp2             : KarÅŸÄ±laÅŸtÄ±rma yapÄ±lacak ikinci bellek bloÄŸunun adresi.
// sz              : KarÅŸÄ±laÅŸtÄ±rma yapÄ±lacak bellek bloÄŸunun bÃ¼yÃ¼klÃ¼ÄŸÃ¼(byte olarak).
// return value    : 'lexicographical compare' yÃ¶ntemine gÃ¶re karÅŸÄ±laÅŸtÄ±rma yapÄ±lÄ±r. Ä°lk parametrenin deÄŸeri bÃ¼yÃ¼kse pozitif, kÃ¼Ã§Ã¼kse negatif, iki pointer'Ä±n gÃ¶sterdiÄŸi nesnelerin byte deÄŸerleri eÅŸitse '0' deÄŸeri dÃ¶ndÃ¼rÃ¼lÃ¼r.
int memcmp(const void* vp1, const void* vp2, size_t sz)
{
    // C dilinin standardÄ±nda 'memcmp' fonksiyonunun karÅŸÄ±laÅŸtÄ±rma yapÄ±lacak 'void*' pointerlarÄ±n 'unsigned char*' tÃ¼rÃ¼ne Ã§evrilerek iÅŸlem yapÄ±lmasÄ±nÄ± belirtmektedir.
    const unsigned char* p1 = (const unsigned char*)vp1;
    const unsigned char* p2 = (const unsigned char*)vp2;

    while(sz--){
        if(*p1 != *p2)
            return *p1 > *p2 ? 1 : -1;
        ++p1, ++p2;
    }

    return 0;
}

int main(void)
{
    
}
```



ğŸ§­ Åu ana kadar `string.h` baÅŸlÄ±k dosyasÄ±ndaki bellek Ã¼zerindeki byte deÄŸerleri ile iÅŸlem yapan "**memory**" sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n kÄ±saltmasÄ± olan "**mem**" ile baÅŸlayan beÅŸ adet fonksiyon aÅŸaÄŸÄ±daki gibidir;
- `memset`: Bir bellek bloÄŸunun her bir byte'Ä±nÄ± bir tam sayÄ± deÄŸeriyle doldurur(set ediyor).
- `memcpy`: Bir bellek bloÄŸunu bir yerden baÅŸka bir yere kopyalar.
- `memmove`: Bir bellek bloÄŸunu bir yerden baÅŸka bir yere kopyalar. 
- `memchr`: Bir bellek bloÄŸunda bir byte'Ä±n deÄŸerini aramak iÃ§in kullanÄ±lÄ±yor.
- `memcmp`: Ä°ki bellek bloÄŸunu karÅŸÄ±laÅŸtÄ±rÄ±yor.


âš ï¸ Åu andan itibaren konunun yarÄ±sÄ±nÄ± tamamladÄ±k ve konular biraz daha zorlaÅŸacak.



Bir dizide "**lineer search(doÄŸrudal arama)**" yapan adÄ± `search_val` olan bir generic fonksiyon tasarlayÄ±nÄ±z, tanÄ±mÄ±nÄ± yazÄ±nÄ±z ve test ediniz.
- ğŸ‘‡ AÅŸaÄŸÄ±daki programda yukarÄ±da istenilen `search_val` fonksiyonunun nasÄ±l gerÃ§ekleÅŸtirildiÄŸi ve test edildiÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "nutility.h"

#define SIZE    100

// vpa          : Ä°Ã§inde arama yapÄ±lacak dizinin adresi.
// size         : Ä°Ã§inde arama yapÄ±lacak dizinin eleman sayÄ±sÄ±.
// sz           : Ä°Ã§inde arama yapÄ±lacak dizinin elemanlarÄ±nÄ±n sizeof deÄŸeri.
// key          : Aranacak deÄŸeri tutan nesnenin adresi.
// return value : Dizide aranÄ±lan deÄŸere sahip ilk tespit edilen nesnenin adresi, bulunamazsa 'NULL' deÄŸer dÃ¶ndÃ¼rÃ¼lÃ¼r.
void* search_val(const void* vpa, size_t size, size_t sz, const void* key)
{
    const char* p = (const char*) vpa;

    for(size_t i = 0; i < size; ++i){
        if(!memcmp(p + i * sz, key, sz))
            return (char*)(p + i * sz);
    }

    return NULL;
}

int main(void)
{
    int ar[] = { 2, 5, 6, 7, 8, 3, 5, 8, 9, 10, 1, 4 };
    int key = 1;

    int* p = (int*)search_val(ar, asize(ar), 3, key);

    if(p){
        printf("bulundu = %d, index = %d\n", *p, p - ar);
    }
    else{
        printf("buunamadi\n");
    }
}
```


>â”
> 
> Sorulan soru; 
> 
> hocam Ã§ok temel dÃ¼zelye bir login programÄ± yazacak olursak ÅŸifre aramasÄ± bÃ¶yle bir fonsiyon yazarsak  kullanÄ±labilir deÄŸil mi?
> Hocam hemen dÃ¼zeltiyorum ğŸ˜„ temel dÃ¼zeyde bir login program yazÄ±caz kullanÄ±cÄ±nÄ±n parolasÄ± doÄŸru mu sorusuna cevap olarak bu yazdÄ±ÄŸÄ±mÄ±z fonksiyonu kullanabilir miyiz?
> 
> Cevap;
> 
> Åifreyle parola terimleri yanlÄ±ÅŸ kullanÄ±ldÄ±ÄŸÄ± sÄ±k oluyormuÅŸ, bu terimleri doÄŸru baÄŸlamlarda kullanmak gerekiyor.



âš ï¸ Pointer konusunun ilk bÃ¶lÃ¼mÃ¼ ÅŸu anda tamamlanmÄ±ÅŸ oldu, buradan sonki bÃ¶lÃ¼m daha zor!

## Pointer Konusunun 2. KÄ±smÄ±(Ä°lk KÄ±sÄ±mdakinden Daha Zor Konular Ä°Ã§ermektedir) 


ğŸ§­ KÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe doÄŸru sÄ±ralama yapacak generic olan(tÃ¼rden baÄŸÄ±msÄ±z olarak) sÄ±ralama fonksiyonun yazÄ±lmasÄ± istense bÃ¶yle bir fonksiyonu yazÄ±labilir mi;
- BaÅŸlangÄ±Ã§ta bu sorunun cevabÄ± evet olacak Ã§Ã¼nkÃ¼ ilk baÅŸta "**dizinin adresini**", "**dizinin boyutu(elaman sayÄ±sÄ±nÄ±)**" ve "**dizinin tek bir elemanÄ±nÄ±n byte deÄŸeri**" alÄ±nsa kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe doÄŸru tÃ¼rÃ¼ bilinmeyen bir dizinin "booble-sort" algoritmasÄ±yla sÄ±ralanabileceÄŸi dÃ¼ÅŸÃ¼nÃ¼lecektir.
- SonrasÄ±nda bu sorunun cevabÄ± hayÄ±r olacak Ã§Ã¼nkÃ¼ "booble-sort" algoritmasÄ±yla ya da baÅŸka bir algoritmayla dizinin elemanlarÄ±nÄ±n tÃ¼rÃ¼nÃ¼ bilmediÄŸimiz bir durumda iÅŸaretli iÅŸaretsiz sayÄ±larda ya da 'user defind type' ya da Ã§ok Ã¶zel nesneler iÃ§in `memcmp` fonksiyonu ile karÅŸÄ±laÅŸtÄ±rma yapmak bize her zaman doÄŸru sonuÃ§ vermeyecektir.
- En son bu sorunun cevabÄ± yeniden evet olacak Ã§Ã¼nkÃ¼ generic olarak sÄ±ralama yapacak fonksiyon "**dizinin adresini**", "**dizinin boyutu(elaman sayÄ±sÄ±nÄ±)**", "**dizinin tek bir elemanÄ±nÄ±n byte deÄŸerini**" ve "**sÄ±ralamayÄ± yapacak olan fonksiyonun adresini**" deÄŸerlerini alarak yazÄ±labilir.



â—â—â— **void pointers** konusundan sonra iÅŸlenecek olan **function pointers** konusu C'nin en Ã¶nemli bir kaÃ§ aracÄ±ndan biri olmasÄ±nÄ±n dÄ±ÅŸÄ±nda programlama dillinden baÄŸÄ±msÄ±z olarak tÃ¼m programlama dilleri iÃ§in Ã§ok Ã¶nemli bir araÃ§tÄ±r. **Function pointers** aracÄ± kullanÄ±larak bir fonksiyon baÅŸka bir fonksiyona bir fonksiyon gÃ¶nderebilir. Bir fonksiyon bir fonksiyonun Ã§aÄŸÄ±racaÄŸÄ± fonksiyonu o fonksiyona geÃ§eceÄŸi bir **function pointer** argÃ¼manla belirleyebilir.

ğŸ§  **Callback Function**: Programlama dilinden baÄŸÄ±msÄ±z olarak kullanÄ±lan bir terimdir, bu terim bir fonksiyon bir fonksiyonun Ã§aÄŸÄ±racaÄŸÄ± fonksiyonu o fonksiyona geÃ§eceÄŸi bir **function pointer** argÃ¼manla belirleyebildiÄŸi durumu ifade etmektedir.

ğŸš€ **Callback function** aracÄ± ile bir fonksiyonun bir fonksiyona bir fonksiyon gÃ¶ndermesi Ã§ok sÄ±k kullanÄ±lmaktadÄ±r, hemen hemen her programda Ã¶zellikle de gÃ¶mÃ¼lÃ¼ sistem programlamada Ã§ok sÄ±k kullanÄ±lan araÃ§lardandÄ±r.

C dili 3. kuÅŸak bir dil olsada, C dili 3. kuÅŸak(yÃ¼ksek seviyeli) dillerin dÃ¼ÅŸÃ¼k seviyeli kÄ±smÄ±nda yer almaktadÄ±r.



â—â—â— Pointer'lar konusu "**Object Pointers**" ve "**Funciton Pointers**" olarak ikiye ayrÄ±lmaktadÄ±r, biz buraya kadar sadece "**Object Pointers**" konusuyla ilgili konularÄ± gÃ¶rdÃ¼k, bir sonraki hafta "**Funciton Pointers**" konusuna geÃ§ilebilecek ve bu konu aÅŸaÄŸÄ± yukarÄ± 5 saat kadar sÃ¼recektir.


â—â—â— Adres deÄŸer tutan deÄŸiÅŸkenler pointer deÄŸiÅŸkenlerdir, Ã¶zel olarak bir fonksiyonun adresini tutan deÄŸiÅŸkenler "**funciton pointer**" tÃ¼rÃ¼nden deÄŸiÅŸken olarak adlandÄ±rÄ±lÄ±yor.


â—â—â— `qsort` fonksiyonu tÃ¼rden baÄŸÄ±msÄ±z olarak yani generic olarak sÄ±ralama yapan `stdlib.h` baÅŸlÄ±k dosyasÄ±nda yer alan standart bir C fonksiyonudur, bu fonksiyon Ã§ok sÄ±k kullanÄ±lmaktadÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `qsort` fonksiyonunun prototipi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>

// 'qsort' fonksiyonu tÃ¼rden baÄŸÄ±msÄ±z olarak dizinin elemanlarÄ±nÄ±n sÄ±ralanmasÄ± iÅŸlemini yapan fonksiyon.
// _Base            : TÃ¼rden baÄŸÄ±msÄ±z olarka sÄ±ralacak dizinin adresi.
// _NumOfElements   : Dizinin eleman sayÄ±sÄ±.
// _SizeOfElements  : Dizinin tek bir elemanÄ±nÄ±n 'sizeof' deÄŸeri(yani byte olarak kapladÄ±ÄŸÄ± alan).
// _ConpareFunction : SÄ±ralama iÅŸleminin yapacak fonksiyonun adres deÄŸeri.
void qsort(void* _Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCtrNonSecureSearchSorthCompareFunciton _ConpareFunction);

int main(void)
{

}
```


>â”
> 
> Sorulan soru; 
> 
> AsÄ±l fonksiyon tur bilgisine agnostik, ama call-back fonksiyon agnostik degil, dogru mu?
> 
> Cevap;
> 
> Evet.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `qsort` fonksiyonuyla bir dizinin nasÄ±l sÄ±ralandÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h> // 'qsort' fonksiyonunun bildirimi bu baÅŸlÄ±k dosyasÄ±nda.
#include "nutility.h"

#define SIZE    100

// 'icmp' fonksiyonu 'qsort' fonksiyonuna gÃ¶nderilecek olan, sÄ±ralamanÄ±n nasÄ±l yapÄ±lacaÄŸÄ±nÄ± belirlecek fonksiyondur.
int icmp(const void* vp1, const void* vp2)
{
    return *(const int*)vp1 - *(const int*)vp2;
}

int main(void)
{
    int a[SIZE];

    randomize();
    set_array_random(a, SIZE);
    printf_array(a, SIZE);

    qsort(a, SIZE, sizeof(int), &icmp); // Burada 'qsort' fonksiyonuna '&icmp' adres deÄŸeriyle birlikte 'icmp' adÄ±ndaki fonksiyon sÄ±ralama kriteri olarak gÃ¶nderiliyor.
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.07-12.17 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


ğŸ“Œ **void pointer** ve **function pointer** konularÄ± birbiriyle iliÅŸkili olduÄŸu iÃ§in aradan Ã¶nce bu duruma deÄŸinilmiÅŸtir, **function pointer** aracÄ±nÄ± kullanmayan **generic funciton**'lar vardÄ±r, **function pointer** aracÄ±nÄ± sadece **generic funciton**'larda kullanÄ±lan bir araÃ§ deÄŸildir Ã§ok daha genel kullanÄ±mÄ± olan bir araÃ§tÄ±r.

â—â—â— **void pointer** tÃ¼rÃ¼yle ilgili aÅŸaÄŸÄ±daki bilgiler bilinmelidir;
- `void*` herhangi tÃ¼rden bir adres tutan bir pointer deÄŸiÅŸkendir.
- `NULL` deÄŸer alabilir. 
- `void*` bir tÃ¼r olduÄŸu gibi `const void*` tÃ¼rÃ¼ de vardÄ±r.
-  Adres dÃ¶ndÃ¼ren bir fonksiyonun geri dÃ¶nÃ¼ÅŸ tÃ¼rÃ¼ `void*` tÃ¼rÃ¼ olabilir.
- Dinamik bellek yÃ¶netiminde kullanÄ±lacak fonksiyonlarÄ±nÄ±n(`malloc`, `calloc` vb.) geri dÃ¶nÃ¼ÅŸ tÃ¼rÃ¼ `void*` tÃ¼rÃ¼dÃ¼r.
- Sistem programlama tarafÄ±nda(Unix/Linux, Windows sistem programlamada) kullanÄ±lan fonksiyonlarÄ±n Ã§oÄŸunun geri dÃ¶nÃ¼ÅŸ tÃ¼rleri `void*` tÃ¼rÃ¼dÃ¼r.

âš ï¸ **void pointer** arada sÄ±rada kullanÄ±lan bir araÃ§ deÄŸildir neredeyse her C programÄ±nda kullanÄ±lmaktadÄ±r. 


### `void**` TÃ¼rÃ¼ 


â— `void*` bir tÃ¼rdÃ¼r ve **generic function**'larda kullanÄ±lmaktadÄ±r, `void**` tÃ¼rÃ¼ de vardÄ±r;
- `void**` tÃ¼rÃ¼ de kullanÄ±lan bir tÃ¼rdÃ¼r.
- `void*` **generic pointer** adres tÃ¼rÃ¼dÃ¼r ama `void**` tÃ¼rÃ¼ **generic pointer** adres tÃ¼rÃ¼ deÄŸildir(profesyonel olarak C diliyle Ã§alÄ±ÅŸan kiÅŸilerden de C mÃ¼lakatlarÄ±nda bazen `void**` tÃ¼rÃ¼nÃ¼n **generic pointer** adres tÃ¼rÃ¼ olduÄŸunu sÃ¶yleyenler olabiliyormuÅŸ).



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `void**` tÃ¼rÃ¼yle ilgili bazÄ± durumlar incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <stdio.h>
#include "nutility.h"

#define SIZE    100

int main(void)
{
    int x = 5;
    double d = 123.42;

    int* ptr = &x;
    double* dptr = &d;
    void* vptr = &x;

    // '&ptr' ifadesinin tÃ¼rÃ¼ 'int**' tÃ¼rÃ¼dÃ¼r.
    // '&dptr' ifadesinin tÃ¼rÃ¼ 'double**' tÃ¼rÃ¼dÃ¼r.
    // '&vptr' ifadesinin tÃ¼rÃ¼ 'void**' tÃ¼rÃ¼dÃ¼r.

    //void** vp1 = &x; // Buradaki atama iÅŸlemi yanlÄ±ÅŸtÄ±r, C++ dilinde sÃ¶zdizim hatasÄ±dÄ±r(syntax error).
    //void** vp2 = &ptr; // Buradaki atama iÅŸlemi yanlÄ±ÅŸtÄ±r, C++ dilinde sÃ¶zdizim hatasÄ±dÄ±r(syntax error).
    void** vp = &vp; // Buradaki atama iÅŸlemi doÄŸrudur.

    // '*vp =' demek 'vptr =' demektir.
}
```


>â”
> 
> Sorulan soru?
> 
> generic bir pointer adresinin adresi midir?
> 
> Cevap;
> 
> Buradaki ifade ÅŸekli doÄŸru deÄŸil, `void*` tÃ¼rÃ¼nden deÄŸiÅŸkenin adresi olan bir tÃ¼rdÃ¼r demek doÄŸrudur.



â—â—â—ğŸ‘‡ AÅŸaÄŸÄ±daki programda `void**` tÃ¼rÃ¼ne deÄŸer atamayla ilgili doÄŸru ve yanlÄ±ÅŸ atama iÅŸlemleri incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <stdio.h>
#include "nutility.h"

#define SIZE    100

int main(void)
{
    int x = 5;
    double dval = 3.534;
    int* ptr = &x;
    void* vptr = &x;
    void** vp = &vptr;

    // '*vp =' demek 'vptr =' demektir.
    *VP = &dval; // Buradaki atama doÄŸrudur Ã§Ã¼nkÃ¼ atama 'vptr' tÃ¼rÃ¼ne yapÄ±lmaktadÄ±r ve 'void*' tÃ¼rÃ¼ herhangi bir tÃ¼rden adresi tutabilir.


    //void** vptr = &x; // Buradaki ilk deÄŸer verme iÅŸlemi yanlÄ±ÅŸtÄ±r Ã§Ã¼nkÃ¼ 'void**' tÃ¼rÃ¼ sadece 'void*' tÃ¼rÃ¼nden nesnelerin adreslerini tutabilir, C++ dilinde sÃ¶zdizim hatasÄ±dÄ±r(syntax error).
    //void** vptr = &dval; // Buradaki ilk deÄŸer verme iÅŸlemi yanlÄ±ÅŸtÄ±r Ã§Ã¼nkÃ¼ 'void**' tÃ¼rÃ¼ sadece 'void*' tÃ¼rÃ¼nden nesnelerin adreslerini tutabilir, C++ dilinde sÃ¶zdizim hatasÄ±dÄ±r(syntax error). 
    void** vptr = &vp;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `void**` tÃ¼rÃ¼ne deÄŸer atamayla ilgili doÄŸru ve yanlÄ±ÅŸ atama iÅŸlemleri incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <stdio.h>
#include "nutility.h"

#define SIZE    100

int main(void)
{
    int x = 5;
    double dval = 3.6;
    void* vp = &x;
    int* ip = &x;

    //void** vptr = &x; // Buradaki ilk deÄŸer verme iÅŸlemi yanlÄ±ÅŸtÄ±r Ã§Ã¼nkÃ¼ 'void**' tÃ¼rÃ¼ sadece 'void*' tÃ¼rÃ¼nden nesnelerin adreslerini tutabilir, C dilinde derleyici uyarÄ± verir, C++ dilinde sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.
    //void** vptr = &ip; //Buradaki ilk deÄŸer verme iÅŸlemi yanlÄ±ÅŸtÄ±r Ã§Ã¼nkÃ¼ 'void**' tÃ¼rÃ¼ sadece 'void*' tÃ¼rÃ¼nden nesnelerin adreslerini tutabilir, C dilinde derleyici uyarÄ± verir, C++ dilinde sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.
    void** vptr = &vp; // Bu atama iÅŸlemi doÄŸrudur, 'void**' tÃ¼rÃ¼ sadece 'void*' tÃ¼rÃ¼nden deÄŸiÅŸkenlerin adresini tutabilir.
}
```


>â”
> 
> Sorulan soru; 
> 
> `void** vptr = &(&x);` R-value'dan dolayi gecersiz degil mi?
> 
> Cevap;
> 
> `&(&x)` ifadesinde `&` operatÃ¶rÃ¼ operandÄ± sadece "L-value" kategorisinden olabileceÄŸi iÃ§in ve `&x` ifadesinin kategorisi de "R-value" olduÄŸu iÃ§in `&(&x)` ifadesi sÃ¶zdizim hatasÄ±dÄ±r(syntax error).
>  
> "DeÄŸiÅŸkenin adresinin adresi" tÃ¼mcesi hatalÄ±dÄ±r, "DeÄŸiÅŸkenin adresini tutan deÄŸiÅŸkenin adresi" tÃ¼mcesi doÄŸrudur.
> 
> C dilinde Ã§alÄ±ÅŸma zamanÄ±nda bir deÄŸiÅŸkenin adresi deÄŸiÅŸtirilemez, deÄŸiÅŸkenlerin adreslerinin ne olacaÄŸÄ±na yazÄ±lmÄ±ÅŸ olan C programÄ± karar vermiyor.


â—â—â— `void**` tÃ¼rÃ¼nden bir deÄŸiÅŸken sadece `void*` tÃ¼rÃ¼nden bir deÄŸiÅŸkenin adresini tutmak iÃ§in kullanÄ±lÄ±yor bundan baÅŸka hiÃ§ bir amacÄ± yoktur ama `void**` tÃ¼rÃ¼nÃ¼n bir Ã§ok kullanÄ±m alanÄ± vardÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `void**` tÃ¼rÃ¼nÃ¼n kullanÄ±m senaryolarÄ±ndan biri, Ã§ok basit bir ÅŸekilde incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <stdio.h>
#include "nutility.h"

#define SIZE    100

//AÅŸaÄŸÄ±daki 'foo' foonksiyonu kendisini Ã§aÄŸÄ±racak koda output parameter olarak aldÄ±ÄŸÄ± 'void** vptr' parametresi Ã¼zerinden geriye 'void*' tÃ¼rÃ¼nden bir nesnenin adresini dÃ¶ndÃ¼rebilir.
int foo(int x, int y, void** vptr)
{
    // *vptr = herhangi bir tÃ¼rden adres;
}

int main(void)
{
    void* vp;
    
    foo(12, 43, &vp);
}
```



â—â—â— ğŸ‘‡ AÅŸaÄŸÄ±daki program `void**` tÃ¼rÃ¼nden bir deÄŸiÅŸkenin hangi deÄŸerleri tutup hangilerini tutamayacaÄŸÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <stdio.h>
#include "nutility.h"

#define SIZE    100

int main(void)
{
    int* p1 = NULL;
    double* p2 = NULL;
    void* vp = NULL;
    void** vptr = NULL;
    int** iptr = NULL;

    void* p;
    int x = 5;
    ++x;

    // AÅŸaÄŸÄ±daki atamalarÄ±n hepsi doÄŸrudur;
    p = p1;
    p = &p1;
    p = p2;
    p = &p2;
    p = vp;
    p = &vp;
    p = vptr;
    p = &vptr;
    p = iptr;
    p = &iptr;
    p = &p;


    void** px;
    int x = 5;
    ++x;

    // AÅŸaÄŸÄ±daki atamalarÄ±n sadece iki tanesi doÄŸrudur gerisi hatalÄ±dÄ±r;
    //px = p1;
    //px = &p1;
    //px = p2;
    //px = &p2;
    px = vp; // Bu atama doÄŸrudur.
    px = &vp; // Bu atama doÄŸrudur.
    //px = vptr;
    //px = &vptr;
    //px = iptr;
    //px = &iptr;
    //px = &px;
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `void*` tÃ¼rÃ¼nden bir dizinin nasÄ±l tanÄ±mlandÄ±ÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <stdio.h>
#include "nutility.h"

#define SIZE    100

int main(void)
{
    int x = 0;
    double d = 2.3;
    char str[] = "adil";
    void* vptr = NULL;
    int* ip = NULL;

    void* p[10] = { &x, &d, str, vptr, &vptr, ip, &ip }; // Bu ÅŸekilde bir dizi ilklendirme sÃ¶zdizimi kullanÄ±labilir.
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda fonksiyonlarÄ±n geri dÃ¶nÃ¼ÅŸ tÃ¼rlerinin ne olabileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <stdio.h>
#include "nutility.h"

#define SIZE    100

int f1(void);
int* f2(void);
int** f3(void);
int*** f4(void);
void f5(void);
void* f6(void);
void** f7(void);

int main(void)
{
    void** a[10]; // 'void**' tÃ¼rÃ¼nden elemanlarÄ± olan diziler de tanÄ±mlanÄ±r ama kullanÄ±m alanlarÄ± Ã§ok sÄ±nÄ±rlÄ±dÄ±r. 
}
```


## Function Pointers GiriÅŸ 

C dilinde gÃ¶stericiler iki tÃ¼re ayrÄ±lmaktadÄ±r;
1. **Object Pointers**: DeÄŸiÅŸkenlerin adresleri.
2. **Function Pointers**: FonksiyonlarÄ±n adresleri.

FonksiyonlarÄ±n adreslerinin tÃ¼rlerinin ne olacaÄŸÄ±na dilin tasarÄ±mÄ±nÄ± yapanlar(mÃ¼lkÃ¼yetsiz dillerde bir komisyon, mÃ¼lkÃ¼yetli dillerde bir firmanÄ±n kendi Ã§alÄ±ÅŸan kadrosu) karar vermektedir.

C dilinde fonksiyon adreslerinin tÃ¼rleri aÅŸaÄŸÄ±daki bilgilere gÃ¶re belirlenmektedir;
- FonksiyonlarÄ±n parametre deÄŸiÅŸkeni sayÄ±sÄ±.
- FonksiyonlarÄ±n parametre deÄŸiÅŸkenlerinin herbirinin tÃ¼rÃ¼.
- Geri dÃ¶nÃ¼ÅŸ deÄŸerinin tÃ¼rÃ¼.


ğŸ‘‡ AÅŸaÄŸÄ±daki programda bildirilmiÅŸ(declare) olan bazÄ± fonksiyonlarÄ±n adreslerinin tÃ¼rlerinin aynÄ± mÄ± yoksa farklÄ± mÄ± olacaÄŸÄ± incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <stdio.h>
#include "nutility.h"

// AÅŸaÄŸÄ±daki 'foo' ve 'bom' fonksiyonlarÄ±nÄ±n adreslerinin tÃ¼rÃ¼ aynÄ±dÄ±r.
int foo(int);
int bom(int);

// AÅŸaÄŸÄ±daki 'bar' ve 'baz' fonksiyonlarÄ±nÄ±n adreslerinin tÃ¼rÃ¼ farklÄ±dÄ±r.
double bar(double);
double baz(int, int);

int main(void)
{

}
```


C ve C++ dillerinde fonksiyonlara iliÅŸkin iki farklÄ± adres tÃ¼rÃ¼ vardÄ±r;
1. **Function Type**: Bir fonksiyonun tÃ¼rÃ¼ ÅŸu ÅŸekilde "**GERÄ°_DÃ–NÃœÅ_TÃœRÃœ(PAREMETRELERÄ°NÄ°N_TÃœRÃœ)**" belirleniyor.
    - `int foo(int);` fonksiyonunun tÃ¼rÃ¼ `int(int)` tÃ¼rÃ¼dÃ¼r.
    - `long bom(int, double);` fonksiyonunun tÃ¼rÃ¼ `long(int, double)` tÃ¼rÃ¼dÃ¼r.
    - "strcmp" fonksiyonunun tÃ¼rÃ¼ `int(const char*, const char*)` tÃ¼rÃ¼dÃ¼r.
2. **Funciton Pointer Type**: Bir fonksiyonunun adresinin tÃ¼rÃ¼ ÅŸu ÅŸekilde "**GERÄ°_DÃ–NÃœÅ_TÃœRÃœ (*)(PAREMETRELERÄ°NÄ°N_TÃœRÃœ)**" belirleniyor.
    - `int foo(int);` fonksiyonunun fonksiyon adresi tÃ¼rÃ¼ yani `&foo` ifadesinin tÃ¼rÃ¼ `int (*)(int)` tÃ¼rÃ¼dÃ¼r.
    - `int func(int, double, int);` fonksiyonunun fonksiyon adresi tÃ¼rÃ¼ yani `&func` ifadesinin tÃ¼rÃ¼ `int (*)(int, double, int)` tÃ¼rÃ¼dÃ¼r.
    - C dilinin standart fonksiyonlarÄ±ndan olan `strlen` fonksiyon adresinin tÃ¼rÃ¼ `size_t (*)(const char*)` tÃ¼rÃ¼dÃ¼r.
    - C dilinin standart fonksiyonlarÄ±ndan olan `isupper` fonksiyon adresinin tÃ¼rÃ¼ `int (*)(int)` tÃ¼rÃ¼dÃ¼r.
    - C dilinin standart fonksiyonlarÄ±ndan olan `strcmp` fonksiyon adresinin tÃ¼rÃ¼ `int (*)(const char*, const char*)` tÃ¼rÃ¼dÃ¼r.


â—â—â— Bir fonksiyonun geri dÃ¶nÃ¼ÅŸ deÄŸerinin tÃ¼rÃ¼ farklÄ±(fonksiyon Ã§aÄŸrÄ±sÄ±nÄ±n tÃ¼rÃ¼ de diyebiliriz), bir fonksiyonun kendi tÃ¼rÃ¼ farklÄ±, bir fonksiyonun adresinin tÃ¼rÃ¼ farklÄ± ÅŸeylerdir! 


Ders sonu ...
