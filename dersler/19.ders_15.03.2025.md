# 19.Ders 15.03.2025 ğŸ•˜

Derse 16(09:01)-20(09:04)-24(09:44)-23(10:15)-25(11:29)-24(12:15) kiÅŸi katÄ±ldÄ±.


## Preprocessor Operators Devam

Preprocessor operatorler Ã¼Ã§ tanedir bunlar;
1. **`#`(stringizing, stringification)**: Bu operatÃ¶r Unary operatÃ¶rdÃ¼r. Bu operatÃ¶rÃ¼n operandÄ± olan ifade Ã§ift tÄ±rnak iÃ§erisine alÄ±nÄ±r.
2. **`##` (token-pasting)**: Token yapÄ±ÅŸtÄ±rma operatÃ¶rÃ¼dÃ¼r, bu operatÃ¶r binary operatÃ¶rdÃ¼r.  
3. **`defined`**: Bu operatÃ¶r koÅŸullu derleme iÅŸlemlerinde kullanÄ±lÄ±r.



ğŸ‘‡ AÅŸaÄŸÄ±daki program preprocessor `#` operatÃ¶rÃ¼nÃ¼n en sade kullanÄ±mÄ±nÄ± iÃ§ermektedir, bu operatÃ¶r Ã¼retime bu ÅŸekilde kullanÄ±lmamaktadÄ±r.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define str(x)  #x

int main(void)
{
    printf(str(custum_name));

}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda iki farklÄ± `printf` Ã§aÄŸrÄ±sÄ± da aynÄ± anlama gelmektedir, derleyici arada boÅŸluk dÄ±ÄŸÄ±nda baÅŸka karakter olmadan peÅŸ peÅŸe gelen **string literal**'leri birleÅŸtirip tek bir **string literal** oluÅŸturduÄŸu durum incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void)
{
    printf(
        "ahmet"
        "berkay"
        "caner"
        "aslÄ±"
        "kerem"
    );

    printf("ahmetberkaycaneraslÄ±kerem");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda alt alta olmasÄ± gereken yazÄ±larÄ±n daha okunaklÄ± nasÄ±l yazÄ±labileceÄŸi incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void)
{
    printf("[1]kayit ara\n[2]kayit sil\n[1]kayit yenile\n[1]kayit ekle\n[1]programdan cik\n");

    printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");

    printf(
        "[1]kayit ara\n"
        "[2]kayit sil\n"
        "[3]kayit yenile\n"
        "[4]kayit ekle\n"
        "[5]programdan cik\n");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda **string literal** Ã¶zelliÄŸinden gelen string kullanÄ±mÄ± gÃ¶rÃ¼lebilir(Ã§Ä±ktÄ± olarak yazÄ±yÄ± tek satÄ±rda yazdÄ±racaktÄ±r ama tÃ¼m boÅŸluk karakterleri yazÄ±ya dahildir), bu bu dersin konusu deÄŸil, bir kiÅŸi bu kullanÄ±mÄ± sorduÄŸu iÃ§in deÄŸinildi.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void)
{
    printf("bugun gunlerden cumartesi \
        ve ben Necati C dersi \
        anlatiyorum degerli ogrencilerime.");
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki programda preprocessor `#` operatÃ¶rÃ¼nÃ¼n **function-like makro** ile nasÄ±l kullanÄ±labileceÄŸine dair kullanÄ±m gÃ¶rÃ¼lebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define iprint(x) printf("%d\n", x)

#define iprint(x) printf_v2(#x "= %d\n", x)


int main(void)
{
    int x = 5;
    int y = 4;
    int z = 8;

    printf("%d\n", x);
    printf("%d\n", y);
    printf("%d\n", z);

    printf("~~~~~~~~~~~~~~~\n");

    iprint(x);
    iprint(y);
    iprint(z);
    
    printf("~~~~~~~~~~~~~~~\n");

    iprint(x * x);
    iprint(x * y *z);
    iprint(x * x + y * y + z * z);
    
    printf("~~~~~~~~~~~~~~~\n");

    iprint_v2(x);
    iprint_v2(y);
    iprint_v2(z);
    
    printf("~~~~~~~~~~~~~~~\n");

    iprint_v2(x * x);
    iprint_v2(x * y *z);
    iprint_v2(x * x + y * y + z * z);
    
    printf("~~~~~~~~~~~~~~~\n");
}
```


> â” [09:22:00-09:29:00]
> Sorulan soru;
> 
> Makrolarin sonuna noktali virgule konmasiyla ilgili noktayi hatirlatmaniz mumkun mu?
> 
> Cevap;
> 
> ğŸ‘‡ AÅŸaÄŸÄ±daki programdan cevap incelenebilir.
> ```C
> #define _CRT_SECURE_NO_WARNINGS
> 
> #include <stdio.h>
> #include <stdlib.h>
> #include <time.h>
> 
> #define SIZE 100;
> 
> #define SWAP(a, b) {int temp = a; a = b; b = temp;}
> #define SWAP_CURRECT(a, b) do{int temp = a; a = b; b = temp;}while(0); // YukarÄ±daki makronun doÄŸru kullanÄ±m ÅŸekli bu olmalÄ±dÄ±r.
> 
> int main(void)
> {
>     int x, y;
> 
>     x = SIZE; // Burada null statement eklenecektir ve Ã¶n-iÅŸlemci program Ã§alÄ±ÅŸtÄ±ktan sonra buradaki kod 'x = 100;;' olacaktÄ±r.
>     y = 10;
> 
>     // Buradaki 'if statement' Ã¶n-iÅŸlemci program Ã§alÄ±ÅŸtÄ±ktan sonra 'if(x == 100;)' ÅŸeklinde aÃ§Ä±lacaÄŸÄ± iÃ§in sÃ¶zdizim hatasÄ±(syntax error) oluÅŸacaktÄ±r.
>     if(x == SIZE)
>         y = 0;
> 
>     if(x > y)
>         SWAP(x, y); // Burada Ã¶n-iÅŸlemci program Ã§alÄ±ÅŸtÄ±ktan makro aÃ§Ä±lÄ±nca '{int temp = x; x = y; y = temp;};' ÅŸeklinde bir kod oluÅŸur ve 'else' kÄ±smÄ± ile 'if' kÄ±smÄ±nÄ±n baÄŸlantÄ±sÄ± kopar bu da sÃ¶zdizim hatasÄ±na(syntax error)  neden olur.
>     else
>         ++x;
> }
> ```


## Function-like Makro ve Fonksiyon KÄ±yaslamasÄ± 

â—MÃ¼lakatlarda **function-like makro** ve **fonksiyon** kÄ±yaslamanÄ±n yapÄ±lmasÄ±nÄ±n istenmesi Ã§ok sÄ±k sorulan bir sorudur.

1. Fonksiyon Ã§aÄŸrÄ±larÄ± optimize edilebilecek kod bloÄŸunu daraltmaktadÄ±r. Makrolar fonksiyon Ã§aÄŸrÄ± maliyetine sahip deÄŸildir. MakrolarÄ±n en sÄ±k kullanÄ±lma nedeni fonksiyon Ã§aÄŸrÄ± maliyetinden kurtulmaktÄ±r. EÄŸer derleyici **inline extension** yapmÄ±yor ise fonksiyon kullanÄ±mlarÄ±nda fonksiyon Ã§aÄŸrÄ± maliyeti kodda oluÅŸacaktÄ±r.

2. Makrolar tÃ¼r kavramÄ±na sahip deÄŸildir(yani generic programlama yapmak iÃ§in kullanÄ±labilir) ama fonksiyonlar tÃ¼r kavramÄ±na sahiptir.

    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include <stdlib.h>
    #include <time.h>

    #define MAX2(a, b) ((a) > (b) ? (a) : (b))

    int main(void)
    {
        int x = 2;
        double y = 5.;

        printf("%d ve %fl buyuk olani ", x, y);
        printf(".");
    }
    ```

3. Makrolar fonksiyon olmadÄ±klarÄ± iÃ§in adrese sahip deÄŸildir, oysa fonksiyonlarÄ±n adresleri vardÄ±r, fonksiyon adresi kullanÄ±lmasÄ± gereken temalarda makrolar kullanÄ±lamaz.

    
    ğŸ‘‡ AÅŸaÄ±daki program fonksiyon adresi alan `print_chars` adlÄ± fonksiyon kullanÄ±lmÄ±ÅŸtÄ±r, bu fonksiyon makro olarak yazÄ±lamazdÄ±. Buradaki programÄ±n anlaÅŸÄ±lmasÄ± beklenmiyor(**function pointer** konusu iÅŸlendikten sonra anlaÅŸÄ±lmasÄ± beklenecektir).
    ```C
    #define _CRT_SECURE_NO_WARNINGS

    #include <stdio.h>
    #include <stdlib.h>
    #include <time.h>
    #include <ctyp.h>

    // AÅŸaÄŸÄ±daki fonksiyon dÄ±ÅŸarÄ±dan 'function pointer' almaktadÄ±r
    void print_chars(const char* p, int (*fptest)(int))
    {
        printf("%s;\n");
        for(int i = 0; i < 128; ++i){
            if(isalpha(i)){
                printf("&c", i);
            }
        }
        printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
    }

    int main(void)
    {
        printf("isalpha;\n");
        for(int i = 0; i < 128; ++i){
            if(isalpha(i)){
                printf("&c", i);
            }
        }
        printf("============================\n");

        printf("ispunch;\n");
        for(int i = 0; i < 128; ++i){
            if(ispunch(i)){
                printf("&c", i);
            }
        }
        printf("============================\n");

        // AÅŸaÄŸÄ±daki fonksiyonlarÄ±n ikinci parametresi fonksiyon adresidir.
        print_chars("isalpha => ", &isalpha);
        print_chars("ispunch => ", &ispunch);
        print_chars("isdigit => ", &isdigit);
        print_chars("isalnum => ", &isalnum);
    }
    ```

    â—Programlamadaki en temel ilkelerden biri kod tekrarÄ±ndan kaÃ§Ä±nmaktÄ±r.

    â—Fonksiyon adresi kullanÄ±lmasÄ± gereken yerlerde makrolar kullanÄ±lamaz, mesela yukarÄ±daki programda `print_chars` fonksiyonunun parametresi olarak gÃ¶nderilecek fonksiyon yerine makro kullanÄ±lamaz.

4. **Debuger(hata ayÄ±klama)** ve **unit-test tool** programlarÄ± fonksiyon kullanÄ±mlarÄ±nda bir Ã§ok desteÄŸe sahiptir fakat makrolar iÃ§in ya Ã§ok az desteÄŸe sahiptir ya da hiÃ§ desteÄŸe sahip deÄŸildir. "**Macros are not debugger-friendly.**"

5. Makrolar fonksiyonlar kadar gÃ¼venli deÄŸildir yani makrolar kullanÄ±ldÄ±ÄŸÄ±nda kodlamada hata yapma olasÄ±lÄ±ÄŸÄ± ve **ub** durumlarÄ±nÄ±n oluÅŸma ihtimali daha yÃ¼ksektir.


**Generic programlama**: TÃ¼rden baÄŸÄ±msÄ±z olarak yapÄ±lan programlamadÄ±r. C dilinde generic programlama yapmak iÃ§in araÃ§lar azdÄ±r ama C++ dilinde bu araÃ§lar dilin temelini oluÅŸturur.


**Trade-off(Ã–dÃ¼nleÅŸim)**: Bir iÅŸin nasÄ±l yapÄ±lmasÄ±na baÄŸlÄ± olarak ne kazanÄ±lÄ±p ne kaybedilecek durumunu ifade etmek iÃ§in kullanÄ±lan bir terimdir. 

**Call chain**: Programlama dillerinde fonksiyonlarÄ±n baÅŸka fonkisyonlarÄ± Ã§aÄŸÄ±rdÄ±ÄŸÄ± ve o fonksiyonlarÄ±nda farklÄ± fonksiyonlarÄ± Ã§aÄŸÄ±rmasÄ± ÅŸeklinde bir yere kadar devam eden fonksiyon Ã§aÄŸrÄ±larÄ±nÄ±n yapÄ±ldÄ±ÄŸÄ± durumu ifade etmek iÃ§in kullanÄ±lan terimdir.

## Conditional Compiling(KoÅŸullu Derleme) 

**Conditional compiling** iÅŸlemi preprocessor program ile yapÄ±lmaktadÄ±r. </br>
Bu sÃ¼reÃ§te Ã¶n-iÅŸlemci program duruma gÃ¶re hangi kodu derleyicinin gÃ¶receÄŸine karar verilmasinde kullanÄ±lÄ±yor. </br>
Ã–n-iÅŸlemci program ile derleyiciye verilecek olan kodlar farklÄ± senaryolarda farklÄ± olmaktadÄ±r ve bu ÅŸekilde farklÄ± durumlarda farklÄ± kodlarÄ±n Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ± saÄŸlanmÄ±ÅŸ olur.

â— C++ dilinde **object-like macro** ve **function-like macro** yerine kullanÄ±labilecek baÅŸka daha iyi araÃ§lar olduÄŸu iÃ§in kullanÄ±lmalarÄ± tercih edilmemektedir ama **conditional Compiling** C++ dilinde de kullanÄ±lmaktadÄ±r.


Neden koÅŸullu derleme yapÄ±lÄ±yor; 
1. Derleyicinin gÃ¶receÄŸi kodun donanÄ±ma gÃ¶re farklÄ± olmasÄ± gerektiÄŸi durumlar(mesela yapÄ±lan C programÄ±nÄ±n Ã¼zerinde Ã§alÄ±ÅŸacaÄŸÄ± micro-controller serisinin tÃ¼rÃ¼ne gÃ¶re bazÄ± deÄŸiÅŸiklikler olmasÄ± gerektiÄŸi durumlar).
2. Derleyicinin gÃ¶receÄŸi kodun iÅŸletim sisteine gÃ¶re farklÄ± olmasÄ± gerektiÄŸi durumlar.
3. Derleyicinin gÃ¶receÄŸi kodun kullanÄ±lan programlama diline(C ya da C++ olmasÄ±) gÃ¶re farklÄ± olmasÄ± gerektiÄŸi durumlar.
4. Derleyicinin ve versiyonunun farklÄ± olmasÄ± gerektiÄŸi durumlar.
5. Ã‡alÄ±ÅŸan kodun kullanÄ±lan dil standardÄ±na(C99, C11, C23 vb.) gÃ¶re farklÄ± olmasÄ± gerektiÄŸi durumlar. GerÃ§i bunun iÃ§in versiyon kontrol sisteminde her standart iÃ§in program farklÄ± dalda(branch) geliÅŸtirilebilir.
6. Derleyicinin gÃ¶receÄŸi kodun programÄ±n sÃ¼rÃ¼mÃ¼ne gÃ¶re farklÄ± olmasÄ± gerektiÄŸi durumlar.
7. Derleyicinin gÃ¶receÄŸi kodun programÄ±n kullanÄ±lacaÄŸÄ± bÃ¶lgeye(localization) ya da dile gÃ¶re farklÄ± olmasÄ± gerektiÄŸi durumlar.
8. Derleyicinin gÃ¶receÄŸi kodun programÄ±n hata ayÄ±klama sÃ¼recinde olunup olunmamasÄ±na gÃ¶re farklÄ± olmasÄ± gerektiÄŸi durumlar. 
9. HatalarÄ±n tespit edilmesi/bulunmasÄ± iÅŸlemlerinde. Kodun yazÄ±lmasÄ± mÄ± hatanÄ±n nedeni yoksa kodla doÄŸrudan alakasÄ± olmayan programÄ±n Ã§alÄ±ÅŸmasÄ±yla ilgili bazÄ± deÄŸerlerin hataya neden olduÄŸu durumlar. En Ã¶nemli madde budur denilebilir. Mesela 


**Run-time errors, expextions**: Kodun yanlÄ±ÅŸ yazÄ±lmasÄ±ndan kaynaklanmayan, programÄ±n Ã§alÄ±ÅŸmasÄ± anÄ±nda programÄ±n kodu dÄ±ÅŸÄ±nda kalan bazÄ± ÅŸeylerden(mesela veri tabanÄ± baÄŸlantÄ±sÄ±nÄ±n yapÄ±lamamasÄ±, bir dosyanÄ±n okunamamasÄ± vb.) kaynaklÄ± oluÅŸan hatalardr.

**Assertion Code(DoÄŸrulama KodlarÄ±)**: Koddaki hatayÄ± bulmaya yÃ¶nelik programa ekelenen kodlara verilen addÄ±r.


ğŸ‘‡ AÅŸaÄŸÄ±daki program **assertion Code** kavramÄ±nÄ± anlayabilmek iÃ§in incelenebilir.
```C
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

#define NDEBUG // Bu kullanÄ±m ileriki derlerde iÅŸlenecek. Bu makro ile program debug-mode ile Ã§alÄ±ÅŸmÄ±yorsa koddaki 'assertion code' kÄ±sÄ±mlarÄ±nÄ±n programdan Ã§Ä±kartÄ±lmasÄ± saÄŸlanÄ±r.

#include <assert.h>

int main(void)
{
    int x = 5, y = 6;

    y = 0;

    // AÅŸaÄŸÄ±daki if ÅŸartÄ± kodda sÄ±fÄ±ra bÃ¶lme hatasÄ±nÄ±nda uyarÄ± verip programÄ± kapatmak iÃ§in 'assertion code' eklenmiÅŸtir.
    //if(y == 0){
    //    printf("burada ... falanca kaynak dosyanin filanca satÄ±rÄ±nda ...");
    //    abord(); // programÄ± sonlandÄ±racak fonksiyon Ã§aÄŸrÄ±sÄ± yapÄ±lÄ±yor
    //}

    assert(y != 0); // Buradaki 'assert' bir makrodur ve yukarÄ±daki if ile eklenen 'assertion code' kullanÄ±mÄ±nÄ±n bir muadilidir.

    int a = x / y;
}
```



KoÅŸullu derlemede kullanÄ±lan komutlar aÅŸaÄŸÄ±daki gibidir;
- `#if`
- `#else`
- `#elif`
- `#endif`
- `#ifdef`
- `#ifendef`
- `#undef`


â—Ã–niÅŸlemci program kod bloklarÄ±nÄ± tanÄ±mamaktadÄ±r bu nedenden dolayÄ± Ã¶niÅŸlemcinin Ã§alÄ±ÅŸmasÄ±nÄ± belirli ÅŸartlara gÃ¶re farklÄ±faÅŸtÄ±rmak iÃ§in `#if ... #endif` gibi yazmak gerekiyor.

``` Poseido
// 'preproccesing expression' deÄŸeri non-zero olduÄŸunda '#if ... #endif' arasÄ±ndaki kodlar derleyiciye verilecektir diÄŸer tÃ¼rlÃ¼ verilmeyecektir.
#if(preproccesing expression) 

#endif
```


ğŸ‘‡ AÅŸaÄŸÄ±daki program **conditional compiling** kullanÄ±mÄ±nÄ±n en temel halini anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>

#define NEC 20
#define SIZE 100

int main(void)
{
    #if NEC == 10
        #undef SIZE
        #define SIZE 200

        int x = 5;

        printf("bu kisma giris yapildi.\n");

        ++x;
        printf("x = %d\n", x);
    #endif

    printf("selam dunya.\n");

    int y = 201;
    printf("x = %d\n", x);
}

```



**Preproccesing expression** iÃ§erisinde neler kullanÄ±labilir ya da kullanÄ±lamaz;
1. **Constand(sabit)** ifadeler(expression) kullanÄ±labilir, **variable(deÄŸiÅŸken)** kullanÄ±lamaz, kÄ±saca Ã¶n-iÅŸlemci programÄ±nÄ±n gÃ¶rebileceÄŸi varlÄ±klar kullanÄ±labilir.
2. Makrolar kullanÄ±labilir
3. OperatÃ¶rler
    1. Aritmetik
    2. KarÅŸÄ±laÅŸtÄ±rma
    3. Logic Operators
    4. Bitwise Operators
    5. Ternary Operator
4. Floating point aritmetiÄŸini iÃ§eren **ifadeler(expression)** kullanÄ±lamaz.
5. Ã–ncelik parantesi kullanÄ±labilir.


â— C dilinin kuralÄ± olarak tanÄ±mlanmamÄ±ÅŸ **object-like makro** kullanÄ±ldÄ±ÄŸÄ±nda "0" deÄŸerini almaktadÄ±r.
- ğŸ‘‡ AÅŸaÄŸÄ±daki program yukarÄ±daki bilgiyi Ã¶zÃ¼msemek iÃ§in incelenebirlir.
```C
#include <stdio.h>

#define PI (3.14159)

int main(void)
{
    #if SIZE > 10 // Buradaki 'SIZE' makrosu tanÄ±mlanmadÄ±ÄŸÄ± iÃ§in deÄŸeri '0' olacaktÄ±r.
        printf("#if kismana giris yapildi-01-.");
    #endif

    #if SIZE > -3
        printf("#if kismana giris yapildi-02-.");
    #endif


    #if PI > 3.14123 // Buradaki koÅŸulda ondalÄ±klÄ± sayÄ± karÅŸÄ±laÅŸtÄ±rmasÄ± yapÄ±ldÄ±ÄŸÄ± iÃ§in sÃ¶zdizim hatasÄ±(syntax error) oluÅŸur.

    #endif
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program **conditional compiling** ile nasÄ±l sade bir **if-else** yazÄ±labileceÄŸini anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>

#define SIZE 100

int main(void)
{
    #if SIZE > 10
        printf("#if kismana giris yapildi.");
    #else
        printf("#else kisma giris yapildi.");
    #endif
}
```

### `#defined` OperatÃ¶rÃ¼ 


â— Ã–n-iÅŸlemci programÄ±n Ã¼Ã§ operatÃ¶rÃ¼nden biri olan `#defined` operatÃ¶rÃ¼ operand olarak makro alÄ±r, eÄŸer operand olarak aldÄ±ÄŸÄ± makro tanÄ±mlÄ±ysa non-zero(true), tanÄ±mlÄ± deÄŸilse zero(false) deÄŸer Ã¼retir.

â— **object-like makrolarÄ±n** kullanÄ±lmasÄ±nÄ±n nedeni Ã§oÄŸunlukla **conditional compiling** iÅŸlemlerinde dÃ¼zenlemeler yapabilmektir.



ğŸ‘‡ AÅŸaÄŸÄ±daki program **conditional compiling** ile nasÄ±l **defined** operatÃ¶rÃ¼nÃ¼n kullanÄ±labileceÄŸini anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>

#define MAX // Buradaki 'MAX' object-like makrosu sadece tanÄ±mlanmÄ±ÅŸ ama bir deÄŸere sahip deÄŸildir.

int main(void)
{
    #if defined MAX
        printf("dogru kisim 1.\n");
    #else
        printf("yanlis kisim 1.\n");
    #endif


    #if defined(MAX)
        printf("dogru kisim 2.\n");
    #else
        printf("yanlis kisim 2.\n");
    #endif


    #if !defined(MAX)
        printf("dogru kisim 3.\n");
    #else
        printf("yanlis kisim 3.\n");
    #endif


    #if defined(MAX2)
        printf("dogru kisim 4.\n");
    #else
        printf("yanlis kisim 4.\n");
    #endif  
}
```



ğŸ‘‡ AÅŸaÄŸÄ±daki program **conditional compiling** ile nasÄ±l **else-if ladder** kullanÄ±labileceÄŸini anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>

#define USD 0
#define EUR 1
#define YEN 3
#define GBP 4

#define CURRENCY USD

int main(void)
{
    #if CURRENCY == USD
        printf("us dollars\n");
    #elif CURRENCY == EUR
        printf("eur\n");
    #elif CURRENCY == YEN
        printf("japanase YEN\n");
    #elif CURRENCY == GBP
        printf("british Pound\n");
    #endif
}
```


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 10.57-11.19 birinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


>â”
> 
> SorduÄŸum soru; 
> 
> `#define SIZE` dedigimizde logic true evet, peki sayisal deger hala 0'a mÄ± eÅŸit?
> 
> Cevap;
> 
> Dilin kuralÄ± olarak sadece hiÃ§ tanÄ±mlanmamÄ±ÅŸ **object-like makro** tanÄ±mlarÄ±nÄ±n varsayÄ±lan deÄŸerleri "0" olmaktadÄ±r, `#define SIZE` ÅŸeklinde tanÄ±mlanan makrolar boÅŸ deÄŸere sahiptir yani deÄŸerleri "0" deÄŸildir.
> 
> ```C
> #include <stdio.h>
> 
> #define NEC 
> 
> int main(void)
> {
>     printf("%d\n", NEC); // Burada 'NEC' object-like makrosunun kulllanÄ±lmasÄ± sÃ¶zdizim hatasÄ±dÄ±r(syntax error) Ã§Ã¼nkÃ¼ bu makronun re-place edilebileceÄŸi bir deÄŸeri yok.
> 
>     #if NEC == 0 // Burada 'NEC' object-like makrosunun kulllanÄ±lmasÄ± sÃ¶zdizim hatasÄ±dÄ±r(syntax error) Ã§Ã¼nkÃ¼ bu makronun re-place edilebileceÄŸi bir deÄŸeri yok.
> 
>     #endif
> }
> ```


`#ifndef` **if not definet** ifadesinin kÄ±saltmasÄ±dÄ±r. </br>
`#ifdef` **if definet** ifadesinin kÄ±saltmasÄ±dÄ±r. </br>

â— `#ifndef` ve `#ifdef` **conditional compiling** komutlarÄ± `defined` operatÃ¶rÃ¼nden Ã¶nceden dilin standardÄ±nda mevcuttu. `defined` operatÃ¶rÃ¼ dile sonradan eklenmiÅŸtir.


ğŸ‘‡ AÅŸaÄŸÄ±daki program `#ifndef` komutu, `#ifdef` komutu ve `defined` operatÃ¶rÃ¼nÃ¼n Ã§alÄ±ÅŸma mantÄ±ÄŸÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>

#define MAX

int main(void)
{
    #if defined MAX
        printf("dogru kisim-1\n");
    #else
        printf("yanlis kisim-1\n");
    #endif

    #ifdef MAX
        printf("dogru kisim-2\n");
    #else
        printf("yanlis kisim-2\n");
    #endif

    // ...

    #if !defined MAX
        printf("dogru kisim-3\n");
    #else
        printf("yanlis kisim-3\n");
    #endif

    #ifndef MAX
        printf("dogru kisim-4\n");
    #else
        printf("yanlis kisim-4\n");
    #endif
}
```


## Makro'lar Neden KullanÄ±lÄ±r 


1. Makro sembolik sabit olarak kullanÄ±lÄ±r(**object-like macro**)
2. Makro fonksiyonel makro olarak kullanÄ±lÄ±r (**function-like macro**)
3. KoÅŸullu derleme iÅŸlemlerinde makrolar kullanÄ±lÄ±r.
4. MakrolarÄ±n dÃ¶rdÃ¼ncÃ¼ kullanÄ±mÄ± boÅŸ makrolar tanÄ±mlayÄ±p programcÄ±yÄ± bilgilendirmektir. Ã–n-iÅŸlemci program Ã§alÄ±ÅŸÄ±rken boÅŸ deÄŸerle tanÄ±mlanmÄ±ÅŸ olan makrolarÄ± koddan siler, bu kullanÄ±mÄ±n nedeni kodun okuyana belirli bilgilieri vermektir. 

    ğŸ‘‡ AÅŸaÄŸÄ±daki programdaki `PUBLIC` ve `NODISCARD` makrolarÄ± boÅŸ olarak tanÄ±mlanmÄ±ÅŸtÄ±r ve bu kullanÄ±mÄ±n nedeni ise programÄ± okuyana belirli bilgileri vermektir, Ã¶niÅŸlem sonrasÄ±nda bu adlar silinecektir.
    ```C
    #include <stdio.h>

    #define PUBLIC
    #define NODISCARD

    PUBLIC NODISCARD int foo(int x)
    {
        return x * x;
    }

    int main(void)
    {

    }
    ```

5. C ve C++ dillerinde bazÄ± varlÄ±klarÄ±n bildirimlerinin aynÄ± kaynak dosyada birden fazla tanÄ±mlanmasÄ±na izin verilmemektedir(sÃ¶zdizimi hatasÄ± oluÅŸturur) ya da bÃ¶yle kullanÄ±lmasÄ± **ub** durumuna sebep olmaktadÄ±r. 

    âš ï¸ Bu maddede anlatÄ±lanlar biraz ileri bir konu ama yine de burada deÄŸiniliyor.

    ğŸš€ **Multiple Inclusion**: AynÄ± baÅŸlÄ±k dosyasÄ±nÄ±n birden fazla defa bir kaynak dosyaya eklenmesi durumudur.

    ğŸ‘‡ AÅŸaÄŸÄ±daki programda en basit ÅŸekilde **multiple inclusion** durumunun nasÄ±l olabileceÄŸi gÃ¶rÃ¼lebilir.
    ```C
    #include "head_file_1.h"
    #include "head_file_1.h"

    int main(void)
    {

    }
    ```
    
    Bazen birden fazla baÅŸlÄ±k dosyasÄ± kullanÄ±lÄ±ndÄ±ÄŸÄ±nda, kullanÄ±lan bu baÅŸlÄ±k dosyalarÄ± baÅŸka bir aynÄ± baÅŸlÄ±k dosyasÄ±nÄ± dahil ediyorsa bu durumda da programcÄ±nÄ±n elinde olmadan oluÅŸan **multiple inclusion** durumu oluÅŸacaktÄ±r.

    ğŸš€ **Multiple Inclusion Guard**: Ã‡oklu baÅŸlÄ±k dosyasÄ± ekleme iÅŸlemine karÅŸÄ± Ã¶nlem alma durumunu ifade etmektedir. Bu koruma iÅŸlemini her bir baÅŸlÄ±k dosyasÄ± kendisi yapar. 

    ğŸ‘‡ AÅŸaÄŸÄ±daki temsili programda birden fazla farklÄ± dosyalarda bulunan giriÅŸik yapÄ±daki tekra tekrak include iÅŸlemi yapÄ±lan baÅŸlÄ±k dosyalarÄ±nda nasÄ±l **multiple inclusion guard** yapÄ±lacaÄŸÄ± gÃ¶rÃ¼lebilir.
    â— `#ifndef HeadFile3` ile `#if !defined HeadFile3` kullanÄ±mlarÄ±nÄ±n aynÄ± olduÄŸu gÃ¶rÃ¼lmelidir!
    ```C
    // main source file content
    #include "head_file_2.h"
    #include "head_file_3.h"

    int main(void)
    {


    }

    // 'head_file_1.h' baÅŸlÄ±k dosyasÄ±, ayrÄ± bir dosyada olduÄŸu varsayÄ±lmalÄ±.
    #ifndef HeadFile1 // '#if !defined HeadFile1' ÅŸeklinde de kullanÄ±lÄ±rsa aynÄ± anlama gelir

    #define HeadFile1

    struck strck1{
        int x;
        int y;
    }
    #endif


    // 'head_file_2.h' baÅŸlÄ±k dosyasÄ±, ayrÄ± bir dosyada olduÄŸu varsayÄ±lmalÄ±.
    #ifndef HeadFile2

    #define HeadFile2

    struck strck2{
        int x;
        int y;
    }
    #endif

    // 'head_file_3.h' baÅŸlÄ±k dosyasÄ±, ayrÄ± bir dosyada olduÄŸu varsayÄ±lmalÄ±.
    #ifndef HeadFile3

    #define HeadFile3

    struck strck3{
        int x;
        int y;
    }
    #endif


    // 'head_file_4.h' baÅŸlÄ±k dosyasÄ±, ayrÄ± bir dosyada olduÄŸu varsayÄ±lmalÄ±.
    #if !defined HeadFile4

    #define HeadFile4

    struck strck4{
        int x;
        int y;
    }
    #endif

    // 'head_file_5.h' baÅŸlÄ±k dosyasÄ±, ayrÄ± bir dosyada olduÄŸu varsayÄ±lmalÄ±.
    #pragma once // Bu kullanÄ±m C dilinin standardÄ±nda yoktur ama bilinen derleyiciler bu kullanÄ±m iÃ§in extension'a sahiptir.

    struck strck5{
        int x;
        int y;
    }
    ```

## `#undef` Ã–n-iÅŸlemci Komutu 

TanÄ±mlanmÄ±ÅŸ olan bir makro varsa ve onun deÄŸeri deÄŸiÅŸtirilmek isteniyorsa bunu ilgili makroyu yeniden tanÄ±mlayarak yapamayÄ±z(bÃ¶yle yapÄ±lÄ±rsa **ub** durumuna neden olacaktÄ±r), bunu yapmak iÃ§in ilk Ã¶nce makroyu `#undef` komutu ile devredÄ±ÅŸÄ± bÄ±rakmak gerekir.

`#undef` komutu aÅŸaÄŸÄ±daki durumlarda kullanÄ±lmaktadÄ±r;
1. Ã–nceden tanÄ±mlanmÄ±ÅŸ olan bir makronun farklÄ± birdeÄŸerle kullanÄ±lmak istenmesi. 

    ğŸ‘‡ AÅŸaÄŸÄ±daki programda Ã¶nceden tanÄ±mlanmÄ±ÅŸ olan bir makronun farklÄ± bir deÄŸerle kullanÄ±lmak istendiÄŸinde bunun nasÄ±l yapÄ±labileceÄŸi gÃ¶rÃ¼lebilir.
    ```C
    #include <stdio.h>

    int main(void)
    {
        #define SIZE 100

        printf("SIZE = %d\n", SIZE);

        #undef SIZE

        #define SIZE 100

        printf("SIZE = %d\n", SIZE);
    }
    ```

2. Makrolar kapsam(scope) tanÄ±mazlar ama `#undef` ile zahiri makro kapsamlarÄ±(scope) oluÅŸturulabilir.

    ğŸ‘‡ AÅŸaÄŸÄ±daki program bir makronun nasÄ±l bir kapsamdaymÄ±ÅŸ(scope) gibi sadece belirli bir kapsamda(scope) geÃ§erli hale getirilebileceÄŸi gÃ¶rÃ¼lebilir.
    ```C
    #include <stdio.h>

    void foo(){
        #undef SIZE
        #define SIZE 100

        printf("SIZE =", SIZE);

        #undef SIZE
    }

    int main(void)
    {

    }
    ```

3. `#undef` komutu bazÄ± durumlarda **conditional compiling** komutlarÄ±yla birlikte kullanÄ±labilir. 

    ğŸ‘‡ AÅŸaÄŸÄ±daki programda bir makronun nasÄ±l **conditional compiling** komutlarÄ±yla birlikte kullanÄ±labileceÄŸi gÃ¶rÃ¼lebilir.
    ```C
    #include <stdio.h>

    #define SIZE

    int main(void)
    {
        #ifdef SIZE
        
        printf("SIZE defined-1.");

        #endif

        #undef SIZE // Burada 'SIZE' makrosunun tanÄ±mÄ± siliniyor.

        #ifdef SIZE
        
        printf("SIZE defined-2.");

        #endif
    }
    ```

## Predefined Makro Or Predefined Sembolic Constands(Ã–n TanÄ±mlÄ± Sembolik Makrolar) 

â— `#line` Ã¶n-iÅŸlemci komutu Ã§ok nadir kullanÄ±lmaktadÄ±r ama bu komutu Ã¶ÄŸrenebilmek iÃ§in aÅŸaÄŸÄ±daki baÅŸlÄ±ktaki konularÄ±n bilinmesi gerekiyor.

Ã–yle makrolar var ki bir define komutu olmamasÄ±na karÅŸÄ±n dilin kuralÄ± gereÄŸi tanÄ±mlÄ± kabul ediliyor ve bir **replacemant(yer deÄŸiÅŸtirme)** yapÄ±lÄ±yor.

âš ï¸ Derleyicilerin kendileri de extension olarak **predefined macro** tanÄ±mlamÄ±ÅŸ olabilir.

C89 standardÄ±nda sadece beÅŸ adet **predefined macro** vardÄ±r(bunlar bilinmelidir), her C standardÄ±yla birlikte bu sayÄ± arttÄ±rÄ±lmÄ±ÅŸtÄ±r.

â— **Predefined macro** tanÄ±mlarÄ± yoktur, bu makrolarÄ± kullanmak iÃ§in bir baÅŸlÄ±k(**.h** file) dosyasÄ±nÄ±n programa dahil edilmesi gerekmiyor, bu makrolar dilin kuralÄ± gereÄŸi mevcuttur.


ğŸ§­ C89 standardÄ±nda C dilinde beÅŸ adet **predefined macro** tanÄ±mlanmÄ±ÅŸtÄ±r, bunlar; 
1. `__LINE__` makrosu kullanÄ±ldÄ±ÄŸÄ± yerin dosyadaki satÄ±r numarasÄ±(bir tam sayÄ± deÄŸeri) ile yer deÄŸiÅŸtirilir.
2. `__FILE__` makrosu kullanÄ±ldÄ±ÄŸÄ± dosyanÄ±n adÄ±yla yer deÄŸiÅŸtirilir.
3. `__DATE__` makrosu programÄ±n derlendiÄŸi andaki derlemenin yapÄ±ldÄ±ÄŸÄ± cihazdaki kayÄ±tlÄ± olan tarih bilgisiyle yer deÄŸiÅŸtirilir.
4. `__TIME__` makrosu programÄ±n derlendiÄŸi andaki derlemenin yapÄ±ldÄ±ÄŸÄ± cihazdaki kayÄ±tlÄ± olan saat bilgisiyle yer deÄŸiÅŸtirilir.
5. `__STDC__` makrosu diÄŸer dÃ¶rt makro'dan farklÄ±dÄ±r, derleyiciden derleyiciye gÃ¶re tanÄ±mlÄ± olabilir ya da tanÄ±mlÄ± olmayabilir ve bu makro'nun sadece **conditional compiling** komutlarÄ±yla birlikte kullanmak mantÄ±klÄ± olacaktÄ±r.


***
==================================================

âœ¦âœ¦âœ¦âœ¦âœ¦ 12.16-12.27 ikinci ara verildi. âœ¦âœ¦âœ¦âœ¦âœ¦

==================================================
***


ğŸ‘‡ AÅŸaÄŸÄ±daki programda **predefined sembolic constands(Ã¶n tanÄ±mlÄ± sembolik makrolar)** kullanÄ±mlarÄ± incelenebilir.
```C   
#include <stdio.h>

int main(void)
{
    printf("kaynak dosyanin %d. satiri.\n", __LINE__);

    printf("kaynak dosyanin adi: %s.\n", __FILE__);
    printf("derlenme tarihi(compolation date): %s.\n", __DATE__); // Burada kodun derlenme zamanÄ±nÄ±n tarihi yazacaktÄ±r.
    printf("derlenme saati(compolation time): %s.\n", __TIME__); // Burada kodun derlenme zamanÄ±nÄ±n saatini yazacaktÄ±r.

    printf("kaynak dosyanin %d. satiri.\n", __LINE__);
}
```

â— Bazen bir kaynak dosya hem C diliyle hem de C++ diliyle Ã§alÄ±ÅŸtÄ±rÄ±labilir, bu Ã§alÄ±ÅŸtÄ±rma iÅŸleminde kullanÄ±lan dile gÃ¶re bazÄ± kodlarÄ±n Ã§alÄ±ÅŸmasÄ± ya da Ã§alÄ±ÅŸmamasÄ± istenebilir bu durumlarda `__STDC__`, `__cplusplus` gibi makrolar kullanÄ±lan derleyiciye baÄŸÄ±mlÄ± olarak tercih edilebilir.



ğŸ‘‡ AÅŸaÄŸÄ±daki programda `__STDC__` ve `__cplusplus` makrolarÄ±nÄ±n kullanÄ±mÄ± incelenebilir. Bu programÄ±n Ã§alÄ±ÅŸmasÄ± kullanÄ±lan derleyiciye gÃ¶re deÄŸiÅŸecektir.
```C
#include <stdio.h>

int main(void)
{
    #ifdef __STDC__
        printf("C compiler.\n");
    #endif

    #ifdef __cplusplus
        printf("C++ compiler.\n");
    #endif
}
```

### `#line` Ã–n-iÅŸlemci Komutu 

`#line` komutu Ã§ok nadir kullanÄ±lmaktadÄ±r. </br>
`#line` komutu nasÄ±l kullanÄ±ldÄ±ÄŸÄ±nÄ± anlamak iÃ§in **predefined sembolic constands(Ã¶n tanÄ±mlÄ± sembolik makrolar)** terimi bilinmesi gerekiyor. </br>
`#line` komutu **predefined sembolic constands(Ã–n tanÄ±mlÄ± sembolik makrolar)** ile birlikte kullanÄ±ldÄ±ÄŸÄ±nda manalÄ± hale gelmektedir. </br>
`#line` komutu programÄ±n dosyalarÄ±nda kullanÄ±ldÄ±ÄŸÄ± kullanÄ±ldÄ±ÄŸÄ± satÄ±rÄ±n numarasÄ±yla yer deÄŸiÅŸtirilir.


ğŸ‘‡ AÅŸaÄŸÄ±daki program `#line` makrosunun Ã§alÄ±ÅŸma mantÄ±ÄŸÄ±nÄ± anlamak iÃ§in incelenebilir.
```C
#include <stdio.h>

int main(void)
{
    printf("kaynak dosyanin %d. satiri.\n", __LINE__);

    printf("%d %s\n", __LINE__, __FILE__);

    #line 374
    printf("kaynak dosyanin %d. satiri.\n", __LINE__);

    #line 374 "new_file_name.c"
    printf("%d %s\n", __LINE__, __FILE__);
}
```


â—BazÄ± C **code generation programlarÄ±** Ã§alÄ±ÅŸtÄ±klarÄ±nda(bu programÄ± biz de yazabiliriz) Ã§alÄ±ÅŸma zamanÄ±nda oluÅŸturulacak olan kaynak dosyalarda hata oluÅŸabilecek durumlarda verilecek mesajlarÄ±n hangi dosya ve satÄ±r numarasÄ±yla ilgili olduÄŸunu iÅŸleyebilmek iÃ§in kullanÄ±lmaktadÄ±r. 



â—C standardÄ±nda olan `exit()` ya da `abort()` fonksiyonlarÄ± programÄ±n process'inin Ã§alÄ±ÅŸmasÄ±nÄ± sonlandÄ±rÄ±r. 


## `#error` Ã–n-iÅŸlemci Komutu 

Bu Ã¶n-iÅŸlemci komutu belirli durumlarda hata oluÅŸturup preprosesor aÅŸamasÄ±nda kodun ileriki derleme aÅŸamalarÄ±na geÃ§ilmeden hata oluÅŸturulmasÄ±nÄ± saÄŸlamaktadÄ±r.

ğŸ‘‡ AÅŸaÄŸÄ±daki programda `#error` Ã¶n-iÅŸlemci komutunun basit bir kullanÄ±mÄ± incelenebilir, bu program C++ derleyicisiyle derlenmek istendiÄŸinde preprocessing aÅŸamasÄ±nda hata alÄ±nacaktÄ±r.
```C   
#ifdef __cplusplus
    #error bu program bu sekilde derlenmemeli
#endif

#include <stdio.h>

int main(void)
{

}
```


## `#pragma` Ã–n-iÅŸlemci Komutu 

C dilinin standartlarÄ±nÄ± belirleyen C standart komitesi `#pragma` komutunun standart olmasÄ±na ama C derleyicilerini yazacaklarÄ±n da esnek bir yapÄ± kullanabilmesine izin vermek iÃ§in bu Ã¶n-iÅŸlemci komutunun ne iÅŸ yapacaÄŸÄ±nÄ± derleyicileri tasarlayanlara bÄ±rakmÄ±ÅŸtÄ±r.
- `#pragma` komutunun kendisi standar ama ne iÅŸe yaradÄ±ÄŸÄ± derleyiciden derleyicide gÃ¶re deÄŸiÅŸebilir.
- `#pragma` komutunun ne iÅŸlem yapacaÄŸÄ±na derleyiciyi tasarlayanlar karar vermektedir.
- `#pragma` komutunun ne iÅŸ yaptÄ±ÄŸÄ±nÄ± anlamak iÃ§in kullanÄ±lan derleyicinin dokÃ¼mantasyonuna bakÄ±lmasÄ± gerekiyor.


Ders sonu ...
